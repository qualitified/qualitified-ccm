<!--
@license
(C) Copyright Nuxeo Corp. (http://nuxeo.com/)

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
--><!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><div hidden="" by-polymer-bundler=""><script>
  /**
  `iron-a11y-keys` provides a cross-browser interface for processing
  keyboard commands. The interface adheres to [WAI-ARIA best
  practices](http://www.w3.org/TR/wai-aria-practices/#kbd_general_binding).
  It uses an expressive syntax to filter key presses.

  ## Basic usage

  The sample code below is a portion of a custom element. The goal is to call
  the `onEnter` method whenever the `paper-input` element is in focus and
  the `Enter` key is pressed.

      <iron-a11y-keys id="a11y" target="[[target]]" keys="enter"
                          on-keys-pressed="onEnter"></iron-a11y-keys>
      <paper-input id="input"
                   placeholder="Type something. Press enter. Check console."
                   value="{{userInput::input}}"></paper-input>

  The custom element declares an `iron-a11y-keys` element that is bound to a
  property called `target`. The `target` property
  needs to evaluate to the `paper-input` node. `iron-a11y-keys` registers
  an event handler for the target node using Polymer's [annotated event handler
  syntax](https://www.polymer-project.org/1.0/docs/devguide/events.html#annotated-listeners).
  `{{userInput::input}}` sets the `userInput` property to the user's input on each
  keystroke.

  The last step is to link the two elements within the custom element's
  registration.

      ...
      properties: {
        userInput: {
          type: String,
          notify: true,
        },
        target: {
          type: Object,
          value: function() {
            return this.$.input;
          }
        },
      },
      onEnter: function() {
        console.log(this.userInput);
      }
      ...

  ## The `keys` attribute

  The `keys` attribute expresses what combination of keys triggers the event.

  The attribute accepts a space-separated, plus-sign-concatenated
  set of modifier keys and some common keyboard keys.

  The common keys are: `a-z`, `0-9` (top row and number pad), `*` (shift 8 and
  number pad), `F1-F12`, `Page Up`, `Page Down`, `Left Arrow`, `Right Arrow`,
  `Down Arrow`, `Up Arrow`, `Home`, `End`, `Escape`, `Space`, `Tab`, `Enter`.

  The modifier keys are: `Shift`, `Control`, `Alt`, `Meta`.

  All keys are expected to be lowercase and shortened. E.g.
  `Left Arrow` is `left`, `Page Down` is `pagedown`, `Control` is `ctrl`,
  `F1` is `f1`, `Escape` is `esc`, etc.

  ### Grammar

  Below is the
  [EBNF](http://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_Form) Grammar
  of the `keys` attribute.

      modifier = "shift" | "ctrl" | "alt" | "meta";
      ascii = ? /[a-z0-9]/ ? ;
      fnkey = ? f1 through f12 ? ;
      arrow = "up" | "down" | "left" | "right" ;
      key = "tab" | "esc" | "space" | "*" | "pageup" | "pagedown" |
            "home" | "end" | arrow | ascii | fnkey;
      event = "keypress" | "keydown" | "keyup";
      keycombo = { modifier, "+" }, key, [ ":", event ] ;
      keys = keycombo, { " ", keycombo } ;

  ### Example

  Given the following value for `keys`:

  `ctrl+shift+f7 up pagedown esc space alt+m`

  The event is fired if any of the following key combinations are fired:
  `Control` and `Shift` and `F7` keys, `Up Arrow` key, `Page Down` key,
  `Escape` key, `Space` key, `Alt` and `M` keys.

  ### WAI-ARIA Slider Example

  The following is an example of the set of keys that fulfills WAI-ARIA's
  "slider" role [best
  practices](http://www.w3.org/TR/wai-aria-practices/#slider):

      <iron-a11y-keys target="[[target]]" keys="left pagedown down"
                      on-keys-pressed="decrement"></iron-a11y-keys>
      <iron-a11y-keys target="[[target]]" keys="right pageup up"
                      on-keys-pressed="increment"></iron-a11y-keys>
      <iron-a11y-keys target="[[target]]" keys="home"
                      on-keys-pressed="setMin"></iron-a11y-keys>
      <iron-a11y-keys target="[[target]]" keys="end"
                      on-keys-pressed="setMax"></iron-a11y-keys>

  The `target` properties must evaluate to a node. See the basic usage
  example above.

  Each of the values for the `on-keys-pressed` attributes must evalute
  to methods. The `increment` method should move the slider a set amount
  toward the maximum value. `decrement` should move the slider a set amount
  toward the minimum value. `setMin` should move the slider to the minimum
  value. `setMax` should move the slider to the maximum value.

  @demo demo/index.html
  */



  Polymer({
    is: 'iron-a11y-keys',

    behaviors: [Polymer.IronA11yKeysBehavior],

    properties: {
      /** @type {?Node} */
      target: {type: Object, observer: '_targetChanged'},

      /**
       * Space delimited list of keys where each key follows the format:
       * `[MODIFIER+]*KEY[:EVENT]`.
       * e.g. `keys="space ctrl+shift+tab enter:keyup"`.
       * More detail can be found in the "Grammar" section of the documentation
       */
      keys: {type: String, reflectToAttribute: true, observer: '_keysChanged'}
    },

    attached: function() {
      if (!this.target) {
        this.target = this.parentNode;
      }
    },

    _targetChanged: function(target) {
      this.keyEventTarget = target;
    },

    _keysChanged: function() {
      this.removeOwnKeyBindings();
      this.addOwnKeyBinding(this.keys, '_fireKeysPressed');
    },

    _fireKeysPressed: function(event) {
      this.fire('keys-pressed', event.detail, {});
    }
  });
</script>
<script>
(function() {
  "use strict";
  /**
   * `Polymer.IronJsonpLibraryBehavior` loads a jsonp library.
   * Multiple components can request same library, only one copy will load.
   *
   * Some libraries require a specific global function be defined.
   * If this is the case, specify the `callbackName` property.
   *
   * You should use an HTML Import to load library dependencies
   * when possible instead of using this element.
   *
   * @hero hero.svg
   * @demo demo/index.html
   * @polymerBehavior
   */
  Polymer.IronJsonpLibraryBehavior = {

    properties: {
      /**
       * True if library has been successfully loaded
       */
      libraryLoaded: {
        type: Boolean,
        value: false,
        notify: true,
        readOnly: true
      },
      /**
       * Not null if library has failed to load
       */
      libraryErrorMessage: {
        type: String,
        value: null,
        notify: true,
        readOnly: true
      }
      // Following properties are to be set by behavior users
      /**
       * Library url. Must contain string `%%callback%%`.
       *
       * `%%callback%%` is a placeholder for jsonp wrapper function name
       *
       * Ex: https://maps.googleapis.com/maps/api/js?callback=%%callback%%
       * @property libraryUrl
       */
      /**
       * Set if library requires specific callback name.
       * Name will be automatically generated if not set.
       * @property callbackName
       */
      /**
       * name of event to be emitted when library loads. Standard is `api-load`
       * @property notifyEvent
       */
      /**
       * event with name specified in `notifyEvent` attribute
       * will fire upon successful load2
       * @event `notifyEvent`
       */
    },

    observers: [
      '_libraryUrlChanged(libraryUrl)'
    ],

    _libraryUrlChanged: function(libraryUrl) {
      // can't load before ready because notifyEvent might not be set
      if (this._isReady && this.libraryUrl)
        this._loadLibrary();
    },

    _libraryLoadCallback: function(err, result) {
      if (err) {
        Polymer.Base._warn("Library load failed:", err.message);
        this._setLibraryErrorMessage(err.message);
      }
      else {
        this._setLibraryErrorMessage(null);
        this._setLibraryLoaded(true);
        if (this.notifyEvent)
          this.fire(this.notifyEvent, result, {composed: true});
      }
    },

    /** loads the library, and fires this.notifyEvent upon completion */
    _loadLibrary: function() {
      LoaderMap.require(
        this.libraryUrl,
        this._libraryLoadCallback.bind(this),
        this.callbackName
      );
    },

    ready: function() {
      this._isReady = true;
      if (this.libraryUrl)
        this._loadLibrary();
    }
  };

  /**
   * LoaderMap keeps track of all Loaders
   */
  var LoaderMap = {
    apiMap: {}, // { hash -> Loader }

    /**
     * @param {Function} notifyCallback loaded callback fn(result)
     * @param {string} jsonpCallbackName name of jsonpcallback. If API does not provide it, leave empty. Optional.
     */
    require: function(url, notifyCallback, jsonpCallbackName) {

      // make hashable string form url
      var name = this.nameFromUrl(url);

      // create a loader as needed
      if (!this.apiMap[name])
        this.apiMap[name] = new Loader(name, url, jsonpCallbackName);

      // ask for notification
      this.apiMap[name].requestNotify(notifyCallback);
    },

    nameFromUrl: function(url) {
      return url.replace(/[\:\/\%\?\&\.\=\-\,]/g, '_') + '_api';
    }
  };

  /** @constructor */
  var Loader = function(name, url, callbackName) {
    this.notifiers = [];  // array of notifyFn [ notifyFn* ]

    // callback is specified either as callback name
    // or computed dynamically if url has callbackMacro in it
    if (!callbackName) {
      if (url.indexOf(this.callbackMacro) >= 0) {
        callbackName = name + '_loaded';
        url = url.replace(this.callbackMacro, callbackName);
      } else {
        this.error = new Error('IronJsonpLibraryBehavior a %%callback%% parameter is required in libraryUrl');
        // TODO(sjmiles): we should probably fallback to listening to script.load
        return;
      }
    }
    this.callbackName = callbackName;
    window[this.callbackName] = this.success.bind(this);
    this.addScript(url);
  };

  Loader.prototype = {

    callbackMacro: '%%callback%%',
    loaded: false,

    addScript: function(src) {
      var script = document.createElement('script');
      script.src = src;
      script.onerror = this.handleError.bind(this);
      var s = document.querySelector('script') || document.body;
      s.parentNode.insertBefore(script, s);
      this.script = script;
    },

    removeScript: function() {
      if (this.script.parentNode) {
        this.script.parentNode.removeChild(this.script);
      }
      this.script = null;
    },

    handleError: function(ev) {
      this.error = new Error("Library failed to load");
      this.notifyAll();
      this.cleanup();
    },

    success: function() {
      this.loaded = true;
      this.result = Array.prototype.slice.call(arguments);
      this.notifyAll();
      this.cleanup();
    },

    cleanup: function() {
      delete window[this.callbackName];
    },

    notifyAll: function() {
      this.notifiers.forEach( function(notifyCallback) {
        notifyCallback(this.error, this.result);
      }.bind(this));
      this.notifiers = [];
    },

    requestNotify: function(notifyCallback) {
      if (this.loaded || this.error) {
        notifyCallback( this.error, this.result);
      } else {
        this.notifiers.push(notifyCallback);
      }
    }
  };
})();
</script>

<script>
  Polymer({

    is: 'iron-jsonp-library',

    behaviors: [ Polymer.IronJsonpLibraryBehavior ],

    properties: {
      /**
       * Library url. Must contain string `%%callback%%`.
       *
       * `%%callback%%` is a placeholder for jsonp wrapper function name
       *
       * Ex: https://maps.googleapis.com/maps/api/js?callback=%%callback%%
       */
      libraryUrl: String,
      /**
       * Set if library requires specific callback name.
       * Name will be automatically generated if not set.
       */
      callbackName: String,
      /**
       * event with name specified in 'notifyEvent' attribute
       * will fire upon successful load
       */
      notifyEvent: String
      /**
       * event with name specified in 'notifyEvent' attribute
       * will fire upon successful load
       * @event `notifyEvent`
       */

    }
  });

</script>
<dom-module id="iron-label" assetpath="bower_components/iron-label/">
  <script>
    Polymer.IronLabel = Polymer({
      is: 'iron-label',

      listeners: {
        'tap': '_tapHandler'
      },

      properties: {
        /**
          * An ID reference to another element that needs to be
          * labelled by this `iron-label` element.
          */
        for: {
          type: String,
          value: '',
          reflectToAttribute: true,
          observer: '_forChanged'
        },
        /**
         * @type {Element}
         */
        _forElement: Object
      },

      attached: function() {
        this._forChanged();
      },

      ready: function() {
        this._generateLabelId();
      },

      // generate a unique id for this element
      _generateLabelId: function() {
        if (!this.id) {
          var id = 'iron-label-' + Polymer.IronLabel._labelNumber++;
          Polymer.dom(this).setAttribute('id', id);
        }
      },

      _findTarget: function() {
        if (this.for) {
          // external target
          var scope = Polymer.dom(this).getOwnerRoot();
          return Polymer.dom(scope).querySelector('#' + this.for);
        } else {
          // explicit internal target
          var el = Polymer.dom(this).querySelector('[iron-label-target]');
          if (!el) {
            // implicit internal target
            el = Polymer.dom(this).firstElementChild;
          }
          return el;
        }
      },

      _tapHandler: function(ev) {
        if (!this._forElement) {
          return;
        }
        var target = Polymer.dom(ev).localTarget;
        if (target === this._forElement) {
          return;
        }
        this._forElement.focus();
        this._forElement.click();
      },

      _applyLabelledBy: function() {
        if (this._forElement) {
          Polymer.dom(this._forElement).setAttribute('aria-labelledby', this.id);
        }
      },

      _forChanged: function() {
        if (this._forElement) {
          Polymer.dom(this._forElement).removeAttribute('aria-labelledby');
        }
        this._forElement = this._findTarget();
        this._applyLabelledBy();
      }
    });

    // global counter for unique label ids
    Polymer.IronLabel._labelNumber = 0;
  </script>
</dom-module>
<script>
  (function() {
  'use strict';

  var workingURL;

  var urlDoc, urlBase, anchor;

  /**
   * @param {string} path
   * @param {string=} base
   * @return {!URL|!HTMLAnchorElement}
   */
  function resolveURL(path, base) {
    if (workingURL === undefined) {
      workingURL = false;
      try {
        var u = new URL('b', 'http://a');
        u.pathname = 'c%20d';
        workingURL = (u.href === 'http://a/c%20d');
        workingURL = workingURL &&
            (new URL('http://www.google.com/?foo bar').href ===
             'http://www.google.com/?foo%20bar');
      } catch (e) {
      }
    }
    if (workingURL) {
      return new URL(path, base);
    }
    if (!urlDoc) {
      urlDoc = document.implementation.createHTMLDocument('url');
      urlBase = urlDoc.createElement('base');
      urlDoc.head.appendChild(urlBase);
      anchor = /** @type {HTMLAnchorElement}*/ (urlDoc.createElement('a'));
    }
    urlBase.href = base;
    anchor.href = path.replace(/ /g, '%20');
    return anchor;
  }

  Polymer({
    is: 'iron-location',

    properties: {
      /**
       * The pathname component of the URL.
       */
      path: {
        type: String,
        notify: true,
        value: function() {
          return window.decodeURIComponent(window.location.pathname);
        }
      },

      /**
       * The query string portion of the URL.
       */
      query: {
        type: String,
        notify: true,
        value: function() {
          return window.location.search.slice(1);
        }
      },

      /**
       * The hash component of the URL.
       */
      hash: {
        type: String,
        notify: true,
        value: function() {
          return window.decodeURIComponent(window.location.hash.slice(1));
        }
      },

      /**
       * If the user was on a URL for less than `dwellTime` milliseconds, it
       * won't be added to the browser's history, but instead will be replaced
       * by the next entry.
       *
       * This is to prevent large numbers of entries from clogging up the user's
       * browser history. Disable by setting to a negative number.
       */
      dwellTime: {type: Number, value: 2000},

      /**
       * A regexp that defines the set of URLs that should be considered part
       * of this web app.
       *
       * Clicking on a link that matches this regex won't result in a full page
       * navigation, but will instead just update the URL state in place.
       *
       * This regexp is given everything after the origin in an absolute
       * URL. So to match just URLs that start with /search/ do:
       *     url-space-regex="^/search/"
       *
       * @type {string|RegExp}
       */
      urlSpaceRegex: {type: String, value: ''},

      /**
       * A flag that specifies whether the spaces in query that would normally be
       * encoded as %20 should be encoded as +.
       *
       * Given an example text "hello world", it is encoded in query as
       * - "hello%20world" without the parameter
       * - "hello+world" with the parameter
       */
      encodeSpaceAsPlusInQuery: {type: Boolean, value: false},

      /**
       * urlSpaceRegex, but coerced into a regexp.
       *
       * @type {RegExp}
       */
      _urlSpaceRegExp: {computed: '_makeRegExp(urlSpaceRegex)'},

      _lastChangedAt: {type: Number},

      _initialized: {type: Boolean, value: false}
    },

    hostAttributes: {hidden: true},

    observers: ['_updateUrl(path, query, hash)'],

    created: function() {
      this.__location = window.location;
    },

    attached: function() {
      this.listen(window, 'hashchange', '_hashChanged');
      this.listen(window, 'location-changed', '_urlChanged');
      this.listen(window, 'popstate', '_urlChanged');
      this.listen(
          /** @type {!HTMLBodyElement} */ (document.body),
          'click',
          '_globalOnClick');
      // Give a 200ms grace period to make initial redirects without any
      // additions to the user's history.
      this._lastChangedAt = window.performance.now() - (this.dwellTime - 200);
      this._initialized = true;

      this._urlChanged();
    },

    detached: function() {
      this.unlisten(window, 'hashchange', '_hashChanged');
      this.unlisten(window, 'location-changed', '_urlChanged');
      this.unlisten(window, 'popstate', '_urlChanged');
      this.unlisten(
          /** @type {!HTMLBodyElement} */ (document.body),
          'click',
          '_globalOnClick');
      this._initialized = false;
    },

    _hashChanged: function() {
      this.hash = window.decodeURIComponent(this.__location.hash.substring(1));
    },

    _urlChanged: function() {
      // We want to extract all info out of the updated URL before we
      // try to write anything back into it.
      //
      // i.e. without _dontUpdateUrl we'd overwrite the new path with the old
      // one when we set this.hash. Likewise for query.
      this._dontUpdateUrl = true;
      this._hashChanged();
      this.path = window.decodeURIComponent(this.__location.pathname);
      this.query = this.__location.search.substring(1);
      this._dontUpdateUrl = false;
      this._updateUrl();
    },

    _getUrl: function() {
      var partiallyEncodedPath =
          window.encodeURI(this.path).replace(/\#/g, '%23').replace(/\?/g, '%3F');
      var partiallyEncodedQuery = '';
      if (this.query) {
        partiallyEncodedQuery = '?' + this.query.replace(/\#/g, '%23');
        if (this.encodeSpaceAsPlusInQuery) {
          partiallyEncodedQuery = partiallyEncodedQuery.replace(/\+/g, '%2B')
                                      .replace(/ /g, '+')
                                      .replace(/%20/g, '+');
        }
      }
      var partiallyEncodedHash = '';
      if (this.hash) {
        partiallyEncodedHash = '#' + window.encodeURI(this.hash);
      }
      return (
          partiallyEncodedPath + partiallyEncodedQuery + partiallyEncodedHash);
    },

    _updateUrl: function() {
      if (this._dontUpdateUrl || !this._initialized) {
        return;
      }

      if (this.path === window.decodeURIComponent(this.__location.pathname) &&
          this.query === this.__location.search.substring(1) &&
          this.hash ===
              window.decodeURIComponent(this.__location.hash.substring(1))) {
        // Nothing to do, the current URL is a representation of our properties.
        return;
      }

      var newUrl = this._getUrl();
      // Need to use a full URL in case the containing page has a base URI.
      var fullNewUrl =
          resolveURL(
              newUrl, this.__location.protocol + '//' + this.__location.host)
              .href;
      var now = window.performance.now();
      var shouldReplace = this._lastChangedAt + this.dwellTime > now;
      this._lastChangedAt = now;

      if (shouldReplace) {
        window.history.replaceState({}, '', fullNewUrl);
      } else {
        window.history.pushState({}, '', fullNewUrl);
      }

      this.fire('location-changed', {}, {node: window});
    },

    /**
     * A necessary evil so that links work as expected. Does its best to
     * bail out early if possible.
     *
     * @param {MouseEvent} event .
     */
    _globalOnClick: function(event) {
      // If another event handler has stopped this event then there's nothing
      // for us to do. This can happen e.g. when there are multiple
      // iron-location elements in a page.
      if (event.defaultPrevented) {
        return;
      }

      var href = this._getSameOriginLinkHref(event);

      if (!href) {
        return;
      }

      event.preventDefault();

      // If the navigation is to the current page we shouldn't add a history
      // entry or fire a change event.
      if (href === this.__location.href) {
        return;
      }

      window.history.pushState({}, '', href);
      this.fire('location-changed', {}, {node: window});
    },

    /**
     * Returns the absolute URL of the link (if any) that this click event
     * is clicking on, if we can and should override the resulting full
     * page navigation. Returns null otherwise.
     *
     * @param {MouseEvent} event .
     * @return {string?} .
     */
    _getSameOriginLinkHref: function(event) {
      // We only care about left-clicks.
      if (event.button !== 0) {
        return null;
      }

      // We don't want modified clicks, where the intent is to open the page
      // in a new tab.
      if (event.metaKey || event.ctrlKey) {
        return null;
      }

      var eventPath = Polymer.dom(event).path;
      var anchor = null;

      for (var i = 0; i < eventPath.length; i++) {
        var element = eventPath[i];

        if (element.tagName === 'A' && element.href) {
          anchor = element;
          break;
        }
      }

      // If there's no link there's nothing to do.
      if (!anchor) {
        return null;
      }

      // Target blank is a new tab, don't intercept.
      if (anchor.target === '_blank') {
        return null;
      }

      // If the link is for an existing parent frame, don't intercept.
      if ((anchor.target === '_top' || anchor.target === '_parent') &&
          window.top !== window) {
        return null;
      }

      // If the link is a download, don't intercept.
      if (anchor.download) {
        return null;
      }

      var href = anchor.href;

      // It only makes sense for us to intercept same-origin navigations.
      // pushState/replaceState don't work with cross-origin links.
      var url;

      if (document.baseURI != null) {
        url = resolveURL(href, /** @type {string} */ (document.baseURI));
      } else {
        url = resolveURL(href);
      }

      var origin;

      // IE Polyfill
      if (this.__location.origin) {
        origin = this.__location.origin;
      } else {
        origin = this.__location.protocol + '//' + this.__location.host;
      }

      var urlOrigin;

      if (url.origin) {
        urlOrigin = url.origin;
      } else {
        // IE always adds port number on HTTP and HTTPS on <a>.host but not on
        // window.location.host
        var urlHost = url.host;
        var urlPort = url.port;
        var urlProtocol = url.protocol;
        var isExtraneousHTTPS = urlProtocol === 'https:' && urlPort === '443';
        var isExtraneousHTTP = urlProtocol === 'http:' && urlPort === '80';

        if (isExtraneousHTTPS || isExtraneousHTTP) {
          urlHost = url.hostname;
        }
        urlOrigin = urlProtocol + '//' + urlHost;
      }

      if (urlOrigin !== origin) {
        return null;
      }

      var normalizedHref = url.pathname + url.search + url.hash;

      // pathname should start with '/', but may not if `new URL` is not supported
      if (normalizedHref[0] !== '/') {
        normalizedHref = '/' + normalizedHref;
      }

      // If we've been configured not to handle this url... don't handle it!
      if (this._urlSpaceRegExp && !this._urlSpaceRegExp.test(normalizedHref)) {
        return null;
      }

      // Need to use a full URL in case the containing page has a base URI.
      var fullNormalizedHref =
          resolveURL(normalizedHref, this.__location.href).href;
      return fullNormalizedHref;
    },

    _makeRegExp: function(urlSpaceRegex) {
      return RegExp(urlSpaceRegex);
    }
  });
  })();
</script>
<script>

  /**
   * Use `Polymer.IronValidatorBehavior` to implement a custom input/form validator. Element
   * instances implementing this behavior will be registered for use in elements that implement
   * `Polymer.IronValidatableBehavior`.
   *
   * @demo demo/index.html
   * @polymerBehavior
   */
  Polymer.IronValidatorBehavior = {
    ready: function() {
      new Polymer.IronMeta({type: 'validator', key: this.is || this.constructor.is, value: this});
    },

    /**
     * Implement custom validation logic in this function.
     * @param {Object} values The value to validate. May be any type depending on the validation logic.
     * @return {boolean} true if `values` is valid.
     */
    validate: function(values) {
    }
  };

</script>
<dom-module id="neon-animated-pages" assetpath="bower_components/neon-animation/">
  <template>
    <style>
      :host {
        display: block;
        position: relative;
      }

      :host > ::slotted(*) {
        position: absolute;
        top: 0;
        left: 0;
        bottom: 0;
        right: 0;
      }

      :host > ::slotted(:not(.iron-selected):not(.neon-animating))
       {
        display: none !important;
      }

      :host > ::slotted(.neon-animating) {
        pointer-events: none;
      }
    </style>

    <slot id="content"></slot>
  </template>

</dom-module>

<script>
(function() {

  Polymer({

    is: 'neon-animated-pages',

    behaviors: [
      Polymer.IronResizableBehavior,
      Polymer.IronSelectableBehavior,
      Polymer.NeonAnimationRunnerBehavior
    ],

    properties: {

      activateEvent: {
        type: String,
        value: ''
      },

      // if true, the initial page selection will also be animated according to its animation config.
      animateInitialSelection: {
        type: Boolean,
        value: false
      }

    },

    listeners: {
      'iron-select': '_onIronSelect',
      'neon-animation-finish': '_onNeonAnimationFinish'
    },

    _onIronSelect: function(event) {
      var selectedPage = event.detail.item;

      // Only consider child elements.
      if (this.items.indexOf(selectedPage) < 0) {
        return;
      }

      var oldPage = this._valueToItem(this._prevSelected) || false;
      this._prevSelected = this.selected;

      // on initial load and if animateInitialSelection is negated, simply display selectedPage.
      if (!oldPage && !this.animateInitialSelection) {
        this._completeSelectedChanged();
        return;
      }

      this.animationConfig = [];

      // configure selectedPage animations.
      if (this.entryAnimation) {
        this.animationConfig.push({
          name: this.entryAnimation,
          node: selectedPage
        });
      } else {
        if (selectedPage.getAnimationConfig) {
          this.animationConfig.push({
            animatable: selectedPage,
            type: 'entry'
          });
        }
      }

      // configure oldPage animations iff exists.
      if (oldPage) {

        // cancel the currently running animation if one is ongoing.
        if (oldPage.classList.contains('neon-animating')) {
          this._squelchNextFinishEvent = true;
          this.cancelAnimation();
          this._completeSelectedChanged();
          this._squelchNextFinishEvent = false;
        }

        // configure the animation.
        if (this.exitAnimation) {
          this.animationConfig.push({
            name: this.exitAnimation,
            node: oldPage
          });
        } else {
          if (oldPage.getAnimationConfig) {
            this.animationConfig.push({
              animatable: oldPage,
              type: 'exit'
            });
          }
        }

        // display the oldPage during the transition.
        oldPage.classList.add('neon-animating');
      }

      // display the selectedPage during the transition.
      selectedPage.classList.add('neon-animating');

      // actually run the animations.
      if (this.animationConfig.length >= 1) {

        // on first load, ensure we run animations only after element is attached.
        if (!this.isAttached) {
          this.async(function () {
            this.playAnimation(undefined, {
              fromPage: null,
              toPage: selectedPage
            });
          });

        } else {
          this.playAnimation(undefined, {
            fromPage: oldPage,
            toPage: selectedPage
          });
        }

      } else {
        this._completeSelectedChanged(oldPage, selectedPage);
      }
    },

    /**
     * @param {Object=} oldPage
     * @param {Object=} selectedPage
     */
    _completeSelectedChanged: function(oldPage, selectedPage) {
      if (selectedPage) {
        selectedPage.classList.remove('neon-animating');
      }
      if (oldPage) {
        oldPage.classList.remove('neon-animating');
      }
      if (!selectedPage || !oldPage) {
        var nodes = Polymer.dom(this.$.content).getDistributedNodes();
        for (var node, index = 0; node = nodes[index]; index++) {
          node.classList && node.classList.remove('neon-animating');
        }
      }
      this.async(this._notifyPageResize);
    },

    _onNeonAnimationFinish: function(event) {
      if (this._squelchNextFinishEvent) {
        this._squelchNextFinishEvent = false;
        return;
      }
      this._completeSelectedChanged(event.detail.fromPage, event.detail.toPage);
    },

    _notifyPageResize: function() {
      var selectedPage = this.selectedItem || this._valueToItem(this.selected);
      this.resizerShouldNotify = function(element) {
        return element == selectedPage;
      };
      this.notifyResize();
    }
  })

})();
</script>
<dom-module id="neon-animatable" assetpath="bower_components/neon-animation/">
  <template>
    <style>
      :host {
        display: block;
      }
    </style>

    <slot></slot>
  </template>

</dom-module>

<script>

  Polymer({

    is: 'neon-animatable',

    behaviors: [
      Polymer.NeonAnimatableBehavior,
      Polymer.IronResizableBehavior
    ]

  });

</script>
<dom-module id="nuxeo-audit-page-provider" assetpath="bower_components/nuxeo-elements/">
  <template>
    <style>
      :host {
        display: none;
      }
    </style>

    <nuxeo-resource id="res" path="/id/[[docId]]/@audit" enrichers="{{enrichers}}" schemas="[[schemas]]" loading="{{loading}}" headers="{{headers}}">
    </nuxeo-resource>

    <nuxeo-operation id="auditOp" op="Audit.QueryWithPageProvider" enrichers="{{enrichers}}" schemas="[[schemas]]" loading="{{loading}}" headers="{{headers}}">
    </nuxeo-operation>
  </template>

  <script>
    {
      /**
       * `nuxeo-audit-page-provider` performs an audit query with the given parameters against audit logs.
       * If the property docId is set, the provider DOCUMENT_HISTORY_PROVIDER is used with docId as queryParameter.
       * If the property docId is not set, the EVENTS_VIEW provider is used instead.
       *
       *     <nuxeo-audit-page-provider
       *         current-page="{{entries}}" params="{...}" page-size="40'">
       *     </nuxeo-audit-page-provider>
       *
       *     <nuxeo-audit-page-provider
       *         current-page="{{entries}}" docId="..." page-size="40'">
       *     </nuxeo-audit-page-provider>
       *
       * @memberof Nuxeo
       */
      class AuditPageProvider extends Nuxeo.Element {

        static get is() {
          return 'nuxeo-audit-page-provider';
        }

        static get properties() {
          return {
            /**
             * The id of a nuxeo-connection to use.
             */
            connectionId: {
              type: String,
              value: '',
            },

            /**
             * If true, automatically execute the operation when either `docId` or `params` change.
             */
            auto: {
              type: Boolean,
              value: false,
            },

            /**
             * The delay in milliseconds to debounce the auto fetch call when `docId`, `params`, etc. changes.
             */
            autoDelay: {
              type: Number,
              value: 300,
            },

            /**
             * The query parameters object.
             */
            params: {
              type: Object,
              value: {},
            },

            /**
             * The document id to retrieve the history from.
             * When set, the provider DOCUMENT_HISTORY_PROVIDER is used.
             */
            docId: {
              type: String,
            },

            /**
             * The number of results per page.
             */
            pageSize: {
              type: Number,
              value: -1,
            },

            /**
             * The current page.
             */
            page: {
              type: Number,
              value: 1,
            },

            /**
             * The current page entries.
             */
            currentPage: {
              type: Array,
              value: [],
              notify: true,
            },

            /**
             * Map of properties and direction 'asc' / 'desc'
             */
            sort: {
              type: Object,
              value: {},
              notify: true,
            },

            /**
             * Total number of pages.
             */
            numberOfPages: {
              type: Number,
              notify: true,
            },

            /**
             * Total number of results.
             */
            resultsCount: {
              type: Number,
              notify: true,
            },

            /**
             * Returns true if a next page is available.
             */
            isNextPageAvailable: {
              type: Boolean,
              value: false,
              notify: true,
            },

            /**
             * Current page's size
             */
            currentPageSize: {
              type: Number,
              notify: true,
            },

            /**
             * The `content enricher` of the resource.
             * Can be an object with entity type as keys or list or string (which defaults to `document` entity type).
             */
            enrichers: {
              type: Object,
              value: {},
            },

            /**
             * List of comma separated values of the document schemas to be returned.
             * All document schemas are returned by default.
             */
            schemas: {
              type: String,
            },

            /**
             * The headers of the request.
             * 'Accept': 'text/plain,application/json' is already set by default.
             */
            headers: {
              type: Object,
              value: null,
            },

            /**
             * True while requests are in flight.
             */
            loading: {
              type: Boolean,
              notify: true,
              readOnly: true,
            },
          };
        }

        static get observers() {
          return [
            '_resetAndAutoFetch(params.*, docId, pageSize, sort)',
            '_autoFetch(page)',
          ];
        }

        /**
         * Fired when the current page is fetched.
         *
         * @event update
         */

        /**
         * Stringifies the elements of a given object
         */
        _stringifyJSONObject(input) {
          const result = input;
          if (input !== null) {
            Object.keys(input).forEach((key) => {
              if (typeof input[key] === 'string') {
                result[key] = input[key];
              } else {
                result[key] = JSON.stringify(input[key]);
              }
            });
          }
          return result;
        }

        /**
         * Fetch the currentPage.
         * @method fetch
         */
        fetch() {
          return this._isForDoc ? this._fetchRes() : this._fetchOp();
        }

        _fetchOp() {
          const params = {
            providerName: 'EVENTS_VIEW',
            namedQueryParams: this._stringifyJSONObject(this.params),
            currentPageIndex: this.page - 1,
            pageSize: this.pageSize,
          };
          return this._fetch(this.$.auditOp, params);
        }

        _fetchRes() {
          const params = {};
          if (this.params.startDate) {
            params.startEventDate = this.params.startDate;
          }
          if (this.params.endDate) {
            params.endEventDate = this.params.endDate;
          }
          params.currentPageIndex = this.page - 1;
          params.pageSize = this.pageSize;
          return this._fetch(this.$.res, params);
        }

        _fetch(exec, params) {
          if (this._sortKeys.length > 0) {
            params.sortBy = this._sortKeys.join(',');
            params.sortOrder = this._sortValues.join(',');
          }
          exec.params = params;
          return exec.execute().then((response) => {
            this.currentPage = response.entries.slice(0);
            this.numberOfPages = response.numberOfPages;
            this.resultsCount = response.resultsCount;
            this.isNextPageAvailable = response.isNextPageAvailable;
            this.currentPageSize = response.currentPageSize;
            this.dispatchEvent(new CustomEvent('update', {
              bubbles: true,
              composed: true,
            }));
            return response;
          });
        }

        get _sortKeys() {
          return Object.keys(this.sort);
        }

        get _sortValues() {
          return this._sortKeys.map((k) => this.sort[k]);
        }

        get _isForDoc() {
          return this.docId && this.docId.length > 0;
        }

        _resetAndAutoFetch() {
          this.page = 1;
          this._autoFetch();
        }

        _autoFetch() {
          if (this.auto) {
            // debounce in case of multiple param changes
            this._debouncer = Polymer.Debouncer.debounce(
              this._debouncer,
              Polymer.Async.timeOut.after(this.autoDelay), () => this.fetch(),
            );
          }
        }
      }

      customElements.define(AuditPageProvider.is, AuditPageProvider);
      Nuxeo.AuditPageProvider = AuditPageProvider;
    }
  </script>
</dom-module>
<script>!function(){function n(n){return n&&(n.ownerDocument||n.document||n).documentElement}function t(n){return n&&(n.ownerDocument&&n.ownerDocument.defaultView||n.document&&n||n.defaultView)}function e(n,t){return t>n?-1:n>t?1:n>=t?0:NaN}function r(n){return null===n?NaN:+n}function i(n){return!isNaN(n)}function u(n){return{left:function(t,e,r,i){for(arguments.length<3&&(r=0),arguments.length<4&&(i=t.length);i>r;){var u=r+i>>>1;n(t[u],e)<0?r=u+1:i=u}return r},right:function(t,e,r,i){for(arguments.length<3&&(r=0),arguments.length<4&&(i=t.length);i>r;){var u=r+i>>>1;n(t[u],e)>0?i=u:r=u+1}return r}}}function o(n){return n.length}function a(n){for(var t=1;n*t%1;)t*=10;return t}function l(n,t){for(var e in t)Object.defineProperty(n.prototype,e,{value:t[e],enumerable:!1})}function c(){this._=Object.create(null)}function f(n){return(n+="")===bo||n[0]===_o?_o+n:n}function s(n){return(n+="")[0]===_o?n.slice(1):n}function h(n){return f(n)in this._}function p(n){return(n=f(n))in this._&&delete this._[n]}function g(){var n=[];for(var t in this._)n.push(s(t));return n}function v(){var n=0;for(var t in this._)++n;return n}function d(){for(var n in this._)return!1;return!0}function y(){this._=Object.create(null)}function m(n){return n}function M(n,t,e){return function(){var r=e.apply(t,arguments);return r===t?n:r}}function x(n,t){if(t in n)return t;t=t.charAt(0).toUpperCase()+t.slice(1);for(var e=0,r=wo.length;r>e;++e){var i=wo[e]+t;if(i in n)return i}}function b(){}function _(){}function w(n){function t(){for(var t,r=e,i=-1,u=r.length;++i<u;)(t=r[i].on)&&t.apply(this,arguments);return n}var e=[],r=new c;return t.on=function(t,i){var u,o=r.get(t);return arguments.length<2?o&&o.on:(o&&(o.on=null,e=e.slice(0,u=e.indexOf(o)).concat(e.slice(u+1)),r.remove(t)),i&&e.push(r.set(t,{on:i})),n)},t}function S(){ao.event.preventDefault()}function k(){for(var n,t=ao.event;n=t.sourceEvent;)t=n;return t}function N(n){for(var t=new _,e=0,r=arguments.length;++e<r;)t[arguments[e]]=w(t);return t.of=function(e,r){return function(i){try{var u=i.sourceEvent=ao.event;i.target=n,ao.event=i,t[i.type].apply(e,r)}finally{ao.event=u}}},t}function E(n){return ko(n,Co),n}function A(n){return"function"==typeof n?n:function(){return No(n,this)}}function C(n){return"function"==typeof n?n:function(){return Eo(n,this)}}function z(n,t){function e(){this.removeAttribute(n)}function r(){this.removeAttributeNS(n.space,n.local)}function i(){this.setAttribute(n,t)}function u(){this.setAttributeNS(n.space,n.local,t)}function o(){var e=t.apply(this,arguments);null==e?this.removeAttribute(n):this.setAttribute(n,e)}function a(){var e=t.apply(this,arguments);null==e?this.removeAttributeNS(n.space,n.local):this.setAttributeNS(n.space,n.local,e)}return n=ao.ns.qualify(n),null==t?n.local?r:e:"function"==typeof t?n.local?a:o:n.local?u:i}function L(n){return n.trim().replace(/\s+/g," ")}function q(n){return new RegExp("(?:^|\\s+)"+ao.requote(n)+"(?:\\s+|$)","g")}function T(n){return(n+"").trim().split(/^|\s+/)}function R(n,t){function e(){for(var e=-1;++e<i;)n[e](this,t)}function r(){for(var e=-1,r=t.apply(this,arguments);++e<i;)n[e](this,r)}n=T(n).map(D);var i=n.length;return"function"==typeof t?r:e}function D(n){var t=q(n);return function(e,r){if(i=e.classList)return r?i.add(n):i.remove(n);var i=e.getAttribute("class")||"";r?(t.lastIndex=0,t.test(i)||e.setAttribute("class",L(i+" "+n))):e.setAttribute("class",L(i.replace(t," ")))}}function P(n,t,e){function r(){this.style.removeProperty(n)}function i(){this.style.setProperty(n,t,e)}function u(){var r=t.apply(this,arguments);null==r?this.style.removeProperty(n):this.style.setProperty(n,r,e)}return null==t?r:"function"==typeof t?u:i}function U(n,t){function e(){delete this[n]}function r(){this[n]=t}function i(){var e=t.apply(this,arguments);null==e?delete this[n]:this[n]=e}return null==t?e:"function"==typeof t?i:r}function j(n){function t(){var t=this.ownerDocument,e=this.namespaceURI;return e===zo&&t.documentElement.namespaceURI===zo?t.createElement(n):t.createElementNS(e,n)}function e(){return this.ownerDocument.createElementNS(n.space,n.local)}return"function"==typeof n?n:(n=ao.ns.qualify(n)).local?e:t}function F(){var n=this.parentNode;n&&n.removeChild(this)}function H(n){return{__data__:n}}function O(n){return function(){return Ao(this,n)}}function I(n){return arguments.length||(n=e),function(t,e){return t&&e?n(t.__data__,e.__data__):!t-!e}}function Y(n,t){for(var e=0,r=n.length;r>e;e++)for(var i,u=n[e],o=0,a=u.length;a>o;o++)(i=u[o])&&t(i,o,e);return n}function Z(n){return ko(n,qo),n}function V(n){var t,e;return function(r,i,u){var o,a=n[u].update,l=a.length;for(u!=e&&(e=u,t=0),i>=t&&(t=i+1);!(o=a[t])&&++t<l;);return o}}function X(n,t,e){function r(){var t=this[o];t&&(this.removeEventListener(n,t,t.$),delete this[o])}function i(){var i=l(t,co(arguments));r.call(this),this.addEventListener(n,this[o]=i,i.$=e),i._=t}function u(){var t,e=new RegExp("^__on([^.]+)"+ao.requote(n)+"$");for(var r in this)if(t=r.match(e)){var i=this[r];this.removeEventListener(t[1],i,i.$),delete this[r]}}var o="__on"+n,a=n.indexOf("."),l=$;a>0&&(n=n.slice(0,a));var c=To.get(n);return c&&(n=c,l=B),a?t?i:r:t?b:u}function $(n,t){return function(e){var r=ao.event;ao.event=e,t[0]=this.__data__;try{n.apply(this,t)}finally{ao.event=r}}}function B(n,t){var e=$(n,t);return function(n){var t=this,r=n.relatedTarget;r&&(r===t||8&r.compareDocumentPosition(t))||e.call(t,n)}}function W(e){var r=".dragsuppress-"+ ++Do,i="click"+r,u=ao.select(t(e)).on("touchmove"+r,S).on("dragstart"+r,S).on("selectstart"+r,S);if(null==Ro&&(Ro="onselectstart"in e?!1:x(e.style,"userSelect")),Ro){var o=n(e).style,a=o[Ro];o[Ro]="none"}return function(n){if(u.on(r,null),Ro&&(o[Ro]=a),n){var t=function(){u.on(i,null)};u.on(i,function(){S(),t()},!0),setTimeout(t,0)}}}function J(n,e){e.changedTouches&&(e=e.changedTouches[0]);var r=n.ownerSVGElement||n;if(r.createSVGPoint){var i=r.createSVGPoint();if(0>Po){var u=t(n);if(u.scrollX||u.scrollY){r=ao.select("body").append("svg").style({position:"absolute",top:0,left:0,margin:0,padding:0,border:"none"},"important");var o=r[0][0].getScreenCTM();Po=!(o.f||o.e),r.remove()}}return Po?(i.x=e.pageX,i.y=e.pageY):(i.x=e.clientX,i.y=e.clientY),i=i.matrixTransform(n.getScreenCTM().inverse()),[i.x,i.y]}var a=n.getBoundingClientRect();return[e.clientX-a.left-n.clientLeft,e.clientY-a.top-n.clientTop]}function G(){return ao.event.changedTouches[0].identifier}function K(n){return n>0?1:0>n?-1:0}function Q(n,t,e){return(t[0]-n[0])*(e[1]-n[1])-(t[1]-n[1])*(e[0]-n[0])}function nn(n){return n>1?0:-1>n?Fo:Math.acos(n)}function tn(n){return n>1?Io:-1>n?-Io:Math.asin(n)}function en(n){return((n=Math.exp(n))-1/n)/2}function rn(n){return((n=Math.exp(n))+1/n)/2}function un(n){return((n=Math.exp(2*n))-1)/(n+1)}function on(n){return(n=Math.sin(n/2))*n}function an(){}function ln(n,t,e){return this instanceof ln?(this.h=+n,this.s=+t,void(this.l=+e)):arguments.length<2?n instanceof ln?new ln(n.h,n.s,n.l):_n(""+n,wn,ln):new ln(n,t,e)}function cn(n,t,e){function r(n){return n>360?n-=360:0>n&&(n+=360),60>n?u+(o-u)*n/60:180>n?o:240>n?u+(o-u)*(240-n)/60:u}function i(n){return Math.round(255*r(n))}var u,o;return n=isNaN(n)?0:(n%=360)<0?n+360:n,t=isNaN(t)?0:0>t?0:t>1?1:t,e=0>e?0:e>1?1:e,o=.5>=e?e*(1+t):e+t-e*t,u=2*e-o,new mn(i(n+120),i(n),i(n-120))}function fn(n,t,e){return this instanceof fn?(this.h=+n,this.c=+t,void(this.l=+e)):arguments.length<2?n instanceof fn?new fn(n.h,n.c,n.l):n instanceof hn?gn(n.l,n.a,n.b):gn((n=Sn((n=ao.rgb(n)).r,n.g,n.b)).l,n.a,n.b):new fn(n,t,e)}function sn(n,t,e){return isNaN(n)&&(n=0),isNaN(t)&&(t=0),new hn(e,Math.cos(n*=Yo)*t,Math.sin(n)*t)}function hn(n,t,e){return this instanceof hn?(this.l=+n,this.a=+t,void(this.b=+e)):arguments.length<2?n instanceof hn?new hn(n.l,n.a,n.b):n instanceof fn?sn(n.h,n.c,n.l):Sn((n=mn(n)).r,n.g,n.b):new hn(n,t,e)}function pn(n,t,e){var r=(n+16)/116,i=r+t/500,u=r-e/200;return i=vn(i)*na,r=vn(r)*ta,u=vn(u)*ea,new mn(yn(3.2404542*i-1.5371385*r-.4985314*u),yn(-.969266*i+1.8760108*r+.041556*u),yn(.0556434*i-.2040259*r+1.0572252*u))}function gn(n,t,e){return n>0?new fn(Math.atan2(e,t)*Zo,Math.sqrt(t*t+e*e),n):new fn(NaN,NaN,n)}function vn(n){return n>.206893034?n*n*n:(n-4/29)/7.787037}function dn(n){return n>.008856?Math.pow(n,1/3):7.787037*n+4/29}function yn(n){return Math.round(255*(.00304>=n?12.92*n:1.055*Math.pow(n,1/2.4)-.055))}function mn(n,t,e){return this instanceof mn?(this.r=~~n,this.g=~~t,void(this.b=~~e)):arguments.length<2?n instanceof mn?new mn(n.r,n.g,n.b):_n(""+n,mn,cn):new mn(n,t,e)}function Mn(n){return new mn(n>>16,n>>8&255,255&n)}function xn(n){return Mn(n)+""}function bn(n){return 16>n?"0"+Math.max(0,n).toString(16):Math.min(255,n).toString(16)}function _n(n,t,e){var r,i,u,o=0,a=0,l=0;if(r=/([a-z]+)\((.*)\)/.exec(n=n.toLowerCase()))switch(i=r[2].split(","),r[1]){case"hsl":return e(parseFloat(i[0]),parseFloat(i[1])/100,parseFloat(i[2])/100);case"rgb":return t(Nn(i[0]),Nn(i[1]),Nn(i[2]))}return(u=ua.get(n))?t(u.r,u.g,u.b):(null==n||"#"!==n.charAt(0)||isNaN(u=parseInt(n.slice(1),16))||(4===n.length?(o=(3840&u)>>4,o=o>>4|o,a=240&u,a=a>>4|a,l=15&u,l=l<<4|l):7===n.length&&(o=(16711680&u)>>16,a=(65280&u)>>8,l=255&u)),t(o,a,l))}function wn(n,t,e){var r,i,u=Math.min(n/=255,t/=255,e/=255),o=Math.max(n,t,e),a=o-u,l=(o+u)/2;return a?(i=.5>l?a/(o+u):a/(2-o-u),r=n==o?(t-e)/a+(e>t?6:0):t==o?(e-n)/a+2:(n-t)/a+4,r*=60):(r=NaN,i=l>0&&1>l?0:r),new ln(r,i,l)}function Sn(n,t,e){n=kn(n),t=kn(t),e=kn(e);var r=dn((.4124564*n+.3575761*t+.1804375*e)/na),i=dn((.2126729*n+.7151522*t+.072175*e)/ta),u=dn((.0193339*n+.119192*t+.9503041*e)/ea);return hn(116*i-16,500*(r-i),200*(i-u))}function kn(n){return(n/=255)<=.04045?n/12.92:Math.pow((n+.055)/1.055,2.4)}function Nn(n){var t=parseFloat(n);return"%"===n.charAt(n.length-1)?Math.round(2.55*t):t}function En(n){return"function"==typeof n?n:function(){return n}}function An(n){return function(t,e,r){return 2===arguments.length&&"function"==typeof e&&(r=e,e=null),Cn(t,e,n,r)}}function Cn(n,t,e,r){function i(){var n,t=l.status;if(!t&&Ln(l)||t>=200&&300>t||304===t){try{n=e.call(u,l)}catch(r){return void o.error.call(u,r)}o.load.call(u,n)}else o.error.call(u,l)}var u={},o=ao.dispatch("beforesend","progress","load","error"),a={},l=new XMLHttpRequest,c=null;return!this.XDomainRequest||"withCredentials"in l||!/^(http(s)?:)?\/\//.test(n)||(l=new XDomainRequest),"onload"in l?l.onload=l.onerror=i:l.onreadystatechange=function(){l.readyState>3&&i()},l.onprogress=function(n){var t=ao.event;ao.event=n;try{o.progress.call(u,l)}finally{ao.event=t}},u.header=function(n,t){return n=(n+"").toLowerCase(),arguments.length<2?a[n]:(null==t?delete a[n]:a[n]=t+"",u)},u.mimeType=function(n){return arguments.length?(t=null==n?null:n+"",u):t},u.responseType=function(n){return arguments.length?(c=n,u):c},u.response=function(n){return e=n,u},["get","post"].forEach(function(n){u[n]=function(){return u.send.apply(u,[n].concat(co(arguments)))}}),u.send=function(e,r,i){if(2===arguments.length&&"function"==typeof r&&(i=r,r=null),l.open(e,n,!0),null==t||"accept"in a||(a.accept=t+",*/*"),l.setRequestHeader)for(var f in a)l.setRequestHeader(f,a[f]);return null!=t&&l.overrideMimeType&&l.overrideMimeType(t),null!=c&&(l.responseType=c),null!=i&&u.on("error",i).on("load",function(n){i(null,n)}),o.beforesend.call(u,l),l.send(null==r?null:r),u},u.abort=function(){return l.abort(),u},ao.rebind(u,o,"on"),null==r?u:u.get(zn(r))}function zn(n){return 1===n.length?function(t,e){n(null==t?e:null)}:n}function Ln(n){var t=n.responseType;return t&&"text"!==t?n.response:n.responseText}function qn(n,t,e){var r=arguments.length;2>r&&(t=0),3>r&&(e=Date.now());var i=e+t,u={c:n,t:i,n:null};return aa?aa.n=u:oa=u,aa=u,la||(ca=clearTimeout(ca),la=1,fa(Tn)),u}function Tn(){var n=Rn(),t=Dn()-n;t>24?(isFinite(t)&&(clearTimeout(ca),ca=setTimeout(Tn,t)),la=0):(la=1,fa(Tn))}function Rn(){for(var n=Date.now(),t=oa;t;)n>=t.t&&t.c(n-t.t)&&(t.c=null),t=t.n;return n}function Dn(){for(var n,t=oa,e=1/0;t;)t.c?(t.t<e&&(e=t.t),t=(n=t).n):t=n?n.n=t.n:oa=t.n;return aa=n,e}function Pn(n,t){return t-(n?Math.ceil(Math.log(n)/Math.LN10):1)}function Un(n,t){var e=Math.pow(10,3*xo(8-t));return{scale:t>8?function(n){return n/e}:function(n){return n*e},symbol:n}}function jn(n){var t=n.decimal,e=n.thousands,r=n.grouping,i=n.currency,u=r&&e?function(n,t){for(var i=n.length,u=[],o=0,a=r[0],l=0;i>0&&a>0&&(l+a+1>t&&(a=Math.max(1,t-l)),u.push(n.substring(i-=a,i+a)),!((l+=a+1)>t));)a=r[o=(o+1)%r.length];return u.reverse().join(e)}:m;return function(n){var e=ha.exec(n),r=e[1]||" ",o=e[2]||">",a=e[3]||"-",l=e[4]||"",c=e[5],f=+e[6],s=e[7],h=e[8],p=e[9],g=1,v="",d="",y=!1,m=!0;switch(h&&(h=+h.substring(1)),(c||"0"===r&&"="===o)&&(c=r="0",o="="),p){case"n":s=!0,p="g";break;case"%":g=100,d="%",p="f";break;case"p":g=100,d="%",p="r";break;case"b":case"o":case"x":case"X":"#"===l&&(v="0"+p.toLowerCase());case"c":m=!1;case"d":y=!0,h=0;break;case"s":g=-1,p="r"}"$"===l&&(v=i[0],d=i[1]),"r"!=p||h||(p="g"),null!=h&&("g"==p?h=Math.max(1,Math.min(21,h)):"e"!=p&&"f"!=p||(h=Math.max(0,Math.min(20,h)))),p=pa.get(p)||Fn;var M=c&&s;return function(n){var e=d;if(y&&n%1)return"";var i=0>n||0===n&&0>1/n?(n=-n,"-"):"-"===a?"":a;if(0>g){var l=ao.formatPrefix(n,h);n=l.scale(n),e=l.symbol+d}else n*=g;n=p(n,h);var x,b,_=n.lastIndexOf(".");if(0>_){var w=m?n.lastIndexOf("e"):-1;0>w?(x=n,b=""):(x=n.substring(0,w),b=n.substring(w))}else x=n.substring(0,_),b=t+n.substring(_+1);!c&&s&&(x=u(x,1/0));var S=v.length+x.length+b.length+(M?0:i.length),k=f>S?new Array(S=f-S+1).join(r):"";return M&&(x=u(k+x,k.length?f-b.length:1/0)),i+=v,n=x+b,("<"===o?i+n+k:">"===o?k+i+n:"^"===o?k.substring(0,S>>=1)+i+n+k.substring(S):i+(M?n:k+n))+e}}}function Fn(n){return n+""}function Hn(){this._=new Date(arguments.length>1?Date.UTC.apply(this,arguments):arguments[0])}function On(n,t,e){function r(t){var e=n(t),r=u(e,1);return r-t>t-e?e:r}function i(e){return t(e=n(new va(e-1)),1),e}function u(n,e){return t(n=new va(+n),e),n}function o(n,r,u){var o=i(n),a=[];if(u>1)for(;r>o;)e(o)%u||a.push(new Date(+o)),t(o,1);else for(;r>o;)a.push(new Date(+o)),t(o,1);return a}function a(n,t,e){try{va=Hn;var r=new Hn;return r._=n,o(r,t,e)}finally{va=Date}}n.floor=n,n.round=r,n.ceil=i,n.offset=u,n.range=o;var l=n.utc=In(n);return l.floor=l,l.round=In(r),l.ceil=In(i),l.offset=In(u),l.range=a,n}function In(n){return function(t,e){try{va=Hn;var r=new Hn;return r._=t,n(r,e)._}finally{va=Date}}}function Yn(n){function t(n){function t(t){for(var e,i,u,o=[],a=-1,l=0;++a<r;)37===n.charCodeAt(a)&&(o.push(n.slice(l,a)),null!=(i=ya[e=n.charAt(++a)])&&(e=n.charAt(++a)),(u=A[e])&&(e=u(t,null==i?"e"===e?" ":"0":i)),o.push(e),l=a+1);return o.push(n.slice(l,a)),o.join("")}var r=n.length;return t.parse=function(t){var r={y:1900,m:0,d:1,H:0,M:0,S:0,L:0,Z:null},i=e(r,n,t,0);if(i!=t.length)return null;"p"in r&&(r.H=r.H%12+12*r.p);var u=null!=r.Z&&va!==Hn,o=new(u?Hn:va);return"j"in r?o.setFullYear(r.y,0,r.j):"W"in r||"U"in r?("w"in r||(r.w="W"in r?1:0),o.setFullYear(r.y,0,1),o.setFullYear(r.y,0,"W"in r?(r.w+6)%7+7*r.W-(o.getDay()+5)%7:r.w+7*r.U-(o.getDay()+6)%7)):o.setFullYear(r.y,r.m,r.d),o.setHours(r.H+(r.Z/100|0),r.M+r.Z%100,r.S,r.L),u?o._:o},t.toString=function(){return n},t}function e(n,t,e,r){for(var i,u,o,a=0,l=t.length,c=e.length;l>a;){if(r>=c)return-1;if(i=t.charCodeAt(a++),37===i){if(o=t.charAt(a++),u=C[o in ya?t.charAt(a++):o],!u||(r=u(n,e,r))<0)return-1}else if(i!=e.charCodeAt(r++))return-1}return r}function r(n,t,e){_.lastIndex=0;var r=_.exec(t.slice(e));return r?(n.w=w.get(r[0].toLowerCase()),e+r[0].length):-1}function i(n,t,e){x.lastIndex=0;var r=x.exec(t.slice(e));return r?(n.w=b.get(r[0].toLowerCase()),e+r[0].length):-1}function u(n,t,e){N.lastIndex=0;var r=N.exec(t.slice(e));return r?(n.m=E.get(r[0].toLowerCase()),e+r[0].length):-1}function o(n,t,e){S.lastIndex=0;var r=S.exec(t.slice(e));return r?(n.m=k.get(r[0].toLowerCase()),e+r[0].length):-1}function a(n,t,r){return e(n,A.c.toString(),t,r)}function l(n,t,r){return e(n,A.x.toString(),t,r)}function c(n,t,r){return e(n,A.X.toString(),t,r)}function f(n,t,e){var r=M.get(t.slice(e,e+=2).toLowerCase());return null==r?-1:(n.p=r,e)}var s=n.dateTime,h=n.date,p=n.time,g=n.periods,v=n.days,d=n.shortDays,y=n.months,m=n.shortMonths;t.utc=function(n){function e(n){try{va=Hn;var t=new va;return t._=n,r(t)}finally{va=Date}}var r=t(n);return e.parse=function(n){try{va=Hn;var t=r.parse(n);return t&&t._}finally{va=Date}},e.toString=r.toString,e},t.multi=t.utc.multi=ct;var M=ao.map(),x=Vn(v),b=Xn(v),_=Vn(d),w=Xn(d),S=Vn(y),k=Xn(y),N=Vn(m),E=Xn(m);g.forEach(function(n,t){M.set(n.toLowerCase(),t)});var A={a:function(n){return d[n.getDay()]},A:function(n){return v[n.getDay()]},b:function(n){return m[n.getMonth()]},B:function(n){return y[n.getMonth()]},c:t(s),d:function(n,t){return Zn(n.getDate(),t,2)},e:function(n,t){return Zn(n.getDate(),t,2)},H:function(n,t){return Zn(n.getHours(),t,2)},I:function(n,t){return Zn(n.getHours()%12||12,t,2)},j:function(n,t){return Zn(1+ga.dayOfYear(n),t,3)},L:function(n,t){return Zn(n.getMilliseconds(),t,3)},m:function(n,t){return Zn(n.getMonth()+1,t,2)},M:function(n,t){return Zn(n.getMinutes(),t,2)},p:function(n){return g[+(n.getHours()>=12)]},S:function(n,t){return Zn(n.getSeconds(),t,2)},U:function(n,t){return Zn(ga.sundayOfYear(n),t,2)},w:function(n){return n.getDay()},W:function(n,t){return Zn(ga.mondayOfYear(n),t,2)},x:t(h),X:t(p),y:function(n,t){return Zn(n.getFullYear()%100,t,2)},Y:function(n,t){return Zn(n.getFullYear()%1e4,t,4)},Z:at,"%":function(){return"%"}},C={a:r,A:i,b:u,B:o,c:a,d:tt,e:tt,H:rt,I:rt,j:et,L:ot,m:nt,M:it,p:f,S:ut,U:Bn,w:$n,W:Wn,x:l,X:c,y:Gn,Y:Jn,Z:Kn,"%":lt};return t}function Zn(n,t,e){var r=0>n?"-":"",i=(r?-n:n)+"",u=i.length;return r+(e>u?new Array(e-u+1).join(t)+i:i)}function Vn(n){return new RegExp("^(?:"+n.map(ao.requote).join("|")+")","i")}function Xn(n){for(var t=new c,e=-1,r=n.length;++e<r;)t.set(n[e].toLowerCase(),e);return t}function $n(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+1));return r?(n.w=+r[0],e+r[0].length):-1}function Bn(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e));return r?(n.U=+r[0],e+r[0].length):-1}function Wn(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e));return r?(n.W=+r[0],e+r[0].length):-1}function Jn(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+4));return r?(n.y=+r[0],e+r[0].length):-1}function Gn(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+2));return r?(n.y=Qn(+r[0]),e+r[0].length):-1}function Kn(n,t,e){return/^[+-]\d{4}$/.test(t=t.slice(e,e+5))?(n.Z=-t,e+5):-1}function Qn(n){return n+(n>68?1900:2e3)}function nt(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+2));return r?(n.m=r[0]-1,e+r[0].length):-1}function tt(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+2));return r?(n.d=+r[0],e+r[0].length):-1}function et(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+3));return r?(n.j=+r[0],e+r[0].length):-1}function rt(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+2));return r?(n.H=+r[0],e+r[0].length):-1}function it(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+2));return r?(n.M=+r[0],e+r[0].length):-1}function ut(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+2));return r?(n.S=+r[0],e+r[0].length):-1}function ot(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+3));return r?(n.L=+r[0],e+r[0].length):-1}function at(n){var t=n.getTimezoneOffset(),e=t>0?"-":"+",r=xo(t)/60|0,i=xo(t)%60;return e+Zn(r,"0",2)+Zn(i,"0",2)}function lt(n,t,e){Ma.lastIndex=0;var r=Ma.exec(t.slice(e,e+1));return r?e+r[0].length:-1}function ct(n){for(var t=n.length,e=-1;++e<t;)n[e][0]=this(n[e][0]);return function(t){for(var e=0,r=n[e];!r[1](t);)r=n[++e];return r[0](t)}}function ft(){}function st(n,t,e){var r=e.s=n+t,i=r-n,u=r-i;e.t=n-u+(t-i)}function ht(n,t){n&&wa.hasOwnProperty(n.type)&&wa[n.type](n,t)}function pt(n,t,e){var r,i=-1,u=n.length-e;for(t.lineStart();++i<u;)r=n[i],t.point(r[0],r[1],r[2]);t.lineEnd()}function gt(n,t){var e=-1,r=n.length;for(t.polygonStart();++e<r;)pt(n[e],t,1);t.polygonEnd()}function vt(){function n(n,t){n*=Yo,t=t*Yo/2+Fo/4;var e=n-r,o=e>=0?1:-1,a=o*e,l=Math.cos(t),c=Math.sin(t),f=u*c,s=i*l+f*Math.cos(a),h=f*o*Math.sin(a);ka.add(Math.atan2(h,s)),r=n,i=l,u=c}var t,e,r,i,u;Na.point=function(o,a){Na.point=n,r=(t=o)*Yo,i=Math.cos(a=(e=a)*Yo/2+Fo/4),u=Math.sin(a)},Na.lineEnd=function(){n(t,e)}}function dt(n){var t=n[0],e=n[1],r=Math.cos(e);return[r*Math.cos(t),r*Math.sin(t),Math.sin(e)]}function yt(n,t){return n[0]*t[0]+n[1]*t[1]+n[2]*t[2]}function mt(n,t){return[n[1]*t[2]-n[2]*t[1],n[2]*t[0]-n[0]*t[2],n[0]*t[1]-n[1]*t[0]]}function Mt(n,t){n[0]+=t[0],n[1]+=t[1],n[2]+=t[2]}function xt(n,t){return[n[0]*t,n[1]*t,n[2]*t]}function bt(n){var t=Math.sqrt(n[0]*n[0]+n[1]*n[1]+n[2]*n[2]);n[0]/=t,n[1]/=t,n[2]/=t}function _t(n){return[Math.atan2(n[1],n[0]),tn(n[2])]}function wt(n,t){return xo(n[0]-t[0])<Uo&&xo(n[1]-t[1])<Uo}function St(n,t){n*=Yo;var e=Math.cos(t*=Yo);kt(e*Math.cos(n),e*Math.sin(n),Math.sin(t))}function kt(n,t,e){++Ea,Ca+=(n-Ca)/Ea,za+=(t-za)/Ea,La+=(e-La)/Ea}function Nt(){function n(n,i){n*=Yo;var u=Math.cos(i*=Yo),o=u*Math.cos(n),a=u*Math.sin(n),l=Math.sin(i),c=Math.atan2(Math.sqrt((c=e*l-r*a)*c+(c=r*o-t*l)*c+(c=t*a-e*o)*c),t*o+e*a+r*l);Aa+=c,qa+=c*(t+(t=o)),Ta+=c*(e+(e=a)),Ra+=c*(r+(r=l)),kt(t,e,r)}var t,e,r;ja.point=function(i,u){i*=Yo;var o=Math.cos(u*=Yo);t=o*Math.cos(i),e=o*Math.sin(i),r=Math.sin(u),ja.point=n,kt(t,e,r)}}function Et(){ja.point=St}function At(){function n(n,t){n*=Yo;var e=Math.cos(t*=Yo),o=e*Math.cos(n),a=e*Math.sin(n),l=Math.sin(t),c=i*l-u*a,f=u*o-r*l,s=r*a-i*o,h=Math.sqrt(c*c+f*f+s*s),p=r*o+i*a+u*l,g=h&&-nn(p)/h,v=Math.atan2(h,p);Da+=g*c,Pa+=g*f,Ua+=g*s,Aa+=v,qa+=v*(r+(r=o)),Ta+=v*(i+(i=a)),Ra+=v*(u+(u=l)),kt(r,i,u)}var t,e,r,i,u;ja.point=function(o,a){t=o,e=a,ja.point=n,o*=Yo;var l=Math.cos(a*=Yo);r=l*Math.cos(o),i=l*Math.sin(o),u=Math.sin(a),kt(r,i,u)},ja.lineEnd=function(){n(t,e),ja.lineEnd=Et,ja.point=St}}function Ct(n,t){function e(e,r){return e=n(e,r),t(e[0],e[1])}return n.invert&&t.invert&&(e.invert=function(e,r){return e=t.invert(e,r),e&&n.invert(e[0],e[1])}),e}function zt(){return!0}function Lt(n,t,e,r,i){var u=[],o=[];if(n.forEach(function(n){if(!((t=n.length-1)<=0)){var t,e=n[0],r=n[t];if(wt(e,r)){i.lineStart();for(var a=0;t>a;++a)i.point((e=n[a])[0],e[1]);return void i.lineEnd()}var l=new Tt(e,n,null,!0),c=new Tt(e,null,l,!1);l.o=c,u.push(l),o.push(c),l=new Tt(r,n,null,!1),c=new Tt(r,null,l,!0),l.o=c,u.push(l),o.push(c)}}),o.sort(t),qt(u),qt(o),u.length){for(var a=0,l=e,c=o.length;c>a;++a)o[a].e=l=!l;for(var f,s,h=u[0];;){for(var p=h,g=!0;p.v;)if((p=p.n)===h)return;f=p.z,i.lineStart();do{if(p.v=p.o.v=!0,p.e){if(g)for(var a=0,c=f.length;c>a;++a)i.point((s=f[a])[0],s[1]);else r(p.x,p.n.x,1,i);p=p.n}else{if(g){f=p.p.z;for(var a=f.length-1;a>=0;--a)i.point((s=f[a])[0],s[1])}else r(p.x,p.p.x,-1,i);p=p.p}p=p.o,f=p.z,g=!g}while(!p.v);i.lineEnd()}}}function qt(n){if(t=n.length){for(var t,e,r=0,i=n[0];++r<t;)i.n=e=n[r],e.p=i,i=e;i.n=e=n[0],e.p=i}}function Tt(n,t,e,r){this.x=n,this.z=t,this.o=e,this.e=r,this.v=!1,this.n=this.p=null}function Rt(n,t,e,r){return function(i,u){function o(t,e){var r=i(t,e);n(t=r[0],e=r[1])&&u.point(t,e)}function a(n,t){var e=i(n,t);d.point(e[0],e[1])}function l(){m.point=a,d.lineStart()}function c(){m.point=o,d.lineEnd()}function f(n,t){v.push([n,t]);var e=i(n,t);x.point(e[0],e[1])}function s(){x.lineStart(),v=[]}function h(){f(v[0][0],v[0][1]),x.lineEnd();var n,t=x.clean(),e=M.buffer(),r=e.length;if(v.pop(),g.push(v),v=null,r)if(1&t){n=e[0];var i,r=n.length-1,o=-1;if(r>0){for(b||(u.polygonStart(),b=!0),u.lineStart();++o<r;)u.point((i=n[o])[0],i[1]);u.lineEnd()}}else r>1&&2&t&&e.push(e.pop().concat(e.shift())),p.push(e.filter(Dt))}var p,g,v,d=t(u),y=i.invert(r[0],r[1]),m={point:o,lineStart:l,lineEnd:c,polygonStart:function(){m.point=f,m.lineStart=s,m.lineEnd=h,p=[],g=[]},polygonEnd:function(){m.point=o,m.lineStart=l,m.lineEnd=c,p=ao.merge(p);var n=Ot(y,g);p.length?(b||(u.polygonStart(),b=!0),Lt(p,Ut,n,e,u)):n&&(b||(u.polygonStart(),b=!0),u.lineStart(),e(null,null,1,u),u.lineEnd()),b&&(u.polygonEnd(),b=!1),p=g=null},sphere:function(){u.polygonStart(),u.lineStart(),e(null,null,1,u),u.lineEnd(),u.polygonEnd()}},M=Pt(),x=t(M),b=!1;return m}}function Dt(n){return n.length>1}function Pt(){var n,t=[];return{lineStart:function(){t.push(n=[])},point:function(t,e){n.push([t,e])},lineEnd:b,buffer:function(){var e=t;return t=[],n=null,e},rejoin:function(){t.length>1&&t.push(t.pop().concat(t.shift()))}}}function Ut(n,t){return((n=n.x)[0]<0?n[1]-Io-Uo:Io-n[1])-((t=t.x)[0]<0?t[1]-Io-Uo:Io-t[1])}function jt(n){var t,e=NaN,r=NaN,i=NaN;return{lineStart:function(){n.lineStart(),t=1},point:function(u,o){var a=u>0?Fo:-Fo,l=xo(u-e);xo(l-Fo)<Uo?(n.point(e,r=(r+o)/2>0?Io:-Io),n.point(i,r),n.lineEnd(),n.lineStart(),n.point(a,r),n.point(u,r),t=0):i!==a&&l>=Fo&&(xo(e-i)<Uo&&(e-=i*Uo),xo(u-a)<Uo&&(u-=a*Uo),r=Ft(e,r,u,o),n.point(i,r),n.lineEnd(),n.lineStart(),n.point(a,r),t=0),n.point(e=u,r=o),i=a},lineEnd:function(){n.lineEnd(),e=r=NaN},clean:function(){return 2-t}}}function Ft(n,t,e,r){var i,u,o=Math.sin(n-e);return xo(o)>Uo?Math.atan((Math.sin(t)*(u=Math.cos(r))*Math.sin(e)-Math.sin(r)*(i=Math.cos(t))*Math.sin(n))/(i*u*o)):(t+r)/2}function Ht(n,t,e,r){var i;if(null==n)i=e*Io,r.point(-Fo,i),r.point(0,i),r.point(Fo,i),r.point(Fo,0),r.point(Fo,-i),r.point(0,-i),r.point(-Fo,-i),r.point(-Fo,0),r.point(-Fo,i);else if(xo(n[0]-t[0])>Uo){var u=n[0]<t[0]?Fo:-Fo;i=e*u/2,r.point(-u,i),r.point(0,i),r.point(u,i)}else r.point(t[0],t[1])}function Ot(n,t){var e=n[0],r=n[1],i=[Math.sin(e),-Math.cos(e),0],u=0,o=0;ka.reset();for(var a=0,l=t.length;l>a;++a){var c=t[a],f=c.length;if(f)for(var s=c[0],h=s[0],p=s[1]/2+Fo/4,g=Math.sin(p),v=Math.cos(p),d=1;;){d===f&&(d=0),n=c[d];var y=n[0],m=n[1]/2+Fo/4,M=Math.sin(m),x=Math.cos(m),b=y-h,_=b>=0?1:-1,w=_*b,S=w>Fo,k=g*M;if(ka.add(Math.atan2(k*_*Math.sin(w),v*x+k*Math.cos(w))),u+=S?b+_*Ho:b,S^h>=e^y>=e){var N=mt(dt(s),dt(n));bt(N);var E=mt(i,N);bt(E);var A=(S^b>=0?-1:1)*tn(E[2]);(r>A||r===A&&(N[0]||N[1]))&&(o+=S^b>=0?1:-1)}if(!d++)break;h=y,g=M,v=x,s=n}}return(-Uo>u||Uo>u&&-Uo>ka)^1&o}function It(n){function t(n,t){return Math.cos(n)*Math.cos(t)>u}function e(n){var e,u,l,c,f;return{lineStart:function(){c=l=!1,f=1},point:function(s,h){var p,g=[s,h],v=t(s,h),d=o?v?0:i(s,h):v?i(s+(0>s?Fo:-Fo),h):0;if(!e&&(c=l=v)&&n.lineStart(),v!==l&&(p=r(e,g),(wt(e,p)||wt(g,p))&&(g[0]+=Uo,g[1]+=Uo,v=t(g[0],g[1]))),v!==l)f=0,v?(n.lineStart(),p=r(g,e),n.point(p[0],p[1])):(p=r(e,g),n.point(p[0],p[1]),n.lineEnd()),e=p;else if(a&&e&&o^v){var y;d&u||!(y=r(g,e,!0))||(f=0,o?(n.lineStart(),n.point(y[0][0],y[0][1]),n.point(y[1][0],y[1][1]),n.lineEnd()):(n.point(y[1][0],y[1][1]),n.lineEnd(),n.lineStart(),n.point(y[0][0],y[0][1])))}!v||e&&wt(e,g)||n.point(g[0],g[1]),e=g,l=v,u=d},lineEnd:function(){l&&n.lineEnd(),e=null},clean:function(){return f|(c&&l)<<1}}}function r(n,t,e){var r=dt(n),i=dt(t),o=[1,0,0],a=mt(r,i),l=yt(a,a),c=a[0],f=l-c*c;if(!f)return!e&&n;var s=u*l/f,h=-u*c/f,p=mt(o,a),g=xt(o,s),v=xt(a,h);Mt(g,v);var d=p,y=yt(g,d),m=yt(d,d),M=y*y-m*(yt(g,g)-1);if(!(0>M)){var x=Math.sqrt(M),b=xt(d,(-y-x)/m);if(Mt(b,g),b=_t(b),!e)return b;var _,w=n[0],S=t[0],k=n[1],N=t[1];w>S&&(_=w,w=S,S=_);var E=S-w,A=xo(E-Fo)<Uo,C=A||Uo>E;if(!A&&k>N&&(_=k,k=N,N=_),C?A?k+N>0^b[1]<(xo(b[0]-w)<Uo?k:N):k<=b[1]&&b[1]<=N:E>Fo^(w<=b[0]&&b[0]<=S)){var z=xt(d,(-y+x)/m);return Mt(z,g),[b,_t(z)]}}}function i(t,e){var r=o?n:Fo-n,i=0;return-r>t?i|=1:t>r&&(i|=2),-r>e?i|=4:e>r&&(i|=8),i}var u=Math.cos(n),o=u>0,a=xo(u)>Uo,l=ve(n,6*Yo);return Rt(t,e,l,o?[0,-n]:[-Fo,n-Fo])}function Yt(n,t,e,r){return function(i){var u,o=i.a,a=i.b,l=o.x,c=o.y,f=a.x,s=a.y,h=0,p=1,g=f-l,v=s-c;if(u=n-l,g||!(u>0)){if(u/=g,0>g){if(h>u)return;p>u&&(p=u)}else if(g>0){if(u>p)return;u>h&&(h=u)}if(u=e-l,g||!(0>u)){if(u/=g,0>g){if(u>p)return;u>h&&(h=u)}else if(g>0){if(h>u)return;p>u&&(p=u)}if(u=t-c,v||!(u>0)){if(u/=v,0>v){if(h>u)return;p>u&&(p=u)}else if(v>0){if(u>p)return;u>h&&(h=u)}if(u=r-c,v||!(0>u)){if(u/=v,0>v){if(u>p)return;u>h&&(h=u)}else if(v>0){if(h>u)return;p>u&&(p=u)}return h>0&&(i.a={x:l+h*g,y:c+h*v}),1>p&&(i.b={x:l+p*g,y:c+p*v}),i}}}}}}function Zt(n,t,e,r){function i(r,i){return xo(r[0]-n)<Uo?i>0?0:3:xo(r[0]-e)<Uo?i>0?2:1:xo(r[1]-t)<Uo?i>0?1:0:i>0?3:2}function u(n,t){return o(n.x,t.x)}function o(n,t){var e=i(n,1),r=i(t,1);return e!==r?e-r:0===e?t[1]-n[1]:1===e?n[0]-t[0]:2===e?n[1]-t[1]:t[0]-n[0]}return function(a){function l(n){for(var t=0,e=d.length,r=n[1],i=0;e>i;++i)for(var u,o=1,a=d[i],l=a.length,c=a[0];l>o;++o)u=a[o],c[1]<=r?u[1]>r&&Q(c,u,n)>0&&++t:u[1]<=r&&Q(c,u,n)<0&&--t,c=u;return 0!==t}function c(u,a,l,c){var f=0,s=0;if(null==u||(f=i(u,l))!==(s=i(a,l))||o(u,a)<0^l>0){do c.point(0===f||3===f?n:e,f>1?r:t);while((f=(f+l+4)%4)!==s)}else c.point(a[0],a[1])}function f(i,u){return i>=n&&e>=i&&u>=t&&r>=u}function s(n,t){f(n,t)&&a.point(n,t)}function h(){C.point=g,d&&d.push(y=[]),S=!0,w=!1,b=_=NaN}function p(){v&&(g(m,M),x&&w&&E.rejoin(),v.push(E.buffer())),C.point=s,w&&a.lineEnd()}function g(n,t){n=Math.max(-Ha,Math.min(Ha,n)),t=Math.max(-Ha,Math.min(Ha,t));var e=f(n,t);if(d&&y.push([n,t]),S)m=n,M=t,x=e,S=!1,e&&(a.lineStart(),a.point(n,t));else if(e&&w)a.point(n,t);else{var r={a:{x:b,y:_},b:{x:n,y:t}};A(r)?(w||(a.lineStart(),a.point(r.a.x,r.a.y)),a.point(r.b.x,r.b.y),e||a.lineEnd(),k=!1):e&&(a.lineStart(),a.point(n,t),k=!1)}b=n,_=t,w=e}var v,d,y,m,M,x,b,_,w,S,k,N=a,E=Pt(),A=Yt(n,t,e,r),C={point:s,lineStart:h,lineEnd:p,polygonStart:function(){a=E,v=[],d=[],k=!0},polygonEnd:function(){a=N,v=ao.merge(v);var t=l([n,r]),e=k&&t,i=v.length;(e||i)&&(a.polygonStart(),e&&(a.lineStart(),c(null,null,1,a),a.lineEnd()),i&&Lt(v,u,t,c,a),a.polygonEnd()),v=d=y=null}};return C}}function Vt(n){var t=0,e=Fo/3,r=ae(n),i=r(t,e);return i.parallels=function(n){return arguments.length?r(t=n[0]*Fo/180,e=n[1]*Fo/180):[t/Fo*180,e/Fo*180]},i}function Xt(n,t){function e(n,t){var e=Math.sqrt(u-2*i*Math.sin(t))/i;return[e*Math.sin(n*=i),o-e*Math.cos(n)]}var r=Math.sin(n),i=(r+Math.sin(t))/2,u=1+r*(2*i-r),o=Math.sqrt(u)/i;return e.invert=function(n,t){var e=o-t;return[Math.atan2(n,e)/i,tn((u-(n*n+e*e)*i*i)/(2*i))]},e}function $t(){function n(n,t){Ia+=i*n-r*t,r=n,i=t}var t,e,r,i;$a.point=function(u,o){$a.point=n,t=r=u,e=i=o},$a.lineEnd=function(){n(t,e)}}function Bt(n,t){Ya>n&&(Ya=n),n>Va&&(Va=n),Za>t&&(Za=t),t>Xa&&(Xa=t)}function Wt(){function n(n,t){o.push("M",n,",",t,u)}function t(n,t){o.push("M",n,",",t),a.point=e}function e(n,t){o.push("L",n,",",t)}function r(){a.point=n}function i(){o.push("Z")}var u=Jt(4.5),o=[],a={point:n,lineStart:function(){a.point=t},lineEnd:r,polygonStart:function(){a.lineEnd=i},polygonEnd:function(){a.lineEnd=r,a.point=n},pointRadius:function(n){return u=Jt(n),a},result:function(){if(o.length){var n=o.join("");return o=[],n}}};return a}function Jt(n){return"m0,"+n+"a"+n+","+n+" 0 1,1 0,"+-2*n+"a"+n+","+n+" 0 1,1 0,"+2*n+"z"}function Gt(n,t){Ca+=n,za+=t,++La}function Kt(){function n(n,r){var i=n-t,u=r-e,o=Math.sqrt(i*i+u*u);qa+=o*(t+n)/2,Ta+=o*(e+r)/2,Ra+=o,Gt(t=n,e=r)}var t,e;Wa.point=function(r,i){Wa.point=n,Gt(t=r,e=i)}}function Qt(){Wa.point=Gt}function ne(){function n(n,t){var e=n-r,u=t-i,o=Math.sqrt(e*e+u*u);qa+=o*(r+n)/2,Ta+=o*(i+t)/2,Ra+=o,o=i*n-r*t,Da+=o*(r+n),Pa+=o*(i+t),Ua+=3*o,Gt(r=n,i=t)}var t,e,r,i;Wa.point=function(u,o){Wa.point=n,Gt(t=r=u,e=i=o)},Wa.lineEnd=function(){n(t,e)}}function te(n){function t(t,e){n.moveTo(t+o,e),n.arc(t,e,o,0,Ho)}function e(t,e){n.moveTo(t,e),a.point=r}function r(t,e){n.lineTo(t,e)}function i(){a.point=t}function u(){n.closePath()}var o=4.5,a={point:t,lineStart:function(){a.point=e},lineEnd:i,polygonStart:function(){a.lineEnd=u},polygonEnd:function(){a.lineEnd=i,a.point=t},pointRadius:function(n){return o=n,a},result:b};return a}function ee(n){function t(n){return(a?r:e)(n)}function e(t){return ue(t,function(e,r){e=n(e,r),t.point(e[0],e[1])})}function r(t){function e(e,r){e=n(e,r),t.point(e[0],e[1])}function r(){M=NaN,S.point=u,t.lineStart()}function u(e,r){var u=dt([e,r]),o=n(e,r);i(M,x,m,b,_,w,M=o[0],x=o[1],m=e,b=u[0],_=u[1],w=u[2],a,t),t.point(M,x)}function o(){S.point=e,t.lineEnd()}function l(){
r(),S.point=c,S.lineEnd=f}function c(n,t){u(s=n,h=t),p=M,g=x,v=b,d=_,y=w,S.point=u}function f(){i(M,x,m,b,_,w,p,g,s,v,d,y,a,t),S.lineEnd=o,o()}var s,h,p,g,v,d,y,m,M,x,b,_,w,S={point:e,lineStart:r,lineEnd:o,polygonStart:function(){t.polygonStart(),S.lineStart=l},polygonEnd:function(){t.polygonEnd(),S.lineStart=r}};return S}function i(t,e,r,a,l,c,f,s,h,p,g,v,d,y){var m=f-t,M=s-e,x=m*m+M*M;if(x>4*u&&d--){var b=a+p,_=l+g,w=c+v,S=Math.sqrt(b*b+_*_+w*w),k=Math.asin(w/=S),N=xo(xo(w)-1)<Uo||xo(r-h)<Uo?(r+h)/2:Math.atan2(_,b),E=n(N,k),A=E[0],C=E[1],z=A-t,L=C-e,q=M*z-m*L;(q*q/x>u||xo((m*z+M*L)/x-.5)>.3||o>a*p+l*g+c*v)&&(i(t,e,r,a,l,c,A,C,N,b/=S,_/=S,w,d,y),y.point(A,C),i(A,C,N,b,_,w,f,s,h,p,g,v,d,y))}}var u=.5,o=Math.cos(30*Yo),a=16;return t.precision=function(n){return arguments.length?(a=(u=n*n)>0&&16,t):Math.sqrt(u)},t}function re(n){var t=ee(function(t,e){return n([t*Zo,e*Zo])});return function(n){return le(t(n))}}function ie(n){this.stream=n}function ue(n,t){return{point:t,sphere:function(){n.sphere()},lineStart:function(){n.lineStart()},lineEnd:function(){n.lineEnd()},polygonStart:function(){n.polygonStart()},polygonEnd:function(){n.polygonEnd()}}}function oe(n){return ae(function(){return n})()}function ae(n){function t(n){return n=a(n[0]*Yo,n[1]*Yo),[n[0]*h+l,c-n[1]*h]}function e(n){return n=a.invert((n[0]-l)/h,(c-n[1])/h),n&&[n[0]*Zo,n[1]*Zo]}function r(){a=Ct(o=se(y,M,x),u);var n=u(v,d);return l=p-n[0]*h,c=g+n[1]*h,i()}function i(){return f&&(f.valid=!1,f=null),t}var u,o,a,l,c,f,s=ee(function(n,t){return n=u(n,t),[n[0]*h+l,c-n[1]*h]}),h=150,p=480,g=250,v=0,d=0,y=0,M=0,x=0,b=Fa,_=m,w=null,S=null;return t.stream=function(n){return f&&(f.valid=!1),f=le(b(o,s(_(n)))),f.valid=!0,f},t.clipAngle=function(n){return arguments.length?(b=null==n?(w=n,Fa):It((w=+n)*Yo),i()):w},t.clipExtent=function(n){return arguments.length?(S=n,_=n?Zt(n[0][0],n[0][1],n[1][0],n[1][1]):m,i()):S},t.scale=function(n){return arguments.length?(h=+n,r()):h},t.translate=function(n){return arguments.length?(p=+n[0],g=+n[1],r()):[p,g]},t.center=function(n){return arguments.length?(v=n[0]%360*Yo,d=n[1]%360*Yo,r()):[v*Zo,d*Zo]},t.rotate=function(n){return arguments.length?(y=n[0]%360*Yo,M=n[1]%360*Yo,x=n.length>2?n[2]%360*Yo:0,r()):[y*Zo,M*Zo,x*Zo]},ao.rebind(t,s,"precision"),function(){return u=n.apply(this,arguments),t.invert=u.invert&&e,r()}}function le(n){return ue(n,function(t,e){n.point(t*Yo,e*Yo)})}function ce(n,t){return[n,t]}function fe(n,t){return[n>Fo?n-Ho:-Fo>n?n+Ho:n,t]}function se(n,t,e){return n?t||e?Ct(pe(n),ge(t,e)):pe(n):t||e?ge(t,e):fe}function he(n){return function(t,e){return t+=n,[t>Fo?t-Ho:-Fo>t?t+Ho:t,e]}}function pe(n){var t=he(n);return t.invert=he(-n),t}function ge(n,t){function e(n,t){var e=Math.cos(t),a=Math.cos(n)*e,l=Math.sin(n)*e,c=Math.sin(t),f=c*r+a*i;return[Math.atan2(l*u-f*o,a*r-c*i),tn(f*u+l*o)]}var r=Math.cos(n),i=Math.sin(n),u=Math.cos(t),o=Math.sin(t);return e.invert=function(n,t){var e=Math.cos(t),a=Math.cos(n)*e,l=Math.sin(n)*e,c=Math.sin(t),f=c*u-l*o;return[Math.atan2(l*u+c*o,a*r+f*i),tn(f*r-a*i)]},e}function ve(n,t){var e=Math.cos(n),r=Math.sin(n);return function(i,u,o,a){var l=o*t;null!=i?(i=de(e,i),u=de(e,u),(o>0?u>i:i>u)&&(i+=o*Ho)):(i=n+o*Ho,u=n-.5*l);for(var c,f=i;o>0?f>u:u>f;f-=l)a.point((c=_t([e,-r*Math.cos(f),-r*Math.sin(f)]))[0],c[1])}}function de(n,t){var e=dt(t);e[0]-=n,bt(e);var r=nn(-e[1]);return((-e[2]<0?-r:r)+2*Math.PI-Uo)%(2*Math.PI)}function ye(n,t,e){var r=ao.range(n,t-Uo,e).concat(t);return function(n){return r.map(function(t){return[n,t]})}}function me(n,t,e){var r=ao.range(n,t-Uo,e).concat(t);return function(n){return r.map(function(t){return[t,n]})}}function Me(n){return n.source}function xe(n){return n.target}function be(n,t,e,r){var i=Math.cos(t),u=Math.sin(t),o=Math.cos(r),a=Math.sin(r),l=i*Math.cos(n),c=i*Math.sin(n),f=o*Math.cos(e),s=o*Math.sin(e),h=2*Math.asin(Math.sqrt(on(r-t)+i*o*on(e-n))),p=1/Math.sin(h),g=h?function(n){var t=Math.sin(n*=h)*p,e=Math.sin(h-n)*p,r=e*l+t*f,i=e*c+t*s,o=e*u+t*a;return[Math.atan2(i,r)*Zo,Math.atan2(o,Math.sqrt(r*r+i*i))*Zo]}:function(){return[n*Zo,t*Zo]};return g.distance=h,g}function _e(){function n(n,i){var u=Math.sin(i*=Yo),o=Math.cos(i),a=xo((n*=Yo)-t),l=Math.cos(a);Ja+=Math.atan2(Math.sqrt((a=o*Math.sin(a))*a+(a=r*u-e*o*l)*a),e*u+r*o*l),t=n,e=u,r=o}var t,e,r;Ga.point=function(i,u){t=i*Yo,e=Math.sin(u*=Yo),r=Math.cos(u),Ga.point=n},Ga.lineEnd=function(){Ga.point=Ga.lineEnd=b}}function we(n,t){function e(t,e){var r=Math.cos(t),i=Math.cos(e),u=n(r*i);return[u*i*Math.sin(t),u*Math.sin(e)]}return e.invert=function(n,e){var r=Math.sqrt(n*n+e*e),i=t(r),u=Math.sin(i),o=Math.cos(i);return[Math.atan2(n*u,r*o),Math.asin(r&&e*u/r)]},e}function Se(n,t){function e(n,t){o>0?-Io+Uo>t&&(t=-Io+Uo):t>Io-Uo&&(t=Io-Uo);var e=o/Math.pow(i(t),u);return[e*Math.sin(u*n),o-e*Math.cos(u*n)]}var r=Math.cos(n),i=function(n){return Math.tan(Fo/4+n/2)},u=n===t?Math.sin(n):Math.log(r/Math.cos(t))/Math.log(i(t)/i(n)),o=r*Math.pow(i(n),u)/u;return u?(e.invert=function(n,t){var e=o-t,r=K(u)*Math.sqrt(n*n+e*e);return[Math.atan2(n,e)/u,2*Math.atan(Math.pow(o/r,1/u))-Io]},e):Ne}function ke(n,t){function e(n,t){var e=u-t;return[e*Math.sin(i*n),u-e*Math.cos(i*n)]}var r=Math.cos(n),i=n===t?Math.sin(n):(r-Math.cos(t))/(t-n),u=r/i+n;return xo(i)<Uo?ce:(e.invert=function(n,t){var e=u-t;return[Math.atan2(n,e)/i,u-K(i)*Math.sqrt(n*n+e*e)]},e)}function Ne(n,t){return[n,Math.log(Math.tan(Fo/4+t/2))]}function Ee(n){var t,e=oe(n),r=e.scale,i=e.translate,u=e.clipExtent;return e.scale=function(){var n=r.apply(e,arguments);return n===e?t?e.clipExtent(null):e:n},e.translate=function(){var n=i.apply(e,arguments);return n===e?t?e.clipExtent(null):e:n},e.clipExtent=function(n){var o=u.apply(e,arguments);if(o===e){if(t=null==n){var a=Fo*r(),l=i();u([[l[0]-a,l[1]-a],[l[0]+a,l[1]+a]])}}else t&&(o=null);return o},e.clipExtent(null)}function Ae(n,t){return[Math.log(Math.tan(Fo/4+t/2)),-n]}function Ce(n){return n[0]}function ze(n){return n[1]}function Le(n){for(var t=n.length,e=[0,1],r=2,i=2;t>i;i++){for(;r>1&&Q(n[e[r-2]],n[e[r-1]],n[i])<=0;)--r;e[r++]=i}return e.slice(0,r)}function qe(n,t){return n[0]-t[0]||n[1]-t[1]}function Te(n,t,e){return(e[0]-t[0])*(n[1]-t[1])<(e[1]-t[1])*(n[0]-t[0])}function Re(n,t,e,r){var i=n[0],u=e[0],o=t[0]-i,a=r[0]-u,l=n[1],c=e[1],f=t[1]-l,s=r[1]-c,h=(a*(l-c)-s*(i-u))/(s*o-a*f);return[i+h*o,l+h*f]}function De(n){var t=n[0],e=n[n.length-1];return!(t[0]-e[0]||t[1]-e[1])}function Pe(){rr(this),this.edge=this.site=this.circle=null}function Ue(n){var t=cl.pop()||new Pe;return t.site=n,t}function je(n){Be(n),ol.remove(n),cl.push(n),rr(n)}function Fe(n){var t=n.circle,e=t.x,r=t.cy,i={x:e,y:r},u=n.P,o=n.N,a=[n];je(n);for(var l=u;l.circle&&xo(e-l.circle.x)<Uo&&xo(r-l.circle.cy)<Uo;)u=l.P,a.unshift(l),je(l),l=u;a.unshift(l),Be(l);for(var c=o;c.circle&&xo(e-c.circle.x)<Uo&&xo(r-c.circle.cy)<Uo;)o=c.N,a.push(c),je(c),c=o;a.push(c),Be(c);var f,s=a.length;for(f=1;s>f;++f)c=a[f],l=a[f-1],nr(c.edge,l.site,c.site,i);l=a[0],c=a[s-1],c.edge=Ke(l.site,c.site,null,i),$e(l),$e(c)}function He(n){for(var t,e,r,i,u=n.x,o=n.y,a=ol._;a;)if(r=Oe(a,o)-u,r>Uo)a=a.L;else{if(i=u-Ie(a,o),!(i>Uo)){r>-Uo?(t=a.P,e=a):i>-Uo?(t=a,e=a.N):t=e=a;break}if(!a.R){t=a;break}a=a.R}var l=Ue(n);if(ol.insert(t,l),t||e){if(t===e)return Be(t),e=Ue(t.site),ol.insert(l,e),l.edge=e.edge=Ke(t.site,l.site),$e(t),void $e(e);if(!e)return void(l.edge=Ke(t.site,l.site));Be(t),Be(e);var c=t.site,f=c.x,s=c.y,h=n.x-f,p=n.y-s,g=e.site,v=g.x-f,d=g.y-s,y=2*(h*d-p*v),m=h*h+p*p,M=v*v+d*d,x={x:(d*m-p*M)/y+f,y:(h*M-v*m)/y+s};nr(e.edge,c,g,x),l.edge=Ke(c,n,null,x),e.edge=Ke(n,g,null,x),$e(t),$e(e)}}function Oe(n,t){var e=n.site,r=e.x,i=e.y,u=i-t;if(!u)return r;var o=n.P;if(!o)return-(1/0);e=o.site;var a=e.x,l=e.y,c=l-t;if(!c)return a;var f=a-r,s=1/u-1/c,h=f/c;return s?(-h+Math.sqrt(h*h-2*s*(f*f/(-2*c)-l+c/2+i-u/2)))/s+r:(r+a)/2}function Ie(n,t){var e=n.N;if(e)return Oe(e,t);var r=n.site;return r.y===t?r.x:1/0}function Ye(n){this.site=n,this.edges=[]}function Ze(n){for(var t,e,r,i,u,o,a,l,c,f,s=n[0][0],h=n[1][0],p=n[0][1],g=n[1][1],v=ul,d=v.length;d--;)if(u=v[d],u&&u.prepare())for(a=u.edges,l=a.length,o=0;l>o;)f=a[o].end(),r=f.x,i=f.y,c=a[++o%l].start(),t=c.x,e=c.y,(xo(r-t)>Uo||xo(i-e)>Uo)&&(a.splice(o,0,new tr(Qe(u.site,f,xo(r-s)<Uo&&g-i>Uo?{x:s,y:xo(t-s)<Uo?e:g}:xo(i-g)<Uo&&h-r>Uo?{x:xo(e-g)<Uo?t:h,y:g}:xo(r-h)<Uo&&i-p>Uo?{x:h,y:xo(t-h)<Uo?e:p}:xo(i-p)<Uo&&r-s>Uo?{x:xo(e-p)<Uo?t:s,y:p}:null),u.site,null)),++l)}function Ve(n,t){return t.angle-n.angle}function Xe(){rr(this),this.x=this.y=this.arc=this.site=this.cy=null}function $e(n){var t=n.P,e=n.N;if(t&&e){var r=t.site,i=n.site,u=e.site;if(r!==u){var o=i.x,a=i.y,l=r.x-o,c=r.y-a,f=u.x-o,s=u.y-a,h=2*(l*s-c*f);if(!(h>=-jo)){var p=l*l+c*c,g=f*f+s*s,v=(s*p-c*g)/h,d=(l*g-f*p)/h,s=d+a,y=fl.pop()||new Xe;y.arc=n,y.site=i,y.x=v+o,y.y=s+Math.sqrt(v*v+d*d),y.cy=s,n.circle=y;for(var m=null,M=ll._;M;)if(y.y<M.y||y.y===M.y&&y.x<=M.x){if(!M.L){m=M.P;break}M=M.L}else{if(!M.R){m=M;break}M=M.R}ll.insert(m,y),m||(al=y)}}}}function Be(n){var t=n.circle;t&&(t.P||(al=t.N),ll.remove(t),fl.push(t),rr(t),n.circle=null)}function We(n){for(var t,e=il,r=Yt(n[0][0],n[0][1],n[1][0],n[1][1]),i=e.length;i--;)t=e[i],(!Je(t,n)||!r(t)||xo(t.a.x-t.b.x)<Uo&&xo(t.a.y-t.b.y)<Uo)&&(t.a=t.b=null,e.splice(i,1))}function Je(n,t){var e=n.b;if(e)return!0;var r,i,u=n.a,o=t[0][0],a=t[1][0],l=t[0][1],c=t[1][1],f=n.l,s=n.r,h=f.x,p=f.y,g=s.x,v=s.y,d=(h+g)/2,y=(p+v)/2;if(v===p){if(o>d||d>=a)return;if(h>g){if(u){if(u.y>=c)return}else u={x:d,y:l};e={x:d,y:c}}else{if(u){if(u.y<l)return}else u={x:d,y:c};e={x:d,y:l}}}else if(r=(h-g)/(v-p),i=y-r*d,-1>r||r>1)if(h>g){if(u){if(u.y>=c)return}else u={x:(l-i)/r,y:l};e={x:(c-i)/r,y:c}}else{if(u){if(u.y<l)return}else u={x:(c-i)/r,y:c};e={x:(l-i)/r,y:l}}else if(v>p){if(u){if(u.x>=a)return}else u={x:o,y:r*o+i};e={x:a,y:r*a+i}}else{if(u){if(u.x<o)return}else u={x:a,y:r*a+i};e={x:o,y:r*o+i}}return n.a=u,n.b=e,!0}function Ge(n,t){this.l=n,this.r=t,this.a=this.b=null}function Ke(n,t,e,r){var i=new Ge(n,t);return il.push(i),e&&nr(i,n,t,e),r&&nr(i,t,n,r),ul[n.i].edges.push(new tr(i,n,t)),ul[t.i].edges.push(new tr(i,t,n)),i}function Qe(n,t,e){var r=new Ge(n,null);return r.a=t,r.b=e,il.push(r),r}function nr(n,t,e,r){n.a||n.b?n.l===e?n.b=r:n.a=r:(n.a=r,n.l=t,n.r=e)}function tr(n,t,e){var r=n.a,i=n.b;this.edge=n,this.site=t,this.angle=e?Math.atan2(e.y-t.y,e.x-t.x):n.l===t?Math.atan2(i.x-r.x,r.y-i.y):Math.atan2(r.x-i.x,i.y-r.y)}function er(){this._=null}function rr(n){n.U=n.C=n.L=n.R=n.P=n.N=null}function ir(n,t){var e=t,r=t.R,i=e.U;i?i.L===e?i.L=r:i.R=r:n._=r,r.U=i,e.U=r,e.R=r.L,e.R&&(e.R.U=e),r.L=e}function ur(n,t){var e=t,r=t.L,i=e.U;i?i.L===e?i.L=r:i.R=r:n._=r,r.U=i,e.U=r,e.L=r.R,e.L&&(e.L.U=e),r.R=e}function or(n){for(;n.L;)n=n.L;return n}function ar(n,t){var e,r,i,u=n.sort(lr).pop();for(il=[],ul=new Array(n.length),ol=new er,ll=new er;;)if(i=al,u&&(!i||u.y<i.y||u.y===i.y&&u.x<i.x))u.x===e&&u.y===r||(ul[u.i]=new Ye(u),He(u),e=u.x,r=u.y),u=n.pop();else{if(!i)break;Fe(i.arc)}t&&(We(t),Ze(t));var o={cells:ul,edges:il};return ol=ll=il=ul=null,o}function lr(n,t){return t.y-n.y||t.x-n.x}function cr(n,t,e){return(n.x-e.x)*(t.y-n.y)-(n.x-t.x)*(e.y-n.y)}function fr(n){return n.x}function sr(n){return n.y}function hr(){return{leaf:!0,nodes:[],point:null,x:null,y:null}}function pr(n,t,e,r,i,u){if(!n(t,e,r,i,u)){var o=.5*(e+i),a=.5*(r+u),l=t.nodes;l[0]&&pr(n,l[0],e,r,o,a),l[1]&&pr(n,l[1],o,r,i,a),l[2]&&pr(n,l[2],e,a,o,u),l[3]&&pr(n,l[3],o,a,i,u)}}function gr(n,t,e,r,i,u,o){var a,l=1/0;return function c(n,f,s,h,p){if(!(f>u||s>o||r>h||i>p)){if(g=n.point){var g,v=t-n.x,d=e-n.y,y=v*v+d*d;if(l>y){var m=Math.sqrt(l=y);r=t-m,i=e-m,u=t+m,o=e+m,a=g}}for(var M=n.nodes,x=.5*(f+h),b=.5*(s+p),_=t>=x,w=e>=b,S=w<<1|_,k=S+4;k>S;++S)if(n=M[3&S])switch(3&S){case 0:c(n,f,s,x,b);break;case 1:c(n,x,s,h,b);break;case 2:c(n,f,b,x,p);break;case 3:c(n,x,b,h,p)}}}(n,r,i,u,o),a}function vr(n,t){n=ao.rgb(n),t=ao.rgb(t);var e=n.r,r=n.g,i=n.b,u=t.r-e,o=t.g-r,a=t.b-i;return function(n){return"#"+bn(Math.round(e+u*n))+bn(Math.round(r+o*n))+bn(Math.round(i+a*n))}}function dr(n,t){var e,r={},i={};for(e in n)e in t?r[e]=Mr(n[e],t[e]):i[e]=n[e];for(e in t)e in n||(i[e]=t[e]);return function(n){for(e in r)i[e]=r[e](n);return i}}function yr(n,t){return n=+n,t=+t,function(e){return n*(1-e)+t*e}}function mr(n,t){var e,r,i,u=hl.lastIndex=pl.lastIndex=0,o=-1,a=[],l=[];for(n+="",t+="";(e=hl.exec(n))&&(r=pl.exec(t));)(i=r.index)>u&&(i=t.slice(u,i),a[o]?a[o]+=i:a[++o]=i),(e=e[0])===(r=r[0])?a[o]?a[o]+=r:a[++o]=r:(a[++o]=null,l.push({i:o,x:yr(e,r)})),u=pl.lastIndex;return u<t.length&&(i=t.slice(u),a[o]?a[o]+=i:a[++o]=i),a.length<2?l[0]?(t=l[0].x,function(n){return t(n)+""}):function(){return t}:(t=l.length,function(n){for(var e,r=0;t>r;++r)a[(e=l[r]).i]=e.x(n);return a.join("")})}function Mr(n,t){for(var e,r=ao.interpolators.length;--r>=0&&!(e=ao.interpolators[r](n,t)););return e}function xr(n,t){var e,r=[],i=[],u=n.length,o=t.length,a=Math.min(n.length,t.length);for(e=0;a>e;++e)r.push(Mr(n[e],t[e]));for(;u>e;++e)i[e]=n[e];for(;o>e;++e)i[e]=t[e];return function(n){for(e=0;a>e;++e)i[e]=r[e](n);return i}}function br(n){return function(t){return 0>=t?0:t>=1?1:n(t)}}function _r(n){return function(t){return 1-n(1-t)}}function wr(n){return function(t){return.5*(.5>t?n(2*t):2-n(2-2*t))}}function Sr(n){return n*n}function kr(n){return n*n*n}function Nr(n){if(0>=n)return 0;if(n>=1)return 1;var t=n*n,e=t*n;return 4*(.5>n?e:3*(n-t)+e-.75)}function Er(n){return function(t){return Math.pow(t,n)}}function Ar(n){return 1-Math.cos(n*Io)}function Cr(n){return Math.pow(2,10*(n-1))}function zr(n){return 1-Math.sqrt(1-n*n)}function Lr(n,t){var e;return arguments.length<2&&(t=.45),arguments.length?e=t/Ho*Math.asin(1/n):(n=1,e=t/4),function(r){return 1+n*Math.pow(2,-10*r)*Math.sin((r-e)*Ho/t)}}function qr(n){return n||(n=1.70158),function(t){return t*t*((n+1)*t-n)}}function Tr(n){return 1/2.75>n?7.5625*n*n:2/2.75>n?7.5625*(n-=1.5/2.75)*n+.75:2.5/2.75>n?7.5625*(n-=2.25/2.75)*n+.9375:7.5625*(n-=2.625/2.75)*n+.984375}function Rr(n,t){n=ao.hcl(n),t=ao.hcl(t);var e=n.h,r=n.c,i=n.l,u=t.h-e,o=t.c-r,a=t.l-i;return isNaN(o)&&(o=0,r=isNaN(r)?t.c:r),isNaN(u)?(u=0,e=isNaN(e)?t.h:e):u>180?u-=360:-180>u&&(u+=360),function(n){return sn(e+u*n,r+o*n,i+a*n)+""}}function Dr(n,t){n=ao.hsl(n),t=ao.hsl(t);var e=n.h,r=n.s,i=n.l,u=t.h-e,o=t.s-r,a=t.l-i;return isNaN(o)&&(o=0,r=isNaN(r)?t.s:r),isNaN(u)?(u=0,e=isNaN(e)?t.h:e):u>180?u-=360:-180>u&&(u+=360),function(n){return cn(e+u*n,r+o*n,i+a*n)+""}}function Pr(n,t){n=ao.lab(n),t=ao.lab(t);var e=n.l,r=n.a,i=n.b,u=t.l-e,o=t.a-r,a=t.b-i;return function(n){return pn(e+u*n,r+o*n,i+a*n)+""}}function Ur(n,t){return t-=n,function(e){return Math.round(n+t*e)}}function jr(n){var t=[n.a,n.b],e=[n.c,n.d],r=Hr(t),i=Fr(t,e),u=Hr(Or(e,t,-i))||0;t[0]*e[1]<e[0]*t[1]&&(t[0]*=-1,t[1]*=-1,r*=-1,i*=-1),this.rotate=(r?Math.atan2(t[1],t[0]):Math.atan2(-e[0],e[1]))*Zo,this.translate=[n.e,n.f],this.scale=[r,u],this.skew=u?Math.atan2(i,u)*Zo:0}function Fr(n,t){return n[0]*t[0]+n[1]*t[1]}function Hr(n){var t=Math.sqrt(Fr(n,n));return t&&(n[0]/=t,n[1]/=t),t}function Or(n,t,e){return n[0]+=e*t[0],n[1]+=e*t[1],n}function Ir(n){return n.length?n.pop()+",":""}function Yr(n,t,e,r){if(n[0]!==t[0]||n[1]!==t[1]){var i=e.push("translate(",null,",",null,")");r.push({i:i-4,x:yr(n[0],t[0])},{i:i-2,x:yr(n[1],t[1])})}else(t[0]||t[1])&&e.push("translate("+t+")")}function Zr(n,t,e,r){n!==t?(n-t>180?t+=360:t-n>180&&(n+=360),r.push({i:e.push(Ir(e)+"rotate(",null,")")-2,x:yr(n,t)})):t&&e.push(Ir(e)+"rotate("+t+")")}function Vr(n,t,e,r){n!==t?r.push({i:e.push(Ir(e)+"skewX(",null,")")-2,x:yr(n,t)}):t&&e.push(Ir(e)+"skewX("+t+")")}function Xr(n,t,e,r){if(n[0]!==t[0]||n[1]!==t[1]){var i=e.push(Ir(e)+"scale(",null,",",null,")");r.push({i:i-4,x:yr(n[0],t[0])},{i:i-2,x:yr(n[1],t[1])})}else 1===t[0]&&1===t[1]||e.push(Ir(e)+"scale("+t+")")}function $r(n,t){var e=[],r=[];return n=ao.transform(n),t=ao.transform(t),Yr(n.translate,t.translate,e,r),Zr(n.rotate,t.rotate,e,r),Vr(n.skew,t.skew,e,r),Xr(n.scale,t.scale,e,r),n=t=null,function(n){for(var t,i=-1,u=r.length;++i<u;)e[(t=r[i]).i]=t.x(n);return e.join("")}}function Br(n,t){return t=(t-=n=+n)||1/t,function(e){return(e-n)/t}}function Wr(n,t){return t=(t-=n=+n)||1/t,function(e){return Math.max(0,Math.min(1,(e-n)/t))}}function Jr(n){for(var t=n.source,e=n.target,r=Kr(t,e),i=[t];t!==r;)t=t.parent,i.push(t);for(var u=i.length;e!==r;)i.splice(u,0,e),e=e.parent;return i}function Gr(n){for(var t=[],e=n.parent;null!=e;)t.push(n),n=e,e=e.parent;return t.push(n),t}function Kr(n,t){if(n===t)return n;for(var e=Gr(n),r=Gr(t),i=e.pop(),u=r.pop(),o=null;i===u;)o=i,i=e.pop(),u=r.pop();return o}function Qr(n){n.fixed|=2}function ni(n){n.fixed&=-7}function ti(n){n.fixed|=4,n.px=n.x,n.py=n.y}function ei(n){n.fixed&=-5}function ri(n,t,e){var r=0,i=0;if(n.charge=0,!n.leaf)for(var u,o=n.nodes,a=o.length,l=-1;++l<a;)u=o[l],null!=u&&(ri(u,t,e),n.charge+=u.charge,r+=u.charge*u.cx,i+=u.charge*u.cy);if(n.point){n.leaf||(n.point.x+=Math.random()-.5,n.point.y+=Math.random()-.5);var c=t*e[n.point.index];n.charge+=n.pointCharge=c,r+=c*n.point.x,i+=c*n.point.y}n.cx=r/n.charge,n.cy=i/n.charge}function ii(n,t){return ao.rebind(n,t,"sort","children","value"),n.nodes=n,n.links=fi,n}function ui(n,t){for(var e=[n];null!=(n=e.pop());)if(t(n),(i=n.children)&&(r=i.length))for(var r,i;--r>=0;)e.push(i[r])}function oi(n,t){for(var e=[n],r=[];null!=(n=e.pop());)if(r.push(n),(u=n.children)&&(i=u.length))for(var i,u,o=-1;++o<i;)e.push(u[o]);for(;null!=(n=r.pop());)t(n)}function ai(n){return n.children}function li(n){return n.value}function ci(n,t){return t.value-n.value}function fi(n){return ao.merge(n.map(function(n){return(n.children||[]).map(function(t){return{source:n,target:t}})}))}function si(n){return n.x}function hi(n){return n.y}function pi(n,t,e){n.y0=t,n.y=e}function gi(n){return ao.range(n.length)}function vi(n){for(var t=-1,e=n[0].length,r=[];++t<e;)r[t]=0;return r}function di(n){for(var t,e=1,r=0,i=n[0][1],u=n.length;u>e;++e)(t=n[e][1])>i&&(r=e,i=t);return r}function yi(n){return n.reduce(mi,0)}function mi(n,t){return n+t[1]}function Mi(n,t){return xi(n,Math.ceil(Math.log(t.length)/Math.LN2+1))}function xi(n,t){for(var e=-1,r=+n[0],i=(n[1]-r)/t,u=[];++e<=t;)u[e]=i*e+r;return u}function bi(n){return[ao.min(n),ao.max(n)]}function _i(n,t){return n.value-t.value}function wi(n,t){var e=n._pack_next;n._pack_next=t,t._pack_prev=n,t._pack_next=e,e._pack_prev=t}function Si(n,t){n._pack_next=t,t._pack_prev=n}function ki(n,t){var e=t.x-n.x,r=t.y-n.y,i=n.r+t.r;return.999*i*i>e*e+r*r}function Ni(n){function t(n){f=Math.min(n.x-n.r,f),s=Math.max(n.x+n.r,s),h=Math.min(n.y-n.r,h),p=Math.max(n.y+n.r,p)}if((e=n.children)&&(c=e.length)){var e,r,i,u,o,a,l,c,f=1/0,s=-(1/0),h=1/0,p=-(1/0);if(e.forEach(Ei),r=e[0],r.x=-r.r,r.y=0,t(r),c>1&&(i=e[1],i.x=i.r,i.y=0,t(i),c>2))for(u=e[2],zi(r,i,u),t(u),wi(r,u),r._pack_prev=u,wi(u,i),i=r._pack_next,o=3;c>o;o++){zi(r,i,u=e[o]);var g=0,v=1,d=1;for(a=i._pack_next;a!==i;a=a._pack_next,v++)if(ki(a,u)){g=1;break}if(1==g)for(l=r._pack_prev;l!==a._pack_prev&&!ki(l,u);l=l._pack_prev,d++);g?(d>v||v==d&&i.r<r.r?Si(r,i=a):Si(r=l,i),o--):(wi(r,u),i=u,t(u))}var y=(f+s)/2,m=(h+p)/2,M=0;for(o=0;c>o;o++)u=e[o],u.x-=y,u.y-=m,M=Math.max(M,u.r+Math.sqrt(u.x*u.x+u.y*u.y));n.r=M,e.forEach(Ai)}}function Ei(n){n._pack_next=n._pack_prev=n}function Ai(n){delete n._pack_next,delete n._pack_prev}function Ci(n,t,e,r){var i=n.children;if(n.x=t+=r*n.x,n.y=e+=r*n.y,n.r*=r,i)for(var u=-1,o=i.length;++u<o;)Ci(i[u],t,e,r)}function zi(n,t,e){var r=n.r+e.r,i=t.x-n.x,u=t.y-n.y;if(r&&(i||u)){var o=t.r+e.r,a=i*i+u*u;o*=o,r*=r;var l=.5+(r-o)/(2*a),c=Math.sqrt(Math.max(0,2*o*(r+a)-(r-=a)*r-o*o))/(2*a);e.x=n.x+l*i+c*u,e.y=n.y+l*u-c*i}else e.x=n.x+r,e.y=n.y}function Li(n,t){return n.parent==t.parent?1:2}function qi(n){var t=n.children;return t.length?t[0]:n.t}function Ti(n){var t,e=n.children;return(t=e.length)?e[t-1]:n.t}function Ri(n,t,e){var r=e/(t.i-n.i);t.c-=r,t.s+=e,n.c+=r,t.z+=e,t.m+=e}function Di(n){for(var t,e=0,r=0,i=n.children,u=i.length;--u>=0;)t=i[u],t.z+=e,t.m+=e,e+=t.s+(r+=t.c)}function Pi(n,t,e){return n.a.parent===t.parent?n.a:e}function Ui(n){return 1+ao.max(n,function(n){return n.y})}function ji(n){return n.reduce(function(n,t){return n+t.x},0)/n.length}function Fi(n){var t=n.children;return t&&t.length?Fi(t[0]):n}function Hi(n){var t,e=n.children;return e&&(t=e.length)?Hi(e[t-1]):n}function Oi(n){return{x:n.x,y:n.y,dx:n.dx,dy:n.dy}}function Ii(n,t){var e=n.x+t[3],r=n.y+t[0],i=n.dx-t[1]-t[3],u=n.dy-t[0]-t[2];return 0>i&&(e+=i/2,i=0),0>u&&(r+=u/2,u=0),{x:e,y:r,dx:i,dy:u}}function Yi(n){var t=n[0],e=n[n.length-1];return e>t?[t,e]:[e,t]}function Zi(n){return n.rangeExtent?n.rangeExtent():Yi(n.range())}function Vi(n,t,e,r){var i=e(n[0],n[1]),u=r(t[0],t[1]);return function(n){return u(i(n))}}function Xi(n,t){var e,r=0,i=n.length-1,u=n[r],o=n[i];return u>o&&(e=r,r=i,i=e,e=u,u=o,o=e),n[r]=t.floor(u),n[i]=t.ceil(o),n}function $i(n){return n?{floor:function(t){return Math.floor(t/n)*n},ceil:function(t){return Math.ceil(t/n)*n}}:Sl}function Bi(n,t,e,r){var i=[],u=[],o=0,a=Math.min(n.length,t.length)-1;for(n[a]<n[0]&&(n=n.slice().reverse(),t=t.slice().reverse());++o<=a;)i.push(e(n[o-1],n[o])),u.push(r(t[o-1],t[o]));return function(t){var e=ao.bisect(n,t,1,a)-1;return u[e](i[e](t))}}function Wi(n,t,e,r){function i(){var i=Math.min(n.length,t.length)>2?Bi:Vi,l=r?Wr:Br;return o=i(n,t,l,e),a=i(t,n,l,Mr),u}function u(n){return o(n)}var o,a;return u.invert=function(n){return a(n)},u.domain=function(t){return arguments.length?(n=t.map(Number),i()):n},u.range=function(n){return arguments.length?(t=n,i()):t},u.rangeRound=function(n){return u.range(n).interpolate(Ur)},u.clamp=function(n){return arguments.length?(r=n,i()):r},u.interpolate=function(n){return arguments.length?(e=n,i()):e},u.ticks=function(t){return Qi(n,t)},u.tickFormat=function(t,e){return nu(n,t,e)},u.nice=function(t){return Gi(n,t),i()},u.copy=function(){return Wi(n,t,e,r)},i()}function Ji(n,t){return ao.rebind(n,t,"range","rangeRound","interpolate","clamp")}function Gi(n,t){return Xi(n,$i(Ki(n,t)[2])),Xi(n,$i(Ki(n,t)[2])),n}function Ki(n,t){null==t&&(t=10);var e=Yi(n),r=e[1]-e[0],i=Math.pow(10,Math.floor(Math.log(r/t)/Math.LN10)),u=t/r*i;return.15>=u?i*=10:.35>=u?i*=5:.75>=u&&(i*=2),e[0]=Math.ceil(e[0]/i)*i,e[1]=Math.floor(e[1]/i)*i+.5*i,e[2]=i,e}function Qi(n,t){return ao.range.apply(ao,Ki(n,t))}function nu(n,t,e){var r=Ki(n,t);if(e){var i=ha.exec(e);if(i.shift(),"s"===i[8]){var u=ao.formatPrefix(Math.max(xo(r[0]),xo(r[1])));return i[7]||(i[7]="."+tu(u.scale(r[2]))),i[8]="f",e=ao.format(i.join("")),function(n){return e(u.scale(n))+u.symbol}}i[7]||(i[7]="."+eu(i[8],r)),e=i.join("")}else e=",."+tu(r[2])+"f";return ao.format(e)}function tu(n){return-Math.floor(Math.log(n)/Math.LN10+.01)}function eu(n,t){var e=tu(t[2]);return n in kl?Math.abs(e-tu(Math.max(xo(t[0]),xo(t[1]))))+ +("e"!==n):e-2*("%"===n)}function ru(n,t,e,r){function i(n){return(e?Math.log(0>n?0:n):-Math.log(n>0?0:-n))/Math.log(t)}function u(n){return e?Math.pow(t,n):-Math.pow(t,-n)}function o(t){return n(i(t))}return o.invert=function(t){return u(n.invert(t))},o.domain=function(t){return arguments.length?(e=t[0]>=0,n.domain((r=t.map(Number)).map(i)),o):r},o.base=function(e){return arguments.length?(t=+e,n.domain(r.map(i)),o):t},o.nice=function(){var t=Xi(r.map(i),e?Math:El);return n.domain(t),r=t.map(u),o},o.ticks=function(){var n=Yi(r),o=[],a=n[0],l=n[1],c=Math.floor(i(a)),f=Math.ceil(i(l)),s=t%1?2:t;if(isFinite(f-c)){if(e){for(;f>c;c++)for(var h=1;s>h;h++)o.push(u(c)*h);o.push(u(c))}else for(o.push(u(c));c++<f;)for(var h=s-1;h>0;h--)o.push(u(c)*h);for(c=0;o[c]<a;c++);for(f=o.length;o[f-1]>l;f--);o=o.slice(c,f)}return o},o.tickFormat=function(n,e){if(!arguments.length)return Nl;arguments.length<2?e=Nl:"function"!=typeof e&&(e=ao.format(e));var r=Math.max(1,t*n/o.ticks().length);return function(n){var o=n/u(Math.round(i(n)));return t-.5>o*t&&(o*=t),r>=o?e(n):""}},o.copy=function(){return ru(n.copy(),t,e,r)},Ji(o,n)}function iu(n,t,e){function r(t){return n(i(t))}var i=uu(t),u=uu(1/t);return r.invert=function(t){return u(n.invert(t))},r.domain=function(t){return arguments.length?(n.domain((e=t.map(Number)).map(i)),r):e},r.ticks=function(n){return Qi(e,n)},r.tickFormat=function(n,t){return nu(e,n,t)},r.nice=function(n){return r.domain(Gi(e,n))},r.exponent=function(o){return arguments.length?(i=uu(t=o),u=uu(1/t),n.domain(e.map(i)),r):t},r.copy=function(){return iu(n.copy(),t,e)},Ji(r,n)}function uu(n){return function(t){return 0>t?-Math.pow(-t,n):Math.pow(t,n)}}function ou(n,t){function e(e){return u[((i.get(e)||("range"===t.t?i.set(e,n.push(e)):NaN))-1)%u.length]}function r(t,e){return ao.range(n.length).map(function(n){return t+e*n})}var i,u,o;return e.domain=function(r){if(!arguments.length)return n;n=[],i=new c;for(var u,o=-1,a=r.length;++o<a;)i.has(u=r[o])||i.set(u,n.push(u));return e[t.t].apply(e,t.a)},e.range=function(n){return arguments.length?(u=n,o=0,t={t:"range",a:arguments},e):u},e.rangePoints=function(i,a){arguments.length<2&&(a=0);var l=i[0],c=i[1],f=n.length<2?(l=(l+c)/2,0):(c-l)/(n.length-1+a);return u=r(l+f*a/2,f),o=0,t={t:"rangePoints",a:arguments},e},e.rangeRoundPoints=function(i,a){arguments.length<2&&(a=0);var l=i[0],c=i[1],f=n.length<2?(l=c=Math.round((l+c)/2),0):(c-l)/(n.length-1+a)|0;return u=r(l+Math.round(f*a/2+(c-l-(n.length-1+a)*f)/2),f),o=0,t={t:"rangeRoundPoints",a:arguments},e},e.rangeBands=function(i,a,l){arguments.length<2&&(a=0),arguments.length<3&&(l=a);var c=i[1]<i[0],f=i[c-0],s=i[1-c],h=(s-f)/(n.length-a+2*l);return u=r(f+h*l,h),c&&u.reverse(),o=h*(1-a),t={t:"rangeBands",a:arguments},e},e.rangeRoundBands=function(i,a,l){arguments.length<2&&(a=0),arguments.length<3&&(l=a);var c=i[1]<i[0],f=i[c-0],s=i[1-c],h=Math.floor((s-f)/(n.length-a+2*l));return u=r(f+Math.round((s-f-(n.length-a)*h)/2),h),c&&u.reverse(),o=Math.round(h*(1-a)),t={t:"rangeRoundBands",a:arguments},e},e.rangeBand=function(){return o},e.rangeExtent=function(){return Yi(t.a[0])},e.copy=function(){return ou(n,t)},e.domain(n)}function au(n,t){function u(){var e=0,r=t.length;for(a=[];++e<r;)a[e-1]=ao.quantile(n,e/r);return o}function o(n){return isNaN(n=+n)?void 0:t[ao.bisect(a,n)]}var a;return o.domain=function(t){return arguments.length?(n=t.map(r).filter(i).sort(e),u()):n},o.range=function(n){return arguments.length?(t=n,u()):t},o.quantiles=function(){return a},o.invertExtent=function(e){return e=t.indexOf(e),0>e?[NaN,NaN]:[e>0?a[e-1]:n[0],e<a.length?a[e]:n[n.length-1]]},o.copy=function(){return au(n,t)},u()}function lu(n,t,e){function r(t){return e[Math.max(0,Math.min(o,Math.floor(u*(t-n))))]}function i(){return u=e.length/(t-n),o=e.length-1,r}var u,o;return r.domain=function(e){return arguments.length?(n=+e[0],t=+e[e.length-1],i()):[n,t]},r.range=function(n){return arguments.length?(e=n,i()):e},r.invertExtent=function(t){return t=e.indexOf(t),t=0>t?NaN:t/u+n,[t,t+1/u]},r.copy=function(){return lu(n,t,e)},i()}function cu(n,t){function e(e){return e>=e?t[ao.bisect(n,e)]:void 0}return e.domain=function(t){return arguments.length?(n=t,e):n},e.range=function(n){return arguments.length?(t=n,e):t},e.invertExtent=function(e){return e=t.indexOf(e),[n[e-1],n[e]]},e.copy=function(){return cu(n,t)},e}function fu(n){function t(n){return+n}return t.invert=t,t.domain=t.range=function(e){return arguments.length?(n=e.map(t),t):n},t.ticks=function(t){return Qi(n,t)},t.tickFormat=function(t,e){return nu(n,t,e)},t.copy=function(){return fu(n)},t}function su(){return 0}function hu(n){return n.innerRadius}function pu(n){return n.outerRadius}function gu(n){return n.startAngle}function vu(n){return n.endAngle}function du(n){return n&&n.padAngle}function yu(n,t,e,r){return(n-e)*t-(t-r)*n>0?0:1}function mu(n,t,e,r,i){var u=n[0]-t[0],o=n[1]-t[1],a=(i?r:-r)/Math.sqrt(u*u+o*o),l=a*o,c=-a*u,f=n[0]+l,s=n[1]+c,h=t[0]+l,p=t[1]+c,g=(f+h)/2,v=(s+p)/2,d=h-f,y=p-s,m=d*d+y*y,M=e-r,x=f*p-h*s,b=(0>y?-1:1)*Math.sqrt(Math.max(0,M*M*m-x*x)),_=(x*y-d*b)/m,w=(-x*d-y*b)/m,S=(x*y+d*b)/m,k=(-x*d+y*b)/m,N=_-g,E=w-v,A=S-g,C=k-v;return N*N+E*E>A*A+C*C&&(_=S,w=k),[[_-l,w-c],[_*e/M,w*e/M]]}function Mu(n){function t(t){function o(){c.push("M",u(n(f),a))}for(var l,c=[],f=[],s=-1,h=t.length,p=En(e),g=En(r);++s<h;)i.call(this,l=t[s],s)?f.push([+p.call(this,l,s),+g.call(this,l,s)]):f.length&&(o(),f=[]);return f.length&&o(),c.length?c.join(""):null}var e=Ce,r=ze,i=zt,u=xu,o=u.key,a=.7;return t.x=function(n){return arguments.length?(e=n,t):e},t.y=function(n){return arguments.length?(r=n,t):r},t.defined=function(n){return arguments.length?(i=n,t):i},t.interpolate=function(n){return arguments.length?(o="function"==typeof n?u=n:(u=Tl.get(n)||xu).key,t):o},t.tension=function(n){return arguments.length?(a=n,t):a},t}function xu(n){return n.length>1?n.join("L"):n+"Z"}function bu(n){return n.join("L")+"Z"}function _u(n){for(var t=0,e=n.length,r=n[0],i=[r[0],",",r[1]];++t<e;)i.push("H",(r[0]+(r=n[t])[0])/2,"V",r[1]);return e>1&&i.push("H",r[0]),i.join("")}function wu(n){for(var t=0,e=n.length,r=n[0],i=[r[0],",",r[1]];++t<e;)i.push("V",(r=n[t])[1],"H",r[0]);return i.join("")}function Su(n){for(var t=0,e=n.length,r=n[0],i=[r[0],",",r[1]];++t<e;)i.push("H",(r=n[t])[0],"V",r[1]);return i.join("")}function ku(n,t){return n.length<4?xu(n):n[1]+Au(n.slice(1,-1),Cu(n,t))}function Nu(n,t){return n.length<3?bu(n):n[0]+Au((n.push(n[0]),n),Cu([n[n.length-2]].concat(n,[n[1]]),t))}function Eu(n,t){return n.length<3?xu(n):n[0]+Au(n,Cu(n,t))}function Au(n,t){if(t.length<1||n.length!=t.length&&n.length!=t.length+2)return xu(n);var e=n.length!=t.length,r="",i=n[0],u=n[1],o=t[0],a=o,l=1;if(e&&(r+="Q"+(u[0]-2*o[0]/3)+","+(u[1]-2*o[1]/3)+","+u[0]+","+u[1],i=n[1],l=2),t.length>1){a=t[1],u=n[l],l++,r+="C"+(i[0]+o[0])+","+(i[1]+o[1])+","+(u[0]-a[0])+","+(u[1]-a[1])+","+u[0]+","+u[1];for(var c=2;c<t.length;c++,l++)u=n[l],a=t[c],r+="S"+(u[0]-a[0])+","+(u[1]-a[1])+","+u[0]+","+u[1]}if(e){var f=n[l];r+="Q"+(u[0]+2*a[0]/3)+","+(u[1]+2*a[1]/3)+","+f[0]+","+f[1]}return r}function Cu(n,t){for(var e,r=[],i=(1-t)/2,u=n[0],o=n[1],a=1,l=n.length;++a<l;)e=u,u=o,o=n[a],r.push([i*(o[0]-e[0]),i*(o[1]-e[1])]);return r}function zu(n){if(n.length<3)return xu(n);var t=1,e=n.length,r=n[0],i=r[0],u=r[1],o=[i,i,i,(r=n[1])[0]],a=[u,u,u,r[1]],l=[i,",",u,"L",Ru(Pl,o),",",Ru(Pl,a)];for(n.push(n[e-1]);++t<=e;)r=n[t],o.shift(),o.push(r[0]),a.shift(),a.push(r[1]),Du(l,o,a);return n.pop(),l.push("L",r),l.join("")}function Lu(n){if(n.length<4)return xu(n);for(var t,e=[],r=-1,i=n.length,u=[0],o=[0];++r<3;)t=n[r],u.push(t[0]),o.push(t[1]);for(e.push(Ru(Pl,u)+","+Ru(Pl,o)),--r;++r<i;)t=n[r],u.shift(),u.push(t[0]),o.shift(),o.push(t[1]),Du(e,u,o);return e.join("")}function qu(n){for(var t,e,r=-1,i=n.length,u=i+4,o=[],a=[];++r<4;)e=n[r%i],o.push(e[0]),a.push(e[1]);for(t=[Ru(Pl,o),",",Ru(Pl,a)],--r;++r<u;)e=n[r%i],o.shift(),o.push(e[0]),a.shift(),a.push(e[1]),Du(t,o,a);return t.join("")}function Tu(n,t){var e=n.length-1;if(e)for(var r,i,u=n[0][0],o=n[0][1],a=n[e][0]-u,l=n[e][1]-o,c=-1;++c<=e;)r=n[c],i=c/e,r[0]=t*r[0]+(1-t)*(u+i*a),r[1]=t*r[1]+(1-t)*(o+i*l);return zu(n)}function Ru(n,t){return n[0]*t[0]+n[1]*t[1]+n[2]*t[2]+n[3]*t[3]}function Du(n,t,e){n.push("C",Ru(Rl,t),",",Ru(Rl,e),",",Ru(Dl,t),",",Ru(Dl,e),",",Ru(Pl,t),",",Ru(Pl,e))}function Pu(n,t){return(t[1]-n[1])/(t[0]-n[0])}function Uu(n){for(var t=0,e=n.length-1,r=[],i=n[0],u=n[1],o=r[0]=Pu(i,u);++t<e;)r[t]=(o+(o=Pu(i=u,u=n[t+1])))/2;return r[t]=o,r}function ju(n){for(var t,e,r,i,u=[],o=Uu(n),a=-1,l=n.length-1;++a<l;)t=Pu(n[a],n[a+1]),xo(t)<Uo?o[a]=o[a+1]=0:(e=o[a]/t,r=o[a+1]/t,i=e*e+r*r,i>9&&(i=3*t/Math.sqrt(i),o[a]=i*e,o[a+1]=i*r));for(a=-1;++a<=l;)i=(n[Math.min(l,a+1)][0]-n[Math.max(0,a-1)][0])/(6*(1+o[a]*o[a])),u.push([i||0,o[a]*i||0]);return u}function Fu(n){return n.length<3?xu(n):n[0]+Au(n,ju(n))}function Hu(n){for(var t,e,r,i=-1,u=n.length;++i<u;)t=n[i],e=t[0],r=t[1]-Io,t[0]=e*Math.cos(r),t[1]=e*Math.sin(r);return n}function Ou(n){function t(t){function l(){v.push("M",a(n(y),s),f,c(n(d.reverse()),s),"Z")}for(var h,p,g,v=[],d=[],y=[],m=-1,M=t.length,x=En(e),b=En(i),_=e===r?function(){
return p}:En(r),w=i===u?function(){return g}:En(u);++m<M;)o.call(this,h=t[m],m)?(d.push([p=+x.call(this,h,m),g=+b.call(this,h,m)]),y.push([+_.call(this,h,m),+w.call(this,h,m)])):d.length&&(l(),d=[],y=[]);return d.length&&l(),v.length?v.join(""):null}var e=Ce,r=Ce,i=0,u=ze,o=zt,a=xu,l=a.key,c=a,f="L",s=.7;return t.x=function(n){return arguments.length?(e=r=n,t):r},t.x0=function(n){return arguments.length?(e=n,t):e},t.x1=function(n){return arguments.length?(r=n,t):r},t.y=function(n){return arguments.length?(i=u=n,t):u},t.y0=function(n){return arguments.length?(i=n,t):i},t.y1=function(n){return arguments.length?(u=n,t):u},t.defined=function(n){return arguments.length?(o=n,t):o},t.interpolate=function(n){return arguments.length?(l="function"==typeof n?a=n:(a=Tl.get(n)||xu).key,c=a.reverse||a,f=a.closed?"M":"L",t):l},t.tension=function(n){return arguments.length?(s=n,t):s},t}function Iu(n){return n.radius}function Yu(n){return[n.x,n.y]}function Zu(n){return function(){var t=n.apply(this,arguments),e=t[0],r=t[1]-Io;return[e*Math.cos(r),e*Math.sin(r)]}}function Vu(){return 64}function Xu(){return"circle"}function $u(n){var t=Math.sqrt(n/Fo);return"M0,"+t+"A"+t+","+t+" 0 1,1 0,"+-t+"A"+t+","+t+" 0 1,1 0,"+t+"Z"}function Bu(n){return function(){var t,e,r;(t=this[n])&&(r=t[e=t.active])&&(r.timer.c=null,r.timer.t=NaN,--t.count?delete t[e]:delete this[n],t.active+=.5,r.event&&r.event.interrupt.call(this,this.__data__,r.index))}}function Wu(n,t,e){return ko(n,Yl),n.namespace=t,n.id=e,n}function Ju(n,t,e,r){var i=n.id,u=n.namespace;return Y(n,"function"==typeof e?function(n,o,a){n[u][i].tween.set(t,r(e.call(n,n.__data__,o,a)))}:(e=r(e),function(n){n[u][i].tween.set(t,e)}))}function Gu(n){return null==n&&(n=""),function(){this.textContent=n}}function Ku(n){return null==n?"__transition__":"__transition_"+n+"__"}function Qu(n,t,e,r,i){function u(n){var t=v.delay;return f.t=t+l,n>=t?o(n-t):void(f.c=o)}function o(e){var i=g.active,u=g[i];u&&(u.timer.c=null,u.timer.t=NaN,--g.count,delete g[i],u.event&&u.event.interrupt.call(n,n.__data__,u.index));for(var o in g)if(r>+o){var c=g[o];c.timer.c=null,c.timer.t=NaN,--g.count,delete g[o]}f.c=a,qn(function(){return f.c&&a(e||1)&&(f.c=null,f.t=NaN),1},0,l),g.active=r,v.event&&v.event.start.call(n,n.__data__,t),p=[],v.tween.forEach(function(e,r){(r=r.call(n,n.__data__,t))&&p.push(r)}),h=v.ease,s=v.duration}function a(i){for(var u=i/s,o=h(u),a=p.length;a>0;)p[--a].call(n,o);return u>=1?(v.event&&v.event.end.call(n,n.__data__,t),--g.count?delete g[r]:delete n[e],1):void 0}var l,f,s,h,p,g=n[e]||(n[e]={active:0,count:0}),v=g[r];v||(l=i.time,f=qn(u,0,l),v=g[r]={tween:new c,time:l,timer:f,delay:i.delay,duration:i.duration,ease:i.ease,index:t},i=null,++g.count)}function no(n,t,e){n.attr("transform",function(n){var r=t(n);return"translate("+(isFinite(r)?r:e(n))+",0)"})}function to(n,t,e){n.attr("transform",function(n){var r=t(n);return"translate(0,"+(isFinite(r)?r:e(n))+")"})}function eo(n){return n.toISOString()}function ro(n,t,e){function r(t){return n(t)}function i(n,e){var r=n[1]-n[0],i=r/e,u=ao.bisect(Kl,i);return u==Kl.length?[t.year,Ki(n.map(function(n){return n/31536e6}),e)[2]]:u?t[i/Kl[u-1]<Kl[u]/i?u-1:u]:[tc,Ki(n,e)[2]]}return r.invert=function(t){return io(n.invert(t))},r.domain=function(t){return arguments.length?(n.domain(t),r):n.domain().map(io)},r.nice=function(n,t){function e(e){return!isNaN(e)&&!n.range(e,io(+e+1),t).length}var u=r.domain(),o=Yi(u),a=null==n?i(o,10):"number"==typeof n&&i(o,n);return a&&(n=a[0],t=a[1]),r.domain(Xi(u,t>1?{floor:function(t){for(;e(t=n.floor(t));)t=io(t-1);return t},ceil:function(t){for(;e(t=n.ceil(t));)t=io(+t+1);return t}}:n))},r.ticks=function(n,t){var e=Yi(r.domain()),u=null==n?i(e,10):"number"==typeof n?i(e,n):!n.range&&[{range:n},t];return u&&(n=u[0],t=u[1]),n.range(e[0],io(+e[1]+1),1>t?1:t)},r.tickFormat=function(){return e},r.copy=function(){return ro(n.copy(),t,e)},Ji(r,n)}function io(n){return new Date(n)}function uo(n){return JSON.parse(n.responseText)}function oo(n){var t=fo.createRange();return t.selectNode(fo.body),t.createContextualFragment(n.responseText)}var ao={version:"3.5.17"},lo=[].slice,co=function(n){return lo.call(n)},fo=this.document;if(fo)try{co(fo.documentElement.childNodes)[0].nodeType}catch(so){co=function(n){for(var t=n.length,e=new Array(t);t--;)e[t]=n[t];return e}}if(Date.now||(Date.now=function(){return+new Date}),fo)try{fo.createElement("DIV").style.setProperty("opacity",0,"")}catch(ho){var po=this.Element.prototype,go=po.setAttribute,vo=po.setAttributeNS,yo=this.CSSStyleDeclaration.prototype,mo=yo.setProperty;po.setAttribute=function(n,t){go.call(this,n,t+"")},po.setAttributeNS=function(n,t,e){vo.call(this,n,t,e+"")},yo.setProperty=function(n,t,e){mo.call(this,n,t+"",e)}}ao.ascending=e,ao.descending=function(n,t){return n>t?-1:t>n?1:t>=n?0:NaN},ao.min=function(n,t){var e,r,i=-1,u=n.length;if(1===arguments.length){for(;++i<u;)if(null!=(r=n[i])&&r>=r){e=r;break}for(;++i<u;)null!=(r=n[i])&&e>r&&(e=r)}else{for(;++i<u;)if(null!=(r=t.call(n,n[i],i))&&r>=r){e=r;break}for(;++i<u;)null!=(r=t.call(n,n[i],i))&&e>r&&(e=r)}return e},ao.max=function(n,t){var e,r,i=-1,u=n.length;if(1===arguments.length){for(;++i<u;)if(null!=(r=n[i])&&r>=r){e=r;break}for(;++i<u;)null!=(r=n[i])&&r>e&&(e=r)}else{for(;++i<u;)if(null!=(r=t.call(n,n[i],i))&&r>=r){e=r;break}for(;++i<u;)null!=(r=t.call(n,n[i],i))&&r>e&&(e=r)}return e},ao.extent=function(n,t){var e,r,i,u=-1,o=n.length;if(1===arguments.length){for(;++u<o;)if(null!=(r=n[u])&&r>=r){e=i=r;break}for(;++u<o;)null!=(r=n[u])&&(e>r&&(e=r),r>i&&(i=r))}else{for(;++u<o;)if(null!=(r=t.call(n,n[u],u))&&r>=r){e=i=r;break}for(;++u<o;)null!=(r=t.call(n,n[u],u))&&(e>r&&(e=r),r>i&&(i=r))}return[e,i]},ao.sum=function(n,t){var e,r=0,u=n.length,o=-1;if(1===arguments.length)for(;++o<u;)i(e=+n[o])&&(r+=e);else for(;++o<u;)i(e=+t.call(n,n[o],o))&&(r+=e);return r},ao.mean=function(n,t){var e,u=0,o=n.length,a=-1,l=o;if(1===arguments.length)for(;++a<o;)i(e=r(n[a]))?u+=e:--l;else for(;++a<o;)i(e=r(t.call(n,n[a],a)))?u+=e:--l;return l?u/l:void 0},ao.quantile=function(n,t){var e=(n.length-1)*t+1,r=Math.floor(e),i=+n[r-1],u=e-r;return u?i+u*(n[r]-i):i},ao.median=function(n,t){var u,o=[],a=n.length,l=-1;if(1===arguments.length)for(;++l<a;)i(u=r(n[l]))&&o.push(u);else for(;++l<a;)i(u=r(t.call(n,n[l],l)))&&o.push(u);return o.length?ao.quantile(o.sort(e),.5):void 0},ao.variance=function(n,t){var e,u,o=n.length,a=0,l=0,c=-1,f=0;if(1===arguments.length)for(;++c<o;)i(e=r(n[c]))&&(u=e-a,a+=u/++f,l+=u*(e-a));else for(;++c<o;)i(e=r(t.call(n,n[c],c)))&&(u=e-a,a+=u/++f,l+=u*(e-a));return f>1?l/(f-1):void 0},ao.deviation=function(){var n=ao.variance.apply(this,arguments);return n?Math.sqrt(n):n};var Mo=u(e);ao.bisectLeft=Mo.left,ao.bisect=ao.bisectRight=Mo.right,ao.bisector=function(n){return u(1===n.length?function(t,r){return e(n(t),r)}:n)},ao.shuffle=function(n,t,e){(u=arguments.length)<3&&(e=n.length,2>u&&(t=0));for(var r,i,u=e-t;u;)i=Math.random()*u--|0,r=n[u+t],n[u+t]=n[i+t],n[i+t]=r;return n},ao.permute=function(n,t){for(var e=t.length,r=new Array(e);e--;)r[e]=n[t[e]];return r},ao.pairs=function(n){for(var t,e=0,r=n.length-1,i=n[0],u=new Array(0>r?0:r);r>e;)u[e]=[t=i,i=n[++e]];return u},ao.transpose=function(n){if(!(i=n.length))return[];for(var t=-1,e=ao.min(n,o),r=new Array(e);++t<e;)for(var i,u=-1,a=r[t]=new Array(i);++u<i;)a[u]=n[u][t];return r},ao.zip=function(){return ao.transpose(arguments)},ao.keys=function(n){var t=[];for(var e in n)t.push(e);return t},ao.values=function(n){var t=[];for(var e in n)t.push(n[e]);return t},ao.entries=function(n){var t=[];for(var e in n)t.push({key:e,value:n[e]});return t},ao.merge=function(n){for(var t,e,r,i=n.length,u=-1,o=0;++u<i;)o+=n[u].length;for(e=new Array(o);--i>=0;)for(r=n[i],t=r.length;--t>=0;)e[--o]=r[t];return e};var xo=Math.abs;ao.range=function(n,t,e){if(arguments.length<3&&(e=1,arguments.length<2&&(t=n,n=0)),(t-n)/e===1/0)throw new Error("infinite range");var r,i=[],u=a(xo(e)),o=-1;if(n*=u,t*=u,e*=u,0>e)for(;(r=n+e*++o)>t;)i.push(r/u);else for(;(r=n+e*++o)<t;)i.push(r/u);return i},ao.map=function(n,t){var e=new c;if(n instanceof c)n.forEach(function(n,t){e.set(n,t)});else if(Array.isArray(n)){var r,i=-1,u=n.length;if(1===arguments.length)for(;++i<u;)e.set(i,n[i]);else for(;++i<u;)e.set(t.call(n,r=n[i],i),r)}else for(var o in n)e.set(o,n[o]);return e};var bo="__proto__",_o="\x00";l(c,{has:h,get:function(n){return this._[f(n)]},set:function(n,t){return this._[f(n)]=t},remove:p,keys:g,values:function(){var n=[];for(var t in this._)n.push(this._[t]);return n},entries:function(){var n=[];for(var t in this._)n.push({key:s(t),value:this._[t]});return n},size:v,empty:d,forEach:function(n){for(var t in this._)n.call(this,s(t),this._[t])}}),ao.nest=function(){function n(t,o,a){if(a>=u.length)return r?r.call(i,o):e?o.sort(e):o;for(var l,f,s,h,p=-1,g=o.length,v=u[a++],d=new c;++p<g;)(h=d.get(l=v(f=o[p])))?h.push(f):d.set(l,[f]);return t?(f=t(),s=function(e,r){f.set(e,n(t,r,a))}):(f={},s=function(e,r){f[e]=n(t,r,a)}),d.forEach(s),f}function t(n,e){if(e>=u.length)return n;var r=[],i=o[e++];return n.forEach(function(n,i){r.push({key:n,values:t(i,e)})}),i?r.sort(function(n,t){return i(n.key,t.key)}):r}var e,r,i={},u=[],o=[];return i.map=function(t,e){return n(e,t,0)},i.entries=function(e){return t(n(ao.map,e,0),0)},i.key=function(n){return u.push(n),i},i.sortKeys=function(n){return o[u.length-1]=n,i},i.sortValues=function(n){return e=n,i},i.rollup=function(n){return r=n,i},i},ao.set=function(n){var t=new y;if(n)for(var e=0,r=n.length;r>e;++e)t.add(n[e]);return t},l(y,{has:h,add:function(n){return this._[f(n+="")]=!0,n},remove:p,values:g,size:v,empty:d,forEach:function(n){for(var t in this._)n.call(this,s(t))}}),ao.behavior={},ao.rebind=function(n,t){for(var e,r=1,i=arguments.length;++r<i;)n[e=arguments[r]]=M(n,t,t[e]);return n};var wo=["webkit","ms","moz","Moz","o","O"];ao.dispatch=function(){for(var n=new _,t=-1,e=arguments.length;++t<e;)n[arguments[t]]=w(n);return n},_.prototype.on=function(n,t){var e=n.indexOf("."),r="";if(e>=0&&(r=n.slice(e+1),n=n.slice(0,e)),n)return arguments.length<2?this[n].on(r):this[n].on(r,t);if(2===arguments.length){if(null==t)for(n in this)this.hasOwnProperty(n)&&this[n].on(r,null);return this}},ao.event=null,ao.requote=function(n){return n.replace(So,"\\$&")};var So=/[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g,ko={}.__proto__?function(n,t){n.__proto__=t}:function(n,t){for(var e in t)n[e]=t[e]},No=function(n,t){return t.querySelector(n)},Eo=function(n,t){return t.querySelectorAll(n)},Ao=function(n,t){var e=n.matches||n[x(n,"matchesSelector")];return(Ao=function(n,t){return e.call(n,t)})(n,t)};"function"==typeof Sizzle&&(No=function(n,t){return Sizzle(n,t)[0]||null},Eo=Sizzle,Ao=Sizzle.matchesSelector),ao.selection=function(){return ao.select(fo.documentElement)};var Co=ao.selection.prototype=[];Co.select=function(n){var t,e,r,i,u=[];n=A(n);for(var o=-1,a=this.length;++o<a;){u.push(t=[]),t.parentNode=(r=this[o]).parentNode;for(var l=-1,c=r.length;++l<c;)(i=r[l])?(t.push(e=n.call(i,i.__data__,l,o)),e&&"__data__"in i&&(e.__data__=i.__data__)):t.push(null)}return E(u)},Co.selectAll=function(n){var t,e,r=[];n=C(n);for(var i=-1,u=this.length;++i<u;)for(var o=this[i],a=-1,l=o.length;++a<l;)(e=o[a])&&(r.push(t=co(n.call(e,e.__data__,a,i))),t.parentNode=e);return E(r)};var zo="http://www.w3.org/1999/xhtml",Lo={svg:"http://www.w3.org/2000/svg",xhtml:zo,xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/"};ao.ns={prefix:Lo,qualify:function(n){var t=n.indexOf(":"),e=n;return t>=0&&"xmlns"!==(e=n.slice(0,t))&&(n=n.slice(t+1)),Lo.hasOwnProperty(e)?{space:Lo[e],local:n}:n}},Co.attr=function(n,t){if(arguments.length<2){if("string"==typeof n){var e=this.node();return n=ao.ns.qualify(n),n.local?e.getAttributeNS(n.space,n.local):e.getAttribute(n)}for(t in n)this.each(z(t,n[t]));return this}return this.each(z(n,t))},Co.classed=function(n,t){if(arguments.length<2){if("string"==typeof n){var e=this.node(),r=(n=T(n)).length,i=-1;if(t=e.classList){for(;++i<r;)if(!t.contains(n[i]))return!1}else for(t=e.getAttribute("class");++i<r;)if(!q(n[i]).test(t))return!1;return!0}for(t in n)this.each(R(t,n[t]));return this}return this.each(R(n,t))},Co.style=function(n,e,r){var i=arguments.length;if(3>i){if("string"!=typeof n){2>i&&(e="");for(r in n)this.each(P(r,n[r],e));return this}if(2>i){var u=this.node();return t(u).getComputedStyle(u,null).getPropertyValue(n)}r=""}return this.each(P(n,e,r))},Co.property=function(n,t){if(arguments.length<2){if("string"==typeof n)return this.node()[n];for(t in n)this.each(U(t,n[t]));return this}return this.each(U(n,t))},Co.text=function(n){return arguments.length?this.each("function"==typeof n?function(){var t=n.apply(this,arguments);this.textContent=null==t?"":t}:null==n?function(){this.textContent=""}:function(){this.textContent=n}):this.node().textContent},Co.html=function(n){return arguments.length?this.each("function"==typeof n?function(){var t=n.apply(this,arguments);this.innerHTML=null==t?"":t}:null==n?function(){this.innerHTML=""}:function(){this.innerHTML=n}):this.node().innerHTML},Co.append=function(n){return n=j(n),this.select(function(){return this.appendChild(n.apply(this,arguments))})},Co.insert=function(n,t){return n=j(n),t=A(t),this.select(function(){return this.insertBefore(n.apply(this,arguments),t.apply(this,arguments)||null)})},Co.remove=function(){return this.each(F)},Co.data=function(n,t){function e(n,e){var r,i,u,o=n.length,s=e.length,h=Math.min(o,s),p=new Array(s),g=new Array(s),v=new Array(o);if(t){var d,y=new c,m=new Array(o);for(r=-1;++r<o;)(i=n[r])&&(y.has(d=t.call(i,i.__data__,r))?v[r]=i:y.set(d,i),m[r]=d);for(r=-1;++r<s;)(i=y.get(d=t.call(e,u=e[r],r)))?i!==!0&&(p[r]=i,i.__data__=u):g[r]=H(u),y.set(d,!0);for(r=-1;++r<o;)r in m&&y.get(m[r])!==!0&&(v[r]=n[r])}else{for(r=-1;++r<h;)i=n[r],u=e[r],i?(i.__data__=u,p[r]=i):g[r]=H(u);for(;s>r;++r)g[r]=H(e[r]);for(;o>r;++r)v[r]=n[r]}g.update=p,g.parentNode=p.parentNode=v.parentNode=n.parentNode,a.push(g),l.push(p),f.push(v)}var r,i,u=-1,o=this.length;if(!arguments.length){for(n=new Array(o=(r=this[0]).length);++u<o;)(i=r[u])&&(n[u]=i.__data__);return n}var a=Z([]),l=E([]),f=E([]);if("function"==typeof n)for(;++u<o;)e(r=this[u],n.call(r,r.parentNode.__data__,u));else for(;++u<o;)e(r=this[u],n);return l.enter=function(){return a},l.exit=function(){return f},l},Co.datum=function(n){return arguments.length?this.property("__data__",n):this.property("__data__")},Co.filter=function(n){var t,e,r,i=[];"function"!=typeof n&&(n=O(n));for(var u=0,o=this.length;o>u;u++){i.push(t=[]),t.parentNode=(e=this[u]).parentNode;for(var a=0,l=e.length;l>a;a++)(r=e[a])&&n.call(r,r.__data__,a,u)&&t.push(r)}return E(i)},Co.order=function(){for(var n=-1,t=this.length;++n<t;)for(var e,r=this[n],i=r.length-1,u=r[i];--i>=0;)(e=r[i])&&(u&&u!==e.nextSibling&&u.parentNode.insertBefore(e,u),u=e);return this},Co.sort=function(n){n=I.apply(this,arguments);for(var t=-1,e=this.length;++t<e;)this[t].sort(n);return this.order()},Co.each=function(n){return Y(this,function(t,e,r){n.call(t,t.__data__,e,r)})},Co.call=function(n){var t=co(arguments);return n.apply(t[0]=this,t),this},Co.empty=function(){return!this.node()},Co.node=function(){for(var n=0,t=this.length;t>n;n++)for(var e=this[n],r=0,i=e.length;i>r;r++){var u=e[r];if(u)return u}return null},Co.size=function(){var n=0;return Y(this,function(){++n}),n};var qo=[];ao.selection.enter=Z,ao.selection.enter.prototype=qo,qo.append=Co.append,qo.empty=Co.empty,qo.node=Co.node,qo.call=Co.call,qo.size=Co.size,qo.select=function(n){for(var t,e,r,i,u,o=[],a=-1,l=this.length;++a<l;){r=(i=this[a]).update,o.push(t=[]),t.parentNode=i.parentNode;for(var c=-1,f=i.length;++c<f;)(u=i[c])?(t.push(r[c]=e=n.call(i.parentNode,u.__data__,c,a)),e.__data__=u.__data__):t.push(null)}return E(o)},qo.insert=function(n,t){return arguments.length<2&&(t=V(this)),Co.insert.call(this,n,t)},ao.select=function(t){var e;return"string"==typeof t?(e=[No(t,fo)],e.parentNode=fo.documentElement):(e=[t],e.parentNode=n(t)),E([e])},ao.selectAll=function(n){var t;return"string"==typeof n?(t=co(Eo(n,fo)),t.parentNode=fo.documentElement):(t=co(n),t.parentNode=null),E([t])},Co.on=function(n,t,e){var r=arguments.length;if(3>r){if("string"!=typeof n){2>r&&(t=!1);for(e in n)this.each(X(e,n[e],t));return this}if(2>r)return(r=this.node()["__on"+n])&&r._;e=!1}return this.each(X(n,t,e))};var To=ao.map({mouseenter:"mouseover",mouseleave:"mouseout"});fo&&To.forEach(function(n){"on"+n in fo&&To.remove(n)});var Ro,Do=0;ao.mouse=function(n){return J(n,k())};var Po=this.navigator&&/WebKit/.test(this.navigator.userAgent)?-1:0;ao.touch=function(n,t,e){if(arguments.length<3&&(e=t,t=k().changedTouches),t)for(var r,i=0,u=t.length;u>i;++i)if((r=t[i]).identifier===e)return J(n,r)},ao.behavior.drag=function(){function n(){this.on("mousedown.drag",u).on("touchstart.drag",o)}function e(n,t,e,u,o){return function(){function a(){var n,e,r=t(h,v);r&&(n=r[0]-M[0],e=r[1]-M[1],g|=n|e,M=r,p({type:"drag",x:r[0]+c[0],y:r[1]+c[1],dx:n,dy:e}))}function l(){t(h,v)&&(y.on(u+d,null).on(o+d,null),m(g),p({type:"dragend"}))}var c,f=this,s=ao.event.target.correspondingElement||ao.event.target,h=f.parentNode,p=r.of(f,arguments),g=0,v=n(),d=".drag"+(null==v?"":"-"+v),y=ao.select(e(s)).on(u+d,a).on(o+d,l),m=W(s),M=t(h,v);i?(c=i.apply(f,arguments),c=[c.x-M[0],c.y-M[1]]):c=[0,0],p({type:"dragstart"})}}var r=N(n,"drag","dragstart","dragend"),i=null,u=e(b,ao.mouse,t,"mousemove","mouseup"),o=e(G,ao.touch,m,"touchmove","touchend");return n.origin=function(t){return arguments.length?(i=t,n):i},ao.rebind(n,r,"on")},ao.touches=function(n,t){return arguments.length<2&&(t=k().touches),t?co(t).map(function(t){var e=J(n,t);return e.identifier=t.identifier,e}):[]};var Uo=1e-6,jo=Uo*Uo,Fo=Math.PI,Ho=2*Fo,Oo=Ho-Uo,Io=Fo/2,Yo=Fo/180,Zo=180/Fo,Vo=Math.SQRT2,Xo=2,$o=4;ao.interpolateZoom=function(n,t){var e,r,i=n[0],u=n[1],o=n[2],a=t[0],l=t[1],c=t[2],f=a-i,s=l-u,h=f*f+s*s;if(jo>h)r=Math.log(c/o)/Vo,e=function(n){return[i+n*f,u+n*s,o*Math.exp(Vo*n*r)]};else{var p=Math.sqrt(h),g=(c*c-o*o+$o*h)/(2*o*Xo*p),v=(c*c-o*o-$o*h)/(2*c*Xo*p),d=Math.log(Math.sqrt(g*g+1)-g),y=Math.log(Math.sqrt(v*v+1)-v);r=(y-d)/Vo,e=function(n){var t=n*r,e=rn(d),a=o/(Xo*p)*(e*un(Vo*t+d)-en(d));return[i+a*f,u+a*s,o*e/rn(Vo*t+d)]}}return e.duration=1e3*r,e},ao.behavior.zoom=function(){function n(n){n.on(L,s).on(Wo+".zoom",p).on("dblclick.zoom",g).on(R,h)}function e(n){return[(n[0]-k.x)/k.k,(n[1]-k.y)/k.k]}function r(n){return[n[0]*k.k+k.x,n[1]*k.k+k.y]}function i(n){k.k=Math.max(A[0],Math.min(A[1],n))}function u(n,t){t=r(t),k.x+=n[0]-t[0],k.y+=n[1]-t[1]}function o(t,e,r,o){t.__chart__={x:k.x,y:k.y,k:k.k},i(Math.pow(2,o)),u(d=e,r),t=ao.select(t),C>0&&(t=t.transition().duration(C)),t.call(n.event)}function a(){b&&b.domain(x.range().map(function(n){return(n-k.x)/k.k}).map(x.invert)),w&&w.domain(_.range().map(function(n){return(n-k.y)/k.k}).map(_.invert))}function l(n){z++||n({type:"zoomstart"})}function c(n){a(),n({type:"zoom",scale:k.k,translate:[k.x,k.y]})}function f(n){--z||(n({type:"zoomend"}),d=null)}function s(){function n(){a=1,u(ao.mouse(i),h),c(o)}function r(){s.on(q,null).on(T,null),p(a),f(o)}var i=this,o=D.of(i,arguments),a=0,s=ao.select(t(i)).on(q,n).on(T,r),h=e(ao.mouse(i)),p=W(i);Il.call(i),l(o)}function h(){function n(){var n=ao.touches(g);return p=k.k,n.forEach(function(n){n.identifier in d&&(d[n.identifier]=e(n))}),n}function t(){var t=ao.event.target;ao.select(t).on(x,r).on(b,a),_.push(t);for(var e=ao.event.changedTouches,i=0,u=e.length;u>i;++i)d[e[i].identifier]=null;var l=n(),c=Date.now();if(1===l.length){if(500>c-M){var f=l[0];o(g,f,d[f.identifier],Math.floor(Math.log(k.k)/Math.LN2)+1),S()}M=c}else if(l.length>1){var f=l[0],s=l[1],h=f[0]-s[0],p=f[1]-s[1];y=h*h+p*p}}function r(){var n,t,e,r,o=ao.touches(g);Il.call(g);for(var a=0,l=o.length;l>a;++a,r=null)if(e=o[a],r=d[e.identifier]){if(t)break;n=e,t=r}if(r){var f=(f=e[0]-n[0])*f+(f=e[1]-n[1])*f,s=y&&Math.sqrt(f/y);n=[(n[0]+e[0])/2,(n[1]+e[1])/2],t=[(t[0]+r[0])/2,(t[1]+r[1])/2],i(s*p)}M=null,u(n,t),c(v)}function a(){if(ao.event.touches.length){for(var t=ao.event.changedTouches,e=0,r=t.length;r>e;++e)delete d[t[e].identifier];for(var i in d)return void n()}ao.selectAll(_).on(m,null),w.on(L,s).on(R,h),N(),f(v)}var p,g=this,v=D.of(g,arguments),d={},y=0,m=".zoom-"+ao.event.changedTouches[0].identifier,x="touchmove"+m,b="touchend"+m,_=[],w=ao.select(g),N=W(g);t(),l(v),w.on(L,null).on(R,t)}function p(){var n=D.of(this,arguments);m?clearTimeout(m):(Il.call(this),v=e(d=y||ao.mouse(this)),l(n)),m=setTimeout(function(){m=null,f(n)},50),S(),i(Math.pow(2,.002*Bo())*k.k),u(d,v),c(n)}function g(){var n=ao.mouse(this),t=Math.log(k.k)/Math.LN2;o(this,n,e(n),ao.event.shiftKey?Math.ceil(t)-1:Math.floor(t)+1)}var v,d,y,m,M,x,b,_,w,k={x:0,y:0,k:1},E=[960,500],A=Jo,C=250,z=0,L="mousedown.zoom",q="mousemove.zoom",T="mouseup.zoom",R="touchstart.zoom",D=N(n,"zoomstart","zoom","zoomend");return Wo||(Wo="onwheel"in fo?(Bo=function(){return-ao.event.deltaY*(ao.event.deltaMode?120:1)},"wheel"):"onmousewheel"in fo?(Bo=function(){return ao.event.wheelDelta},"mousewheel"):(Bo=function(){return-ao.event.detail},"MozMousePixelScroll")),n.event=function(n){n.each(function(){var n=D.of(this,arguments),t=k;Hl?ao.select(this).transition().each("start.zoom",function(){k=this.__chart__||{x:0,y:0,k:1},l(n)}).tween("zoom:zoom",function(){var e=E[0],r=E[1],i=d?d[0]:e/2,u=d?d[1]:r/2,o=ao.interpolateZoom([(i-k.x)/k.k,(u-k.y)/k.k,e/k.k],[(i-t.x)/t.k,(u-t.y)/t.k,e/t.k]);return function(t){var r=o(t),a=e/r[2];this.__chart__=k={x:i-r[0]*a,y:u-r[1]*a,k:a},c(n)}}).each("interrupt.zoom",function(){f(n)}).each("end.zoom",function(){f(n)}):(this.__chart__=k,l(n),c(n),f(n))})},n.translate=function(t){return arguments.length?(k={x:+t[0],y:+t[1],k:k.k},a(),n):[k.x,k.y]},n.scale=function(t){return arguments.length?(k={x:k.x,y:k.y,k:null},i(+t),a(),n):k.k},n.scaleExtent=function(t){return arguments.length?(A=null==t?Jo:[+t[0],+t[1]],n):A},n.center=function(t){return arguments.length?(y=t&&[+t[0],+t[1]],n):y},n.size=function(t){return arguments.length?(E=t&&[+t[0],+t[1]],n):E},n.duration=function(t){return arguments.length?(C=+t,n):C},n.x=function(t){return arguments.length?(b=t,x=t.copy(),k={x:0,y:0,k:1},n):b},n.y=function(t){return arguments.length?(w=t,_=t.copy(),k={x:0,y:0,k:1},n):w},ao.rebind(n,D,"on")};var Bo,Wo,Jo=[0,1/0];ao.color=an,an.prototype.toString=function(){return this.rgb()+""},ao.hsl=ln;var Go=ln.prototype=new an;Go.brighter=function(n){return n=Math.pow(.7,arguments.length?n:1),new ln(this.h,this.s,this.l/n)},Go.darker=function(n){return n=Math.pow(.7,arguments.length?n:1),new ln(this.h,this.s,n*this.l)},Go.rgb=function(){return cn(this.h,this.s,this.l)},ao.hcl=fn;var Ko=fn.prototype=new an;Ko.brighter=function(n){return new fn(this.h,this.c,Math.min(100,this.l+Qo*(arguments.length?n:1)))},Ko.darker=function(n){return new fn(this.h,this.c,Math.max(0,this.l-Qo*(arguments.length?n:1)))},Ko.rgb=function(){return sn(this.h,this.c,this.l).rgb()},ao.lab=hn;var Qo=18,na=.95047,ta=1,ea=1.08883,ra=hn.prototype=new an;ra.brighter=function(n){return new hn(Math.min(100,this.l+Qo*(arguments.length?n:1)),this.a,this.b)},ra.darker=function(n){return new hn(Math.max(0,this.l-Qo*(arguments.length?n:1)),this.a,this.b)},ra.rgb=function(){return pn(this.l,this.a,this.b)},ao.rgb=mn;var ia=mn.prototype=new an;ia.brighter=function(n){n=Math.pow(.7,arguments.length?n:1);var t=this.r,e=this.g,r=this.b,i=30;return t||e||r?(t&&i>t&&(t=i),e&&i>e&&(e=i),r&&i>r&&(r=i),new mn(Math.min(255,t/n),Math.min(255,e/n),Math.min(255,r/n))):new mn(i,i,i)},ia.darker=function(n){return n=Math.pow(.7,arguments.length?n:1),new mn(n*this.r,n*this.g,n*this.b)},ia.hsl=function(){return wn(this.r,this.g,this.b)},ia.toString=function(){return"#"+bn(this.r)+bn(this.g)+bn(this.b)};var ua=ao.map({aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074});ua.forEach(function(n,t){ua.set(n,Mn(t))}),ao.functor=En,ao.xhr=An(m),ao.dsv=function(n,t){function e(n,e,u){arguments.length<3&&(u=e,e=null);var o=Cn(n,t,null==e?r:i(e),u);return o.row=function(n){return arguments.length?o.response(null==(e=n)?r:i(n)):e},o}function r(n){return e.parse(n.responseText)}function i(n){return function(t){return e.parse(t.responseText,n)}}function u(t){return t.map(o).join(n)}function o(n){return a.test(n)?'"'+n.replace(/\"/g,'""')+'"':n}var a=new RegExp('["'+n+"\n]"),l=n.charCodeAt(0);return e.parse=function(n,t){var r;return e.parseRows(n,function(n,e){if(r)return r(n,e-1);var i=new Function("d","return {"+n.map(function(n,t){return JSON.stringify(n)+": d["+t+"]"}).join(",")+"}");r=t?function(n,e){return t(i(n),e)}:i})},e.parseRows=function(n,t){function e(){if(f>=c)return o;if(i)return i=!1,u;var t=f;if(34===n.charCodeAt(t)){for(var e=t;e++<c;)if(34===n.charCodeAt(e)){if(34!==n.charCodeAt(e+1))break;++e}f=e+2;var r=n.charCodeAt(e+1);return 13===r?(i=!0,10===n.charCodeAt(e+2)&&++f):10===r&&(i=!0),n.slice(t+1,e).replace(/""/g,'"')}for(;c>f;){var r=n.charCodeAt(f++),a=1;if(10===r)i=!0;else if(13===r)i=!0,10===n.charCodeAt(f)&&(++f,++a);else if(r!==l)continue;return n.slice(t,f-a)}return n.slice(t)}for(var r,i,u={},o={},a=[],c=n.length,f=0,s=0;(r=e())!==o;){for(var h=[];r!==u&&r!==o;)h.push(r),r=e();t&&null==(h=t(h,s++))||a.push(h)}return a},e.format=function(t){if(Array.isArray(t[0]))return e.formatRows(t);var r=new y,i=[];return t.forEach(function(n){for(var t in n)r.has(t)||i.push(r.add(t))}),[i.map(o).join(n)].concat(t.map(function(t){return i.map(function(n){return o(t[n])}).join(n)})).join("\n")},e.formatRows=function(n){return n.map(u).join("\n")},e},ao.csv=ao.dsv(",","text/csv"),ao.tsv=ao.dsv("	","text/tab-separated-values");var oa,aa,la,ca,fa=this[x(this,"requestAnimationFrame")]||function(n){setTimeout(n,17)};ao.timer=function(){qn.apply(this,arguments)},ao.timer.flush=function(){Rn(),Dn()},ao.round=function(n,t){return t?Math.round(n*(t=Math.pow(10,t)))/t:Math.round(n)};var sa=["y","z","a","f","p","n","\xb5","m","","k","M","G","T","P","E","Z","Y"].map(Un);ao.formatPrefix=function(n,t){var e=0;return(n=+n)&&(0>n&&(n*=-1),t&&(n=ao.round(n,Pn(n,t))),e=1+Math.floor(1e-12+Math.log(n)/Math.LN10),e=Math.max(-24,Math.min(24,3*Math.floor((e-1)/3)))),sa[8+e/3]};var ha=/(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i,pa=ao.map({b:function(n){return n.toString(2)},c:function(n){return String.fromCharCode(n)},o:function(n){return n.toString(8)},x:function(n){return n.toString(16)},X:function(n){return n.toString(16).toUpperCase()},g:function(n,t){return n.toPrecision(t)},e:function(n,t){return n.toExponential(t)},f:function(n,t){return n.toFixed(t)},r:function(n,t){return(n=ao.round(n,Pn(n,t))).toFixed(Math.max(0,Math.min(20,Pn(n*(1+1e-15),t))))}}),ga=ao.time={},va=Date;Hn.prototype={getDate:function(){return this._.getUTCDate()},getDay:function(){return this._.getUTCDay()},getFullYear:function(){return this._.getUTCFullYear()},getHours:function(){return this._.getUTCHours()},getMilliseconds:function(){return this._.getUTCMilliseconds()},getMinutes:function(){return this._.getUTCMinutes()},getMonth:function(){return this._.getUTCMonth()},getSeconds:function(){return this._.getUTCSeconds()},getTime:function(){return this._.getTime()},getTimezoneOffset:function(){return 0},valueOf:function(){return this._.valueOf()},setDate:function(){da.setUTCDate.apply(this._,arguments)},setDay:function(){da.setUTCDay.apply(this._,arguments)},setFullYear:function(){da.setUTCFullYear.apply(this._,arguments)},setHours:function(){da.setUTCHours.apply(this._,arguments)},setMilliseconds:function(){da.setUTCMilliseconds.apply(this._,arguments)},setMinutes:function(){da.setUTCMinutes.apply(this._,arguments)},setMonth:function(){da.setUTCMonth.apply(this._,arguments)},setSeconds:function(){da.setUTCSeconds.apply(this._,arguments)},setTime:function(){da.setTime.apply(this._,arguments)}};var da=Date.prototype;ga.year=On(function(n){return n=ga.day(n),n.setMonth(0,1),n},function(n,t){n.setFullYear(n.getFullYear()+t)},function(n){return n.getFullYear()}),ga.years=ga.year.range,ga.years.utc=ga.year.utc.range,ga.day=On(function(n){var t=new va(2e3,0);return t.setFullYear(n.getFullYear(),n.getMonth(),n.getDate()),t},function(n,t){n.setDate(n.getDate()+t)},function(n){return n.getDate()-1}),ga.days=ga.day.range,ga.days.utc=ga.day.utc.range,ga.dayOfYear=function(n){var t=ga.year(n);return Math.floor((n-t-6e4*(n.getTimezoneOffset()-t.getTimezoneOffset()))/864e5)},["sunday","monday","tuesday","wednesday","thursday","friday","saturday"].forEach(function(n,t){t=7-t;var e=ga[n]=On(function(n){return(n=ga.day(n)).setDate(n.getDate()-(n.getDay()+t)%7),n},function(n,t){n.setDate(n.getDate()+7*Math.floor(t))},function(n){var e=ga.year(n).getDay();return Math.floor((ga.dayOfYear(n)+(e+t)%7)/7)-(e!==t)});ga[n+"s"]=e.range,ga[n+"s"].utc=e.utc.range,ga[n+"OfYear"]=function(n){var e=ga.year(n).getDay();return Math.floor((ga.dayOfYear(n)+(e+t)%7)/7)}}),ga.week=ga.sunday,ga.weeks=ga.sunday.range,ga.weeks.utc=ga.sunday.utc.range,ga.weekOfYear=ga.sundayOfYear;var ya={"-":"",_:" ",0:"0"},ma=/^\s*\d+/,Ma=/^%/;ao.locale=function(n){return{numberFormat:jn(n),timeFormat:Yn(n)}};var xa=ao.locale({decimal:".",thousands:",",grouping:[3],currency:["$",""],dateTime:"%a %b %e %X %Y",date:"%m/%d/%Y",time:"%H:%M:%S",periods:["AM","PM"],days:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],
shortDays:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],months:["January","February","March","April","May","June","July","August","September","October","November","December"],shortMonths:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"]});ao.format=xa.numberFormat,ao.geo={},ft.prototype={s:0,t:0,add:function(n){st(n,this.t,ba),st(ba.s,this.s,this),this.s?this.t+=ba.t:this.s=ba.t},reset:function(){this.s=this.t=0},valueOf:function(){return this.s}};var ba=new ft;ao.geo.stream=function(n,t){n&&_a.hasOwnProperty(n.type)?_a[n.type](n,t):ht(n,t)};var _a={Feature:function(n,t){ht(n.geometry,t)},FeatureCollection:function(n,t){for(var e=n.features,r=-1,i=e.length;++r<i;)ht(e[r].geometry,t)}},wa={Sphere:function(n,t){t.sphere()},Point:function(n,t){n=n.coordinates,t.point(n[0],n[1],n[2])},MultiPoint:function(n,t){for(var e=n.coordinates,r=-1,i=e.length;++r<i;)n=e[r],t.point(n[0],n[1],n[2])},LineString:function(n,t){pt(n.coordinates,t,0)},MultiLineString:function(n,t){for(var e=n.coordinates,r=-1,i=e.length;++r<i;)pt(e[r],t,0)},Polygon:function(n,t){gt(n.coordinates,t)},MultiPolygon:function(n,t){for(var e=n.coordinates,r=-1,i=e.length;++r<i;)gt(e[r],t)},GeometryCollection:function(n,t){for(var e=n.geometries,r=-1,i=e.length;++r<i;)ht(e[r],t)}};ao.geo.area=function(n){return Sa=0,ao.geo.stream(n,Na),Sa};var Sa,ka=new ft,Na={sphere:function(){Sa+=4*Fo},point:b,lineStart:b,lineEnd:b,polygonStart:function(){ka.reset(),Na.lineStart=vt},polygonEnd:function(){var n=2*ka;Sa+=0>n?4*Fo+n:n,Na.lineStart=Na.lineEnd=Na.point=b}};ao.geo.bounds=function(){function n(n,t){M.push(x=[f=n,h=n]),s>t&&(s=t),t>p&&(p=t)}function t(t,e){var r=dt([t*Yo,e*Yo]);if(y){var i=mt(y,r),u=[i[1],-i[0],0],o=mt(u,i);bt(o),o=_t(o);var l=t-g,c=l>0?1:-1,v=o[0]*Zo*c,d=xo(l)>180;if(d^(v>c*g&&c*t>v)){var m=o[1]*Zo;m>p&&(p=m)}else if(v=(v+360)%360-180,d^(v>c*g&&c*t>v)){var m=-o[1]*Zo;s>m&&(s=m)}else s>e&&(s=e),e>p&&(p=e);d?g>t?a(f,t)>a(f,h)&&(h=t):a(t,h)>a(f,h)&&(f=t):h>=f?(f>t&&(f=t),t>h&&(h=t)):t>g?a(f,t)>a(f,h)&&(h=t):a(t,h)>a(f,h)&&(f=t)}else n(t,e);y=r,g=t}function e(){b.point=t}function r(){x[0]=f,x[1]=h,b.point=n,y=null}function i(n,e){if(y){var r=n-g;m+=xo(r)>180?r+(r>0?360:-360):r}else v=n,d=e;Na.point(n,e),t(n,e)}function u(){Na.lineStart()}function o(){i(v,d),Na.lineEnd(),xo(m)>Uo&&(f=-(h=180)),x[0]=f,x[1]=h,y=null}function a(n,t){return(t-=n)<0?t+360:t}function l(n,t){return n[0]-t[0]}function c(n,t){return t[0]<=t[1]?t[0]<=n&&n<=t[1]:n<t[0]||t[1]<n}var f,s,h,p,g,v,d,y,m,M,x,b={point:n,lineStart:e,lineEnd:r,polygonStart:function(){b.point=i,b.lineStart=u,b.lineEnd=o,m=0,Na.polygonStart()},polygonEnd:function(){Na.polygonEnd(),b.point=n,b.lineStart=e,b.lineEnd=r,0>ka?(f=-(h=180),s=-(p=90)):m>Uo?p=90:-Uo>m&&(s=-90),x[0]=f,x[1]=h}};return function(n){p=h=-(f=s=1/0),M=[],ao.geo.stream(n,b);var t=M.length;if(t){M.sort(l);for(var e,r=1,i=M[0],u=[i];t>r;++r)e=M[r],c(e[0],i)||c(e[1],i)?(a(i[0],e[1])>a(i[0],i[1])&&(i[1]=e[1]),a(e[0],i[1])>a(i[0],i[1])&&(i[0]=e[0])):u.push(i=e);for(var o,e,g=-(1/0),t=u.length-1,r=0,i=u[t];t>=r;i=e,++r)e=u[r],(o=a(i[1],e[0]))>g&&(g=o,f=e[0],h=i[1])}return M=x=null,f===1/0||s===1/0?[[NaN,NaN],[NaN,NaN]]:[[f,s],[h,p]]}}(),ao.geo.centroid=function(n){Ea=Aa=Ca=za=La=qa=Ta=Ra=Da=Pa=Ua=0,ao.geo.stream(n,ja);var t=Da,e=Pa,r=Ua,i=t*t+e*e+r*r;return jo>i&&(t=qa,e=Ta,r=Ra,Uo>Aa&&(t=Ca,e=za,r=La),i=t*t+e*e+r*r,jo>i)?[NaN,NaN]:[Math.atan2(e,t)*Zo,tn(r/Math.sqrt(i))*Zo]};var Ea,Aa,Ca,za,La,qa,Ta,Ra,Da,Pa,Ua,ja={sphere:b,point:St,lineStart:Nt,lineEnd:Et,polygonStart:function(){ja.lineStart=At},polygonEnd:function(){ja.lineStart=Nt}},Fa=Rt(zt,jt,Ht,[-Fo,-Fo/2]),Ha=1e9;ao.geo.clipExtent=function(){var n,t,e,r,i,u,o={stream:function(n){return i&&(i.valid=!1),i=u(n),i.valid=!0,i},extent:function(a){return arguments.length?(u=Zt(n=+a[0][0],t=+a[0][1],e=+a[1][0],r=+a[1][1]),i&&(i.valid=!1,i=null),o):[[n,t],[e,r]]}};return o.extent([[0,0],[960,500]])},(ao.geo.conicEqualArea=function(){return Vt(Xt)}).raw=Xt,ao.geo.albers=function(){return ao.geo.conicEqualArea().rotate([96,0]).center([-.6,38.7]).parallels([29.5,45.5]).scale(1070)},ao.geo.albersUsa=function(){function n(n){var u=n[0],o=n[1];return t=null,e(u,o),t||(r(u,o),t)||i(u,o),t}var t,e,r,i,u=ao.geo.albers(),o=ao.geo.conicEqualArea().rotate([154,0]).center([-2,58.5]).parallels([55,65]),a=ao.geo.conicEqualArea().rotate([157,0]).center([-3,19.9]).parallels([8,18]),l={point:function(n,e){t=[n,e]}};return n.invert=function(n){var t=u.scale(),e=u.translate(),r=(n[0]-e[0])/t,i=(n[1]-e[1])/t;return(i>=.12&&.234>i&&r>=-.425&&-.214>r?o:i>=.166&&.234>i&&r>=-.214&&-.115>r?a:u).invert(n)},n.stream=function(n){var t=u.stream(n),e=o.stream(n),r=a.stream(n);return{point:function(n,i){t.point(n,i),e.point(n,i),r.point(n,i)},sphere:function(){t.sphere(),e.sphere(),r.sphere()},lineStart:function(){t.lineStart(),e.lineStart(),r.lineStart()},lineEnd:function(){t.lineEnd(),e.lineEnd(),r.lineEnd()},polygonStart:function(){t.polygonStart(),e.polygonStart(),r.polygonStart()},polygonEnd:function(){t.polygonEnd(),e.polygonEnd(),r.polygonEnd()}}},n.precision=function(t){return arguments.length?(u.precision(t),o.precision(t),a.precision(t),n):u.precision()},n.scale=function(t){return arguments.length?(u.scale(t),o.scale(.35*t),a.scale(t),n.translate(u.translate())):u.scale()},n.translate=function(t){if(!arguments.length)return u.translate();var c=u.scale(),f=+t[0],s=+t[1];return e=u.translate(t).clipExtent([[f-.455*c,s-.238*c],[f+.455*c,s+.238*c]]).stream(l).point,r=o.translate([f-.307*c,s+.201*c]).clipExtent([[f-.425*c+Uo,s+.12*c+Uo],[f-.214*c-Uo,s+.234*c-Uo]]).stream(l).point,i=a.translate([f-.205*c,s+.212*c]).clipExtent([[f-.214*c+Uo,s+.166*c+Uo],[f-.115*c-Uo,s+.234*c-Uo]]).stream(l).point,n},n.scale(1070)};var Oa,Ia,Ya,Za,Va,Xa,$a={point:b,lineStart:b,lineEnd:b,polygonStart:function(){Ia=0,$a.lineStart=$t},polygonEnd:function(){$a.lineStart=$a.lineEnd=$a.point=b,Oa+=xo(Ia/2)}},Ba={point:Bt,lineStart:b,lineEnd:b,polygonStart:b,polygonEnd:b},Wa={point:Gt,lineStart:Kt,lineEnd:Qt,polygonStart:function(){Wa.lineStart=ne},polygonEnd:function(){Wa.point=Gt,Wa.lineStart=Kt,Wa.lineEnd=Qt}};ao.geo.path=function(){function n(n){return n&&("function"==typeof a&&u.pointRadius(+a.apply(this,arguments)),o&&o.valid||(o=i(u)),ao.geo.stream(n,o)),u.result()}function t(){return o=null,n}var e,r,i,u,o,a=4.5;return n.area=function(n){return Oa=0,ao.geo.stream(n,i($a)),Oa},n.centroid=function(n){return Ca=za=La=qa=Ta=Ra=Da=Pa=Ua=0,ao.geo.stream(n,i(Wa)),Ua?[Da/Ua,Pa/Ua]:Ra?[qa/Ra,Ta/Ra]:La?[Ca/La,za/La]:[NaN,NaN]},n.bounds=function(n){return Va=Xa=-(Ya=Za=1/0),ao.geo.stream(n,i(Ba)),[[Ya,Za],[Va,Xa]]},n.projection=function(n){return arguments.length?(i=(e=n)?n.stream||re(n):m,t()):e},n.context=function(n){return arguments.length?(u=null==(r=n)?new Wt:new te(n),"function"!=typeof a&&u.pointRadius(a),t()):r},n.pointRadius=function(t){return arguments.length?(a="function"==typeof t?t:(u.pointRadius(+t),+t),n):a},n.projection(ao.geo.albersUsa()).context(null)},ao.geo.transform=function(n){return{stream:function(t){var e=new ie(t);for(var r in n)e[r]=n[r];return e}}},ie.prototype={point:function(n,t){this.stream.point(n,t)},sphere:function(){this.stream.sphere()},lineStart:function(){this.stream.lineStart()},lineEnd:function(){this.stream.lineEnd()},polygonStart:function(){this.stream.polygonStart()},polygonEnd:function(){this.stream.polygonEnd()}},ao.geo.projection=oe,ao.geo.projectionMutator=ae,(ao.geo.equirectangular=function(){return oe(ce)}).raw=ce.invert=ce,ao.geo.rotation=function(n){function t(t){return t=n(t[0]*Yo,t[1]*Yo),t[0]*=Zo,t[1]*=Zo,t}return n=se(n[0]%360*Yo,n[1]*Yo,n.length>2?n[2]*Yo:0),t.invert=function(t){return t=n.invert(t[0]*Yo,t[1]*Yo),t[0]*=Zo,t[1]*=Zo,t},t},fe.invert=ce,ao.geo.circle=function(){function n(){var n="function"==typeof r?r.apply(this,arguments):r,t=se(-n[0]*Yo,-n[1]*Yo,0).invert,i=[];return e(null,null,1,{point:function(n,e){i.push(n=t(n,e)),n[0]*=Zo,n[1]*=Zo}}),{type:"Polygon",coordinates:[i]}}var t,e,r=[0,0],i=6;return n.origin=function(t){return arguments.length?(r=t,n):r},n.angle=function(r){return arguments.length?(e=ve((t=+r)*Yo,i*Yo),n):t},n.precision=function(r){return arguments.length?(e=ve(t*Yo,(i=+r)*Yo),n):i},n.angle(90)},ao.geo.distance=function(n,t){var e,r=(t[0]-n[0])*Yo,i=n[1]*Yo,u=t[1]*Yo,o=Math.sin(r),a=Math.cos(r),l=Math.sin(i),c=Math.cos(i),f=Math.sin(u),s=Math.cos(u);return Math.atan2(Math.sqrt((e=s*o)*e+(e=c*f-l*s*a)*e),l*f+c*s*a)},ao.geo.graticule=function(){function n(){return{type:"MultiLineString",coordinates:t()}}function t(){return ao.range(Math.ceil(u/d)*d,i,d).map(h).concat(ao.range(Math.ceil(c/y)*y,l,y).map(p)).concat(ao.range(Math.ceil(r/g)*g,e,g).filter(function(n){return xo(n%d)>Uo}).map(f)).concat(ao.range(Math.ceil(a/v)*v,o,v).filter(function(n){return xo(n%y)>Uo}).map(s))}var e,r,i,u,o,a,l,c,f,s,h,p,g=10,v=g,d=90,y=360,m=2.5;return n.lines=function(){return t().map(function(n){return{type:"LineString",coordinates:n}})},n.outline=function(){return{type:"Polygon",coordinates:[h(u).concat(p(l).slice(1),h(i).reverse().slice(1),p(c).reverse().slice(1))]}},n.extent=function(t){return arguments.length?n.majorExtent(t).minorExtent(t):n.minorExtent()},n.majorExtent=function(t){return arguments.length?(u=+t[0][0],i=+t[1][0],c=+t[0][1],l=+t[1][1],u>i&&(t=u,u=i,i=t),c>l&&(t=c,c=l,l=t),n.precision(m)):[[u,c],[i,l]]},n.minorExtent=function(t){return arguments.length?(r=+t[0][0],e=+t[1][0],a=+t[0][1],o=+t[1][1],r>e&&(t=r,r=e,e=t),a>o&&(t=a,a=o,o=t),n.precision(m)):[[r,a],[e,o]]},n.step=function(t){return arguments.length?n.majorStep(t).minorStep(t):n.minorStep()},n.majorStep=function(t){return arguments.length?(d=+t[0],y=+t[1],n):[d,y]},n.minorStep=function(t){return arguments.length?(g=+t[0],v=+t[1],n):[g,v]},n.precision=function(t){return arguments.length?(m=+t,f=ye(a,o,90),s=me(r,e,m),h=ye(c,l,90),p=me(u,i,m),n):m},n.majorExtent([[-180,-90+Uo],[180,90-Uo]]).minorExtent([[-180,-80-Uo],[180,80+Uo]])},ao.geo.greatArc=function(){function n(){return{type:"LineString",coordinates:[t||r.apply(this,arguments),e||i.apply(this,arguments)]}}var t,e,r=Me,i=xe;return n.distance=function(){return ao.geo.distance(t||r.apply(this,arguments),e||i.apply(this,arguments))},n.source=function(e){return arguments.length?(r=e,t="function"==typeof e?null:e,n):r},n.target=function(t){return arguments.length?(i=t,e="function"==typeof t?null:t,n):i},n.precision=function(){return arguments.length?n:0},n},ao.geo.interpolate=function(n,t){return be(n[0]*Yo,n[1]*Yo,t[0]*Yo,t[1]*Yo)},ao.geo.length=function(n){return Ja=0,ao.geo.stream(n,Ga),Ja};var Ja,Ga={sphere:b,point:b,lineStart:_e,lineEnd:b,polygonStart:b,polygonEnd:b},Ka=we(function(n){return Math.sqrt(2/(1+n))},function(n){return 2*Math.asin(n/2)});(ao.geo.azimuthalEqualArea=function(){return oe(Ka)}).raw=Ka;var Qa=we(function(n){var t=Math.acos(n);return t&&t/Math.sin(t)},m);(ao.geo.azimuthalEquidistant=function(){return oe(Qa)}).raw=Qa,(ao.geo.conicConformal=function(){return Vt(Se)}).raw=Se,(ao.geo.conicEquidistant=function(){return Vt(ke)}).raw=ke;var nl=we(function(n){return 1/n},Math.atan);(ao.geo.gnomonic=function(){return oe(nl)}).raw=nl,Ne.invert=function(n,t){return[n,2*Math.atan(Math.exp(t))-Io]},(ao.geo.mercator=function(){return Ee(Ne)}).raw=Ne;var tl=we(function(){return 1},Math.asin);(ao.geo.orthographic=function(){return oe(tl)}).raw=tl;var el=we(function(n){return 1/(1+n)},function(n){return 2*Math.atan(n)});(ao.geo.stereographic=function(){return oe(el)}).raw=el,Ae.invert=function(n,t){return[-t,2*Math.atan(Math.exp(n))-Io]},(ao.geo.transverseMercator=function(){var n=Ee(Ae),t=n.center,e=n.rotate;return n.center=function(n){return n?t([-n[1],n[0]]):(n=t(),[n[1],-n[0]])},n.rotate=function(n){return n?e([n[0],n[1],n.length>2?n[2]+90:90]):(n=e(),[n[0],n[1],n[2]-90])},e([0,0,90])}).raw=Ae,ao.geom={},ao.geom.hull=function(n){function t(n){if(n.length<3)return[];var t,i=En(e),u=En(r),o=n.length,a=[],l=[];for(t=0;o>t;t++)a.push([+i.call(this,n[t],t),+u.call(this,n[t],t),t]);for(a.sort(qe),t=0;o>t;t++)l.push([a[t][0],-a[t][1]]);var c=Le(a),f=Le(l),s=f[0]===c[0],h=f[f.length-1]===c[c.length-1],p=[];for(t=c.length-1;t>=0;--t)p.push(n[a[c[t]][2]]);for(t=+s;t<f.length-h;++t)p.push(n[a[f[t]][2]]);return p}var e=Ce,r=ze;return arguments.length?t(n):(t.x=function(n){return arguments.length?(e=n,t):e},t.y=function(n){return arguments.length?(r=n,t):r},t)},ao.geom.polygon=function(n){return ko(n,rl),n};var rl=ao.geom.polygon.prototype=[];rl.area=function(){for(var n,t=-1,e=this.length,r=this[e-1],i=0;++t<e;)n=r,r=this[t],i+=n[1]*r[0]-n[0]*r[1];return.5*i},rl.centroid=function(n){var t,e,r=-1,i=this.length,u=0,o=0,a=this[i-1];for(arguments.length||(n=-1/(6*this.area()));++r<i;)t=a,a=this[r],e=t[0]*a[1]-a[0]*t[1],u+=(t[0]+a[0])*e,o+=(t[1]+a[1])*e;return[u*n,o*n]},rl.clip=function(n){for(var t,e,r,i,u,o,a=De(n),l=-1,c=this.length-De(this),f=this[c-1];++l<c;){for(t=n.slice(),n.length=0,i=this[l],u=t[(r=t.length-a)-1],e=-1;++e<r;)o=t[e],Te(o,f,i)?(Te(u,f,i)||n.push(Re(u,o,f,i)),n.push(o)):Te(u,f,i)&&n.push(Re(u,o,f,i)),u=o;a&&n.push(n[0]),f=i}return n};var il,ul,ol,al,ll,cl=[],fl=[];Ye.prototype.prepare=function(){for(var n,t=this.edges,e=t.length;e--;)n=t[e].edge,n.b&&n.a||t.splice(e,1);return t.sort(Ve),t.length},tr.prototype={start:function(){return this.edge.l===this.site?this.edge.a:this.edge.b},end:function(){return this.edge.l===this.site?this.edge.b:this.edge.a}},er.prototype={insert:function(n,t){var e,r,i;if(n){if(t.P=n,t.N=n.N,n.N&&(n.N.P=t),n.N=t,n.R){for(n=n.R;n.L;)n=n.L;n.L=t}else n.R=t;e=n}else this._?(n=or(this._),t.P=null,t.N=n,n.P=n.L=t,e=n):(t.P=t.N=null,this._=t,e=null);for(t.L=t.R=null,t.U=e,t.C=!0,n=t;e&&e.C;)r=e.U,e===r.L?(i=r.R,i&&i.C?(e.C=i.C=!1,r.C=!0,n=r):(n===e.R&&(ir(this,e),n=e,e=n.U),e.C=!1,r.C=!0,ur(this,r))):(i=r.L,i&&i.C?(e.C=i.C=!1,r.C=!0,n=r):(n===e.L&&(ur(this,e),n=e,e=n.U),e.C=!1,r.C=!0,ir(this,r))),e=n.U;this._.C=!1},remove:function(n){n.N&&(n.N.P=n.P),n.P&&(n.P.N=n.N),n.N=n.P=null;var t,e,r,i=n.U,u=n.L,o=n.R;if(e=u?o?or(o):u:o,i?i.L===n?i.L=e:i.R=e:this._=e,u&&o?(r=e.C,e.C=n.C,e.L=u,u.U=e,e!==o?(i=e.U,e.U=n.U,n=e.R,i.L=n,e.R=o,o.U=e):(e.U=i,i=e,n=e.R)):(r=n.C,n=e),n&&(n.U=i),!r){if(n&&n.C)return void(n.C=!1);do{if(n===this._)break;if(n===i.L){if(t=i.R,t.C&&(t.C=!1,i.C=!0,ir(this,i),t=i.R),t.L&&t.L.C||t.R&&t.R.C){t.R&&t.R.C||(t.L.C=!1,t.C=!0,ur(this,t),t=i.R),t.C=i.C,i.C=t.R.C=!1,ir(this,i),n=this._;break}}else if(t=i.L,t.C&&(t.C=!1,i.C=!0,ur(this,i),t=i.L),t.L&&t.L.C||t.R&&t.R.C){t.L&&t.L.C||(t.R.C=!1,t.C=!0,ir(this,t),t=i.L),t.C=i.C,i.C=t.L.C=!1,ur(this,i),n=this._;break}t.C=!0,n=i,i=i.U}while(!n.C);n&&(n.C=!1)}}},ao.geom.voronoi=function(n){function t(n){var t=new Array(n.length),r=a[0][0],i=a[0][1],u=a[1][0],o=a[1][1];return ar(e(n),a).cells.forEach(function(e,a){var l=e.edges,c=e.site,f=t[a]=l.length?l.map(function(n){var t=n.start();return[t.x,t.y]}):c.x>=r&&c.x<=u&&c.y>=i&&c.y<=o?[[r,o],[u,o],[u,i],[r,i]]:[];f.point=n[a]}),t}function e(n){return n.map(function(n,t){return{x:Math.round(u(n,t)/Uo)*Uo,y:Math.round(o(n,t)/Uo)*Uo,i:t}})}var r=Ce,i=ze,u=r,o=i,a=sl;return n?t(n):(t.links=function(n){return ar(e(n)).edges.filter(function(n){return n.l&&n.r}).map(function(t){return{source:n[t.l.i],target:n[t.r.i]}})},t.triangles=function(n){var t=[];return ar(e(n)).cells.forEach(function(e,r){for(var i,u,o=e.site,a=e.edges.sort(Ve),l=-1,c=a.length,f=a[c-1].edge,s=f.l===o?f.r:f.l;++l<c;)i=f,u=s,f=a[l].edge,s=f.l===o?f.r:f.l,r<u.i&&r<s.i&&cr(o,u,s)<0&&t.push([n[r],n[u.i],n[s.i]])}),t},t.x=function(n){return arguments.length?(u=En(r=n),t):r},t.y=function(n){return arguments.length?(o=En(i=n),t):i},t.clipExtent=function(n){return arguments.length?(a=null==n?sl:n,t):a===sl?null:a},t.size=function(n){return arguments.length?t.clipExtent(n&&[[0,0],n]):a===sl?null:a&&a[1]},t)};var sl=[[-1e6,-1e6],[1e6,1e6]];ao.geom.delaunay=function(n){return ao.geom.voronoi().triangles(n)},ao.geom.quadtree=function(n,t,e,r,i){function u(n){function u(n,t,e,r,i,u,o,a){if(!isNaN(e)&&!isNaN(r))if(n.leaf){var l=n.x,f=n.y;if(null!=l)if(xo(l-e)+xo(f-r)<.01)c(n,t,e,r,i,u,o,a);else{var s=n.point;n.x=n.y=n.point=null,c(n,s,l,f,i,u,o,a),c(n,t,e,r,i,u,o,a)}else n.x=e,n.y=r,n.point=t}else c(n,t,e,r,i,u,o,a)}function c(n,t,e,r,i,o,a,l){var c=.5*(i+a),f=.5*(o+l),s=e>=c,h=r>=f,p=h<<1|s;n.leaf=!1,n=n.nodes[p]||(n.nodes[p]=hr()),s?i=c:a=c,h?o=f:l=f,u(n,t,e,r,i,o,a,l)}var f,s,h,p,g,v,d,y,m,M=En(a),x=En(l);if(null!=t)v=t,d=e,y=r,m=i;else if(y=m=-(v=d=1/0),s=[],h=[],g=n.length,o)for(p=0;g>p;++p)f=n[p],f.x<v&&(v=f.x),f.y<d&&(d=f.y),f.x>y&&(y=f.x),f.y>m&&(m=f.y),s.push(f.x),h.push(f.y);else for(p=0;g>p;++p){var b=+M(f=n[p],p),_=+x(f,p);v>b&&(v=b),d>_&&(d=_),b>y&&(y=b),_>m&&(m=_),s.push(b),h.push(_)}var w=y-v,S=m-d;w>S?m=d+w:y=v+S;var k=hr();if(k.add=function(n){u(k,n,+M(n,++p),+x(n,p),v,d,y,m)},k.visit=function(n){pr(n,k,v,d,y,m)},k.find=function(n){return gr(k,n[0],n[1],v,d,y,m)},p=-1,null==t){for(;++p<g;)u(k,n[p],s[p],h[p],v,d,y,m);--p}else n.forEach(k.add);return s=h=n=f=null,k}var o,a=Ce,l=ze;return(o=arguments.length)?(a=fr,l=sr,3===o&&(i=e,r=t,e=t=0),u(n)):(u.x=function(n){return arguments.length?(a=n,u):a},u.y=function(n){return arguments.length?(l=n,u):l},u.extent=function(n){return arguments.length?(null==n?t=e=r=i=null:(t=+n[0][0],e=+n[0][1],r=+n[1][0],i=+n[1][1]),u):null==t?null:[[t,e],[r,i]]},u.size=function(n){return arguments.length?(null==n?t=e=r=i=null:(t=e=0,r=+n[0],i=+n[1]),u):null==t?null:[r-t,i-e]},u)},ao.interpolateRgb=vr,ao.interpolateObject=dr,ao.interpolateNumber=yr,ao.interpolateString=mr;var hl=/[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,pl=new RegExp(hl.source,"g");ao.interpolate=Mr,ao.interpolators=[function(n,t){var e=typeof t;return("string"===e?ua.has(t.toLowerCase())||/^(#|rgb\(|hsl\()/i.test(t)?vr:mr:t instanceof an?vr:Array.isArray(t)?xr:"object"===e&&isNaN(t)?dr:yr)(n,t)}],ao.interpolateArray=xr;var gl=function(){return m},vl=ao.map({linear:gl,poly:Er,quad:function(){return Sr},cubic:function(){return kr},sin:function(){return Ar},exp:function(){return Cr},circle:function(){return zr},elastic:Lr,back:qr,bounce:function(){return Tr}}),dl=ao.map({"in":m,out:_r,"in-out":wr,"out-in":function(n){return wr(_r(n))}});ao.ease=function(n){var t=n.indexOf("-"),e=t>=0?n.slice(0,t):n,r=t>=0?n.slice(t+1):"in";return e=vl.get(e)||gl,r=dl.get(r)||m,br(r(e.apply(null,lo.call(arguments,1))))},ao.interpolateHcl=Rr,ao.interpolateHsl=Dr,ao.interpolateLab=Pr,ao.interpolateRound=Ur,ao.transform=function(n){var t=fo.createElementNS(ao.ns.prefix.svg,"g");return(ao.transform=function(n){if(null!=n){t.setAttribute("transform",n);var e=t.transform.baseVal.consolidate()}return new jr(e?e.matrix:yl)})(n)},jr.prototype.toString=function(){return"translate("+this.translate+")rotate("+this.rotate+")skewX("+this.skew+")scale("+this.scale+")"};var yl={a:1,b:0,c:0,d:1,e:0,f:0};ao.interpolateTransform=$r,ao.layout={},ao.layout.bundle=function(){return function(n){for(var t=[],e=-1,r=n.length;++e<r;)t.push(Jr(n[e]));return t}},ao.layout.chord=function(){function n(){var n,c,s,h,p,g={},v=[],d=ao.range(u),y=[];for(e=[],r=[],n=0,h=-1;++h<u;){for(c=0,p=-1;++p<u;)c+=i[h][p];v.push(c),y.push(ao.range(u)),n+=c}for(o&&d.sort(function(n,t){return o(v[n],v[t])}),a&&y.forEach(function(n,t){n.sort(function(n,e){return a(i[t][n],i[t][e])})}),n=(Ho-f*u)/n,c=0,h=-1;++h<u;){for(s=c,p=-1;++p<u;){var m=d[h],M=y[m][p],x=i[m][M],b=c,_=c+=x*n;g[m+"-"+M]={index:m,subindex:M,startAngle:b,endAngle:_,value:x}}r[m]={index:m,startAngle:s,endAngle:c,value:v[m]},c+=f}for(h=-1;++h<u;)for(p=h-1;++p<u;){var w=g[h+"-"+p],S=g[p+"-"+h];(w.value||S.value)&&e.push(w.value<S.value?{source:S,target:w}:{source:w,target:S})}l&&t()}function t(){e.sort(function(n,t){return l((n.source.value+n.target.value)/2,(t.source.value+t.target.value)/2)})}var e,r,i,u,o,a,l,c={},f=0;return c.matrix=function(n){return arguments.length?(u=(i=n)&&i.length,e=r=null,c):i},c.padding=function(n){return arguments.length?(f=n,e=r=null,c):f},c.sortGroups=function(n){return arguments.length?(o=n,e=r=null,c):o},c.sortSubgroups=function(n){return arguments.length?(a=n,e=null,c):a},c.sortChords=function(n){return arguments.length?(l=n,e&&t(),c):l},c.chords=function(){return e||n(),e},c.groups=function(){return r||n(),r},c},ao.layout.force=function(){function n(n){return function(t,e,r,i){if(t.point!==n){var u=t.cx-n.x,o=t.cy-n.y,a=i-e,l=u*u+o*o;if(l>a*a/y){if(v>l){var c=t.charge/l;n.px-=u*c,n.py-=o*c}return!0}if(t.point&&l&&v>l){var c=t.pointCharge/l;n.px-=u*c,n.py-=o*c}}return!t.charge}}function t(n){n.px=ao.event.x,n.py=ao.event.y,l.resume()}var e,r,i,u,o,a,l={},c=ao.dispatch("start","tick","end"),f=[1,1],s=.9,h=ml,p=Ml,g=-30,v=xl,d=.1,y=.64,M=[],x=[];return l.tick=function(){if((i*=.99)<.005)return e=null,c.end({type:"end",alpha:i=0}),!0;var t,r,l,h,p,v,y,m,b,_=M.length,w=x.length;for(r=0;w>r;++r)l=x[r],h=l.source,p=l.target,m=p.x-h.x,b=p.y-h.y,(v=m*m+b*b)&&(v=i*o[r]*((v=Math.sqrt(v))-u[r])/v,m*=v,b*=v,p.x-=m*(y=h.weight+p.weight?h.weight/(h.weight+p.weight):.5),p.y-=b*y,h.x+=m*(y=1-y),h.y+=b*y);if((y=i*d)&&(m=f[0]/2,b=f[1]/2,r=-1,y))for(;++r<_;)l=M[r],l.x+=(m-l.x)*y,l.y+=(b-l.y)*y;if(g)for(ri(t=ao.geom.quadtree(M),i,a),r=-1;++r<_;)(l=M[r]).fixed||t.visit(n(l));for(r=-1;++r<_;)l=M[r],l.fixed?(l.x=l.px,l.y=l.py):(l.x-=(l.px-(l.px=l.x))*s,l.y-=(l.py-(l.py=l.y))*s);c.tick({type:"tick",alpha:i})},l.nodes=function(n){return arguments.length?(M=n,l):M},l.links=function(n){return arguments.length?(x=n,l):x},l.size=function(n){return arguments.length?(f=n,l):f},l.linkDistance=function(n){return arguments.length?(h="function"==typeof n?n:+n,l):h},l.distance=l.linkDistance,l.linkStrength=function(n){return arguments.length?(p="function"==typeof n?n:+n,l):p},l.friction=function(n){return arguments.length?(s=+n,l):s},l.charge=function(n){return arguments.length?(g="function"==typeof n?n:+n,l):g},l.chargeDistance=function(n){return arguments.length?(v=n*n,l):Math.sqrt(v)},l.gravity=function(n){return arguments.length?(d=+n,l):d},l.theta=function(n){return arguments.length?(y=n*n,l):Math.sqrt(y)},l.alpha=function(n){return arguments.length?(n=+n,i?n>0?i=n:(e.c=null,e.t=NaN,e=null,c.end({type:"end",alpha:i=0})):n>0&&(c.start({type:"start",alpha:i=n}),e=qn(l.tick)),l):i},l.start=function(){function n(n,r){if(!e){for(e=new Array(i),l=0;i>l;++l)e[l]=[];for(l=0;c>l;++l){var u=x[l];e[u.source.index].push(u.target),e[u.target.index].push(u.source)}}for(var o,a=e[t],l=-1,f=a.length;++l<f;)if(!isNaN(o=a[l][n]))return o;return Math.random()*r}var t,e,r,i=M.length,c=x.length,s=f[0],v=f[1];for(t=0;i>t;++t)(r=M[t]).index=t,r.weight=0;for(t=0;c>t;++t)r=x[t],"number"==typeof r.source&&(r.source=M[r.source]),"number"==typeof r.target&&(r.target=M[r.target]),++r.source.weight,++r.target.weight;for(t=0;i>t;++t)r=M[t],isNaN(r.x)&&(r.x=n("x",s)),isNaN(r.y)&&(r.y=n("y",v)),isNaN(r.px)&&(r.px=r.x),isNaN(r.py)&&(r.py=r.y);if(u=[],"function"==typeof h)for(t=0;c>t;++t)u[t]=+h.call(this,x[t],t);else for(t=0;c>t;++t)u[t]=h;if(o=[],"function"==typeof p)for(t=0;c>t;++t)o[t]=+p.call(this,x[t],t);else for(t=0;c>t;++t)o[t]=p;if(a=[],"function"==typeof g)for(t=0;i>t;++t)a[t]=+g.call(this,M[t],t);else for(t=0;i>t;++t)a[t]=g;return l.resume()},l.resume=function(){return l.alpha(.1)},l.stop=function(){return l.alpha(0)},l.drag=function(){return r||(r=ao.behavior.drag().origin(m).on("dragstart.force",Qr).on("drag.force",t).on("dragend.force",ni)),arguments.length?void this.on("mouseover.force",ti).on("mouseout.force",ei).call(r):r},ao.rebind(l,c,"on")};var ml=20,Ml=1,xl=1/0;ao.layout.hierarchy=function(){function n(i){var u,o=[i],a=[];for(i.depth=0;null!=(u=o.pop());)if(a.push(u),(c=e.call(n,u,u.depth))&&(l=c.length)){for(var l,c,f;--l>=0;)o.push(f=c[l]),f.parent=u,f.depth=u.depth+1;r&&(u.value=0),u.children=c}else r&&(u.value=+r.call(n,u,u.depth)||0),delete u.children;return oi(i,function(n){var e,i;t&&(e=n.children)&&e.sort(t),r&&(i=n.parent)&&(i.value+=n.value)}),a}var t=ci,e=ai,r=li;return n.sort=function(e){return arguments.length?(t=e,n):t},n.children=function(t){return arguments.length?(e=t,n):e},n.value=function(t){return arguments.length?(r=t,n):r},n.revalue=function(t){return r&&(ui(t,function(n){n.children&&(n.value=0)}),oi(t,function(t){var e;t.children||(t.value=+r.call(n,t,t.depth)||0),(e=t.parent)&&(e.value+=t.value)})),t},n},ao.layout.partition=function(){function n(t,e,r,i){var u=t.children;if(t.x=e,t.y=t.depth*i,t.dx=r,t.dy=i,u&&(o=u.length)){var o,a,l,c=-1;for(r=t.value?r/t.value:0;++c<o;)n(a=u[c],e,l=a.value*r,i),e+=l}}function t(n){var e=n.children,r=0;if(e&&(i=e.length))for(var i,u=-1;++u<i;)r=Math.max(r,t(e[u]));return 1+r}function e(e,u){var o=r.call(this,e,u);return n(o[0],0,i[0],i[1]/t(o[0])),o}var r=ao.layout.hierarchy(),i=[1,1];return e.size=function(n){return arguments.length?(i=n,e):i},ii(e,r)},ao.layout.pie=function(){function n(o){var a,l=o.length,c=o.map(function(e,r){return+t.call(n,e,r)}),f=+("function"==typeof r?r.apply(this,arguments):r),s=("function"==typeof i?i.apply(this,arguments):i)-f,h=Math.min(Math.abs(s)/l,+("function"==typeof u?u.apply(this,arguments):u)),p=h*(0>s?-1:1),g=ao.sum(c),v=g?(s-l*p)/g:0,d=ao.range(l),y=[];return null!=e&&d.sort(e===bl?function(n,t){return c[t]-c[n]}:function(n,t){return e(o[n],o[t])}),d.forEach(function(n){y[n]={data:o[n],value:a=c[n],startAngle:f,endAngle:f+=a*v+p,padAngle:h}}),y}var t=Number,e=bl,r=0,i=Ho,u=0;return n.value=function(e){return arguments.length?(t=e,n):t},n.sort=function(t){return arguments.length?(e=t,n):e},n.startAngle=function(t){return arguments.length?(r=t,n):r},n.endAngle=function(t){return arguments.length?(i=t,n):i},n.padAngle=function(t){return arguments.length?(u=t,n):u},n};var bl={};ao.layout.stack=function(){function n(a,l){if(!(h=a.length))return a;var c=a.map(function(e,r){return t.call(n,e,r)}),f=c.map(function(t){return t.map(function(t,e){return[u.call(n,t,e),o.call(n,t,e)]})}),s=e.call(n,f,l);c=ao.permute(c,s),f=ao.permute(f,s);var h,p,g,v,d=r.call(n,f,l),y=c[0].length;for(g=0;y>g;++g)for(i.call(n,c[0][g],v=d[g],f[0][g][1]),p=1;h>p;++p)i.call(n,c[p][g],v+=f[p-1][g][1],f[p][g][1]);return a}var t=m,e=gi,r=vi,i=pi,u=si,o=hi;return n.values=function(e){return arguments.length?(t=e,n):t},n.order=function(t){return arguments.length?(e="function"==typeof t?t:_l.get(t)||gi,n):e},n.offset=function(t){return arguments.length?(r="function"==typeof t?t:wl.get(t)||vi,n):r},n.x=function(t){return arguments.length?(u=t,n):u},n.y=function(t){return arguments.length?(o=t,n):o},n.out=function(t){return arguments.length?(i=t,n):i},n};var _l=ao.map({"inside-out":function(n){var t,e,r=n.length,i=n.map(di),u=n.map(yi),o=ao.range(r).sort(function(n,t){return i[n]-i[t]}),a=0,l=0,c=[],f=[];for(t=0;r>t;++t)e=o[t],l>a?(a+=u[e],c.push(e)):(l+=u[e],f.push(e));return f.reverse().concat(c)},reverse:function(n){return ao.range(n.length).reverse()},"default":gi}),wl=ao.map({silhouette:function(n){var t,e,r,i=n.length,u=n[0].length,o=[],a=0,l=[];for(e=0;u>e;++e){for(t=0,r=0;i>t;t++)r+=n[t][e][1];r>a&&(a=r),o.push(r)}for(e=0;u>e;++e)l[e]=(a-o[e])/2;return l},wiggle:function(n){var t,e,r,i,u,o,a,l,c,f=n.length,s=n[0],h=s.length,p=[];for(p[0]=l=c=0,e=1;h>e;++e){for(t=0,i=0;f>t;++t)i+=n[t][e][1];for(t=0,u=0,a=s[e][0]-s[e-1][0];f>t;++t){for(r=0,o=(n[t][e][1]-n[t][e-1][1])/(2*a);t>r;++r)o+=(n[r][e][1]-n[r][e-1][1])/a;u+=o*n[t][e][1]}p[e]=l-=i?u/i*a:0,c>l&&(c=l)}for(e=0;h>e;++e)p[e]-=c;return p},expand:function(n){var t,e,r,i=n.length,u=n[0].length,o=1/i,a=[];for(e=0;u>e;++e){for(t=0,r=0;i>t;t++)r+=n[t][e][1];if(r)for(t=0;i>t;t++)n[t][e][1]/=r;else for(t=0;i>t;t++)n[t][e][1]=o}for(e=0;u>e;++e)a[e]=0;return a},zero:vi});ao.layout.histogram=function(){function n(n,u){for(var o,a,l=[],c=n.map(e,this),f=r.call(this,c,u),s=i.call(this,f,c,u),u=-1,h=c.length,p=s.length-1,g=t?1:1/h;++u<p;)o=l[u]=[],o.dx=s[u+1]-(o.x=s[u]),o.y=0;if(p>0)for(u=-1;++u<h;)a=c[u],a>=f[0]&&a<=f[1]&&(o=l[ao.bisect(s,a,1,p)-1],o.y+=g,o.push(n[u]));return l}var t=!0,e=Number,r=bi,i=Mi;return n.value=function(t){return arguments.length?(e=t,n):e},n.range=function(t){return arguments.length?(r=En(t),n):r},n.bins=function(t){return arguments.length?(i="number"==typeof t?function(n){return xi(n,t)}:En(t),n):i},n.frequency=function(e){return arguments.length?(t=!!e,n):t},n},ao.layout.pack=function(){function n(n,u){var o=e.call(this,n,u),a=o[0],l=i[0],c=i[1],f=null==t?Math.sqrt:"function"==typeof t?t:function(){return t};if(a.x=a.y=0,oi(a,function(n){n.r=+f(n.value)}),oi(a,Ni),r){var s=r*(t?1:Math.max(2*a.r/l,2*a.r/c))/2;oi(a,function(n){n.r+=s}),oi(a,Ni),oi(a,function(n){n.r-=s})}return Ci(a,l/2,c/2,t?1:1/Math.max(2*a.r/l,2*a.r/c)),o}var t,e=ao.layout.hierarchy().sort(_i),r=0,i=[1,1];return n.size=function(t){return arguments.length?(i=t,n):i},n.radius=function(e){return arguments.length?(t=null==e||"function"==typeof e?e:+e,n):t},n.padding=function(t){return arguments.length?(r=+t,n):r},ii(n,e)},ao.layout.tree=function(){function n(n,i){var f=o.call(this,n,i),s=f[0],h=t(s);if(oi(h,e),h.parent.m=-h.z,ui(h,r),c)ui(s,u);else{var p=s,g=s,v=s;ui(s,function(n){n.x<p.x&&(p=n),n.x>g.x&&(g=n),n.depth>v.depth&&(v=n)});var d=a(p,g)/2-p.x,y=l[0]/(g.x+a(g,p)/2+d),m=l[1]/(v.depth||1);ui(s,function(n){n.x=(n.x+d)*y,n.y=n.depth*m})}return f}function t(n){for(var t,e={A:null,children:[n]},r=[e];null!=(t=r.pop());)for(var i,u=t.children,o=0,a=u.length;a>o;++o)r.push((u[o]=i={_:u[o],parent:t,children:(i=u[o].children)&&i.slice()||[],A:null,a:null,z:0,m:0,c:0,s:0,t:null,i:o}).a=i);return e.children[0]}function e(n){var t=n.children,e=n.parent.children,r=n.i?e[n.i-1]:null;if(t.length){Di(n);var u=(t[0].z+t[t.length-1].z)/2;r?(n.z=r.z+a(n._,r._),n.m=n.z-u):n.z=u}else r&&(n.z=r.z+a(n._,r._));n.parent.A=i(n,r,n.parent.A||e[0])}function r(n){n._.x=n.z+n.parent.m,n.m+=n.parent.m}function i(n,t,e){if(t){for(var r,i=n,u=n,o=t,l=i.parent.children[0],c=i.m,f=u.m,s=o.m,h=l.m;o=Ti(o),i=qi(i),o&&i;)l=qi(l),u=Ti(u),u.a=n,r=o.z+s-i.z-c+a(o._,i._),r>0&&(Ri(Pi(o,n,e),n,r),c+=r,f+=r),s+=o.m,c+=i.m,h+=l.m,f+=u.m;o&&!Ti(u)&&(u.t=o,u.m+=s-f),i&&!qi(l)&&(l.t=i,l.m+=c-h,e=n)}return e}function u(n){n.x*=l[0],n.y=n.depth*l[1]}var o=ao.layout.hierarchy().sort(null).value(null),a=Li,l=[1,1],c=null;return n.separation=function(t){return arguments.length?(a=t,n):a},n.size=function(t){return arguments.length?(c=null==(l=t)?u:null,n):c?null:l},n.nodeSize=function(t){return arguments.length?(c=null==(l=t)?null:u,n):c?l:null},ii(n,o)},ao.layout.cluster=function(){function n(n,u){var o,a=t.call(this,n,u),l=a[0],c=0;oi(l,function(n){var t=n.children;t&&t.length?(n.x=ji(t),n.y=Ui(t)):(n.x=o?c+=e(n,o):0,n.y=0,o=n)});var f=Fi(l),s=Hi(l),h=f.x-e(f,s)/2,p=s.x+e(s,f)/2;return oi(l,i?function(n){n.x=(n.x-l.x)*r[0],n.y=(l.y-n.y)*r[1]}:function(n){n.x=(n.x-h)/(p-h)*r[0],n.y=(1-(l.y?n.y/l.y:1))*r[1]}),a}var t=ao.layout.hierarchy().sort(null).value(null),e=Li,r=[1,1],i=!1;return n.separation=function(t){return arguments.length?(e=t,n):e},n.size=function(t){return arguments.length?(i=null==(r=t),n):i?null:r},n.nodeSize=function(t){return arguments.length?(i=null!=(r=t),n):i?r:null},ii(n,t)},ao.layout.treemap=function(){function n(n,t){for(var e,r,i=-1,u=n.length;++i<u;)r=(e=n[i]).value*(0>t?0:t),e.area=isNaN(r)||0>=r?0:r}function t(e){var u=e.children;if(u&&u.length){var o,a,l,c=s(e),f=[],h=u.slice(),g=1/0,v="slice"===p?c.dx:"dice"===p?c.dy:"slice-dice"===p?1&e.depth?c.dy:c.dx:Math.min(c.dx,c.dy);for(n(h,c.dx*c.dy/e.value),f.area=0;(l=h.length)>0;)f.push(o=h[l-1]),f.area+=o.area,"squarify"!==p||(a=r(f,v))<=g?(h.pop(),g=a):(f.area-=f.pop().area,i(f,v,c,!1),v=Math.min(c.dx,c.dy),f.length=f.area=0,g=1/0);f.length&&(i(f,v,c,!0),f.length=f.area=0),u.forEach(t)}}function e(t){var r=t.children;if(r&&r.length){var u,o=s(t),a=r.slice(),l=[];for(n(a,o.dx*o.dy/t.value),l.area=0;u=a.pop();)l.push(u),l.area+=u.area,null!=u.z&&(i(l,u.z?o.dx:o.dy,o,!a.length),l.length=l.area=0);r.forEach(e)}}function r(n,t){for(var e,r=n.area,i=0,u=1/0,o=-1,a=n.length;++o<a;)(e=n[o].area)&&(u>e&&(u=e),e>i&&(i=e));return r*=r,t*=t,r?Math.max(t*i*g/r,r/(t*u*g)):1/0}function i(n,t,e,r){var i,u=-1,o=n.length,a=e.x,c=e.y,f=t?l(n.area/t):0;
if(t==e.dx){for((r||f>e.dy)&&(f=e.dy);++u<o;)i=n[u],i.x=a,i.y=c,i.dy=f,a+=i.dx=Math.min(e.x+e.dx-a,f?l(i.area/f):0);i.z=!0,i.dx+=e.x+e.dx-a,e.y+=f,e.dy-=f}else{for((r||f>e.dx)&&(f=e.dx);++u<o;)i=n[u],i.x=a,i.y=c,i.dx=f,c+=i.dy=Math.min(e.y+e.dy-c,f?l(i.area/f):0);i.z=!1,i.dy+=e.y+e.dy-c,e.x+=f,e.dx-=f}}function u(r){var i=o||a(r),u=i[0];return u.x=u.y=0,u.value?(u.dx=c[0],u.dy=c[1]):u.dx=u.dy=0,o&&a.revalue(u),n([u],u.dx*u.dy/u.value),(o?e:t)(u),h&&(o=i),i}var o,a=ao.layout.hierarchy(),l=Math.round,c=[1,1],f=null,s=Oi,h=!1,p="squarify",g=.5*(1+Math.sqrt(5));return u.size=function(n){return arguments.length?(c=n,u):c},u.padding=function(n){function t(t){var e=n.call(u,t,t.depth);return null==e?Oi(t):Ii(t,"number"==typeof e?[e,e,e,e]:e)}function e(t){return Ii(t,n)}if(!arguments.length)return f;var r;return s=null==(f=n)?Oi:"function"==(r=typeof n)?t:"number"===r?(n=[n,n,n,n],e):e,u},u.round=function(n){return arguments.length?(l=n?Math.round:Number,u):l!=Number},u.sticky=function(n){return arguments.length?(h=n,o=null,u):h},u.ratio=function(n){return arguments.length?(g=n,u):g},u.mode=function(n){return arguments.length?(p=n+"",u):p},ii(u,a)},ao.random={normal:function(n,t){var e=arguments.length;return 2>e&&(t=1),1>e&&(n=0),function(){var e,r,i;do e=2*Math.random()-1,r=2*Math.random()-1,i=e*e+r*r;while(!i||i>1);return n+t*e*Math.sqrt(-2*Math.log(i)/i)}},logNormal:function(){var n=ao.random.normal.apply(ao,arguments);return function(){return Math.exp(n())}},bates:function(n){var t=ao.random.irwinHall(n);return function(){return t()/n}},irwinHall:function(n){return function(){for(var t=0,e=0;n>e;e++)t+=Math.random();return t}}},ao.scale={};var Sl={floor:m,ceil:m};ao.scale.linear=function(){return Wi([0,1],[0,1],Mr,!1)};var kl={s:1,g:1,p:1,r:1,e:1};ao.scale.log=function(){return ru(ao.scale.linear().domain([0,1]),10,!0,[1,10])};var Nl=ao.format(".0e"),El={floor:function(n){return-Math.ceil(-n)},ceil:function(n){return-Math.floor(-n)}};ao.scale.pow=function(){return iu(ao.scale.linear(),1,[0,1])},ao.scale.sqrt=function(){return ao.scale.pow().exponent(.5)},ao.scale.ordinal=function(){return ou([],{t:"range",a:[[]]})},ao.scale.category10=function(){return ao.scale.ordinal().range(Al)},ao.scale.category20=function(){return ao.scale.ordinal().range(Cl)},ao.scale.category20b=function(){return ao.scale.ordinal().range(zl)},ao.scale.category20c=function(){return ao.scale.ordinal().range(Ll)};var Al=[2062260,16744206,2924588,14034728,9725885,9197131,14907330,8355711,12369186,1556175].map(xn),Cl=[2062260,11454440,16744206,16759672,2924588,10018698,14034728,16750742,9725885,12955861,9197131,12885140,14907330,16234194,8355711,13092807,12369186,14408589,1556175,10410725].map(xn),zl=[3750777,5395619,7040719,10264286,6519097,9216594,11915115,13556636,9202993,12426809,15186514,15190932,8666169,11356490,14049643,15177372,8077683,10834324,13528509,14589654].map(xn),Ll=[3244733,7057110,10406625,13032431,15095053,16616764,16625259,16634018,3253076,7652470,10607003,13101504,7695281,10394312,12369372,14342891,6513507,9868950,12434877,14277081].map(xn);ao.scale.quantile=function(){return au([],[])},ao.scale.quantize=function(){return lu(0,1,[0,1])},ao.scale.threshold=function(){return cu([.5],[0,1])},ao.scale.identity=function(){return fu([0,1])},ao.svg={},ao.svg.arc=function(){function n(){var n=Math.max(0,+e.apply(this,arguments)),c=Math.max(0,+r.apply(this,arguments)),f=o.apply(this,arguments)-Io,s=a.apply(this,arguments)-Io,h=Math.abs(s-f),p=f>s?0:1;if(n>c&&(g=c,c=n,n=g),h>=Oo)return t(c,p)+(n?t(n,1-p):"")+"Z";var g,v,d,y,m,M,x,b,_,w,S,k,N=0,E=0,A=[];if((y=(+l.apply(this,arguments)||0)/2)&&(d=u===ql?Math.sqrt(n*n+c*c):+u.apply(this,arguments),p||(E*=-1),c&&(E=tn(d/c*Math.sin(y))),n&&(N=tn(d/n*Math.sin(y)))),c){m=c*Math.cos(f+E),M=c*Math.sin(f+E),x=c*Math.cos(s-E),b=c*Math.sin(s-E);var C=Math.abs(s-f-2*E)<=Fo?0:1;if(E&&yu(m,M,x,b)===p^C){var z=(f+s)/2;m=c*Math.cos(z),M=c*Math.sin(z),x=b=null}}else m=M=0;if(n){_=n*Math.cos(s-N),w=n*Math.sin(s-N),S=n*Math.cos(f+N),k=n*Math.sin(f+N);var L=Math.abs(f-s+2*N)<=Fo?0:1;if(N&&yu(_,w,S,k)===1-p^L){var q=(f+s)/2;_=n*Math.cos(q),w=n*Math.sin(q),S=k=null}}else _=w=0;if(h>Uo&&(g=Math.min(Math.abs(c-n)/2,+i.apply(this,arguments)))>.001){v=c>n^p?0:1;var T=g,R=g;if(Fo>h){var D=null==S?[_,w]:null==x?[m,M]:Re([m,M],[S,k],[x,b],[_,w]),P=m-D[0],U=M-D[1],j=x-D[0],F=b-D[1],H=1/Math.sin(Math.acos((P*j+U*F)/(Math.sqrt(P*P+U*U)*Math.sqrt(j*j+F*F)))/2),O=Math.sqrt(D[0]*D[0]+D[1]*D[1]);R=Math.min(g,(n-O)/(H-1)),T=Math.min(g,(c-O)/(H+1))}if(null!=x){var I=mu(null==S?[_,w]:[S,k],[m,M],c,T,p),Y=mu([x,b],[_,w],c,T,p);g===T?A.push("M",I[0],"A",T,",",T," 0 0,",v," ",I[1],"A",c,",",c," 0 ",1-p^yu(I[1][0],I[1][1],Y[1][0],Y[1][1]),",",p," ",Y[1],"A",T,",",T," 0 0,",v," ",Y[0]):A.push("M",I[0],"A",T,",",T," 0 1,",v," ",Y[0])}else A.push("M",m,",",M);if(null!=S){var Z=mu([m,M],[S,k],n,-R,p),V=mu([_,w],null==x?[m,M]:[x,b],n,-R,p);g===R?A.push("L",V[0],"A",R,",",R," 0 0,",v," ",V[1],"A",n,",",n," 0 ",p^yu(V[1][0],V[1][1],Z[1][0],Z[1][1]),",",1-p," ",Z[1],"A",R,",",R," 0 0,",v," ",Z[0]):A.push("L",V[0],"A",R,",",R," 0 0,",v," ",Z[0])}else A.push("L",_,",",w)}else A.push("M",m,",",M),null!=x&&A.push("A",c,",",c," 0 ",C,",",p," ",x,",",b),A.push("L",_,",",w),null!=S&&A.push("A",n,",",n," 0 ",L,",",1-p," ",S,",",k);return A.push("Z"),A.join("")}function t(n,t){return"M0,"+n+"A"+n+","+n+" 0 1,"+t+" 0,"+-n+"A"+n+","+n+" 0 1,"+t+" 0,"+n}var e=hu,r=pu,i=su,u=ql,o=gu,a=vu,l=du;return n.innerRadius=function(t){return arguments.length?(e=En(t),n):e},n.outerRadius=function(t){return arguments.length?(r=En(t),n):r},n.cornerRadius=function(t){return arguments.length?(i=En(t),n):i},n.padRadius=function(t){return arguments.length?(u=t==ql?ql:En(t),n):u},n.startAngle=function(t){return arguments.length?(o=En(t),n):o},n.endAngle=function(t){return arguments.length?(a=En(t),n):a},n.padAngle=function(t){return arguments.length?(l=En(t),n):l},n.centroid=function(){var n=(+e.apply(this,arguments)+ +r.apply(this,arguments))/2,t=(+o.apply(this,arguments)+ +a.apply(this,arguments))/2-Io;return[Math.cos(t)*n,Math.sin(t)*n]},n};var ql="auto";ao.svg.line=function(){return Mu(m)};var Tl=ao.map({linear:xu,"linear-closed":bu,step:_u,"step-before":wu,"step-after":Su,basis:zu,"basis-open":Lu,"basis-closed":qu,bundle:Tu,cardinal:Eu,"cardinal-open":ku,"cardinal-closed":Nu,monotone:Fu});Tl.forEach(function(n,t){t.key=n,t.closed=/-closed$/.test(n)});var Rl=[0,2/3,1/3,0],Dl=[0,1/3,2/3,0],Pl=[0,1/6,2/3,1/6];ao.svg.line.radial=function(){var n=Mu(Hu);return n.radius=n.x,delete n.x,n.angle=n.y,delete n.y,n},wu.reverse=Su,Su.reverse=wu,ao.svg.area=function(){return Ou(m)},ao.svg.area.radial=function(){var n=Ou(Hu);return n.radius=n.x,delete n.x,n.innerRadius=n.x0,delete n.x0,n.outerRadius=n.x1,delete n.x1,n.angle=n.y,delete n.y,n.startAngle=n.y0,delete n.y0,n.endAngle=n.y1,delete n.y1,n},ao.svg.chord=function(){function n(n,a){var l=t(this,u,n,a),c=t(this,o,n,a);return"M"+l.p0+r(l.r,l.p1,l.a1-l.a0)+(e(l,c)?i(l.r,l.p1,l.r,l.p0):i(l.r,l.p1,c.r,c.p0)+r(c.r,c.p1,c.a1-c.a0)+i(c.r,c.p1,l.r,l.p0))+"Z"}function t(n,t,e,r){var i=t.call(n,e,r),u=a.call(n,i,r),o=l.call(n,i,r)-Io,f=c.call(n,i,r)-Io;return{r:u,a0:o,a1:f,p0:[u*Math.cos(o),u*Math.sin(o)],p1:[u*Math.cos(f),u*Math.sin(f)]}}function e(n,t){return n.a0==t.a0&&n.a1==t.a1}function r(n,t,e){return"A"+n+","+n+" 0 "+ +(e>Fo)+",1 "+t}function i(n,t,e,r){return"Q 0,0 "+r}var u=Me,o=xe,a=Iu,l=gu,c=vu;return n.radius=function(t){return arguments.length?(a=En(t),n):a},n.source=function(t){return arguments.length?(u=En(t),n):u},n.target=function(t){return arguments.length?(o=En(t),n):o},n.startAngle=function(t){return arguments.length?(l=En(t),n):l},n.endAngle=function(t){return arguments.length?(c=En(t),n):c},n},ao.svg.diagonal=function(){function n(n,i){var u=t.call(this,n,i),o=e.call(this,n,i),a=(u.y+o.y)/2,l=[u,{x:u.x,y:a},{x:o.x,y:a},o];return l=l.map(r),"M"+l[0]+"C"+l[1]+" "+l[2]+" "+l[3]}var t=Me,e=xe,r=Yu;return n.source=function(e){return arguments.length?(t=En(e),n):t},n.target=function(t){return arguments.length?(e=En(t),n):e},n.projection=function(t){return arguments.length?(r=t,n):r},n},ao.svg.diagonal.radial=function(){var n=ao.svg.diagonal(),t=Yu,e=n.projection;return n.projection=function(n){return arguments.length?e(Zu(t=n)):t},n},ao.svg.symbol=function(){function n(n,r){return(Ul.get(t.call(this,n,r))||$u)(e.call(this,n,r))}var t=Xu,e=Vu;return n.type=function(e){return arguments.length?(t=En(e),n):t},n.size=function(t){return arguments.length?(e=En(t),n):e},n};var Ul=ao.map({circle:$u,cross:function(n){var t=Math.sqrt(n/5)/2;return"M"+-3*t+","+-t+"H"+-t+"V"+-3*t+"H"+t+"V"+-t+"H"+3*t+"V"+t+"H"+t+"V"+3*t+"H"+-t+"V"+t+"H"+-3*t+"Z"},diamond:function(n){var t=Math.sqrt(n/(2*Fl)),e=t*Fl;return"M0,"+-t+"L"+e+",0 0,"+t+" "+-e+",0Z"},square:function(n){var t=Math.sqrt(n)/2;return"M"+-t+","+-t+"L"+t+","+-t+" "+t+","+t+" "+-t+","+t+"Z"},"triangle-down":function(n){var t=Math.sqrt(n/jl),e=t*jl/2;return"M0,"+e+"L"+t+","+-e+" "+-t+","+-e+"Z"},"triangle-up":function(n){var t=Math.sqrt(n/jl),e=t*jl/2;return"M0,"+-e+"L"+t+","+e+" "+-t+","+e+"Z"}});ao.svg.symbolTypes=Ul.keys();var jl=Math.sqrt(3),Fl=Math.tan(30*Yo);Co.transition=function(n){for(var t,e,r=Hl||++Zl,i=Ku(n),u=[],o=Ol||{time:Date.now(),ease:Nr,delay:0,duration:250},a=-1,l=this.length;++a<l;){u.push(t=[]);for(var c=this[a],f=-1,s=c.length;++f<s;)(e=c[f])&&Qu(e,f,i,r,o),t.push(e)}return Wu(u,i,r)},Co.interrupt=function(n){return this.each(null==n?Il:Bu(Ku(n)))};var Hl,Ol,Il=Bu(Ku()),Yl=[],Zl=0;Yl.call=Co.call,Yl.empty=Co.empty,Yl.node=Co.node,Yl.size=Co.size,ao.transition=function(n,t){return n&&n.transition?Hl?n.transition(t):n:ao.selection().transition(n)},ao.transition.prototype=Yl,Yl.select=function(n){var t,e,r,i=this.id,u=this.namespace,o=[];n=A(n);for(var a=-1,l=this.length;++a<l;){o.push(t=[]);for(var c=this[a],f=-1,s=c.length;++f<s;)(r=c[f])&&(e=n.call(r,r.__data__,f,a))?("__data__"in r&&(e.__data__=r.__data__),Qu(e,f,u,i,r[u][i]),t.push(e)):t.push(null)}return Wu(o,u,i)},Yl.selectAll=function(n){var t,e,r,i,u,o=this.id,a=this.namespace,l=[];n=C(n);for(var c=-1,f=this.length;++c<f;)for(var s=this[c],h=-1,p=s.length;++h<p;)if(r=s[h]){u=r[a][o],e=n.call(r,r.__data__,h,c),l.push(t=[]);for(var g=-1,v=e.length;++g<v;)(i=e[g])&&Qu(i,g,a,o,u),t.push(i)}return Wu(l,a,o)},Yl.filter=function(n){var t,e,r,i=[];"function"!=typeof n&&(n=O(n));for(var u=0,o=this.length;o>u;u++){i.push(t=[]);for(var e=this[u],a=0,l=e.length;l>a;a++)(r=e[a])&&n.call(r,r.__data__,a,u)&&t.push(r)}return Wu(i,this.namespace,this.id)},Yl.tween=function(n,t){var e=this.id,r=this.namespace;return arguments.length<2?this.node()[r][e].tween.get(n):Y(this,null==t?function(t){t[r][e].tween.remove(n)}:function(i){i[r][e].tween.set(n,t)})},Yl.attr=function(n,t){function e(){this.removeAttribute(a)}function r(){this.removeAttributeNS(a.space,a.local)}function i(n){return null==n?e:(n+="",function(){var t,e=this.getAttribute(a);return e!==n&&(t=o(e,n),function(n){this.setAttribute(a,t(n))})})}function u(n){return null==n?r:(n+="",function(){var t,e=this.getAttributeNS(a.space,a.local);return e!==n&&(t=o(e,n),function(n){this.setAttributeNS(a.space,a.local,t(n))})})}if(arguments.length<2){for(t in n)this.attr(t,n[t]);return this}var o="transform"==n?$r:Mr,a=ao.ns.qualify(n);return Ju(this,"attr."+n,t,a.local?u:i)},Yl.attrTween=function(n,t){function e(n,e){var r=t.call(this,n,e,this.getAttribute(i));return r&&function(n){this.setAttribute(i,r(n))}}function r(n,e){var r=t.call(this,n,e,this.getAttributeNS(i.space,i.local));return r&&function(n){this.setAttributeNS(i.space,i.local,r(n))}}var i=ao.ns.qualify(n);return this.tween("attr."+n,i.local?r:e)},Yl.style=function(n,e,r){function i(){this.style.removeProperty(n)}function u(e){return null==e?i:(e+="",function(){var i,u=t(this).getComputedStyle(this,null).getPropertyValue(n);return u!==e&&(i=Mr(u,e),function(t){this.style.setProperty(n,i(t),r)})})}var o=arguments.length;if(3>o){if("string"!=typeof n){2>o&&(e="");for(r in n)this.style(r,n[r],e);return this}r=""}return Ju(this,"style."+n,e,u)},Yl.styleTween=function(n,e,r){function i(i,u){var o=e.call(this,i,u,t(this).getComputedStyle(this,null).getPropertyValue(n));return o&&function(t){this.style.setProperty(n,o(t),r)}}return arguments.length<3&&(r=""),this.tween("style."+n,i)},Yl.text=function(n){return Ju(this,"text",n,Gu)},Yl.remove=function(){var n=this.namespace;return this.each("end.transition",function(){var t;this[n].count<2&&(t=this.parentNode)&&t.removeChild(this)})},Yl.ease=function(n){var t=this.id,e=this.namespace;return arguments.length<1?this.node()[e][t].ease:("function"!=typeof n&&(n=ao.ease.apply(ao,arguments)),Y(this,function(r){r[e][t].ease=n}))},Yl.delay=function(n){var t=this.id,e=this.namespace;return arguments.length<1?this.node()[e][t].delay:Y(this,"function"==typeof n?function(r,i,u){r[e][t].delay=+n.call(r,r.__data__,i,u)}:(n=+n,function(r){r[e][t].delay=n}))},Yl.duration=function(n){var t=this.id,e=this.namespace;return arguments.length<1?this.node()[e][t].duration:Y(this,"function"==typeof n?function(r,i,u){r[e][t].duration=Math.max(1,n.call(r,r.__data__,i,u))}:(n=Math.max(1,n),function(r){r[e][t].duration=n}))},Yl.each=function(n,t){var e=this.id,r=this.namespace;if(arguments.length<2){var i=Ol,u=Hl;try{Hl=e,Y(this,function(t,i,u){Ol=t[r][e],n.call(t,t.__data__,i,u)})}finally{Ol=i,Hl=u}}else Y(this,function(i){var u=i[r][e];(u.event||(u.event=ao.dispatch("start","end","interrupt"))).on(n,t)});return this},Yl.transition=function(){for(var n,t,e,r,i=this.id,u=++Zl,o=this.namespace,a=[],l=0,c=this.length;c>l;l++){a.push(n=[]);for(var t=this[l],f=0,s=t.length;s>f;f++)(e=t[f])&&(r=e[o][i],Qu(e,f,o,u,{time:r.time,ease:r.ease,delay:r.delay+r.duration,duration:r.duration})),n.push(e)}return Wu(a,o,u)},ao.svg.axis=function(){function n(n){n.each(function(){var n,c=ao.select(this),f=this.__chart__||e,s=this.__chart__=e.copy(),h=null==l?s.ticks?s.ticks.apply(s,a):s.domain():l,p=null==t?s.tickFormat?s.tickFormat.apply(s,a):m:t,g=c.selectAll(".tick").data(h,s),v=g.enter().insert("g",".domain").attr("class","tick").style("opacity",Uo),d=ao.transition(g.exit()).style("opacity",Uo).remove(),y=ao.transition(g.order()).style("opacity",1),M=Math.max(i,0)+o,x=Zi(s),b=c.selectAll(".domain").data([0]),_=(b.enter().append("path").attr("class","domain"),ao.transition(b));v.append("line"),v.append("text");var w,S,k,N,E=v.select("line"),A=y.select("line"),C=g.select("text").text(p),z=v.select("text"),L=y.select("text"),q="top"===r||"left"===r?-1:1;if("bottom"===r||"top"===r?(n=no,w="x",k="y",S="x2",N="y2",C.attr("dy",0>q?"0em":".71em").style("text-anchor","middle"),_.attr("d","M"+x[0]+","+q*u+"V0H"+x[1]+"V"+q*u)):(n=to,w="y",k="x",S="y2",N="x2",C.attr("dy",".32em").style("text-anchor",0>q?"end":"start"),_.attr("d","M"+q*u+","+x[0]+"H0V"+x[1]+"H"+q*u)),E.attr(N,q*i),z.attr(k,q*M),A.attr(S,0).attr(N,q*i),L.attr(w,0).attr(k,q*M),s.rangeBand){var T=s,R=T.rangeBand()/2;f=s=function(n){return T(n)+R}}else f.rangeBand?f=s:d.call(n,s,f);v.call(n,f,s),y.call(n,s,s)})}var t,e=ao.scale.linear(),r=Vl,i=6,u=6,o=3,a=[10],l=null;return n.scale=function(t){return arguments.length?(e=t,n):e},n.orient=function(t){return arguments.length?(r=t in Xl?t+"":Vl,n):r},n.ticks=function(){return arguments.length?(a=co(arguments),n):a},n.tickValues=function(t){return arguments.length?(l=t,n):l},n.tickFormat=function(e){return arguments.length?(t=e,n):t},n.tickSize=function(t){var e=arguments.length;return e?(i=+t,u=+arguments[e-1],n):i},n.innerTickSize=function(t){return arguments.length?(i=+t,n):i},n.outerTickSize=function(t){return arguments.length?(u=+t,n):u},n.tickPadding=function(t){return arguments.length?(o=+t,n):o},n.tickSubdivide=function(){return arguments.length&&n},n};var Vl="bottom",Xl={top:1,right:1,bottom:1,left:1};ao.svg.brush=function(){function n(t){t.each(function(){var t=ao.select(this).style("pointer-events","all").style("-webkit-tap-highlight-color","rgba(0,0,0,0)").on("mousedown.brush",u).on("touchstart.brush",u),o=t.selectAll(".background").data([0]);o.enter().append("rect").attr("class","background").style("visibility","hidden").style("cursor","crosshair"),t.selectAll(".extent").data([0]).enter().append("rect").attr("class","extent").style("cursor","move");var a=t.selectAll(".resize").data(v,m);a.exit().remove(),a.enter().append("g").attr("class",function(n){return"resize "+n}).style("cursor",function(n){return $l[n]}).append("rect").attr("x",function(n){return/[ew]$/.test(n)?-3:null}).attr("y",function(n){return/^[ns]/.test(n)?-3:null}).attr("width",6).attr("height",6).style("visibility","hidden"),a.style("display",n.empty()?"none":null);var l,s=ao.transition(t),h=ao.transition(o);c&&(l=Zi(c),h.attr("x",l[0]).attr("width",l[1]-l[0]),r(s)),f&&(l=Zi(f),h.attr("y",l[0]).attr("height",l[1]-l[0]),i(s)),e(s)})}function e(n){n.selectAll(".resize").attr("transform",function(n){return"translate("+s[+/e$/.test(n)]+","+h[+/^s/.test(n)]+")"})}function r(n){n.select(".extent").attr("x",s[0]),n.selectAll(".extent,.n>rect,.s>rect").attr("width",s[1]-s[0])}function i(n){n.select(".extent").attr("y",h[0]),n.selectAll(".extent,.e>rect,.w>rect").attr("height",h[1]-h[0])}function u(){function u(){32==ao.event.keyCode&&(C||(M=null,L[0]-=s[1],L[1]-=h[1],C=2),S())}function v(){32==ao.event.keyCode&&2==C&&(L[0]+=s[1],L[1]+=h[1],C=0,S())}function d(){var n=ao.mouse(b),t=!1;x&&(n[0]+=x[0],n[1]+=x[1]),C||(ao.event.altKey?(M||(M=[(s[0]+s[1])/2,(h[0]+h[1])/2]),L[0]=s[+(n[0]<M[0])],L[1]=h[+(n[1]<M[1])]):M=null),E&&y(n,c,0)&&(r(k),t=!0),A&&y(n,f,1)&&(i(k),t=!0),t&&(e(k),w({type:"brush",mode:C?"move":"resize"}))}function y(n,t,e){var r,i,u=Zi(t),l=u[0],c=u[1],f=L[e],v=e?h:s,d=v[1]-v[0];return C&&(l-=f,c-=d+f),r=(e?g:p)?Math.max(l,Math.min(c,n[e])):n[e],C?i=(r+=f)+d:(M&&(f=Math.max(l,Math.min(c,2*M[e]-r))),r>f?(i=r,r=f):i=f),v[0]!=r||v[1]!=i?(e?a=null:o=null,v[0]=r,v[1]=i,!0):void 0}function m(){d(),k.style("pointer-events","all").selectAll(".resize").style("display",n.empty()?"none":null),ao.select("body").style("cursor",null),q.on("mousemove.brush",null).on("mouseup.brush",null).on("touchmove.brush",null).on("touchend.brush",null).on("keydown.brush",null).on("keyup.brush",null),z(),w({type:"brushend"})}var M,x,b=this,_=ao.select(ao.event.target),w=l.of(b,arguments),k=ao.select(b),N=_.datum(),E=!/^(n|s)$/.test(N)&&c,A=!/^(e|w)$/.test(N)&&f,C=_.classed("extent"),z=W(b),L=ao.mouse(b),q=ao.select(t(b)).on("keydown.brush",u).on("keyup.brush",v);if(ao.event.changedTouches?q.on("touchmove.brush",d).on("touchend.brush",m):q.on("mousemove.brush",d).on("mouseup.brush",m),k.interrupt().selectAll("*").interrupt(),C)L[0]=s[0]-L[0],L[1]=h[0]-L[1];else if(N){var T=+/w$/.test(N),R=+/^n/.test(N);x=[s[1-T]-L[0],h[1-R]-L[1]],L[0]=s[T],L[1]=h[R]}else ao.event.altKey&&(M=L.slice());k.style("pointer-events","none").selectAll(".resize").style("display",null),ao.select("body").style("cursor",_.style("cursor")),w({type:"brushstart"}),d()}var o,a,l=N(n,"brushstart","brush","brushend"),c=null,f=null,s=[0,0],h=[0,0],p=!0,g=!0,v=Bl[0];return n.event=function(n){n.each(function(){var n=l.of(this,arguments),t={x:s,y:h,i:o,j:a},e=this.__chart__||t;this.__chart__=t,Hl?ao.select(this).transition().each("start.brush",function(){o=e.i,a=e.j,s=e.x,h=e.y,n({type:"brushstart"})}).tween("brush:brush",function(){var e=xr(s,t.x),r=xr(h,t.y);return o=a=null,function(i){s=t.x=e(i),h=t.y=r(i),n({type:"brush",mode:"resize"})}}).each("end.brush",function(){o=t.i,a=t.j,n({type:"brush",mode:"resize"}),n({type:"brushend"})}):(n({type:"brushstart"}),n({type:"brush",mode:"resize"}),n({type:"brushend"}))})},n.x=function(t){return arguments.length?(c=t,v=Bl[!c<<1|!f],n):c},n.y=function(t){return arguments.length?(f=t,v=Bl[!c<<1|!f],n):f},n.clamp=function(t){return arguments.length?(c&&f?(p=!!t[0],g=!!t[1]):c?p=!!t:f&&(g=!!t),n):c&&f?[p,g]:c?p:f?g:null},n.extent=function(t){var e,r,i,u,l;return arguments.length?(c&&(e=t[0],r=t[1],f&&(e=e[0],r=r[0]),o=[e,r],c.invert&&(e=c(e),r=c(r)),e>r&&(l=e,e=r,r=l),e==s[0]&&r==s[1]||(s=[e,r])),f&&(i=t[0],u=t[1],c&&(i=i[1],u=u[1]),a=[i,u],f.invert&&(i=f(i),u=f(u)),i>u&&(l=i,i=u,u=l),i==h[0]&&u==h[1]||(h=[i,u])),n):(c&&(o?(e=o[0],r=o[1]):(e=s[0],r=s[1],c.invert&&(e=c.invert(e),r=c.invert(r)),e>r&&(l=e,e=r,r=l))),f&&(a?(i=a[0],u=a[1]):(i=h[0],u=h[1],f.invert&&(i=f.invert(i),u=f.invert(u)),i>u&&(l=i,i=u,u=l))),c&&f?[[e,i],[r,u]]:c?[e,r]:f&&[i,u])},n.clear=function(){return n.empty()||(s=[0,0],h=[0,0],o=a=null),n},n.empty=function(){return!!c&&s[0]==s[1]||!!f&&h[0]==h[1]},ao.rebind(n,l,"on")};var $l={n:"ns-resize",e:"ew-resize",s:"ns-resize",w:"ew-resize",nw:"nwse-resize",ne:"nesw-resize",se:"nwse-resize",sw:"nesw-resize"},Bl=[["n","e","s","w","nw","ne","se","sw"],["e","w"],["n","s"],[]],Wl=ga.format=xa.timeFormat,Jl=Wl.utc,Gl=Jl("%Y-%m-%dT%H:%M:%S.%LZ");Wl.iso=Date.prototype.toISOString&&+new Date("2000-01-01T00:00:00.000Z")?eo:Gl,eo.parse=function(n){var t=new Date(n);return isNaN(t)?null:t},eo.toString=Gl.toString,ga.second=On(function(n){return new va(1e3*Math.floor(n/1e3))},function(n,t){n.setTime(n.getTime()+1e3*Math.floor(t))},function(n){return n.getSeconds()}),ga.seconds=ga.second.range,ga.seconds.utc=ga.second.utc.range,ga.minute=On(function(n){return new va(6e4*Math.floor(n/6e4))},function(n,t){n.setTime(n.getTime()+6e4*Math.floor(t))},function(n){return n.getMinutes()}),ga.minutes=ga.minute.range,ga.minutes.utc=ga.minute.utc.range,ga.hour=On(function(n){var t=n.getTimezoneOffset()/60;return new va(36e5*(Math.floor(n/36e5-t)+t))},function(n,t){n.setTime(n.getTime()+36e5*Math.floor(t))},function(n){return n.getHours()}),ga.hours=ga.hour.range,ga.hours.utc=ga.hour.utc.range,ga.month=On(function(n){return n=ga.day(n),n.setDate(1),n},function(n,t){n.setMonth(n.getMonth()+t)},function(n){return n.getMonth()}),ga.months=ga.month.range,ga.months.utc=ga.month.utc.range;var Kl=[1e3,5e3,15e3,3e4,6e4,3e5,9e5,18e5,36e5,108e5,216e5,432e5,864e5,1728e5,6048e5,2592e6,7776e6,31536e6],Ql=[[ga.second,1],[ga.second,5],[ga.second,15],[ga.second,30],[ga.minute,1],[ga.minute,5],[ga.minute,15],[ga.minute,30],[ga.hour,1],[ga.hour,3],[ga.hour,6],[ga.hour,12],[ga.day,1],[ga.day,2],[ga.week,1],[ga.month,1],[ga.month,3],[ga.year,1]],nc=Wl.multi([[".%L",function(n){return n.getMilliseconds()}],[":%S",function(n){return n.getSeconds()}],["%I:%M",function(n){return n.getMinutes()}],["%I %p",function(n){return n.getHours()}],["%a %d",function(n){return n.getDay()&&1!=n.getDate()}],["%b %d",function(n){return 1!=n.getDate()}],["%B",function(n){return n.getMonth()}],["%Y",zt]]),tc={range:function(n,t,e){return ao.range(Math.ceil(n/e)*e,+t,e).map(io)},floor:m,ceil:m};Ql.year=ga.year,ga.scale=function(){return ro(ao.scale.linear(),Ql,nc)};var ec=Ql.map(function(n){return[n[0].utc,n[1]]}),rc=Jl.multi([[".%L",function(n){return n.getUTCMilliseconds()}],[":%S",function(n){return n.getUTCSeconds()}],["%I:%M",function(n){return n.getUTCMinutes()}],["%I %p",function(n){return n.getUTCHours()}],["%a %d",function(n){return n.getUTCDay()&&1!=n.getUTCDate()}],["%b %d",function(n){return 1!=n.getUTCDate()}],["%B",function(n){return n.getUTCMonth()}],["%Y",zt]]);ec.year=ga.year.utc,ga.scale.utc=function(){return ro(ao.scale.linear(),ec,rc)},ao.text=An(function(n){return n.responseText}),ao.json=function(n,t){return Cn(n,"application/json",uo,t)},ao.html=function(n,t){return Cn(n,"text/html",oo,t)},ao.xml=An(function(n){return n.responseXML}),"function"==typeof define&&define.amd?(this.d3=ao,define(ao)):"object"==typeof module&&module.exports?module.exports=ao:this.d3=ao}();</script>
<script>// randomColor by David Merfield under the MIT license
// https://github.com/davidmerfield/randomColor/
;(function(root, factory) {

  // Support AMD
  if (typeof define === 'function' && define.amd) {
    define([], factory);

  // Support CommonJS
  } else if (typeof exports === 'object') {
    var randomColor = factory();

    // Support NodeJS & Component, which allow module.exports to be a function
    if (typeof module === 'object' && module && module.exports) {
      exports = module.exports = randomColor;
    }

    // Support CommonJS 1.1.1 spec
    exports.randomColor = randomColor;

  // Support vanilla script loading
  } else {
    root.randomColor = factory();
  }

}(this, function() {

  // Seed to get repeatable colors
  var seed = null;

  // Shared color dictionary
  var colorDictionary = {};

  // Populate the color dictionary
  loadColorBounds();

  var randomColor = function (options) {

    options = options || {};

    if (options.seed && !seed) {
      seed = options.seed;
    }

    var H,S,B;

    // Check if we need to generate multiple colors
    if (options.count !== null && options.count !== undefined) {

      var totalColors = options.count,
          colors = [];

      options.count = null;

      while (totalColors > colors.length) {
        colors.push(randomColor(options));
      }

      options.count = totalColors;

      //Keep the seed constant between runs.
      if (options.seed && totalColors !== colors.length) {
        seed = options.seed;
      } else {
        seed = null;
      }

      return colors;
    }

    // First we pick a hue (H)
    H = pickHue(options);

    // Then use H to determine saturation (S)
    S = pickSaturation(H, options);

    // Then use S and H to determine brightness (B).
    B = pickBrightness(H, S, options);

    // Then we return the HSB color in the desired format
    return setFormat([H,S,B], options);
  };

  function pickHue (options) {

    var hueRange = getHueRange(options.hue),
        hue = randomWithin(hueRange);

    // Instead of storing red as two seperate ranges,
    // we group them, using negative numbers
    if (hue < 0) {hue = 360 + hue;}

    return hue;

  }

  function pickSaturation (hue, options) {

    if (options.luminosity === 'random') {
      return randomWithin([0,100]);
    }

    if (options.hue === 'monochrome') {
      return 0;
    }

    var saturationRange = getSaturationRange(hue);

    var sMin = saturationRange[0],
        sMax = saturationRange[1];

    switch (options.luminosity) {

      case 'bright':
        sMin = 55;
        break;

      case 'dark':
        sMin = sMax - 10;
        break;

      case 'light':
        sMax = 55;
        break;
   }

    return randomWithin([sMin, sMax]);

  }

  function pickBrightness (H, S, options) {

    var bMin = getMinimumBrightness(H, S),
        bMax = 100;

    switch (options.luminosity) {

      case 'dark':
        bMax = bMin + 20;
        break;

      case 'light':
        bMin = (bMax + bMin)/2;
        break;

      case 'random':
        bMin = 0;
        bMax = 100;
        break;
    }

    return randomWithin([bMin, bMax]);
  }

  function setFormat (hsv, options) {

    switch (options.format) {

      case 'hsvArray':
        return hsv;

      case 'hslArray':
        return HSVtoHSL(hsv);

      case 'hsl':
        var hsl = HSVtoHSL(hsv);
        return 'hsl('+hsl[0]+', '+hsl[1]+'%, '+hsl[2]+'%)';

      case 'hsla':
        var hslColor = HSVtoHSL(hsv);
        return 'hsla('+hslColor[0]+', '+hslColor[1]+'%, '+hslColor[2]+'%, ' + Math.random() + ')';

      case 'rgbArray':
        return HSVtoRGB(hsv);

      case 'rgb':
        var rgb = HSVtoRGB(hsv);
        return 'rgb(' + rgb.join(', ') + ')';

      case 'rgba':
        var rgbColor = HSVtoRGB(hsv);
        return 'rgba(' + rgbColor.join(', ') + ', ' + Math.random() + ')';

      default:
        return HSVtoHex(hsv);
    }

  }

  function getMinimumBrightness(H, S) {

    var lowerBounds = getColorInfo(H).lowerBounds;

    for (var i = 0; i < lowerBounds.length - 1; i++) {

      var s1 = lowerBounds[i][0],
          v1 = lowerBounds[i][1];

      var s2 = lowerBounds[i+1][0],
          v2 = lowerBounds[i+1][1];

      if (S >= s1 && S <= s2) {

         var m = (v2 - v1)/(s2 - s1),
             b = v1 - m*s1;

         return m*S + b;
      }

    }

    return 0;
  }

  function getHueRange (colorInput) {

    if (typeof parseInt(colorInput) === 'number') {

      var number = parseInt(colorInput);

      if (number < 360 && number > 0) {
        return [number, number];
      }

    }

    if (typeof colorInput === 'string') {

      if (colorDictionary[colorInput]) {
        var color = colorDictionary[colorInput];
        if (color.hueRange) {return color.hueRange;}
      }
    }

    return [0,360];

  }

  function getSaturationRange (hue) {
    return getColorInfo(hue).saturationRange;
  }

  function getColorInfo (hue) {

    // Maps red colors to make picking hue easier
    if (hue >= 334 && hue <= 360) {
      hue-= 360;
    }

    for (var colorName in colorDictionary) {
       var color = colorDictionary[colorName];
       if (color.hueRange &&
           hue >= color.hueRange[0] &&
           hue <= color.hueRange[1]) {
          return colorDictionary[colorName];
       }
    } return 'Color not found';
  }

  function randomWithin (range) {
    if (seed === null) {
      return Math.floor(range[0] + Math.random()*(range[1] + 1 - range[0]));
    } else {
      //Seeded random algorithm from http://indiegamr.com/generate-repeatable-random-numbers-in-js/
      var max = range[1] || 1;
      var min = range[0] || 0;
      seed = (seed * 9301 + 49297) % 233280;
      var rnd = seed / 233280.0;
      return Math.floor(min + rnd * (max - min));
    }
  }

  function HSVtoHex (hsv){

    var rgb = HSVtoRGB(hsv);

    function componentToHex(c) {
        var hex = c.toString(16);
        return hex.length == 1 ? '0' + hex : hex;
    }

    var hex = '#' + componentToHex(rgb[0]) + componentToHex(rgb[1]) + componentToHex(rgb[2]);

    return hex;

  }

  function defineColor (name, hueRange, lowerBounds) {

    var sMin = lowerBounds[0][0],
        sMax = lowerBounds[lowerBounds.length - 1][0],

        bMin = lowerBounds[lowerBounds.length - 1][1],
        bMax = lowerBounds[0][1];

    colorDictionary[name] = {
      hueRange: hueRange,
      lowerBounds: lowerBounds,
      saturationRange: [sMin, sMax],
      brightnessRange: [bMin, bMax]
    };

  }

  function loadColorBounds () {

    defineColor(
      'monochrome',
      null,
      [[0,0],[100,0]]
    );

    defineColor(
      'red',
      [-26,18],
      [[20,100],[30,92],[40,89],[50,85],[60,78],[70,70],[80,60],[90,55],[100,50]]
    );

    defineColor(
      'orange',
      [19,46],
      [[20,100],[30,93],[40,88],[50,86],[60,85],[70,70],[100,70]]
    );

    defineColor(
      'yellow',
      [47,62],
      [[25,100],[40,94],[50,89],[60,86],[70,84],[80,82],[90,80],[100,75]]
    );

    defineColor(
      'green',
      [63,178],
      [[30,100],[40,90],[50,85],[60,81],[70,74],[80,64],[90,50],[100,40]]
    );

    defineColor(
      'blue',
      [179, 257],
      [[20,100],[30,86],[40,80],[50,74],[60,60],[70,52],[80,44],[90,39],[100,35]]
    );

    defineColor(
      'purple',
      [258, 282],
      [[20,100],[30,87],[40,79],[50,70],[60,65],[70,59],[80,52],[90,45],[100,42]]
    );

    defineColor(
      'pink',
      [283, 334],
      [[20,100],[30,90],[40,86],[60,84],[80,80],[90,75],[100,73]]
    );

  }

  function HSVtoRGB (hsv) {

    // this doesn't work for the values of 0 and 360
    // here's the hacky fix
    var h = hsv[0];
    if (h === 0) {h = 1;}
    if (h === 360) {h = 359;}

    // Rebase the h,s,v values
    h = h/360;
    var s = hsv[1]/100,
        v = hsv[2]/100;

    var h_i = Math.floor(h*6),
      f = h * 6 - h_i,
      p = v * (1 - s),
      q = v * (1 - f*s),
      t = v * (1 - (1 - f)*s),
      r = 256,
      g = 256,
      b = 256;

    switch(h_i) {
      case 0: r = v; g = t; b = p;  break;
      case 1: r = q; g = v; b = p;  break;
      case 2: r = p; g = v; b = t;  break;
      case 3: r = p; g = q; b = v;  break;
      case 4: r = t; g = p; b = v;  break;
      case 5: r = v; g = p; b = q;  break;
    }

    var result = [Math.floor(r*255), Math.floor(g*255), Math.floor(b*255)];
    return result;
  }

  function HSVtoHSL (hsv) {
    var h = hsv[0],
      s = hsv[1]/100,
      v = hsv[2]/100,
      k = (2-s)*v;

    return [
      h,
      Math.round(s*v / (k<1 ? k : 2-k) * 10000) / 100,
      k/2 * 100
    ];
  }

  return randomColor;
}));</script>

<dom-module id="nuxeo-document-distribution-chart" assetpath="bower_components/nuxeo-ui-elements/dataviz/">
  <template>

    <style>
      :host {
        color: var(--nuxeo-text-default, #000);
      }

      #du {
        font-size: 1rem;
        font-weight: 400;
        width: 100%;
        height: 700px;
        margin-top: 10px;
      }

      #main {
        float: left;
        width: 70%;
      }

      #sb {
        float: right;
        width: 30%;
      }

      #sequence {
        width: 100%;
        height: 70px;
      }

      #chart {
        position: relative;
      }

      #chart path {
        stroke: #fff;
      }

      #ex {
        position: absolute;
        top: 260px;
        left: 305px;
        width: 140px;
        text-align: center;
        z-index: 10;
      }

      #cl {
        font-size: 2rem;
      }

      :host([loading]) .loadable {
        opacity: 0.25;
      }

      :host([loading]) paper-spinner-lite {
        position: absolute;
        top: 45%;
        left: 50%;
        --paper-spinner-color: var(--default-primary-color);
      }

    </style>

    <nuxeo-connection id="nx" connection-id="[[connectionId]]"></nuxeo-connection>

    <div id="du">
      <div id="main" class="loadable">
        <div id="sequence"></div>
        <div id="chart">
          <div id="ex" style="visibility: hidden">
            <span id="cl"></span><br>
            <span id="clb"></span>
          </div>
        </div>
      </div>
      <div id="sb" class="loadable">
        <paper-radio-group selected="{{mode}}" on-paper-radio-group-changed="execute">
          <paper-radio-button noink="" name="size">[[i18n('documentDistributionChart.size')]]</paper-radio-button>
          <paper-radio-button noink="" name="count">[[i18n('documentDistributionChart.count')]]</paper-radio-button>
        </paper-radio-group>
        <p>
        <paper-checkbox noink="" on-change="execute" checked="{{includeHidden}}">[[i18n('documentDistributionChart.includeHidden')]]</paper-checkbox>
        </p><p>
        <paper-checkbox noink="" on-change="execute" checked="{{includeDeleted}}">[[i18n('documentDistributionChart.includeDeleted')]]</paper-checkbox>
        </p><p>
        <paper-checkbox noink="" on-change="execute" checked="{{includeVersion}}">[[i18n('documentDistributionChart.includeVersions')]]</paper-checkbox>
        </p><p>
        <paper-checkbox noink="" on-change="execute" checked="{{onlyFolder}}" disabled="[[_chechFolderDisabled(mode)]]">[[i18n('documentDistributionChart.foldersOnly')]]</paper-checkbox>
        </p><p>
      </p></div>

      <paper-spinner-lite active$="[[loading]]"></paper-spinner-lite>

    </div>

  </template>

  <script>
    {
      let vis;
      let radius;
      let partition;
      let arc;

      // Breadcrumb dimensions: width, height, spacing, width of tip/tail.
      const b = {
        w: 100, h: 30, s: 3, t: 10,
      };

      const colors = {};

      /**
       * A sunburst chart presenting Nuxeo Document Distribution.
       *
       * Example:
       *
       *     <nuxeo-document-distribution-chart index="nuxeo"
       *       path="/default-domain" mode="count" max-depth="7"
       *       chart-hue="red" chart-lumonisity="light"
       *       include-version include-hidden"
       *       include-deleted only-folder">
       *     </nuxeo-document-distribution-chart>
       *
       * @appliesMixin Nuxeo.I18nBehavior
       * @memberof Nuxeo
       * @demo demo/nuxeo-document-distribution-chart/index.html
       */
      class DocumentDistributionChart extends Polymer.mixinBehaviors([Nuxeo.I18nBehavior], Nuxeo.Element) {

        static get is() {
          return 'nuxeo-document-distribution-chart';
        }

        static get properties() {
          return {
            /**
             * The id of a nuxeo-connection to use.
             */
            connectionId: {
              type: String,
              value: 'nx',
            },

            /**
             * The name of the index.
             */
            index: {
              type: String,
              value: 'nuxeo',
            },

            /**
             * Path of the document to scan. For instance '/default-domain/workspaces'.
             * Leave blank to scan the full repository.
             */
            path: {
              type: String,
              value: '',
            },

            /**
             * Possible values are 'size' for Document size or 'count' for Document count.
             */
            mode: {
              type: String,
              value: 'size',
              observer: '_observeMode',
            },

            /**
             * Maximum depth to scan in the hierarchy.
             */
            maxDepth: {
              type: Number,
              value: 10,
            },

            /**
             * Possible values are 'red', 'orange', 'yellow', 'green', 'blue', 'purple', 'pink' and 'monochrome'.
             */
            chartLuminosity: {
              type: String,
              value: 'light',
            },

            /**
             * Possible values are 'bright', 'light' or 'dark'.
             */
            chartHue: {
              type: String,
              value: 'blue',
            },

            /**
             * Chart width.
             */
            width: {
              type: Number,
              value: 750,
            },

            /**
             * Chart height.
             */
            height: {
              type: Number,
              value: 600,
            },

            /**
             * To take into account hidden Documents (i.e. Documents with HiddenInNavigation facet).
             */
            includeHidden: {
              type: Boolean,
              value: false,
            },

            /**
             * To take into account Versions in the size/count computation.
             *
             * LIMITATION: the size of Versions are not properly taken into account in the final result.
             */
            includeVersion: {
              type: Boolean,
              value: false,
            },

            /**
             * To take into account trashed Documents.
             */
            includeDeleted: {
              type: Boolean,
              value: true,
            },

            /**
             * To take into account folder Documents (i.e. Documents with Folderish facet).
             */
            onlyFolder: {
              type: Boolean,
              value: false,
            },

            _chartData: {
              type: Object,
            },

            loading: {
              type: Boolean,
              notify: true,
              reflectToAttribute: true,
              value: false,
            },

            /**
             * Maximum number of documents returned per hierarchy level.
             */
            maxDocSize: {
              type: Number,
              value: 1000,
            },
          };
        }

        ready() {
          super.ready();
          this.execute();
        }

        _chechFolderDisabled(mode) {
          return mode === 'size';
        }

        _observeMode() {
          if (this.mode === 'size') {
            this.onlyFolder = false;
          }
        }

        _computeSizeQuery() {
          const pathDepth = this.path.replace(/\/$/, '').split('/').length;

          let subPart = {
            size: {
              sum: {
                field: 'file:content.length',
              },
            },
          };
          for (let depth = (pathDepth - 1) + this.maxDepth; depth > pathDepth; depth--) {
            subPart = {
              size: {
                sum: {
                  field: 'file:content.length',
                },
              },
              subLevel: {
                terms: {
                  field: `ecm:path@level${depth}`,
                  size: this.maxDocSize,
                },
                aggs: subPart,
              },
            };
          }
          const query = {
            query: {
              bool: {
                must: {
                  match_all: {},
                },
                must_not: this._computeMustNot(),
                filter: this._computeFilter(),
              },
            },
            size: 0,
            aggs: {
              subLevel: {
                terms: {
                  field: `ecm:path@level${pathDepth}`,
                  size: this.maxDocSize,
                },
                aggs: subPart,
              },
            },
          };
          return query;
        }

        _computeDocCountQuery() {
          const pathDepth = this.path.replace(/\/$/, '').split('/').length;

          let subPart = {
            subLevel: {
              terms: {
                field: `ecm:path@level${(pathDepth - 1) + this.maxDepth}`,
                size: this.maxDocSize,
                order: {
                  _count: 'desc',
                },
              },
            },
          };

          for (let depth = (pathDepth - 2) + this.maxDepth; depth >= pathDepth; depth--) {
            subPart = {
              subLevel: {
                terms: {
                  field: `ecm:path@level${depth}`,
                  size: this.maxDocSize,
                  order: {
                    _count: 'desc',
                  },
                },
                aggs: subPart,
              },
            };
          }
          const query = {
            query: {
              bool: {
                must: {
                  match_all: {},
                },
                must_not: this._computeMustNot(),
                filter: this._computeFilter(),
              },
            },
            size: 0,
            aggs: subPart,
          };
          return query;
        }

        _computeMustNot() {
          const result = [];
          if (!this.includeHidden) {
            result.push({
              term: {
                'ecm:mixinType': 'HiddenInNavigation',
              },
            });
          }
          if (!this.includeDeleted) {
            result.push({
              term: {
                'ecm:isTrashed': true,
              },
            });
          }
          return result;
        }

        _computeFilter() {
          const result = [];
          if (this.onlyFolder && this.mode !== 'size') {
            result.push({
              term: {
                'ecm:mixinType': 'Folderish',
              },
            });
          }
          if (!this.includeVersion) {
            result.push({
              term: {
                'ecm:isVersion': false,
              },
            });
          }
          if (this.path && this.path.length > 0) {
            const split = this.path.replace(/\/$/, '').split('/');
            for (let i = 1; i < split.length; i++) {
              const toPush = {
                term: {},
              };
              toPush.term[`ecm:path@level${i}`] = split[i];
              result.push(toPush);
            }
          }
          return result;
        }

        execute() {
          this.loading = true;
          let query;
          if (this.mode === 'size') {
            query = this._computeSizeQuery();
          } else if (this.mode === 'count') {
            query = this._computeDocCountQuery();
          } else {
            alert('Mode must be either size or docCount');
            return;
          }
          let url = [this.$.nx.client._baseURL, 'site/es', this.index, 'doc', '_search'].join('/');
          url = url.replace(/(^\/+)|([^:])\/\/+/g, '$2/');

          const options = {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: query,
            url,
          };
          return this.$.nx.request().then((request) => request
            .execute(options)
            .then(this._handleResponse.bind(this))
            .catch(this._handleError.bind(this)));
        }

        _handleError(reason) {
          console.error(reason);
          this.dispatchEvent(new CustomEvent('error', {
            composed: true,
            bubbles: true,
            detail: { reason, error: reason },
          }));
          this.loading = false;
        }

        _handleResponse(response) {
          this._buildSunBurst(response.aggregations);
          this.loading = false;
        }

        _transformSubBuckets(bucket) {
          bucket.name = bucket.key;
          bucket.color = this._getColor(bucket.name, this.chartHue, this.chartLuminosity);
          let size;
          if (this.mode === 'size') {
            size = bucket.size.value;
            delete bucket.size;
          } else if (this.mode === 'count') {
            size = bucket.doc_count;
            delete bucket.doc_count;
          }
          delete bucket.key;
          bucket.size = size;
          if (bucket.subLevel) {
            bucket.children = bucket.subLevel.buckets;
            delete bucket.subLevel;
            if (bucket.children.length === 0) {
              return;
            }
            for (let j = 0; j < bucket.children.length; j++) {
              this._transformSubBuckets(bucket.children[j]);
            }
          }
        }

        _buildSunBurst(aggs) {
          const aggregations = aggs.subLevel;
          aggregations.name = 'root';
          aggregations.color = this._getColor(aggregations.name, this.chartHue, this.chartLuminosity);
          aggregations.children = aggregations.buckets;
          delete aggregations.buckets;
          delete aggregations.doc_count_error_upper_bound;
          delete aggregations.sum_other_doc_count;
          for (let i = 0; i < aggregations.children.length; i++) {
            this._transformSubBuckets(aggregations.children[i]);
          }

          this._chartData = aggregations;

          // Dimensions of sunburst.
          radius = Math.min(this.width, this.height) / 2;

          // Total size of all segments; we set this later, after loading the data.
          this.totalSize = 0;

          const svg = this.$.chart.querySelector('svg');
          if (svg) {
            svg.parentNode.removeChild(svg);
          }

          vis = d3.select(this.$.chart).append('svg:svg')
            .attr('width', this.width)
            .attr('height', this.height)
            .append('svg:g')
            .attr('id', 'container')
            .attr('transform', `translate(${this.width / 2},${this.height / 2})`);

          partition = d3.layout.partition()
            .size([2 * Math.PI, radius * radius])
            .value((d) => d.size);

          arc = d3.svg.arc()
            .startAngle((d) => d.x)
            .endAngle((d) => d.x + d.dx)
            .innerRadius((d) => Math.sqrt(d.y))
            .outerRadius((d) => Math.sqrt(d.y + d.dy));

          this._createVisualization();
        }

        _getColor(pathPart, hue, luminosity) {
          let result = colors[pathPart];
          if (result === undefined) {
            result = randomColor({
              hue,
              luminosity,
            });
            colors[pathPart] = result;
          }
          return result;
        }

        // Given a node in a partition layout, return an array of all of its ancestor
        // nodes, highest first, but excluding the root.
        _getAncestors(node) {
          const path = [];
          let current = node;
          while (current.parent) {
            path.unshift(current);
            current = current.parent;
          }
          return path;
        }

        // Update the breadcrumb trail to show the current sequence and percentage.
        _updateBreadcrumbs(nodeArray, percentageString) {

          // Data join; key function combines name and depth (= position in sequence).
          const g = d3.select(Polymer.dom(this.root).querySelector('#trail'))
            .selectAll('g')
            .data(nodeArray, (d) => d.name + d.depth);

          // Add breadcrumb and label for entering nodes.
          const entering = g.enter().append('svg:g');

          entering.append('svg:polygon')
            .attr('points', this._breadcrumbPoints)
            .style('fill', (d) => d.color);

          entering.append('svg:text')
            .attr('x', (b.w + b.t) / 2)
            .attr('y', b.h / 2)
            .attr('dy', '0.35em')
            .attr('text-anchor', 'middle')
            .text((d) => {
              if (d.name.length > 10) {
                return `${d.name.substring(0, 9)}...`;
              } else {
                return d.name;
              }
            });

          // Set position for entering and updating nodes.
          g.attr('transform', (d, i) => `translate(${i * (b.w + b.s)}, 0)`);

          // Remove exiting nodes.
          g.exit().remove();

          // Now move and update the percentage at the end.
          d3.select(Polymer.dom(this.root).querySelector('#trail').querySelector('#endlabel'))
            .attr('x', (nodeArray.length + 0.5) * (b.w + b.s))
            .attr('y', b.h / 2)
            .attr('dy', '0.35em')
            .attr('text-anchor', 'middle')
            .text(percentageString);

          // Make the breadcrumb trail visible, if it's hidden.
          d3.select(Polymer.dom(this.root).querySelector('#trail'))
            .style('visibility', '');

        }

        // Main function to draw and set up the visualization, once we have the data.
        _createVisualization() {

          this._initializeBreadcrumbTrail();

          // Bounding circle underneath the sunburst, to make it easier to detect
          // when the mouse leaves the parent g.
          vis.append('svg:circle')
            .attr('r', radius)
            .style('opacity', 0);

          // For efficiency, filter nodes to keep only those large enough to see.
          const nodes = partition.nodes(this._chartData).filter((d) => (d.dx > 0.005)); // 0.005 radians = 0.29 degrees

          const path = vis.data([this._chartData]).selectAll('path')
            .data(nodes)
            .enter()
            .append('svg:path')
            .attr('display', (d) => (d.depth ? null : 'none'))
            .attr('d', arc)
            .attr('fill-rule', 'evenodd')
            .style('fill', (d) => d.color)
            .style('opacity', 1)
            .on('mouseover', this._mouseover.bind(this));

          // Add the mouseleave handler to the bounding circle.
          d3.select(Polymer.dom(this.root).querySelector('#container')).on('mouseleave', this._mouseleave);

          // Get total size of the tree = value of root node from partition.
          this.totalSize = path.node().__data__.value;
        }

        // Fade all but the current sequence, and show it in the breadcrumb trail.
        _mouseover(d) {

          const percentage = ((100 * d.value) / this.totalSize).toPrecision(3);
          let percentageString = `${percentage}%`;
          if (percentage < 0.1) {
            percentageString = '< 0.1%';
          }

          d3.select(this.$.cl)
            .text(this._formatValue(d.value, true));
          d3.select(this.$.clb)
            .text(`(${percentageString})`);

          d3.select(this.$.ex)
            .style('visibility', '');

          const sequenceArray = this._getAncestors(d);
          this._updateBreadcrumbs(sequenceArray, percentageString);

          // Fade all the segments.
          d3.selectAll(Polymer.dom(this.root).querySelectorAll('#chart path'))
            .style('opacity', 0.3);

          // Then highlight only those that are an ancestor of the current segment.
          vis.selectAll('#chart path')
            .filter((node) => (sequenceArray.indexOf(node) >= 0))
            .style('opacity', 1);
        }

        // Restore everything to full opacity when moving off the visualization.
        _mouseleave() {
          // return;
          // Hide the breadcrumb trail
          // d3.select(Polymer.dom(this.root).querySelector('#trail'))
          //   .style('visibility', 'hidden');
          //
          // // Deactivate all segments during transition.
          // d3.selectAll(Polymer.dom(this.root).querySelectorAll('#chart path'))
          //   .on('mouseover', null);
          //
          // // Transition each segment to full opacity and then reactivate it.
          // d3.selectAll(Polymer.dom(this.root).querySelectorAll('#chart path'))
          //   .transition()
          //   .duration(1000)
          //   .style('opacity', 1)
          //   .each('end', function () {
          //     d3.select(this).on('mouseover', this._mouseover.bind(this));
          //   });
          //
          // d3.select(this.$.ex)
          //   .style('visibility', 'hidden');
        }

        _initializeBreadcrumbTrail() {
          while (this.$.sequence.firstChild) {
            this.$.sequence.removeChild(this.$.sequence.firstChild);
          }

          // Add the svg area.
          const trail = d3.select(this.$.sequence).append('svg:svg')
            .attr('width', '100%')
            .attr('height', 50)
            .attr('id', 'trail');
          // Add the label at the end, for the percentage.
          trail.append('svg:text')
            .attr('id', 'endlabel')
            .style('fill', '#000');

          d3.select(this.$.cl)
            .text('');
          d3.select(this.$.clb)
            .text('');
        }

        // Generate a string that describes the points of a breadcrumb polygon.
        _breadcrumbPoints(d, i) {
          const points = [];
          points.push('0,0');
          points.push(`${b.w},0`);
          points.push(`${b.w + b.t},${b.h / 2}`);
          points.push(`${b.w},${b.h}`);
          points.push(`0,${b.h}`);
          if (i > 0) { // Leftmost breadcrumb; don't include 6th vertex.
            points.push(`${b.t},${b.h / 2}`);
          }
          return points.join(' ');
        }

        _formatValue(value, si) {
          if (this.mode === 'size') {
            const thresh = si ? 1000 : 1024;
            if (Math.abs(value) < thresh) {
              return `${value} B`;
            }
            const units = si
              ? ['kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']
              : ['KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB'];
            let u = -1;
            do {
              value /= thresh;
              ++u;
            } while (Math.abs(value) >= thresh && u < units.length - 1);
            return `${value.toFixed(1)} ${units[u]}`;
          } else if (this.mode === 'count') {
            let result = value + (value === this.maxDocSize ? '+ ' : ' ');
            if (value > 1) {
              result += this.i18n('documentDistributionChart.documents');
            } else {
              result += this.i18n('documentDistributionChart.document');
            }
            return result;
          } else {
            return value;
          }
        }

      }

      customElements.define(DocumentDistributionChart.is, DocumentDistributionChart);
      Nuxeo.DocumentDistributionChart = DocumentDistributionChart;
    }
  </script>

</dom-module>
<script>/**
 * marked - a markdown parser
 * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/markedjs/marked
 */

;(function(root) {
'use strict';

/**
 * Block-Level Grammar
 */

var block = {
  newline: /^\n+/,
  code: /^( {4}[^\n]+\n*)+/,
  fences: noop,
  hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/,
  heading: /^ *(#{1,6}) *([^\n]+?) *#* *(?:\n+|$)/,
  nptable: noop,
  blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
  list: /^( *)(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
  html: /^ *(?:comment *(?:\n|\s*$)|closed *(?:\n{2,}|\s*$)|closing *(?:\n{2,}|\s*$))/,
  def: /^ {0,3}\[(label)\]: *\n? *<?([^\s>]+)>?(?:(?: +\n? *| *\n *)(title))? *(?:\n+|$)/,
  table: noop,
  lheading: /^([^\n]+)\n *(=|-){2,} *(?:\n+|$)/,
  paragraph: /^([^\n]+(?:\n?(?!hr|heading|lheading| {0,3}>|tag)[^\n]+)+)/,
  text: /^[^\n]+/
};

block._label = /(?:\\[\[\]]|[^\[\]])+/;
block._title = /(?:"(?:\\"|[^"]|"[^"\n]*")*"|'\n?(?:[^'\n]+\n?)*'|\([^()]*\))/;
block.def = edit(block.def)
  .replace('label', block._label)
  .replace('title', block._title)
  .getRegex();

block.bullet = /(?:[*+-]|\d+\.)/;
block.item = /^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/;
block.item = edit(block.item, 'gm')
  .replace(/bull/g, block.bullet)
  .getRegex();

block.list = edit(block.list)
  .replace(/bull/g, block.bullet)
  .replace('hr', '\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))')
  .replace('def', '\\n+(?=' + block.def.source + ')')
  .getRegex();

block._tag = '(?!(?:'
  + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code'
  + '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo'
  + '|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b';

block.html = edit(block.html)
  .replace('comment', /\x3c!--[\s\S]*?--\x3e/)
  .replace('closed', /<(tag)[\s\S]+?<\/\1>/)
  .replace('closing', /<tag(?:"[^"]*"|'[^']*'|\s[^'"\/>\s]*)*?\/?>/)
  .replace(/tag/g, block._tag)
  .getRegex();

block.paragraph = edit(block.paragraph)
  .replace('hr', block.hr)
  .replace('heading', block.heading)
  .replace('lheading', block.lheading)
  .replace('tag', '<' + block._tag)
  .getRegex();

block.blockquote = edit(block.blockquote)
  .replace('paragraph', block.paragraph)
  .getRegex();

/**
 * Normal Block Grammar
 */

block.normal = merge({}, block);

/**
 * GFM Block Grammar
 */

block.gfm = merge({}, block.normal, {
  fences: /^ *(`{3,}|~{3,})[ \.]*(\S+)? *\n([\s\S]*?)\n? *\1 *(?:\n+|$)/,
  paragraph: /^/,
  heading: /^ *(#{1,6}) +([^\n]+?) *#* *(?:\n+|$)/
});

block.gfm.paragraph = edit(block.paragraph)
  .replace('(?!', '(?!'
    + block.gfm.fences.source.replace('\\1', '\\2') + '|'
    + block.list.source.replace('\\1', '\\3') + '|')
  .getRegex();

/**
 * GFM + Tables Block Grammar
 */

block.tables = merge({}, block.gfm, {
  nptable: /^ *(\S.*\|.*)\n *([-:]+ *\|[-| :]*)\n((?:.*\|.*(?:\n|$))*)\n*/,
  table: /^ *\|(.+)\n *\|( *[-:]+[-| :]*)\n((?: *\|.*(?:\n|$))*)\n*/
});

/**
 * Block Lexer
 */

function Lexer(options) {
  this.tokens = [];
  this.tokens.links = {};
  this.options = options || marked.defaults;
  this.rules = block.normal;

  if (this.options.gfm) {
    if (this.options.tables) {
      this.rules = block.tables;
    } else {
      this.rules = block.gfm;
    }
  }
}

/**
 * Expose Block Rules
 */

Lexer.rules = block;

/**
 * Static Lex Method
 */

Lexer.lex = function(src, options) {
  var lexer = new Lexer(options);
  return lexer.lex(src);
};

/**
 * Preprocessing
 */

Lexer.prototype.lex = function(src) {
  src = src
    .replace(/\r\n|\r/g, '\n')
    .replace(/\t/g, '    ')
    .replace(/\u00a0/g, ' ')
    .replace(/\u2424/g, '\n');

  return this.token(src, true);
};

/**
 * Lexing
 */

Lexer.prototype.token = function(src, top) {
  src = src.replace(/^ +$/gm, '');
  var next,
      loose,
      cap,
      bull,
      b,
      item,
      space,
      i,
      tag,
      l,
      isordered;

  while (src) {
    // newline
    if (cap = this.rules.newline.exec(src)) {
      src = src.substring(cap[0].length);
      if (cap[0].length > 1) {
        this.tokens.push({
          type: 'space'
        });
      }
    }

    // code
    if (cap = this.rules.code.exec(src)) {
      src = src.substring(cap[0].length);
      cap = cap[0].replace(/^ {4}/gm, '');
      this.tokens.push({
        type: 'code',
        text: !this.options.pedantic
          ? cap.replace(/\n+$/, '')
          : cap
      });
      continue;
    }

    // fences (gfm)
    if (cap = this.rules.fences.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'code',
        lang: cap[2],
        text: cap[3] || ''
      });
      continue;
    }

    // heading
    if (cap = this.rules.heading.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'heading',
        depth: cap[1].length,
        text: cap[2]
      });
      continue;
    }

    // table no leading pipe (gfm)
    if (top && (cap = this.rules.nptable.exec(src))) {
      src = src.substring(cap[0].length);

      item = {
        type: 'table',
        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        cells: cap[3].replace(/\n$/, '').split('\n')
      };

      for (i = 0; i < item.align.length; i++) {
        if (/^ *-+: *$/.test(item.align[i])) {
          item.align[i] = 'right';
        } else if (/^ *:-+: *$/.test(item.align[i])) {
          item.align[i] = 'center';
        } else if (/^ *:-+ *$/.test(item.align[i])) {
          item.align[i] = 'left';
        } else {
          item.align[i] = null;
        }
      }

      for (i = 0; i < item.cells.length; i++) {
        item.cells[i] = item.cells[i].split(/ *\| */);
      }

      this.tokens.push(item);

      continue;
    }

    // hr
    if (cap = this.rules.hr.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'hr'
      });
      continue;
    }

    // blockquote
    if (cap = this.rules.blockquote.exec(src)) {
      src = src.substring(cap[0].length);

      this.tokens.push({
        type: 'blockquote_start'
      });

      cap = cap[0].replace(/^ *> ?/gm, '');

      // Pass `top` to keep the current
      // "toplevel" state. This is exactly
      // how markdown.pl works.
      this.token(cap, top);

      this.tokens.push({
        type: 'blockquote_end'
      });

      continue;
    }

    // list
    if (cap = this.rules.list.exec(src)) {
      src = src.substring(cap[0].length);
      bull = cap[2];
      isordered = bull.length > 1;

      this.tokens.push({
        type: 'list_start',
        ordered: isordered,
        start: isordered ? +bull : ''
      });

      // Get each top-level item.
      cap = cap[0].match(this.rules.item);

      next = false;
      l = cap.length;
      i = 0;

      for (; i < l; i++) {
        item = cap[i];

        // Remove the list item's bullet
        // so it is seen as the next token.
        space = item.length;
        item = item.replace(/^ *([*+-]|\d+\.) +/, '');

        // Outdent whatever the
        // list item contains. Hacky.
        if (~item.indexOf('\n ')) {
          space -= item.length;
          item = !this.options.pedantic
            ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')
            : item.replace(/^ {1,4}/gm, '');
        }

        // Determine whether the next list item belongs here.
        // Backpedal if it does not belong in this list.
        if (this.options.smartLists && i !== l - 1) {
          b = block.bullet.exec(cap[i + 1])[0];
          if (bull !== b && !(bull.length > 1 && b.length > 1)) {
            src = cap.slice(i + 1).join('\n') + src;
            i = l - 1;
          }
        }

        // Determine whether item is loose or not.
        // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
        // for discount behavior.
        loose = next || /\n\n(?!\s*$)/.test(item);
        if (i !== l - 1) {
          next = item.charAt(item.length - 1) === '\n';
          if (!loose) loose = next;
        }

        this.tokens.push({
          type: loose
            ? 'loose_item_start'
            : 'list_item_start'
        });

        // Recurse.
        this.token(item, false);

        this.tokens.push({
          type: 'list_item_end'
        });
      }

      this.tokens.push({
        type: 'list_end'
      });

      continue;
    }

    // html
    if (cap = this.rules.html.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: this.options.sanitize
          ? 'paragraph'
          : 'html',
        pre: !this.options.sanitizer
          && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),
        text: cap[0]
      });
      continue;
    }

    // def
    if (top && (cap = this.rules.def.exec(src))) {
      src = src.substring(cap[0].length);
      if (cap[3]) cap[3] = cap[3].substring(1, cap[3].length - 1);
      tag = cap[1].toLowerCase();
      if (!this.tokens.links[tag]) {
        this.tokens.links[tag] = {
          href: cap[2],
          title: cap[3]
        };
      }
      continue;
    }

    // table (gfm)
    if (top && (cap = this.rules.table.exec(src))) {
      src = src.substring(cap[0].length);

      item = {
        type: 'table',
        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        cells: cap[3].replace(/(?: *\| *)?\n$/, '').split('\n')
      };

      for (i = 0; i < item.align.length; i++) {
        if (/^ *-+: *$/.test(item.align[i])) {
          item.align[i] = 'right';
        } else if (/^ *:-+: *$/.test(item.align[i])) {
          item.align[i] = 'center';
        } else if (/^ *:-+ *$/.test(item.align[i])) {
          item.align[i] = 'left';
        } else {
          item.align[i] = null;
        }
      }

      for (i = 0; i < item.cells.length; i++) {
        item.cells[i] = item.cells[i]
          .replace(/^ *\| *| *\| *$/g, '')
          .split(/ *\| */);
      }

      this.tokens.push(item);

      continue;
    }

    // lheading
    if (cap = this.rules.lheading.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'heading',
        depth: cap[2] === '=' ? 1 : 2,
        text: cap[1]
      });
      continue;
    }

    // top-level paragraph
    if (top && (cap = this.rules.paragraph.exec(src))) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'paragraph',
        text: cap[1].charAt(cap[1].length - 1) === '\n'
          ? cap[1].slice(0, -1)
          : cap[1]
      });
      continue;
    }

    // text
    if (cap = this.rules.text.exec(src)) {
      // Top-level should never reach here.
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'text',
        text: cap[0]
      });
      continue;
    }

    if (src) {
      throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));
    }
  }

  return this.tokens;
};

/**
 * Inline-Level Grammar
 */

var inline = {
  escape: /^\\([\\`*{}\[\]()#+\-.!_>])/,
  autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
  url: noop,
  tag: /^\x3c!--[\s\S]*?--\x3e|^<\/?[a-zA-Z0-9\-]+(?:"[^"]*"|'[^']*'|\s[^<'">\/\s]*)*?\/?>/,
  link: /^!?\[(inside)\]\(href\)/,
  reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/,
  nolink: /^!?\[((?:\[[^\[\]]*\]|\\[\[\]]|[^\[\]])*)\]/,
  strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/,
  em: /^_([^\s_](?:[^_]|__)+?[^\s_])_\b|^\*((?:\*\*|[^*])+?)\*(?!\*)/,
  code: /^(`+)\s*([\s\S]*?[^`]?)\s*\1(?!`)/,
  br: /^ {2,}\n(?!\s*$)/,
  del: noop,
  text: /^[\s\S]+?(?=[\\<!\[`*]|\b_| {2,}\n|$)/
};

inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;

inline.autolink = edit(inline.autolink)
  .replace('scheme', inline._scheme)
  .replace('email', inline._email)
  .getRegex()

inline._inside = /(?:\[[^\[\]]*\]|\\[\[\]]|[^\[\]]|\](?=[^\[]*\]))*/;
inline._href = /\s*<?([\s\S]*?)>?(?:\s+['"]([\s\S]*?)['"])?\s*/;

inline.link = edit(inline.link)
  .replace('inside', inline._inside)
  .replace('href', inline._href)
  .getRegex();

inline.reflink = edit(inline.reflink)
  .replace('inside', inline._inside)
  .getRegex();

/**
 * Normal Inline Grammar
 */

inline.normal = merge({}, inline);

/**
 * Pedantic Inline Grammar
 */

inline.pedantic = merge({}, inline.normal, {
  strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
  em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/
});

/**
 * GFM Inline Grammar
 */

inline.gfm = merge({}, inline.normal, {
  escape: edit(inline.escape).replace('])', '~|])').getRegex(),
  url: edit(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/)
    .replace('email', inline._email)
    .getRegex(),
  _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
  del: /^~~(?=\S)([\s\S]*?\S)~~/,
  text: edit(inline.text)
    .replace(']|', '~]|')
    .replace('|', '|https?://|ftp://|www\\.|[a-zA-Z0-9.!#$%&\'*+/=?^_`{\\|}~-]+@|')
    .getRegex()
});

/**
 * GFM + Line Breaks Inline Grammar
 */

inline.breaks = merge({}, inline.gfm, {
  br: edit(inline.br).replace('{2,}', '*').getRegex(),
  text: edit(inline.gfm.text).replace('{2,}', '*').getRegex()
});

/**
 * Inline Lexer & Compiler
 */

function InlineLexer(links, options) {
  this.options = options || marked.defaults;
  this.links = links;
  this.rules = inline.normal;
  this.renderer = this.options.renderer || new Renderer();
  this.renderer.options = this.options;

  if (!this.links) {
    throw new Error('Tokens array requires a `links` property.');
  }

  if (this.options.gfm) {
    if (this.options.breaks) {
      this.rules = inline.breaks;
    } else {
      this.rules = inline.gfm;
    }
  } else if (this.options.pedantic) {
    this.rules = inline.pedantic;
  }
}

/**
 * Expose Inline Rules
 */

InlineLexer.rules = inline;

/**
 * Static Lexing/Compiling Method
 */

InlineLexer.output = function(src, links, options) {
  var inline = new InlineLexer(links, options);
  return inline.output(src);
};

/**
 * Lexing/Compiling
 */

InlineLexer.prototype.output = function(src) {
  var out = '',
      link,
      text,
      href,
      cap;

  while (src) {
    // escape
    if (cap = this.rules.escape.exec(src)) {
      src = src.substring(cap[0].length);
      out += cap[1];
      continue;
    }

    // autolink
    if (cap = this.rules.autolink.exec(src)) {
      src = src.substring(cap[0].length);
      if (cap[2] === '@') {
        text = escape(this.mangle(cap[1]));
        href = 'mailto:' + text;
      } else {
        text = escape(cap[1]);
        href = text;
      }
      out += this.renderer.link(href, null, text);
      continue;
    }

    // url (gfm)
    if (!this.inLink && (cap = this.rules.url.exec(src))) {
      cap[0] = this.rules._backpedal.exec(cap[0])[0];
      src = src.substring(cap[0].length);
      if (cap[2] === '@') {
        text = escape(cap[0]);
        href = 'mailto:' + text;
      } else {
        text = escape(cap[0]);
        if (cap[1] === 'www.') {
          href = 'http://' + text;
        } else {
          href = text;
        }
      }
      out += this.renderer.link(href, null, text);
      continue;
    }

    // tag
    if (cap = this.rules.tag.exec(src)) {
      if (!this.inLink && /^<a /i.test(cap[0])) {
        this.inLink = true;
      } else if (this.inLink && /^<\/a>/i.test(cap[0])) {
        this.inLink = false;
      }
      src = src.substring(cap[0].length);
      out += this.options.sanitize
        ? this.options.sanitizer
          ? this.options.sanitizer(cap[0])
          : escape(cap[0])
        : cap[0]
      continue;
    }

    // link
    if (cap = this.rules.link.exec(src)) {
      src = src.substring(cap[0].length);
      this.inLink = true;
      out += this.outputLink(cap, {
        href: cap[2],
        title: cap[3]
      });
      this.inLink = false;
      continue;
    }

    // reflink, nolink
    if ((cap = this.rules.reflink.exec(src))
        || (cap = this.rules.nolink.exec(src))) {
      src = src.substring(cap[0].length);
      link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
      link = this.links[link.toLowerCase()];
      if (!link || !link.href) {
        out += cap[0].charAt(0);
        src = cap[0].substring(1) + src;
        continue;
      }
      this.inLink = true;
      out += this.outputLink(cap, link);
      this.inLink = false;
      continue;
    }

    // strong
    if (cap = this.rules.strong.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.strong(this.output(cap[2] || cap[1]));
      continue;
    }

    // em
    if (cap = this.rules.em.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.em(this.output(cap[2] || cap[1]));
      continue;
    }

    // code
    if (cap = this.rules.code.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.codespan(escape(cap[2].trim(), true));
      continue;
    }

    // br
    if (cap = this.rules.br.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.br();
      continue;
    }

    // del (gfm)
    if (cap = this.rules.del.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.del(this.output(cap[1]));
      continue;
    }

    // text
    if (cap = this.rules.text.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.text(escape(this.smartypants(cap[0])));
      continue;
    }

    if (src) {
      throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));
    }
  }

  return out;
};

/**
 * Compile Link
 */

InlineLexer.prototype.outputLink = function(cap, link) {
  var href = escape(link.href),
      title = link.title ? escape(link.title) : null;

  return cap[0].charAt(0) !== '!'
    ? this.renderer.link(href, title, this.output(cap[1]))
    : this.renderer.image(href, title, escape(cap[1]));
};

/**
 * Smartypants Transformations
 */

InlineLexer.prototype.smartypants = function(text) {
  if (!this.options.smartypants) return text;
  return text
    // em-dashes
    .replace(/---/g, '\u2014')
    // en-dashes
    .replace(/--/g, '\u2013')
    // opening singles
    .replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018')
    // closing singles & apostrophes
    .replace(/'/g, '\u2019')
    // opening doubles
    .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201c')
    // closing doubles
    .replace(/"/g, '\u201d')
    // ellipses
    .replace(/\.{3}/g, '\u2026');
};

/**
 * Mangle Links
 */

InlineLexer.prototype.mangle = function(text) {
  if (!this.options.mangle) return text;
  var out = '',
      l = text.length,
      i = 0,
      ch;

  for (; i < l; i++) {
    ch = text.charCodeAt(i);
    if (Math.random() > 0.5) {
      ch = 'x' + ch.toString(16);
    }
    out += '&#' + ch + ';';
  }

  return out;
};

/**
 * Renderer
 */

function Renderer(options) {
  this.options = options || {};
}

Renderer.prototype.code = function(code, lang, escaped) {
  if (this.options.highlight) {
    var out = this.options.highlight(code, lang);
    if (out != null && out !== code) {
      escaped = true;
      code = out;
    }
  }

  if (!lang) {
    return '<pre><code>'
      + (escaped ? code : escape(code, true))
      + '\n</code></pre>';
  }

  return '<pre><code class="'
    + this.options.langPrefix
    + escape(lang, true)
    + '">'
    + (escaped ? code : escape(code, true))
    + '\n</code></pre>\n';
};

Renderer.prototype.blockquote = function(quote) {
  return '<blockquote>\n' + quote + '</blockquote>\n';
};

Renderer.prototype.html = function(html) {
  return html;
};

Renderer.prototype.heading = function(text, level, raw) {
  return '<h'
    + level
    + ' id="'
    + this.options.headerPrefix
    + raw.toLowerCase().replace(/[^\w]+/g, '-')
    + '">'
    + text
    + '</h'
    + level
    + '>\n';
};

Renderer.prototype.hr = function() {
  return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
};

Renderer.prototype.list = function(body, ordered, start) {
  var type = ordered ? 'ol' : 'ul',
      startatt = (ordered && start !== 1) ? (' start="' + start + '"') : '';
  return '<' + type + startatt + '>\n' + body + '</' + type + '>\n';
};

Renderer.prototype.listitem = function(text) {
  return '<li>' + text + '</li>\n';
};

Renderer.prototype.paragraph = function(text) {
  return '<p>' + text + '</p>\n';
};

Renderer.prototype.table = function(header, body) {
  return '<table>\n'
    + '<thead>\n'
    + header
    + '</thead>\n'
    + '<tbody>\n'
    + body
    + '</tbody>\n'
    + '</table>\n';
};

Renderer.prototype.tablerow = function(content) {
  return '<tr>\n' + content + '</tr>\n';
};

Renderer.prototype.tablecell = function(content, flags) {
  var type = flags.header ? 'th' : 'td';
  var tag = flags.align
    ? '<' + type + ' style="text-align:' + flags.align + '">'
    : '<' + type + '>';
  return tag + content + '</' + type + '>\n';
};

// span level renderer
Renderer.prototype.strong = function(text) {
  return '<strong>' + text + '</strong>';
};

Renderer.prototype.em = function(text) {
  return '<em>' + text + '</em>';
};

Renderer.prototype.codespan = function(text) {
  return '<code>' + text + '</code>';
};

Renderer.prototype.br = function() {
  return this.options.xhtml ? '<br/>' : '<br>';
};

Renderer.prototype.del = function(text) {
  return '<del>' + text + '</del>';
};

Renderer.prototype.link = function(href, title, text) {
  if (this.options.sanitize) {
    try {
      var prot = decodeURIComponent(unescape(href))
        .replace(/[^\w:]/g, '')
        .toLowerCase();
    } catch (e) {
      return text;
    }
    if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {
      return text;
    }
  }
  if (this.options.baseUrl && !originIndependentUrl.test(href)) {
    href = resolveUrl(this.options.baseUrl, href);
  }
  var out = '<a href="' + href + '"';
  if (title) {
    out += ' title="' + title + '"';
  }
  out += '>' + text + '</a>';
  return out;
};

Renderer.prototype.image = function(href, title, text) {
  if (this.options.baseUrl && !originIndependentUrl.test(href)) {
    href = resolveUrl(this.options.baseUrl, href);
  }
  var out = '<img src="' + href + '" alt="' + text + '"';
  if (title) {
    out += ' title="' + title + '"';
  }
  out += this.options.xhtml ? '/>' : '>';
  return out;
};

Renderer.prototype.text = function(text) {
  return text;
};

/**
 * TextRenderer
 * returns only the textual part of the token
 */

function TextRenderer() {}

// no need for block level renderers

TextRenderer.prototype.strong =
TextRenderer.prototype.em =
TextRenderer.prototype.codespan =
TextRenderer.prototype.del =
TextRenderer.prototype.text = function (text) {
  return text;
}

TextRenderer.prototype.link =
TextRenderer.prototype.image = function(href, title, text) {
  return '' + text;
}

TextRenderer.prototype.br = function() {
  return '';
}

/**
 * Parsing & Compiling
 */

function Parser(options) {
  this.tokens = [];
  this.token = null;
  this.options = options || marked.defaults;
  this.options.renderer = this.options.renderer || new Renderer();
  this.renderer = this.options.renderer;
  this.renderer.options = this.options;
}

/**
 * Static Parse Method
 */

Parser.parse = function(src, options) {
  var parser = new Parser(options);
  return parser.parse(src);
};

/**
 * Parse Loop
 */

Parser.prototype.parse = function(src) {
  this.inline = new InlineLexer(src.links, this.options);
  // use an InlineLexer with a TextRenderer to extract pure text
  this.inlineText = new InlineLexer(
    src.links,
    merge({}, this.options, {renderer: new TextRenderer()})
  );
  this.tokens = src.reverse();

  var out = '';
  while (this.next()) {
    out += this.tok();
  }

  return out;
};

/**
 * Next Token
 */

Parser.prototype.next = function() {
  return this.token = this.tokens.pop();
};

/**
 * Preview Next Token
 */

Parser.prototype.peek = function() {
  return this.tokens[this.tokens.length - 1] || 0;
};

/**
 * Parse Text Tokens
 */

Parser.prototype.parseText = function() {
  var body = this.token.text;

  while (this.peek().type === 'text') {
    body += '\n' + this.next().text;
  }

  return this.inline.output(body);
};

/**
 * Parse Current Token
 */

Parser.prototype.tok = function() {
  switch (this.token.type) {
    case 'space': {
      return '';
    }
    case 'hr': {
      return this.renderer.hr();
    }
    case 'heading': {
      return this.renderer.heading(
        this.inline.output(this.token.text),
        this.token.depth,
        unescape(this.inlineText.output(this.token.text)));
    }
    case 'code': {
      return this.renderer.code(this.token.text,
        this.token.lang,
        this.token.escaped);
    }
    case 'table': {
      var header = '',
          body = '',
          i,
          row,
          cell,
          j;

      // header
      cell = '';
      for (i = 0; i < this.token.header.length; i++) {
        cell += this.renderer.tablecell(
          this.inline.output(this.token.header[i]),
          { header: true, align: this.token.align[i] }
        );
      }
      header += this.renderer.tablerow(cell);

      for (i = 0; i < this.token.cells.length; i++) {
        row = this.token.cells[i];

        cell = '';
        for (j = 0; j < row.length; j++) {
          cell += this.renderer.tablecell(
            this.inline.output(row[j]),
            { header: false, align: this.token.align[j] }
          );
        }

        body += this.renderer.tablerow(cell);
      }
      return this.renderer.table(header, body);
    }
    case 'blockquote_start': {
      body = '';

      while (this.next().type !== 'blockquote_end') {
        body += this.tok();
      }

      return this.renderer.blockquote(body);
    }
    case 'list_start': {
      body = '';
      var ordered = this.token.ordered,
          start = this.token.start;

      while (this.next().type !== 'list_end') {
        body += this.tok();
      }

      return this.renderer.list(body, ordered, start);
    }
    case 'list_item_start': {
      body = '';

      while (this.next().type !== 'list_item_end') {
        body += this.token.type === 'text'
          ? this.parseText()
          : this.tok();
      }

      return this.renderer.listitem(body);
    }
    case 'loose_item_start': {
      body = '';

      while (this.next().type !== 'list_item_end') {
        body += this.tok();
      }

      return this.renderer.listitem(body);
    }
    case 'html': {
      var html = !this.token.pre && !this.options.pedantic
        ? this.inline.output(this.token.text)
        : this.token.text;
      return this.renderer.html(html);
    }
    case 'paragraph': {
      return this.renderer.paragraph(this.inline.output(this.token.text));
    }
    case 'text': {
      return this.renderer.paragraph(this.parseText());
    }
  }
};

/**
 * Helpers
 */

function escape(html, encode) {
  return html
    .replace(!encode ? /&(?!#?\w+;)/g : /&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

function unescape(html) {
  // explicitly match decimal, hex, and named HTML entities
  return html.replace(/&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig, function(_, n) {
    n = n.toLowerCase();
    if (n === 'colon') return ':';
    if (n.charAt(0) === '#') {
      return n.charAt(1) === 'x'
        ? String.fromCharCode(parseInt(n.substring(2), 16))
        : String.fromCharCode(+n.substring(1));
    }
    return '';
  });
}

function edit(regex, opt) {
  regex = regex.source;
  opt = opt || '';
  return {
    replace: function(name, val) {
      val = val.source || val;
      val = val.replace(/(^|[^\[])\^/g, '$1');
      regex = regex.replace(name, val);
      return this;
    },
    getRegex: function() {
      return new RegExp(regex, opt);
    }
  };
}

function resolveUrl(base, href) {
  if (!baseUrls[' ' + base]) {
    // we can ignore everything in base after the last slash of its path component,
    // but we might need to add _that_
    // https://tools.ietf.org/html/rfc3986#section-3
    if (/^[^:]+:\/*[^/]*$/.test(base)) {
      baseUrls[' ' + base] = base + '/';
    } else {
      baseUrls[' ' + base] = base.replace(/[^/]*$/, '');
    }
  }
  base = baseUrls[' ' + base];

  if (href.slice(0, 2) === '//') {
    return base.replace(/:[\s\S]*/, ':') + href;
  } else if (href.charAt(0) === '/') {
    return base.replace(/(:\/*[^/]*)[\s\S]*/, '$1') + href;
  } else {
    return base + href;
  }
}
var baseUrls = {};
var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;

function noop() {}
noop.exec = noop;

function merge(obj) {
  var i = 1,
      target,
      key;

  for (; i < arguments.length; i++) {
    target = arguments[i];
    for (key in target) {
      if (Object.prototype.hasOwnProperty.call(target, key)) {
        obj[key] = target[key];
      }
    }
  }

  return obj;
}

/**
 * Marked
 */

function marked(src, opt, callback) {
  // throw error in case of non string input
  if (typeof src === 'undefined' || src === null) {
    throw new Error('marked(): input parameter is undefined or null');
  }
  if (typeof src !== 'string') {
    throw new Error('marked(): input parameter is of type '
      + Object.prototype.toString.call(src) + ', string expected');
  }

  if (callback || typeof opt === 'function') {
    if (!callback) {
      callback = opt;
      opt = null;
    }

    opt = merge({}, marked.defaults, opt || {});

    var highlight = opt.highlight,
        tokens,
        pending,
        i = 0;

    try {
      tokens = Lexer.lex(src, opt)
    } catch (e) {
      return callback(e);
    }

    pending = tokens.length;

    var done = function(err) {
      if (err) {
        opt.highlight = highlight;
        return callback(err);
      }

      var out;

      try {
        out = Parser.parse(tokens, opt);
      } catch (e) {
        err = e;
      }

      opt.highlight = highlight;

      return err
        ? callback(err)
        : callback(null, out);
    };

    if (!highlight || highlight.length < 3) {
      return done();
    }

    delete opt.highlight;

    if (!pending) return done();

    for (; i < tokens.length; i++) {
      (function(token) {
        if (token.type !== 'code') {
          return --pending || done();
        }
        return highlight(token.text, token.lang, function(err, code) {
          if (err) return done(err);
          if (code == null || code === token.text) {
            return --pending || done();
          }
          token.text = code;
          token.escaped = true;
          --pending || done();
        });
      })(tokens[i]);
    }

    return;
  }
  try {
    if (opt) opt = merge({}, marked.defaults, opt);
    return Parser.parse(Lexer.lex(src, opt), opt);
  } catch (e) {
    e.message += '\nPlease report this to https://github.com/markedjs/marked.';
    if ((opt || marked.defaults).silent) {
      return '<p>An error occurred:</p><pre>'
        + escape(e.message + '', true)
        + '</pre>';
    }
    throw e;
  }
}

/**
 * Options
 */

marked.options =
marked.setOptions = function(opt) {
  merge(marked.defaults, opt);
  return marked;
};

marked.defaults = {
  gfm: true,
  tables: true,
  breaks: false,
  pedantic: false,
  sanitize: false,
  sanitizer: null,
  mangle: true,
  smartLists: false,
  silent: false,
  highlight: null,
  langPrefix: 'lang-',
  smartypants: false,
  headerPrefix: '',
  renderer: new Renderer(),
  xhtml: false,
  baseUrl: null
};

/**
 * Expose
 */

marked.Parser = Parser;
marked.parser = Parser.parse;

marked.Renderer = Renderer;
marked.TextRenderer = TextRenderer;

marked.Lexer = Lexer;
marked.lexer = Lexer.lex;

marked.InlineLexer = InlineLexer;
marked.inlineLexer = InlineLexer.output;

marked.parse = marked;

if (typeof module !== 'undefined' && typeof exports === 'object') {
  module.exports = marked;
} else if (typeof define === 'function' && define.amd) {
  define(function() { return marked; });
} else {
  root.marked = marked;
}
})(this || (typeof window !== 'undefined' ? window : global));
</script>
<script>
if (!window.marked) {
  // For webpack support for the Polymer 3 version created by the Polymer Modulizer
  // More info: https://github.com/PolymerElements/marked-element/issues/81
  window.marked = require('../../marked/lib/marked.js');
}
</script>
<dom-module id="marked-element" assetpath="bower_components/marked-element/">
  <template>
    <style>
      :host {
        display: block;
      }
    </style>
    <slot name="markdown-html">
      <div id="content"></div>
    </slot>
  </template>
</dom-module>

<script>
  'use strict';

  Polymer({

    is: 'marked-element',

    properties: {

      /**
       * The markdown source that should be rendered by this element.
       */
      markdown: {
        type: String,
        value: null
      },
      /**
       * Enable GFM line breaks (regular newlines instead of two spaces for breaks)
       */
      breaks: {
        type: Boolean,
        value: false
      },
      /**
       * Conform to obscure parts of markdown.pl as much as possible. Don't fix any of the original markdown bugs or poor behavior.
       */
      pedantic: {
        type: Boolean,
        value: false
      },
      /**
       * Function used to customize a renderer based on the [API specified in the Marked
       * library](https://github.com/chjj/marked#overriding-renderer-methods).
       * It takes one argument: a marked renderer object, which is mutated by the function.
       */
      renderer: {
        type: Function,
        value: null
      },
      /**
       * Sanitize the output. Ignore any HTML that has been input.
       */
      sanitize: {
        type: Boolean,
        value: false
      },
      /**
       * Function used to customize a sanitize behavior.
       * It takes one argument: element String without text Contents.
       *
       * e.g. `<div>` `<a href="/">` `</p>'.
       * Note: To enable this function, must set `sanitize` to true.
       * WARNING: If you are using this option to untrusted text, you must to prevent XSS Attacks.
       */
      sanitizer: {
        type: Function,
        value: null
      },
      /**
       * If true, disables the default sanitization of any markdown received by
       * a request and allows fetched unsanitized markdown
       *
       * e.g. fetching markdown via `src` that has HTML.
       * Note: this value overrides `sanitize` if a request is made.
       */
      disableRemoteSanitization: {
        type: Boolean,
        value: false
      },
      /**
       * Use "smart" typographic punctuation for things like quotes and dashes.
       */
      smartypants: {
        type: Boolean,
        value: false
      },
      /**
       * Callback function invoked by Marked after HTML has been rendered.
       * It must take two arguments: err and text and must return the resulting text.
       */
      callback: {
        type: Function,
        value: null
      },
      /**
       * A reference to the XMLHttpRequest instance used to generate the
       * network request.
       *
       * @type {XMLHttpRequest}
       */
      xhr: {
        type: Object,
        notify: true,
        readOnly: true
      }
    },

    observers: [
      'render(markdown, breaks, pedantic, renderer, sanitize, sanitizer, smartypants, callback)'
    ],

    ready: function() {
      if (this.markdown) {
        return;
      }

      // Use the Markdown from the first `<script>` descendant whose MIME type starts with
      // "text/markdown". Script elements beyond the first are ignored.
      this._markdownElement = Polymer.dom(this).querySelector('[type="text/markdown"]');
      if (!this._markdownElement) {
        return;
      }

      if (this._markdownElement.src) {
        this._request(this._markdownElement.src);
      }

      if (this._markdownElement.textContent.trim() !== '') {
        this.markdown = this._unindent(this._markdownElement.textContent);
      }

      var observer = new MutationObserver(this._onScriptAttributeChanged
          .bind(this));
      observer.observe(this._markdownElement, { attributes: true });
    },

    /**
     * Renders `markdown` to HTML when the element is attached.
     *
     * This serves a dual purpose:
     *
     *  * Prevents unnecessary work (no need to render when not visible).
     *
     *  * `attached` fires top-down, so we can give ancestors a chance to
     *    register listeners for the `syntax-highlight` event _before_ we render
     *    any markdown.
     *
     */
    attached: function() {
      this._attached = true;
      this._outputElement = this.outputElement;
      this.render();
    },

    detached: function() {
      this._attached = false;
    },

    /**
     * Unindents the markdown source that will be rendered.
     *
     * @param {string} text
     * @return {string}
     */
    unindent: function(text) {
      return this._unindent(text);
    },

    get outputElement () {
      var child = Polymer.dom(this).queryDistributedElements('[slot="markdown-html"]')[0];
      return child || this.$.content;
    },

    /**
     * The `marked-render-complete` event is fired once Markdown to HTML
     * conversion has finished, and the DOM has been populated via the resulting
     * HTML.
     *
     * @event marked-render-complete
     */

    /**
     * Renders `markdown` into this element's DOM.
     *
     * This is automatically called whenever the `markdown` property is changed.
     *
     * The only case where you should be calling this is if you are providing
     * markdown via `<script type="text/markdown">` after this element has been
     * constructed (or updating that markdown).
     */
    render: function() {
      if (!this._attached) {
        return;
      };

      if (!this.markdown) {
        Polymer.dom(this._outputElement).innerHTML = '';
        return;
      }

      var renderer = new marked.Renderer();

      if (this.renderer) {
        this.renderer(renderer);
      }

      var opts = {
        renderer: renderer,
        highlight: this._highlight.bind(this),
        breaks: this.breaks,
        sanitize: this.sanitize,
        sanitizer: this.sanitizer,
        pedantic: this.pedantic,
        smartypants: this.smartypants
      };

      Polymer.dom(this._outputElement).innerHTML = marked(this.markdown, opts, this.callback);
      this.fire('marked-render-complete', {}, {composed: true});
    },

    /**
     * Fired when the content is being processed and before it is rendered.
     * Provides an opportunity to highlight code blocks based on the programming language used. This
     * is also known as syntax highlighting. One example would be to use a prebuilt syntax
     * highlighting library, e.g with [highlightjs](https://highlightjs.org/).
     *
     * @param {string} code
     * @param {string} lang
     * @return {string}
     * @event syntax-highlight
     */
    _highlight: function(code, lang) {
      var event = this.fire('syntax-highlight', {code: code, lang: lang}, {composed: true});
      return event.detail.code || code;
    },

    /**
     * @param {string} text
     * @return {string}
     */
    _unindent: function(text) {
      if (!text) return text;
      var lines  = text.replace(/\t/g, '  ').split('\n');
      var indent = lines.reduce(function(prev, line) {
        if (/^\s*$/.test(line)) return prev;  // Completely ignore blank lines.

        var lineIndent = line.match(/^(\s*)/)[0].length;
        if (prev === null) return lineIndent;
        return lineIndent < prev ? lineIndent : prev;
      }, null);

      return lines.map(function(l) { return l.substr(indent); }).join('\n');
    },

    /**
     * Fired when the XHR finishes loading
     *
     * @param {string} url
     * @event marked-loadend
     */
    _request: function(url) {
      this._setXhr(new XMLHttpRequest());
      var xhr = this.xhr;

      if (xhr.readyState > 0) {
        return null;
      }

      xhr.addEventListener('error', this._handleError.bind(this));
      xhr.addEventListener('loadend', function(e) {
        var status = this.xhr.status || 0;
        // Note: if we are using the file:// protocol, the status code will be 0
        // for all outcomes (successful or otherwise).
        if (status === 0 || (status >= 200 && status < 300)) {
          this.sanitize = !this.disableRemoteSanitization;
          this.markdown = e.target.response;
        } else {
          this._handleError(e);
        }

        this.fire('marked-loadend', e);
      }.bind(this));

      xhr.open('GET', url);
      xhr.setRequestHeader('Accept', 'text/markdown');
      xhr.send();
    },

    /**
     * Fired when an error is received while fetching remote markdown content.
     *
     * @param {!Event} e
     * @event marked-request-error
     */
    _handleError: function(e) {
      var evt = this.fire('marked-request-error', e, {cancelable: true});
      if (!evt.defaultPrevented) {
        this.markdown = 'Failed loading markdown source';
      }
    },

    /**
     * @param {!Array<!MutationRecord>} mutation
     */
    _onScriptAttributeChanged: function(mutation) {
      if (mutation[0].attributeName !== 'src') {
        return;
      }

      this._request(this._markdownElement.src);
    }
  });

</script>
<style>.cropper-container{font-size:0;line-height:0;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;direction:ltr !important;-ms-touch-action:none;touch-action:none;-webkit-tap-highlight-color:transparent;-webkit-touch-callout:none;}.cropper-container img{display:block;width:100%;min-width:0 !important;max-width:none !important;height:100%;min-height:0 !important;max-height:none !important;image-orientation:0deg !important;}.cropper-wrap-box,
.cropper-canvas,
.cropper-drag-box,
.cropper-crop-box,
.cropper-modal{position:absolute;top:0;right:0;bottom:0;left:0;}.cropper-wrap-box{overflow:hidden;}.cropper-drag-box{opacity:0;background-color:#fff;filter:alpha(opacity=0);}.cropper-modal{opacity:.5;background-color:#000;filter:alpha(opacity=50);}.cropper-view-box{display:block;overflow:hidden;width:100%;height:100%;outline:1px solid #39f;outline-color:rgba(51, 153, 255, .75);}.cropper-dashed{position:absolute;display:block;opacity:.5;border:0 dashed #eee;filter:alpha(opacity=50);}.cropper-dashed.dashed-h{top:33.33333%;left:0;width:100%;height:33.33333%;border-top-width:1px;border-bottom-width:1px;}.cropper-dashed.dashed-v{top:0;left:33.33333%;width:33.33333%;height:100%;border-right-width:1px;border-left-width:1px;}.cropper-center{position:absolute;top:50%;left:50%;display:block;width:0;height:0;opacity:.75;filter:alpha(opacity=75);}.cropper-center:before,
.cropper-center:after{position:absolute;display:block;content:' ';background-color:#eee;}.cropper-center:before{top:0;left:-3px;width:7px;height:1px;}.cropper-center:after{top:-3px;left:0;width:1px;height:7px;}.cropper-face,
.cropper-line,
.cropper-point{position:absolute;display:block;width:100%;height:100%;opacity:.1;filter:alpha(opacity=10);}.cropper-face{top:0;left:0;background-color:#fff;}.cropper-line{background-color:#39f;}.cropper-line.line-e{top:0;right:-3px;width:5px;cursor:e-resize;}.cropper-line.line-n{top:-3px;left:0;height:5px;cursor:n-resize;}.cropper-line.line-w{top:0;left:-3px;width:5px;cursor:w-resize;}.cropper-line.line-s{bottom:-3px;left:0;height:5px;cursor:s-resize;}.cropper-point{width:5px;height:5px;opacity:.75;background-color:#39f;filter:alpha(opacity=75);}.cropper-point.point-e{top:50%;right:-3px;margin-top:-3px;cursor:e-resize;}.cropper-point.point-n{top:-3px;left:50%;margin-left:-3px;cursor:n-resize;}.cropper-point.point-w{top:50%;left:-3px;margin-top:-3px;cursor:w-resize;}.cropper-point.point-s{bottom:-3px;left:50%;margin-left:-3px;cursor:s-resize;}.cropper-point.point-ne{top:-3px;right:-3px;cursor:ne-resize;}.cropper-point.point-nw{top:-3px;left:-3px;cursor:nw-resize;}.cropper-point.point-sw{bottom:-3px;left:-3px;cursor:sw-resize;}.cropper-point.point-se{right:-3px;bottom:-3px;width:20px;height:20px;cursor:se-resize;opacity:1;filter:alpha(opacity=100);}.cropper-point.point-se:before{position:absolute;right:-50%;bottom:-50%;display:block;width:200%;height:200%;content:' ';opacity:0;background-color:#39f;filter:alpha(opacity=0);}@media (min-width: 768px){.cropper-point.point-se{width:15px;height:15px;}}@media (min-width: 992px){.cropper-point.point-se{width:10px;height:10px;}}@media (min-width: 1200px){.cropper-point.point-se{width:5px;height:5px;opacity:.75;filter:alpha(opacity=75);}}.cropper-invisible{opacity:0;filter:alpha(opacity=0);}.cropper-bg{background-image:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQAQMAAAAlPW0iAAAAA3NCSVQICAjb4U/gAAAABlBMVEXMzMz////TjRV2AAAACXBIWXMAAArrAAAK6wGCiw1aAAAAHHRFWHRTb2Z0d2FyZQBBZG9iZSBGaXJld29ya3MgQ1M26LyyjAAAABFJREFUCJlj+M/AgBVhF/0PAH6/D/HkDxOGAAAAAElFTkSuQmCC");}.cropper-hide{position:absolute;display:block;width:0;height:0;}.cropper-hidden{display:none !important;}.cropper-move{cursor:move;}.cropper-crop{cursor:crosshair;}.cropper-disabled .cropper-drag-box,
.cropper-disabled .cropper-face,
.cropper-disabled .cropper-line,
.cropper-disabled .cropper-point{cursor:not-allowed;}</style>
<script>/*!
 * Cropper.js v0.5.6
 * https://github.com/fengyuanchen/cropperjs
 *
 * Copyright (c) 2015-2016 Fengyuan Chen
 * Released under the MIT license
 *
 * Date: 2016-01-18T05:33:43.542Z
 */

(function (global, factory) {
  if (typeof module === 'object' && typeof module.exports === 'object') {
    module.exports = global.document ? factory(global, true) : function (window) {
      if (!window.document) {
        throw new Error('Cropper requires a window with a document');
      }

      return factory(window);
    };
  } else {
    factory(global);
  }
})(typeof window !== 'undefined' ? window : this, function (window, noGlobal) {

  'use strict';

  // Globals
  var document = window.document;
  var location = window.location;
  var ArrayBuffer = window.ArrayBuffer;
  var Object = window.Object;
  var Array = window.Array;
  var String = window.String;
  var Number = window.Number;
  var Math = window.Math;

  // Constants
  var NAMESPACE = 'cropper';

  // Classes
  var CLASS_MODAL = NAMESPACE + '-modal';
  var CLASS_HIDE = NAMESPACE + '-hide';
  var CLASS_HIDDEN = NAMESPACE + '-hidden';
  var CLASS_INVISIBLE = NAMESPACE + '-invisible';
  var CLASS_MOVE = NAMESPACE + '-move';
  var CLASS_CROP = NAMESPACE + '-crop';
  var CLASS_DISABLED = NAMESPACE + '-disabled';
  var CLASS_BG = NAMESPACE + '-bg';

  // Events
  var EVENT_MOUSE_DOWN = 'mousedown touchstart pointerdown MSPointerDown';
  var EVENT_MOUSE_MOVE = 'mousemove touchmove pointermove MSPointerMove';
  var EVENT_MOUSE_UP = 'mouseup touchend touchcancel pointerup pointercancel MSPointerUp MSPointerCancel';
  var EVENT_WHEEL = 'wheel mousewheel DOMMouseScroll';
  var EVENT_DBLCLICK = 'dblclick';
  var EVENT_RESIZE = 'resize';
  var EVENT_ERROR = 'error';
  var EVENT_LOAD = 'load';

  // RegExps
  var REGEXP_ACTIONS = /e|w|s|n|se|sw|ne|nw|all|crop|move|zoom/;
  var REGEXP_SUFFIX = /width|height|left|top|marginLeft|marginTop/;
  var REGEXP_ORIGINS = /^(https?:)\/\/([^\:\/\?#]+):?(\d*)/i;
  var REGEXP_TRIM = /^\s+(.*)\s+$/;
  var REGEXP_SPACES = /\s+/;
  var REGEXP_DATA_URL = /^data\:/;
  var REGEXP_DATA_URL_HEAD = /^data\:([^\;]+)\;base64,/;
  var REGEXP_DATA_URL_JPEG = /^data\:image\/jpeg.*;base64,/;

  // Data
  var DATA_PREVIEW = 'preview';
  var DATA_ACTION = 'action';

  // Actions
  var ACTION_EAST = 'e';
  var ACTION_WEST = 'w';
  var ACTION_SOUTH = 's';
  var ACTION_NORTH = 'n';
  var ACTION_SOUTH_EAST = 'se';
  var ACTION_SOUTH_WEST = 'sw';
  var ACTION_NORTH_EAST = 'ne';
  var ACTION_NORTH_WEST = 'nw';
  var ACTION_ALL = 'all';
  var ACTION_CROP = 'crop';
  var ACTION_MOVE = 'move';
  var ACTION_ZOOM = 'zoom';
  var ACTION_NONE = 'none';

  // Supports
  var SUPPORT_CANVAS = !!document.createElement('canvas').getContext;

  // Maths
  var min = Math.min;
  var max = Math.max;
  var abs = Math.abs;
  var sin = Math.sin;
  var cos = Math.cos;
  var sqrt = Math.sqrt;
  var round = Math.round;
  var floor = Math.floor;
  var PI = Math.PI;

  // Utilities
  var objectProto = Object.prototype;
  var toString = objectProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var slice = Array.prototype.slice;
  var fromCharCode = String.fromCharCode;

  function typeOf(obj) {
    return toString.call(obj).slice(8, -1).toLowerCase();
  }

  function isNumber(num) {
    return typeof num === 'number' && !isNaN(num);
  }

  function isUndefined(obj) {
    return typeof obj === 'undefined';
  }

  function isObject(obj) {
    return typeof obj === 'object' && obj !== null;
  }

  function isPlainObject(obj) {
    var constructor;
    var prototype;

    if (!isObject(obj)) {
      return false;
    }

    try {
      constructor = obj.constructor;
      prototype = constructor.prototype;

      return constructor && prototype && hasOwnProperty.call(prototype, 'isPrototypeOf');
    } catch (e) {
      return false;
    }
  }

  function isFunction(fn) {
    return typeOf(fn) === 'function';
  }

  function isArray(arr) {
    return Array.isArray ? Array.isArray(arr) : typeOf(arr) === 'array';
  }

  function toArray(obj, offset) {
    offset = offset >= 0 ? offset : 0;

    if (Array.from) {
      return Array.from(obj).slice(offset);
    }

    return slice.call(obj, offset);
  }

  function trim(str) {
    if (typeof str === 'string') {
      str = str.trim ? str.trim() : str.replace(REGEXP_TRIM, '$1');
    }

    return str;
  }

  function each(obj, callback) {
    var length;
    var i;

    if (obj && isFunction(callback)) {
      if (isArray(obj) || isNumber(obj.length)/* array-like */) {
        for (i = 0, length = obj.length; i < length; i++) {
          if (callback.call(obj, obj[i], i, obj) === false) {
            break;
          }
        }
      } else if (isObject(obj)) {
        for (i in obj) {
          if (obj.hasOwnProperty(i)) {
            if (callback.call(obj, obj[i], i, obj) === false) {
              break;
            }
          }
        }
      }
    }

    return obj;
  }

  function extend(obj) {
    var args;

    if (arguments.length > 1) {
      args = toArray(arguments);

      if (Object.assign) {
        return Object.assign.apply(Object, args);
      }

      args.shift();

      each(args, function (arg) {
        each(arg, function (prop, i) {
          obj[i] = prop;
        });
      });
    }

    return obj;
  }

  function proxy(fn, context) {
    var args = toArray(arguments, 2);

    return function () {
      return fn.apply(context, args.concat(toArray(arguments)));
    };
  }

  function setStyle(element, styles) {
    var style = element.style;

    each(styles, function (value, property) {
      if (REGEXP_SUFFIX.test(property) && isNumber(value)) {
        value += 'px';
      }

      style[property] = value;
    });
  }

  function hasClass(element, value) {
    return element.classList ?
      element.classList.contains(value) :
      element.className.indexOf(value) > -1;
  }

  function addClass(element, value) {
    var className;

    if (isNumber(element.length)) {
      return each(element, function (elem) {
        addClass(elem, value);
      });
    }

    if (element.classList) {
      return element.classList.add(value);
    }

    className = trim(element.className);

    if (!className) {
      element.className = value;
    } else if (className.indexOf(value) < 0) {
      element.className = className + ' ' + value;
    }
  }

  function removeClass(element, value) {
    if (isNumber(element.length)) {
      return each(element, function (elem) {
        removeClass(elem, value);
      });
    }

    if (element.classList) {
      return element.classList.remove(value);
    }

    if (element.className.indexOf(value) >= 0) {
      element.className = element.className.replace(value, '');
    }
  }

  function toggleClass(element, value, added) {
    if (isNumber(element.length)) {
      return each(element, function (elem) {
        toggleClass(elem, value, added);
      });
    }

    // IE10-11 doesn't support the second parameter of `classList.toggle`
    if (added) {
      addClass(element, value);
    } else {
      removeClass(element, value);
    }
  }

  function getData(element, name) {
    return isObject(element[name]) ?
      element[name] :
      element.dataset ?
        element.dataset[name] :
        element.getAttribute('data-' + name);
  }

  function setData(element, name, data) {
    if (isObject(data) && isUndefined(element[name])) {
      element[name] = data;
    } else if (element.dataset) {
      element.dataset[name] = data;
    } else {
      element.setAttribute('data-' + name, data);
    }
  }

  function removeData(element, name) {
    if (isObject(element[name])) {
      delete element[name];
    } else if (element.dataset) {
      delete element.dataset[name];
    } else {
      element.removeAttribute('data-' + name);
    }
  }

  function addListener(element, type, handler) {
    var types = trim(type).split(REGEXP_SPACES);

    if (types.length > 1) {
      return each(types, function (type) {
        addListener(element, type, handler);
      });
    }

    if (element.addEventListener) {
      element.addEventListener(type, handler, false);
    } else if (element.attachEvent) {
      element.attachEvent('on' + type, handler);
    }
  }

  function removeListener(element, type, handler) {
    var types = trim(type).split(REGEXP_SPACES);

    if (types.length > 1) {
      return each(types, function (type) {
        removeListener(element, type, handler);
      });
    }

    if (element.removeEventListener) {
      element.removeEventListener(type, handler, false);
    } else if (element.detachEvent) {
      element.detachEvent('on' + type, handler);
    }
  }

  function preventDefault(e) {
    if (e.preventDefault) {
      e.preventDefault();
    } else {
      e.returnValue = false;
    }
  }

  function getEvent(event) {
    var e = event || window.event;
    var doc;

    // Fix target property (IE8)
    if (!e.target) {
      e.target = e.srcElement || document;
    }

    if (!isNumber(e.pageX)) {
      doc = document.documentElement;
      e.pageX = e.clientX + (window.scrollX || doc && doc.scrollLeft || 0) - (doc && doc.clientLeft || 0);
      e.pageY = e.clientY + (window.scrollY || doc && doc.scrollTop || 0) - (doc && doc.clientTop || 0);
    }

    return e;
  }

  function getOffset(element) {
    var doc = document.documentElement;
    var box = element.getBoundingClientRect();

    return {
      left: box.left + (window.scrollX || doc && doc.scrollLeft || 0) - (doc && doc.clientLeft || 0),
      top: box.top + (window.scrollY || doc && doc.scrollTop || 0) - (doc && doc.clientTop || 0)
    };
  }

  function getTouchesCenter(touches) {
    var length = touches.length;
    var pageX = 0;
    var pageY = 0;

    if (length) {
      each(touches, function (touch) {
        pageX += touch.pageX;
        pageY += touch.pageY;
      });

      pageX /= length;
      pageY /= length;
    }

    return {
      pageX: pageX,
      pageY: pageY
    };
  }

  function getByTag(element, tagName) {
    return element.getElementsByTagName(tagName);
  }

  function getByClass(element, className) {
    return element.getElementsByClassName ?
      element.getElementsByClassName(className) :
      element.querySelectorAll('.' + className);
  }

  function createElement(tagName) {
    return document.createElement(tagName);
  }

  function appendChild(element, elem) {
    element.appendChild(elem);
  }

  function removeChild(element) {
    if (element.parentNode) {
      element.parentNode.removeChild(element);
    }
  }

  function empty(element) {
    while (element.firstChild) {
      element.removeChild(element.firstChild);
    }
  }

  function isCrossOriginURL(url) {
    var parts = url.match(REGEXP_ORIGINS);

    return parts && (
      parts[1] !== location.protocol ||
      parts[2] !== location.hostname ||
      parts[3] !== location.port
    );
  }

  function addTimestamp(url) {
    var timestamp = 'timestamp=' + (new Date()).getTime();

    return (url + (url.indexOf('?') === -1 ? '?' : '&') + timestamp);
  }

  function getImageSize(image, callback) {
    var newImage;

    // Modern browsers
    if (image.naturalWidth) {
      return callback(image.naturalWidth, image.naturalHeight);
    }

    // IE8: Don't use `new Image()` here
    newImage = createElement('img');

    newImage.onload = function () {
      callback(this.width, this.height);
    };

    newImage.src = image.src;
  }

  function getTransform(data) {
    var transforms = [];
    var rotate = data.rotate;
    var scaleX = data.scaleX;
    var scaleY = data.scaleY;

    if (isNumber(rotate)) {
      transforms.push('rotate(' + rotate + 'deg)');
    }

    if (isNumber(scaleX) && isNumber(scaleY)) {
      transforms.push('scale(' + scaleX + ',' + scaleY + ')');
    }

    return transforms.length ? transforms.join(' ') : 'none';
  }

  function getRotatedSizes(data, reversed) {
    var deg = abs(data.degree) % 180;
    var arc = (deg > 90 ? (180 - deg) : deg) * PI / 180;
    var sinArc = sin(arc);
    var cosArc = cos(arc);
    var width = data.width;
    var height = data.height;
    var aspectRatio = data.aspectRatio;
    var newWidth;
    var newHeight;

    if (!reversed) {
      newWidth = width * cosArc + height * sinArc;
      newHeight = width * sinArc + height * cosArc;
    } else {
      newWidth = width / (cosArc + sinArc / aspectRatio);
      newHeight = newWidth / aspectRatio;
    }

    return {
      width: newWidth,
      height: newHeight
    };
  }

  function getSourceCanvas(image, data) {
    var canvas = createElement('canvas');
    var context = canvas.getContext('2d');
    var x = 0;
    var y = 0;
    var width = data.naturalWidth;
    var height = data.naturalHeight;
    var rotate = data.rotate;
    var scaleX = data.scaleX;
    var scaleY = data.scaleY;
    var scalable = isNumber(scaleX) && isNumber(scaleY) && (scaleX !== 1 || scaleY !== 1);
    var rotatable = isNumber(rotate) && rotate !== 0;
    var advanced = rotatable || scalable;
    var canvasWidth = width;
    var canvasHeight = height;
    var translateX;
    var translateY;
    var rotated;

    if (scalable) {
      translateX = width / 2;
      translateY = height / 2;
    }

    if (rotatable) {
      rotated = getRotatedSizes({
        width: width,
        height: height,
        degree: rotate
      });

      canvasWidth = rotated.width;
      canvasHeight = rotated.height;
      translateX = rotated.width / 2;
      translateY = rotated.height / 2;
    }

    canvas.width = canvasWidth;
    canvas.height = canvasHeight;

    if (advanced) {
      x = -width / 2;
      y = -height / 2;

      context.save();
      context.translate(translateX, translateY);
    }

    if (rotatable) {
      context.rotate(rotate * PI / 180);
    }

    // Should call `scale` after rotated
    if (scalable) {
      context.scale(scaleX, scaleY);
    }

    context.drawImage(image, floor(x), floor(y), floor(width), floor(height));

    if (advanced) {
      context.restore();
    }

    return canvas;
  }

  function getStringFromCharCode(dataView, start, length) {
    var str = '';
    var i = start;

    for (length += start; i < length; i++) {
      str += fromCharCode(dataView.getUint8(i));
    }

    return str;
  }

  function getOrientation(arrayBuffer) {
    var dataView = new DataView(arrayBuffer);
    var length = dataView.byteLength;
    var orientation;
    var exifIDCode;
    var tiffOffset;
    var firstIFDOffset;
    var littleEndian;
    var endianness;
    var app1Start;
    var ifdStart;
    var offset;
    var i;

    // Only handle JPEG image (start by 0xFFD8)
    if (dataView.getUint8(0) === 0xFF && dataView.getUint8(1) === 0xD8) {
      offset = 2;

      while (offset < length) {
        if (dataView.getUint8(offset) === 0xFF && dataView.getUint8(offset + 1) === 0xE1) {
          app1Start = offset;
          break;
        }

        offset++;
      }
    }

    if (app1Start) {
      exifIDCode = app1Start + 4;
      tiffOffset = app1Start + 10;

      if (getStringFromCharCode(dataView, exifIDCode, 4) === 'Exif') {
        endianness = dataView.getUint16(tiffOffset);
        littleEndian = endianness === 0x4949;

        if (littleEndian || endianness === 0x4D4D /* bigEndian */) {
          if (dataView.getUint16(tiffOffset + 2, littleEndian) === 0x002A) {
            firstIFDOffset = dataView.getUint32(tiffOffset + 4, littleEndian);

            if (firstIFDOffset >= 0x00000008) {
              ifdStart = tiffOffset + firstIFDOffset;
            }
          }
        }
      }
    }

    if (ifdStart) {
      length = dataView.getUint16(ifdStart, littleEndian);

      for (i = 0; i < length; i++) {
        offset = ifdStart + i * 12 + 2;

        if (dataView.getUint16(offset, littleEndian) === 0x0112 /* Orientation */) {

          // 8 is the offset of the current tag's value
          offset += 8;

          // Get the original orientation value
          orientation = dataView.getUint16(offset, littleEndian);

          // Override the orientation with the default value: 1
          dataView.setUint16(offset, 1, littleEndian);
          break;
        }
      }
    }

    return orientation;
  }

  function dataURLToArrayBuffer(dataURL) {
    var base64 = dataURL.replace(REGEXP_DATA_URL_HEAD, '');
    var binary = atob(base64);
    var length = binary.length;
    var arrayBuffer = new ArrayBuffer(length);
    var dataView = new Uint8Array(arrayBuffer);
    var i;

    for (i = 0; i < length; i++) {
      dataView[i] = binary.charCodeAt(i);
    }

    return arrayBuffer;
  }

  // Only available for JPEG image
  function arrayBufferToDataURL(arrayBuffer) {
    var dataView = new Uint8Array(arrayBuffer);
    var length = dataView.length;
    var base64 = '';
    var i;

    for (i = 0; i < length; i++) {
      base64 += fromCharCode(dataView[i]);
    }

    return 'data:image/jpeg;base64,' + btoa(base64);
  }

  function Cropper(element, options) {
    var _this = this;

    _this.element = element;
    _this.options = extend({}, Cropper.DEFAULTS, isPlainObject(options) && options);
    _this.ready = false;
    _this.built = false;
    _this.complete = false;
    _this.rotated = false;
    _this.cropped = false;
    _this.disabled = false;
    _this.replaced = false;
    _this.limited = false;
    _this.wheeling = false;
    _this.isImg = false;
    _this.originalUrl = '';
    _this.canvasData = null;
    _this.cropBoxData = null;
    _this.previews = null;
    _this.init();
  }

  Cropper.prototype = {
    constructor: Cropper,

    init: function () {
      var _this = this;
      var element = _this.element;
      var tagName = element.tagName.toLowerCase();
      var url;

      if (getData(element, NAMESPACE)) {
        return;
      }

      setData(element, NAMESPACE, _this);

      if (tagName === 'img') {
        _this.isImg = true;

        // e.g.: "img/picture.jpg"
        _this.originalUrl = url = element.getAttribute('src');

        // Stop when it's a blank image
        if (!url) {
          return;
        }

        // e.g.: "http://example.com/img/picture.jpg"
        url = element.src;
      } else if (tagName === 'canvas' && SUPPORT_CANVAS) {
        url = element.toDataURL();
      }

      _this.load(url);
    },

    load: function (url) {
      var _this = this;
      var options = _this.options;
      var xhr;

      if (!url) {
        return;
      }

      if (isFunction(options.build) && options.build.call(_this.element) === false) {
        return;
      }

      _this.url = url;
      _this.imageData = {};

      if (!options.checkOrientation || !ArrayBuffer) {
        return _this.clone();
      }

      // XMLHttpRequest disallows to open a Data URL in some browsers like IE11 and Safari
      if (REGEXP_DATA_URL.test(url)) {
        return REGEXP_DATA_URL_JPEG.test(url) ?
          _this.read(dataURLToArrayBuffer(url)) :
          _this.clone();
      }

      xhr = new XMLHttpRequest();

      xhr.onerror = xhr.onabort = function () {
        _this.clone();
      };

      xhr.onload = function () {
        _this.read(this.response);
      };

      xhr.open('get', url);
      xhr.responseType = 'arraybuffer';
      xhr.send();
    },

    read: function (arrayBuffer) {
      var _this = this;
      var options = _this.options;
      var orientation = getOrientation(arrayBuffer);
      var imageData = _this.imageData;
      var rotate;
      var scaleX;
      var scaleY;

      if (orientation > 1) {
        _this.url = arrayBufferToDataURL(arrayBuffer);

        switch (orientation) {

          // flip horizontal
          case 2:
            scaleX = -1;
            break;

          // rotate left 180
          case 3:
            rotate = -180;
            break;

          // flip vertical
          case 4:
            scaleY = -1;
            break;

          // flip vertical + rotate right 90
          case 5:
            rotate = 90;
            scaleY = -1;
            break;

          // rotate right 90
          case 6:
            rotate = 90;
            break;

          // flip horizontal + rotate right 90
          case 7:
            rotate = 90;
            scaleX = -1;
            break;

          // rotate left 90
          case 8:
            rotate = -90;
            break;
        }
      }

      if (options.rotatable) {
        imageData.rotate = rotate;
      }

      if (options.scalable) {
        imageData.scaleX = scaleX;
        imageData.scaleY = scaleY;
      }

      _this.clone();
    },

    clone: function () {
      var _this = this;
      var element = _this.element;
      var url = _this.url;
      var crossOrigin;
      var crossOriginUrl;
      var image;
      var start;
      var stop;

      if (_this.options.checkCrossOrigin && isCrossOriginURL(url)) {
        crossOrigin = element.crossOrigin;

        if (crossOrigin) {
          crossOriginUrl = url;
        } else {
          crossOrigin = 'anonymous';

          // Bust cache when there is not a "crossOrigin" property
          crossOriginUrl = addTimestamp(url);
        }
      }

      _this.crossOrigin = crossOrigin;
      _this.crossOriginUrl = crossOriginUrl;
      image = createElement('img');

      if (crossOrigin) {
        image.crossOrigin = crossOrigin;
      }

      image.src = crossOriginUrl || url;
      _this.image = image;
      _this._start = start = proxy(_this.start, _this);
      _this._stop = stop = proxy(_this.stop, _this);

      if (_this.isImg) {
        if (element.complete) {
          _this.start();
        } else {
          addListener(element, EVENT_LOAD, start);
        }
      } else {
        addListener(image, EVENT_LOAD, start);
        addListener(image, EVENT_ERROR, stop);
        addClass(image, CLASS_HIDE);
        element.parentNode.insertBefore(image, element.nextSibling);
      }
    },

    start: function (event) {
      var _this = this;
      var image = _this.isImg ? _this.element : _this.image;

      if (event) {
        removeListener(image, EVENT_LOAD, _this._start);
        removeListener(image, EVENT_ERROR, _this._stop);
      }

      getImageSize(image, function (naturalWidth, naturalHeight) {
        extend(_this.imageData, {
          naturalWidth: naturalWidth,
          naturalHeight: naturalHeight,
          aspectRatio: naturalWidth / naturalHeight
        });

        _this.ready = true;
        _this.build();
      });
    },

    stop: function () {
      var _this = this;
      var image = _this.image;

      removeListener(image, EVENT_LOAD, _this._start);
      removeListener(image, EVENT_ERROR, _this._stop);

      removeChild(image);
      _this.image = null;
    },

    build: function () {
      var _this = this;
      var options = _this.options;
      var element = _this.element;
      var image = _this.image;
      var container;
      var template;
      var cropper;
      var canvas;
      var dragBox;
      var cropBox;
      var face;

      if (!_this.ready) {
        return;
      }

      // Unbuild first when replace
      if (_this.built) {
        _this.unbuild();
      }

      template = createElement('div');
      template.innerHTML = Cropper.TEMPLATE;

      // Create cropper elements
      _this.container = container = element.parentNode;
      _this.cropper = cropper = getByClass(template, 'cropper-container')[0];
      _this.canvas = canvas = getByClass(cropper, 'cropper-canvas')[0];
      _this.dragBox = dragBox = getByClass(cropper, 'cropper-drag-box')[0];
      _this.cropBox = cropBox = getByClass(cropper, 'cropper-crop-box')[0];
      _this.viewBox = getByClass(cropper, 'cropper-view-box')[0];
      _this.face = face = getByClass(cropBox, 'cropper-face')[0];

      appendChild(canvas, image);

      // Hide the original image
      addClass(element, CLASS_HIDDEN);

      // Inserts the cropper after to the current image
      container.insertBefore(cropper, element.nextSibling);

      // Show the image if is hidden
      if (!_this.isImg) {
        removeClass(image, CLASS_HIDE);
      }

      _this.initPreview();
      _this.bind();

      options.aspectRatio = max(0, options.aspectRatio) || NaN;
      options.viewMode = max(0, min(3, round(options.viewMode))) || 0;

      if (options.autoCrop) {
        _this.cropped = true;

        if (options.modal) {
          addClass(dragBox, CLASS_MODAL);
        }
      } else {
        addClass(cropBox, CLASS_HIDDEN);
      }

      if (!options.guides) {
        addClass(getByClass(cropBox, 'cropper-dashed'), CLASS_HIDDEN);
      }

      if (!options.center) {
        addClass(getByClass(cropBox, 'cropper-center'), CLASS_HIDDEN);
      }

      if (options.background) {
        addClass(cropper, CLASS_BG);
      }

      if (!options.highlight) {
        addClass(face, CLASS_INVISIBLE);
      }

      if (options.cropBoxMovable) {
        addClass(face, CLASS_MOVE);
        setData(face, DATA_ACTION, ACTION_ALL);
      }

      if (!options.cropBoxResizable) {
        addClass(getByClass(cropBox, 'cropper-line'), CLASS_HIDDEN);
        addClass(getByClass(cropBox, 'cropper-point'), CLASS_HIDDEN);
      }

      _this.setDragMode(options.dragMode);
      _this.render();
      _this.built = true;
      _this.setData(options.data);

      // Call the built asynchronously to keep "image.cropper" is defined
      setTimeout(function () {
        if (isFunction(options.built)) {
          options.built.call(element);
        }

        if (isFunction(options.crop)) {
          options.crop.call(element, _this.getData());
        }

        _this.complete = true;
      }, 0);
    },

    unbuild: function () {
      var _this = this;

      if (!_this.built) {
        return;
      }

      _this.built = false;
      _this.complete = false;
      _this.initialImageData = null;

      // Clear `initialCanvasData` is necessary when replace
      _this.initialCanvasData = null;
      _this.initialCropBoxData = null;
      _this.containerData = null;
      _this.canvasData = null;

      // Clear `cropBoxData` is necessary when replace
      _this.cropBoxData = null;
      _this.unbind();

      _this.resetPreview();
      _this.previews = null;

      _this.viewBox = null;
      _this.cropBox = null;
      _this.dragBox = null;
      _this.canvas = null;
      _this.container = null;

      removeChild(_this.cropper);
      _this.cropper = null;
    },

    render: function () {
      var _this = this;

      _this.initContainer();
      _this.initCanvas();
      _this.initCropBox();

      _this.renderCanvas();

      if (_this.cropped) {
        _this.renderCropBox();
      }
    },

    initContainer: function () {
      var _this = this;
      var options = _this.options;
      var element = _this.element;
      var container = _this.container;
      var cropper = _this.cropper;
      var containerData;

      addClass(cropper, CLASS_HIDDEN);
      removeClass(element, CLASS_HIDDEN);

      _this.containerData = containerData = {
        width: max(
          container.offsetWidth,
          Number(options.minContainerWidth) || 200
        ),
        height: max(
          container.offsetHeight,
          Number(options.minContainerHeight) || 100
        )
      };

      setStyle(cropper, {
        width: containerData.width,
        height: containerData.height
      });

      addClass(element, CLASS_HIDDEN);
      removeClass(cropper, CLASS_HIDDEN);
    },

    // Canvas (image wrapper)
    initCanvas: function () {
      var _this = this;
      var viewMode = _this.options.viewMode;
      var containerData = _this.containerData;
      var imageData = _this.imageData;
      var rotated = abs(imageData.rotate) === 90;
      var naturalWidth = rotated ? imageData.naturalHeight : imageData.naturalWidth;
      var naturalHeight = rotated ? imageData.naturalWidth : imageData.naturalHeight;
      var aspectRatio = naturalWidth / naturalHeight;
      var canvasWidth = containerData.width;
      var canvasHeight = containerData.height;
      var canvasData;

      if (containerData.height * aspectRatio > containerData.width) {
        if (viewMode === 3) {
          canvasWidth = containerData.height * aspectRatio;
        } else {
          canvasHeight = containerData.width / aspectRatio;
        }
      } else {
        if (viewMode === 3) {
          canvasHeight = containerData.width / aspectRatio;
        } else {
          canvasWidth = containerData.height * aspectRatio;
        }
      }

      canvasData = {
        naturalWidth: naturalWidth,
        naturalHeight: naturalHeight,
        aspectRatio: aspectRatio,
        width: canvasWidth,
        height: canvasHeight
      };

      canvasData.oldLeft = canvasData.left = (containerData.width - canvasWidth) / 2;
      canvasData.oldTop = canvasData.top = (containerData.height - canvasHeight) / 2;

      _this.canvasData = canvasData;
      _this.limited = (viewMode === 1 || viewMode === 2);
      _this.limitCanvas(true, true);
      _this.initialImageData = extend({}, imageData);
      _this.initialCanvasData = extend({}, canvasData);
    },

    limitCanvas: function (sizeLimited, positionLimited) {
      var _this = this;
      var options = _this.options;
      var viewMode = options.viewMode;
      var containerData = _this.containerData;
      var canvasData = _this.canvasData;
      var aspectRatio = canvasData.aspectRatio;
      var cropBoxData = _this.cropBoxData;
      var cropped = _this.cropped && cropBoxData;
      var minCanvasWidth;
      var minCanvasHeight;
      var newCanvasLeft;
      var newCanvasTop;

      if (sizeLimited) {
        minCanvasWidth = Number(options.minCanvasWidth) || 0;
        minCanvasHeight = Number(options.minCanvasHeight) || 0;

        if (viewMode > 1) {
          minCanvasWidth = max(minCanvasWidth, containerData.width);
          minCanvasHeight = max(minCanvasHeight, containerData.height);

          if (viewMode === 3) {
            if (minCanvasHeight * aspectRatio > minCanvasWidth) {
              minCanvasWidth = minCanvasHeight * aspectRatio;
            } else {
              minCanvasHeight = minCanvasWidth / aspectRatio;
            }
          }
        } else if (viewMode > 0) {
          if (minCanvasWidth) {
            minCanvasWidth = max(
              minCanvasWidth,
              cropped ? cropBoxData.width : 0
            );
          } else if (minCanvasHeight) {
            minCanvasHeight = max(
              minCanvasHeight,
              cropped ? cropBoxData.height : 0
            );
          } else if (cropped) {
            minCanvasWidth = cropBoxData.width;
            minCanvasHeight = cropBoxData.height;

            if (minCanvasHeight * aspectRatio > minCanvasWidth) {
              minCanvasWidth = minCanvasHeight * aspectRatio;
            } else {
              minCanvasHeight = minCanvasWidth / aspectRatio;
            }
          }
        }

        if (minCanvasWidth && minCanvasHeight) {
          if (minCanvasHeight * aspectRatio > minCanvasWidth) {
            minCanvasHeight = minCanvasWidth / aspectRatio;
          } else {
            minCanvasWidth = minCanvasHeight * aspectRatio;
          }
        } else if (minCanvasWidth) {
          minCanvasHeight = minCanvasWidth / aspectRatio;
        } else if (minCanvasHeight) {
          minCanvasWidth = minCanvasHeight * aspectRatio;
        }

        canvasData.minWidth = minCanvasWidth;
        canvasData.minHeight = minCanvasHeight;
        canvasData.maxWidth = Infinity;
        canvasData.maxHeight = Infinity;
      }

      if (positionLimited) {
        if (viewMode) {
          newCanvasLeft = containerData.width - canvasData.width;
          newCanvasTop = containerData.height - canvasData.height;

          canvasData.minLeft = min(0, newCanvasLeft);
          canvasData.minTop = min(0, newCanvasTop);
          canvasData.maxLeft = max(0, newCanvasLeft);
          canvasData.maxTop = max(0, newCanvasTop);

          if (cropped && _this.limited) {
            canvasData.minLeft = min(
              cropBoxData.left,
              cropBoxData.left + cropBoxData.width - canvasData.width
            );
            canvasData.minTop = min(
              cropBoxData.top,
              cropBoxData.top + cropBoxData.height - canvasData.height
            );
            canvasData.maxLeft = cropBoxData.left;
            canvasData.maxTop = cropBoxData.top;

            if (viewMode === 2) {
              if (canvasData.width >= containerData.width) {
                canvasData.minLeft = min(0, newCanvasLeft);
                canvasData.maxLeft = max(0, newCanvasLeft);
              }

              if (canvasData.height >= containerData.height) {
                canvasData.minTop = min(0, newCanvasTop);
                canvasData.maxTop = max(0, newCanvasTop);
              }
            }
          }
        } else {
          canvasData.minLeft = -canvasData.width;
          canvasData.minTop = -canvasData.height;
          canvasData.maxLeft = containerData.width;
          canvasData.maxTop = containerData.height;
        }
      }
    },

    renderCanvas: function (changed) {
      var _this = this;
      var canvasData = _this.canvasData;
      var imageData = _this.imageData;
      var rotate = imageData.rotate;
      var aspectRatio;
      var rotatedData;

      if (_this.rotated) {
        _this.rotated = false;

        // Computes rotated sizes with image sizes
        rotatedData = getRotatedSizes({
          width: imageData.width,
          height: imageData.height,
          degree: rotate
        });

        aspectRatio = rotatedData.width / rotatedData.height;

        if (aspectRatio !== canvasData.aspectRatio) {
          canvasData.left -= (rotatedData.width - canvasData.width) / 2;
          canvasData.top -= (rotatedData.height - canvasData.height) / 2;
          canvasData.width = rotatedData.width;
          canvasData.height = rotatedData.height;
          canvasData.aspectRatio = aspectRatio;
          canvasData.naturalWidth = imageData.naturalWidth;
          canvasData.naturalHeight = imageData.naturalHeight;

          // Computes rotated sizes with natural image sizes
          if (rotate % 180) {
            rotatedData = getRotatedSizes({
              width: imageData.naturalWidth,
              height: imageData.naturalHeight,
              degree: rotate
            });

            canvasData.naturalWidth = rotatedData.width;
            canvasData.naturalHeight = rotatedData.height;
          }

          _this.limitCanvas(true, false);
        }
      }

      if (canvasData.width > canvasData.maxWidth ||
        canvasData.width < canvasData.minWidth) {
        canvasData.left = canvasData.oldLeft;
      }

      if (canvasData.height > canvasData.maxHeight ||
        canvasData.height < canvasData.minHeight) {
        canvasData.top = canvasData.oldTop;
      }

      canvasData.width = min(
        max(canvasData.width, canvasData.minWidth),
        canvasData.maxWidth
      );
      canvasData.height = min(
        max(canvasData.height, canvasData.minHeight),
        canvasData.maxHeight
      );

      _this.limitCanvas(false, true);

      canvasData.oldLeft = canvasData.left = min(
        max(canvasData.left, canvasData.minLeft),
        canvasData.maxLeft
      );
      canvasData.oldTop = canvasData.top = min(
        max(canvasData.top, canvasData.minTop),
        canvasData.maxTop
      );

      setStyle(_this.canvas, {
        width: canvasData.width,
        height: canvasData.height,
        left: canvasData.left,
        top: canvasData.top
      });

      _this.renderImage();

      if (_this.cropped && _this.limited) {
        _this.limitCropBox(true, true);
      }

      if (changed) {
        _this.output();
      }
    },

    renderImage: function (changed) {
      var _this = this;
      var canvasData = _this.canvasData;
      var imageData = _this.imageData;
      var newImageData;
      var reversedData;
      var reversedWidth;
      var reversedHeight;
      var transform;

      if (imageData.rotate) {
        reversedData = getRotatedSizes({
          width: canvasData.width,
          height: canvasData.height,
          degree: imageData.rotate,
          aspectRatio: imageData.aspectRatio
        }, true);

        reversedWidth = reversedData.width;
        reversedHeight = reversedData.height;

        newImageData = {
          width: reversedWidth,
          height: reversedHeight,
          left: (canvasData.width - reversedWidth) / 2,
          top: (canvasData.height - reversedHeight) / 2
        };
      }

      extend(imageData, newImageData || {
        width: canvasData.width,
        height: canvasData.height,
        left: 0,
        top: 0
      });

      transform = getTransform(imageData);

      setStyle(_this.image, {
        width: imageData.width,
        height: imageData.height,
        marginLeft: imageData.left,
        marginTop: imageData.top,
        WebkitTransform: transform,
        msTransform: transform,
        transform: transform
      });

      if (changed) {
        _this.output();
      }
    },

    initCropBox: function () {
      var _this = this;
      var options = _this.options;
      var aspectRatio = options.aspectRatio;
      var autoCropArea = Number(options.autoCropArea) || 0.8;
      var canvasData = _this.canvasData;
      var cropBoxData = {
            width: canvasData.width,
            height: canvasData.height
          };

      if (aspectRatio) {
        if (canvasData.height * aspectRatio > canvasData.width) {
          cropBoxData.height = cropBoxData.width / aspectRatio;
        } else {
          cropBoxData.width = cropBoxData.height * aspectRatio;
        }
      }

      _this.cropBoxData = cropBoxData;
      _this.limitCropBox(true, true);

      // Initialize auto crop area
      cropBoxData.width = min(
        max(cropBoxData.width, cropBoxData.minWidth),
        cropBoxData.maxWidth
      );
      cropBoxData.height = min(
        max(cropBoxData.height, cropBoxData.minHeight),
        cropBoxData.maxHeight
      );

      // The width/height of auto crop area must large than "minWidth/Height"
      cropBoxData.width = max(
        cropBoxData.minWidth,
        cropBoxData.width * autoCropArea
      );
      cropBoxData.height = max(
        cropBoxData.minHeight,
        cropBoxData.height * autoCropArea
      );
      cropBoxData.oldLeft = cropBoxData.left = (
        canvasData.left + (canvasData.width - cropBoxData.width) / 2
      );
      cropBoxData.oldTop = cropBoxData.top = (
        canvasData.top + (canvasData.height - cropBoxData.height) / 2
      );

      _this.initialCropBoxData = extend({}, cropBoxData);
    },

    limitCropBox: function (sizeLimited, positionLimited) {
      var _this = this;
      var options = _this.options;
      var aspectRatio = options.aspectRatio;
      var containerData = _this.containerData;
      var canvasData = _this.canvasData;
      var cropBoxData = _this.cropBoxData;
      var limited = _this.limited;
      var minCropBoxWidth;
      var minCropBoxHeight;
      var maxCropBoxWidth;
      var maxCropBoxHeight;

      if (sizeLimited) {
        minCropBoxWidth = Number(options.minCropBoxWidth) || 0;
        minCropBoxHeight = Number(options.minCropBoxHeight) || 0;

        // The min/maxCropBoxWidth/Height must be less than containerWidth/Height
        minCropBoxWidth = min(minCropBoxWidth, containerData.width);
        minCropBoxHeight = min(minCropBoxHeight, containerData.height);
        maxCropBoxWidth = min(
          containerData.width,
          limited ? canvasData.width : containerData.width
        );
        maxCropBoxHeight = min(
          containerData.height,
          limited ? canvasData.height : containerData.height
        );

        if (aspectRatio) {
          if (minCropBoxWidth && minCropBoxHeight) {
            if (minCropBoxHeight * aspectRatio > minCropBoxWidth) {
              minCropBoxHeight = minCropBoxWidth / aspectRatio;
            } else {
              minCropBoxWidth = minCropBoxHeight * aspectRatio;
            }
          } else if (minCropBoxWidth) {
            minCropBoxHeight = minCropBoxWidth / aspectRatio;
          } else if (minCropBoxHeight) {
            minCropBoxWidth = minCropBoxHeight * aspectRatio;
          }

          if (maxCropBoxHeight * aspectRatio > maxCropBoxWidth) {
            maxCropBoxHeight = maxCropBoxWidth / aspectRatio;
          } else {
            maxCropBoxWidth = maxCropBoxHeight * aspectRatio;
          }
        }

        // The minWidth/Height must be less than maxWidth/Height
        cropBoxData.minWidth = min(minCropBoxWidth, maxCropBoxWidth);
        cropBoxData.minHeight = min(minCropBoxHeight, maxCropBoxHeight);
        cropBoxData.maxWidth = maxCropBoxWidth;
        cropBoxData.maxHeight = maxCropBoxHeight;
      }

      if (positionLimited) {
        if (limited) {
          cropBoxData.minLeft = max(0, canvasData.left);
          cropBoxData.minTop = max(0, canvasData.top);
          cropBoxData.maxLeft = min(
            containerData.width,
            canvasData.left + canvasData.width
          ) - cropBoxData.width;
          cropBoxData.maxTop = min(
            containerData.height,
            canvasData.top + canvasData.height
          ) - cropBoxData.height;
        } else {
          cropBoxData.minLeft = 0;
          cropBoxData.minTop = 0;
          cropBoxData.maxLeft = containerData.width - cropBoxData.width;
          cropBoxData.maxTop = containerData.height - cropBoxData.height;
        }
      }
    },

    renderCropBox: function () {
      var _this = this;
      var options = _this.options;
      var containerData = _this.containerData;
      var cropBoxData = _this.cropBoxData;

      if (cropBoxData.width > cropBoxData.maxWidth ||
        cropBoxData.width < cropBoxData.minWidth) {
        cropBoxData.left = cropBoxData.oldLeft;
      }

      if (cropBoxData.height > cropBoxData.maxHeight ||
        cropBoxData.height < cropBoxData.minHeight) {
        cropBoxData.top = cropBoxData.oldTop;
      }

      cropBoxData.width = min(
        max(cropBoxData.width, cropBoxData.minWidth),
        cropBoxData.maxWidth
      );
      cropBoxData.height = min(
        max(cropBoxData.height, cropBoxData.minHeight),
        cropBoxData.maxHeight
      );

      _this.limitCropBox(false, true);

      cropBoxData.oldLeft = cropBoxData.left = min(
        max(cropBoxData.left, cropBoxData.minLeft),
        cropBoxData.maxLeft
      );
      cropBoxData.oldTop = cropBoxData.top = min(
        max(cropBoxData.top, cropBoxData.minTop),
        cropBoxData.maxTop
      );

      if (options.movable && options.cropBoxMovable) {

        // Turn to move the canvas when the crop box is equal to the container
        setData(_this.face, DATA_ACTION, cropBoxData.width === containerData.width &&
          cropBoxData.height === containerData.height ? ACTION_MOVE : ACTION_ALL);
      }

      setStyle(_this.cropBox, {
        width: cropBoxData.width,
        height: cropBoxData.height,
        left: cropBoxData.left,
        top: cropBoxData.top
      });

      if (_this.cropped && _this.limited) {
        _this.limitCanvas(true, true);
      }

      if (!_this.disabled) {
        _this.output();
      }
    },

    output: function () {
      var _this = this;
      var options = _this.options;

      _this.preview();

      if (_this.complete && isFunction(options.crop)) {
        options.crop.call(_this.element, _this.getData());
      }
    },

    initPreview: function () {
      var _this = this;
      var preview = _this.options.preview;
      var image = createElement('img');
      var crossOrigin = _this.crossOrigin;
      var url = crossOrigin ? _this.crossOriginUrl : _this.url;
      var previews;

      if (crossOrigin) {
        image.crossOrigin = crossOrigin;
      }

      image.src = url;
      appendChild(_this.viewBox, image);

      if (!preview) {
        return;
      }

      _this.previews = previews = document.querySelectorAll(preview);

      each(previews, function (element) {
        var image = createElement('img');

        // Save the original size for recover
        setData(element, DATA_PREVIEW, {
          width: element.offsetWidth,
          height: element.offsetHeight,
          html: element.innerHTML
        });

        if (crossOrigin) {
          image.crossOrigin = crossOrigin;
        }

        image.src = url;

        /**
         * Override img element styles
         * Add `display:block` to avoid margin top issue
         * Add `height:auto` to override `height` attribute on IE8
         * (Occur only when margin-top <= -height)
         */

        image.style.cssText = (
          'display:block;' +
          'width:100%;' +
          'height:auto;' +
          'min-width:0!important;' +
          'min-height:0!important;' +
          'max-width:none!important;' +
          'max-height:none!important;' +
          'image-orientation:0deg!important;"'
        );

        empty(element);
        appendChild(element, image);
      });
    },

    resetPreview: function () {
      each(this.previews, function (element) {
        var data = getData(element, DATA_PREVIEW);

        setStyle(element, {
          width: data.width,
          height: data.height
        });

        element.innerHTML = data.html;
        removeData(element, DATA_PREVIEW);
      });
    },

    preview: function () {
      var _this = this;
      var imageData = _this.imageData;
      var canvasData = _this.canvasData;
      var cropBoxData = _this.cropBoxData;
      var cropBoxWidth = cropBoxData.width;
      var cropBoxHeight = cropBoxData.height;
      var width = imageData.width;
      var height = imageData.height;
      var left = cropBoxData.left - canvasData.left - imageData.left;
      var top = cropBoxData.top - canvasData.top - imageData.top;
      var transform = getTransform(imageData);
      var transforms = {
            WebkitTransform: transform,
            msTransform: transform,
            transform: transform
          };

      if (!_this.cropped || _this.disabled) {
        return;
      }

      setStyle(getByTag(_this.viewBox, 'img')[0], extend({
        width: width,
        height: height,
        marginLeft: -left,
        marginTop: -top
      }, transforms));

      each(_this.previews, function (element) {
        var data = getData(element, DATA_PREVIEW);
        var originalWidth = data.width;
        var originalHeight = data.height;
        var newWidth = originalWidth;
        var newHeight = originalHeight;
        var ratio = 1;

        if (cropBoxWidth) {
          ratio = originalWidth / cropBoxWidth;
          newHeight = cropBoxHeight * ratio;
        }

        if (cropBoxHeight && newHeight > originalHeight) {
          ratio = originalHeight / cropBoxHeight;
          newWidth = cropBoxWidth * ratio;
          newHeight = originalHeight;
        }

        setStyle(element, {
          width: newWidth,
          height: newHeight
        });

        setStyle(getByTag(element, 'img')[0], extend({
          width: width * ratio,
          height: height * ratio,
          marginLeft: -left * ratio,
          marginTop: -top * ratio
        }, transforms));
      });
    },

    bind: function () {
      var _this = this;
      var options = _this.options;
      var cropper = _this.cropper;

      addListener(cropper, EVENT_MOUSE_DOWN, (_this._cropStart = proxy(_this.cropStart, _this)));

      if (options.zoomable && options.zoomOnWheel) {
        addListener(cropper, EVENT_WHEEL, (_this._wheel = proxy(_this.wheel, _this)));
      }

      if (options.toggleDragModeOnDblclick) {
        addListener(cropper, EVENT_DBLCLICK, (_this._dblclick = proxy(_this.dblclick, _this)));
      }

      addListener(document, EVENT_MOUSE_MOVE, (_this._cropMove = proxy(_this.cropMove, _this)));
      addListener(document, EVENT_MOUSE_UP, (_this._cropEnd = proxy(_this.cropEnd, _this)));

      if (options.responsive) {
        addListener(window, EVENT_RESIZE, (_this._resize = proxy(_this.resize, _this)));
      }
    },

    unbind: function () {
      var _this = this;
      var options = _this.options;
      var cropper = _this.cropper;

      removeListener(cropper, EVENT_MOUSE_DOWN, _this._cropStart);

      if (options.zoomable && options.zoomOnWheel) {
        removeListener(cropper, EVENT_WHEEL, _this._wheel);
      }

      if (options.toggleDragModeOnDblclick) {
        removeListener(cropper, EVENT_DBLCLICK, _this._dblclick);
      }

      removeListener(document, EVENT_MOUSE_MOVE, _this._cropMove);
      removeListener(document, EVENT_MOUSE_UP, _this._cropEnd);

      if (options.responsive) {
        removeListener(window, EVENT_RESIZE, _this._resize);
      }
    },

    resize: function () {
      var _this = this;
      var restore = _this.options.restore;
      var container = _this.container;
      var containerData = _this.containerData;
      var canvasData;
      var cropBoxData;
      var ratio;

      // Check `container` is necessary for IE8
      if (_this.disabled || !containerData) {
        return;
      }

      ratio = container.offsetWidth / containerData.width;

      // Resize when width changed or height changed
      if (ratio !== 1 || container.offsetHeight !== containerData.height) {
        if (restore) {
          canvasData = _this.getCanvasData();
          cropBoxData = _this.getCropBoxData();
        }

        _this.render();

        if (restore) {
          _this.setCanvasData(each(canvasData, function (n, i) {
            canvasData[i] = n * ratio;
          }));
          _this.setCropBoxData(each(cropBoxData, function (n, i) {
            cropBoxData[i] = n * ratio;
          }));
        }
      }
    },

    dblclick: function () {
      var _this = this;

      if (_this.disabled) {
        return;
      }

      _this.setDragMode(hasClass(_this.dragBox, CLASS_CROP) ? ACTION_MOVE : ACTION_CROP);
    },

    wheel: function (event) {
      var _this = this;
      var e = getEvent(event);
      var ratio = Number(_this.options.wheelZoomRatio) || 0.1;
      var delta = 1;

      if (_this.disabled) {
        return;
      }

      preventDefault(e);

      // Limit wheel speed to prevent zoom too fast (#21)
      if (_this.wheeling) {
        return;
      }

      _this.wheeling = true;

      setTimeout(function () {
        _this.wheeling = false;
      }, 50);

      if (e.deltaY) {
        delta = e.deltaY > 0 ? 1 : -1;
      } else if (e.wheelDelta) {
        delta = -e.wheelDelta / 120;
      } else if (e.detail) {
        delta = e.detail > 0 ? 1 : -1;
      }

      _this.zoom(-delta * ratio, e);
    },

    cropStart: function (event) {
      var _this = this;
      var options = _this.options;
      var e = getEvent(event);
      var touches = e.touches;
      var touchesLength;
      var touch;
      var action;

      if (_this.disabled) {
        return;
      }

      if (touches) {
        touchesLength = touches.length;

        if (touchesLength > 1) {
          if (options.zoomable && options.zoomOnTouch && touchesLength === 2) {
            touch = touches[1];
            _this.startX2 = touch.pageX;
            _this.startY2 = touch.pageY;
            action = ACTION_ZOOM;
          } else {
            return;
          }
        }

        touch = touches[0];
      }

      action = action || getData(e.target, DATA_ACTION);

      if (REGEXP_ACTIONS.test(action)) {
        if (isFunction(options.cropstart) && options.cropstart.call(_this.element, {
          originalEvent: e,
          action: action
        }) === false) {
          return;
        }

        preventDefault(e);

        _this.action = action;
        _this.cropping = false;

        _this.startX = touch ? touch.pageX : e.pageX;
        _this.startY = touch ? touch.pageY : e.pageY;

        if (action === ACTION_CROP) {
          _this.cropping = true;
          addClass(_this.dragBox, CLASS_MODAL);
        }
      }
    },

    cropMove: function (event) {
      var _this = this;
      var options = _this.options;
      var e = getEvent(event);
      var touches = e.touches;
      var action = _this.action;
      var touchesLength;
      var touch;

      if (_this.disabled) {
        return;
      }

      if (touches) {
        touchesLength = touches.length;

        if (touchesLength > 1) {
          if (options.zoomable && options.zoomOnTouch && touchesLength === 2) {
            touch = touches[1];
            _this.endX2 = touch.pageX;
            _this.endY2 = touch.pageY;
          } else {
            return;
          }
        }

        touch = touches[0];
      }

      if (action) {
        if (isFunction(options.cropmove) && options.cropmove.call(_this.element, {
          originalEvent: e,
          action: action
        }) === false) {
          return;
        }

        preventDefault(e);

        _this.endX = touch ? touch.pageX : e.pageX;
        _this.endY = touch ? touch.pageY : e.pageY;

        _this.change(e.shiftKey, action === ACTION_ZOOM ? e : null);
      }
    },

    cropEnd: function (event) {
      var _this = this;
      var options = _this.options;
      var e = getEvent(event);
      var action = _this.action;

      if (_this.disabled) {
        return;
      }

      if (action) {
        preventDefault(e);

        if (_this.cropping) {
          _this.cropping = false;
          toggleClass(_this.dragBox, CLASS_MODAL, _this.cropped && options.modal);
        }

        _this.action = '';

        if (isFunction(options.cropend)) {
          options.cropend.call(_this.element, {
            originalEvent: e,
            action: action
          });
        }
      }
    },

    change: function (shiftKey, originalEvent) {
      var _this = this;
      var options = _this.options;
      var aspectRatio = options.aspectRatio;
      var action = _this.action;
      var containerData = _this.containerData;
      var canvasData = _this.canvasData;
      var cropBoxData = _this.cropBoxData;
      var width = cropBoxData.width;
      var height = cropBoxData.height;
      var left = cropBoxData.left;
      var top = cropBoxData.top;
      var right = left + width;
      var bottom = top + height;
      var minLeft = 0;
      var minTop = 0;
      var maxWidth = containerData.width;
      var maxHeight = containerData.height;
      var renderable = true;
      var offset;
      var range;

      // Locking aspect ratio in "free mode" by holding shift key
      if (!aspectRatio && shiftKey) {
        aspectRatio = width && height ? width / height : 1;
      }

      if (_this.limited) {
        minLeft = cropBoxData.minLeft;
        minTop = cropBoxData.minTop;
        maxWidth = minLeft + min(containerData.width, canvasData.width);
        maxHeight = minTop + min(containerData.height, canvasData.height);
      }

      range = {
        x: _this.endX - _this.startX,
        y: _this.endY - _this.startY
      };

      if (aspectRatio) {
        range.X = range.y * aspectRatio;
        range.Y = range.x / aspectRatio;
      }

      switch (action) {
        // Move crop box
        case ACTION_ALL:
          left += range.x;
          top += range.y;
          break;

        // Resize crop box
        case ACTION_EAST:
          if (range.x >= 0 && (right >= maxWidth || aspectRatio &&
            (top <= minTop || bottom >= maxHeight))) {

            renderable = false;
            break;
          }

          width += range.x;

          if (aspectRatio) {
            height = width / aspectRatio;
            top -= range.Y / 2;
          }

          if (width < 0) {
            action = ACTION_WEST;
            width = 0;
          }

          break;

        case ACTION_NORTH:
          if (range.y <= 0 && (top <= minTop || aspectRatio &&
            (left <= minLeft || right >= maxWidth))) {

            renderable = false;
            break;
          }

          height -= range.y;
          top += range.y;

          if (aspectRatio) {
            width = height * aspectRatio;
            left += range.X / 2;
          }

          if (height < 0) {
            action = ACTION_SOUTH;
            height = 0;
          }

          break;

        case ACTION_WEST:
          if (range.x <= 0 && (left <= minLeft || aspectRatio &&
            (top <= minTop || bottom >= maxHeight))) {

            renderable = false;
            break;
          }

          width -= range.x;
          left += range.x;

          if (aspectRatio) {
            height = width / aspectRatio;
            top += range.Y / 2;
          }

          if (width < 0) {
            action = ACTION_EAST;
            width = 0;
          }

          break;

        case ACTION_SOUTH:
          if (range.y >= 0 && (bottom >= maxHeight || aspectRatio &&
            (left <= minLeft || right >= maxWidth))) {

            renderable = false;
            break;
          }

          height += range.y;

          if (aspectRatio) {
            width = height * aspectRatio;
            left -= range.X / 2;
          }

          if (height < 0) {
            action = ACTION_NORTH;
            height = 0;
          }

          break;

        case ACTION_NORTH_EAST:
          if (aspectRatio) {
            if (range.y <= 0 && (top <= minTop || right >= maxWidth)) {
              renderable = false;
              break;
            }

            height -= range.y;
            top += range.y;
            width = height * aspectRatio;
          } else {
            if (range.x >= 0) {
              if (right < maxWidth) {
                width += range.x;
              } else if (range.y <= 0 && top <= minTop) {
                renderable = false;
              }
            } else {
              width += range.x;
            }

            if (range.y <= 0) {
              if (top > minTop) {
                height -= range.y;
                top += range.y;
              }
            } else {
              height -= range.y;
              top += range.y;
            }
          }

          if (width < 0 && height < 0) {
            action = ACTION_SOUTH_WEST;
            height = 0;
            width = 0;
          } else if (width < 0) {
            action = ACTION_NORTH_WEST;
            width = 0;
          } else if (height < 0) {
            action = ACTION_SOUTH_EAST;
            height = 0;
          }

          break;

        case ACTION_NORTH_WEST:
          if (aspectRatio) {
            if (range.y <= 0 && (top <= minTop || left <= minLeft)) {
              renderable = false;
              break;
            }

            height -= range.y;
            top += range.y;
            width = height * aspectRatio;
            left += range.X;
          } else {
            if (range.x <= 0) {
              if (left > minLeft) {
                width -= range.x;
                left += range.x;
              } else if (range.y <= 0 && top <= minTop) {
                renderable = false;
              }
            } else {
              width -= range.x;
              left += range.x;
            }

            if (range.y <= 0) {
              if (top > minTop) {
                height -= range.y;
                top += range.y;
              }
            } else {
              height -= range.y;
              top += range.y;
            }
          }

          if (width < 0 && height < 0) {
            action = ACTION_SOUTH_EAST;
            height = 0;
            width = 0;
          } else if (width < 0) {
            action = ACTION_NORTH_EAST;
            width = 0;
          } else if (height < 0) {
            action = ACTION_SOUTH_WEST;
            height = 0;
          }

          break;

        case ACTION_SOUTH_WEST:
          if (aspectRatio) {
            if (range.x <= 0 && (left <= minLeft || bottom >= maxHeight)) {
              renderable = false;
              break;
            }

            width -= range.x;
            left += range.x;
            height = width / aspectRatio;
          } else {
            if (range.x <= 0) {
              if (left > minLeft) {
                width -= range.x;
                left += range.x;
              } else if (range.y >= 0 && bottom >= maxHeight) {
                renderable = false;
              }
            } else {
              width -= range.x;
              left += range.x;
            }

            if (range.y >= 0) {
              if (bottom < maxHeight) {
                height += range.y;
              }
            } else {
              height += range.y;
            }
          }

          if (width < 0 && height < 0) {
            action = ACTION_NORTH_EAST;
            height = 0;
            width = 0;
          } else if (width < 0) {
            action = ACTION_SOUTH_EAST;
            width = 0;
          } else if (height < 0) {
            action = ACTION_NORTH_WEST;
            height = 0;
          }

          break;

        case ACTION_SOUTH_EAST:
          if (aspectRatio) {
            if (range.x >= 0 && (right >= maxWidth || bottom >= maxHeight)) {
              renderable = false;
              break;
            }

            width += range.x;
            height = width / aspectRatio;
          } else {
            if (range.x >= 0) {
              if (right < maxWidth) {
                width += range.x;
              } else if (range.y >= 0 && bottom >= maxHeight) {
                renderable = false;
              }
            } else {
              width += range.x;
            }

            if (range.y >= 0) {
              if (bottom < maxHeight) {
                height += range.y;
              }
            } else {
              height += range.y;
            }
          }

          if (width < 0 && height < 0) {
            action = ACTION_NORTH_WEST;
            height = 0;
            width = 0;
          } else if (width < 0) {
            action = ACTION_SOUTH_WEST;
            width = 0;
          } else if (height < 0) {
            action = ACTION_NORTH_EAST;
            height = 0;
          }

          break;

        // Move canvas
        case ACTION_MOVE:
          _this.move(range.x, range.y);
          renderable = false;
          break;

        // Zoom canvas
        case ACTION_ZOOM:
          _this.zoom((function (x1, y1, x2, y2) {
            var z1 = sqrt(x1 * x1 + y1 * y1);
            var z2 = sqrt(x2 * x2 + y2 * y2);

            return (z2 - z1) / z1;
          })(
            abs(_this.startX - _this.startX2),
            abs(_this.startY - _this.startY2),
            abs(_this.endX - _this.endX2),
            abs(_this.endY - _this.endY2)
          ), originalEvent);
          _this.startX2 = _this.endX2;
          _this.startY2 = _this.endY2;
          renderable = false;
          break;

        // Create crop box
        case ACTION_CROP:
          if (!range.x || !range.y) {
            renderable = false;
            break;
          }

          offset = getOffset(_this.cropper);
          left = _this.startX - offset.left;
          top = _this.startY - offset.top;
          width = cropBoxData.minWidth;
          height = cropBoxData.minHeight;

          if (range.x > 0) {
            action = range.y > 0 ? ACTION_SOUTH_EAST : ACTION_NORTH_EAST;
          } else if (range.x < 0) {
            left -= width;
            action = range.y > 0 ? ACTION_SOUTH_WEST : ACTION_NORTH_WEST;
          }

          if (range.y < 0) {
            top -= height;
          }

          // Show the crop box if is hidden
          if (!_this.cropped) {
            removeClass(_this.cropBox, CLASS_HIDDEN);
            _this.cropped = true;

            if (_this.limited) {
              _this.limitCropBox(true, true);
            }
          }

          break;

        // No default
      }

      if (renderable) {
        cropBoxData.width = width;
        cropBoxData.height = height;
        cropBoxData.left = left;
        cropBoxData.top = top;
        _this.action = action;

        _this.renderCropBox();
      }

      // Override
      _this.startX = _this.endX;
      _this.startY = _this.endY;
    },

    // Show the crop box manually
    crop: function () {
      var _this = this;

      if (_this.built && !_this.disabled) {
        if (!_this.cropped) {
          _this.cropped = true;
          _this.limitCropBox(true, true);

          if (_this.options.modal) {
            addClass(_this.dragBox, CLASS_MODAL);
          }

          removeClass(_this.cropBox, CLASS_HIDDEN);
        }

        _this.setCropBoxData(_this.initialCropBoxData);
      }

      return _this;
    },

    // Reset the image and crop box to their initial states
    reset: function () {
      var _this = this;

      if (_this.built && !_this.disabled) {
        _this.imageData = extend({}, _this.initialImageData);
        _this.canvasData = extend({}, _this.initialCanvasData);
        _this.cropBoxData = extend({}, _this.initialCropBoxData);

        _this.renderCanvas();

        if (_this.cropped) {
          _this.renderCropBox();
        }
      }

      return _this;
    },

    // Clear the crop box
    clear: function () {
      var _this = this;

      if (_this.cropped && !_this.disabled) {
        extend(_this.cropBoxData, {
          left: 0,
          top: 0,
          width: 0,
          height: 0
        });

        _this.cropped = false;
        _this.renderCropBox();

        _this.limitCanvas();

        // Render canvas after crop box rendered
        _this.renderCanvas();

        removeClass(_this.dragBox, CLASS_MODAL);
        addClass(_this.cropBox, CLASS_HIDDEN);
      }

      return _this;
    },

    /**
     * Replace the image's src and rebuild the cropper
     *
     * @param {String} url
     */
    replace: function (url) {
      var _this = this;

      if (!_this.disabled && url) {
        if (_this.isImg) {
          _this.replaced = true;
          _this.element.src = url;
        }

        // Clear previous data
        _this.options.data = null;
        _this.load(url);
      }

      return _this;
    },

    // Enable (unfreeze) the cropper
    enable: function () {
      var _this = this;

      if (_this.built) {
        _this.disabled = false;
        removeClass(_this.cropper, CLASS_DISABLED);
      }

      return _this;
    },

    // Disable (freeze) the cropper
    disable: function () {
      var _this = this;

      if (_this.built) {
        _this.disabled = true;
        addClass(_this.cropper, CLASS_DISABLED);
      }

      return _this;
    },

    // Destroy the cropper and remove the instance from the image
    destroy: function () {
      var _this = this;
      var element = _this.element;
      var image = _this.image;

      if (_this.ready) {
        if (_this.isImg && _this.replaced) {
          element.src = _this.originalUrl;
        }

        _this.unbuild();
        removeClass(element, CLASS_HIDDEN);
      } else {
        if (_this.isImg) {
          removeListener(element, EVENT_LOAD, _this.start);
        } else if (image) {
          removeChild(image);
        }
      }

      removeData(element, NAMESPACE);

      return _this;
    },

    /**
     * Move the canvas with relative offsets
     *
     * @param {Number} offsetX
     * @param {Number} offsetY (optional)
     */
    move: function (offsetX, offsetY) {
      var _this = this;
      var canvasData = _this.canvasData;

      return _this.moveTo(
        isUndefined(offsetX) ? offsetX : canvasData.left + Number(offsetX),
        isUndefined(offsetY) ? offsetY : canvasData.top + Number(offsetY)
      );
    },

    /**
     * Move the canvas to an absolute point
     *
     * @param {Number} x
     * @param {Number} y (optional)
     */
    moveTo: function (x, y) {
      var _this = this;
      var canvasData = _this.canvasData;
      var changed = false;

      // If "y" is not present, its default value is "x"
      if (isUndefined(y)) {
        y = x;
      }

      x = Number(x);
      y = Number(y);

      if (_this.built && !_this.disabled && _this.options.movable) {
        if (isNumber(x)) {
          canvasData.left = x;
          changed = true;
        }

        if (isNumber(y)) {
          canvasData.top = y;
          changed = true;
        }

        if (changed) {
          _this.renderCanvas(true);
        }
      }

      return _this;
    },

    /**
     * Zoom the canvas with a relative ratio
     *
     * @param {Number} ratio
     * @param {Event} _originalEvent (private)
     */
    zoom: function (ratio, _originalEvent) {
      var _this = this;
      var canvasData = _this.canvasData;

      ratio = Number(ratio);

      if (ratio < 0) {
        ratio = 1 / (1 - ratio);
      } else {
        ratio = 1 + ratio;
      }

      return _this.zoomTo(canvasData.width * ratio / canvasData.naturalWidth, _originalEvent);
    },

    /**
     * Zoom the canvas to an absolute ratio
     *
     * @param {Number} ratio
     * @param {Event} _originalEvent (private)
     */
    zoomTo: function (ratio, _originalEvent) {
      var _this = this;
      var options = _this.options;
      var canvasData = _this.canvasData;
      var width = canvasData.width;
      var height = canvasData.height;
      var naturalWidth = canvasData.naturalWidth;
      var naturalHeight = canvasData.naturalHeight;
      var newWidth;
      var newHeight;
      var offset;
      var center;

      ratio = Number(ratio);

      if (ratio >= 0 && _this.built && !_this.disabled && options.zoomable) {
        newWidth = naturalWidth * ratio;
        newHeight = naturalHeight * ratio;

        if (isFunction(options.zoom) && options.zoom.call(_this.element, {
          originalEvent: _originalEvent,
          oldRatio: width / naturalWidth,
          ratio: newWidth / naturalWidth
        }) === false) {
          return _this;
        }

        if (_originalEvent) {
          offset = getOffset(_this.cropper);
          center = _originalEvent.touches ? getTouchesCenter(_originalEvent.touches) : {
            pageX: _originalEvent.pageX,
            pageY: _originalEvent.pageY
          };

          // Zoom from the triggering point of the event
          canvasData.left -= (newWidth - width) * (
            ((center.pageX - offset.left) - canvasData.left) / width
          );
          canvasData.top -= (newHeight - height) * (
            ((center.pageY - offset.top) - canvasData.top) / height
          );
        } else {

          // Zoom from the center of the canvas
          canvasData.left -= (newWidth - width) / 2;
          canvasData.top -= (newHeight - height) / 2;
        }

        canvasData.width = newWidth;
        canvasData.height = newHeight;
        _this.renderCanvas(true);
      }

      return _this;
    },

    /**
     * Rotate the canvas with a relative degree
     *
     * @param {Number} degree
     */
    rotate: function (degree) {
      var _this = this;

      return _this.rotateTo((_this.imageData.rotate || 0) + Number(degree));
    },

    /**
     * Rotate the canvas to an absolute degree
     * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function#rotate()
     *
     * @param {Number} degree
     */
    rotateTo: function (degree) {
      var _this = this;

      degree = Number(degree);

      if (isNumber(degree) && _this.built && !_this.disabled && _this.options.rotatable) {
        _this.imageData.rotate = degree % 360;
        _this.rotated = true;
        _this.renderCanvas(true);
      }

      return _this;
    },

    /**
     * Scale the image
     * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function#scale()
     *
     * @param {Number} scaleX
     * @param {Number} scaleY (optional)
     */
    scale: function (scaleX, scaleY) {
      var _this = this;
      var imageData = _this.imageData;
      var changed = false;

      // If "scaleY" is not present, its default value is "scaleX"
      if (isUndefined(scaleY)) {
        scaleY = scaleX;
      }

      scaleX = Number(scaleX);
      scaleY = Number(scaleY);

      if (_this.built && !_this.disabled && _this.options.scalable) {
        if (isNumber(scaleX)) {
          imageData.scaleX = scaleX;
          changed = true;
        }

        if (isNumber(scaleY)) {
          imageData.scaleY = scaleY;
          changed = true;
        }

        if (changed) {
          _this.renderImage(true);
        }
      }

      return _this;
    },

    /**
     * Scale the abscissa of the image
     *
     * @param {Number} scaleX
     */
    scaleX: function (scaleX) {
      var _this = this;
      var scaleY = _this.imageData.scaleY;

      return _this.scale(scaleX, isNumber(scaleY) ? scaleY : 1);
    },

    /**
     * Scale the ordinate of the image
     *
     * @param {Number} scaleY
     */
    scaleY: function (scaleY) {
      var _this = this;
      var scaleX = _this.imageData.scaleX;

      return _this.scale(isNumber(scaleX) ? scaleX : 1, scaleY);
    },

    /**
     * Get the cropped area position and size data (base on the original image)
     *
     * @param {Boolean} rounded (optional)
     * @return {Object} data
     */
    getData: function (rounded) {
      var _this = this;
      var options = _this.options;
      var imageData = _this.imageData;
      var canvasData = _this.canvasData;
      var cropBoxData = _this.cropBoxData;
      var ratio;
      var data;

      if (_this.built && _this.cropped) {
        data = {
          x: cropBoxData.left - canvasData.left,
          y: cropBoxData.top - canvasData.top,
          width: cropBoxData.width,
          height: cropBoxData.height
        };

        ratio = imageData.width / imageData.naturalWidth;

        each(data, function (n, i) {
          n = n / ratio;
          data[i] = rounded ? round(n) : n;
        });

      } else {
        data = {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        };
      }

      if (options.rotatable) {
        data.rotate = imageData.rotate || 0;
      }

      if (options.scalable) {
        data.scaleX = imageData.scaleX || 1;
        data.scaleY = imageData.scaleY || 1;
      }

      return data;
    },

    /**
     * Set the cropped area position and size with new data
     *
     * @param {Object} data
     */
    setData: function (data) {
      var _this = this;
      var options = _this.options;
      var imageData = _this.imageData;
      var canvasData = _this.canvasData;
      var cropBoxData = {};
      var rotated;
      var scaled;
      var ratio;

      if (isFunction(data)) {
        data = data.call(_this.element);
      }

      if (_this.built && !_this.disabled && isPlainObject(data)) {
        if (options.rotatable) {
          if (isNumber(data.rotate) && data.rotate !== imageData.rotate) {
            imageData.rotate = data.rotate;
            _this.rotated = rotated = true;
          }
        }

        if (options.scalable) {
          if (isNumber(data.scaleX) && data.scaleX !== imageData.scaleX) {
            imageData.scaleX = data.scaleX;
            scaled = true;
          }

          if (isNumber(data.scaleY) && data.scaleY !== imageData.scaleY) {
            imageData.scaleY = data.scaleY;
            scaled = true;
          }
        }

        if (rotated) {
          _this.renderCanvas();
        } else if (scaled) {
          _this.renderImage();
        }

        ratio = imageData.width / imageData.naturalWidth;

        if (isNumber(data.x)) {
          cropBoxData.left = data.x * ratio + canvasData.left;
        }

        if (isNumber(data.y)) {
          cropBoxData.top = data.y * ratio + canvasData.top;
        }

        if (isNumber(data.width)) {
          cropBoxData.width = data.width * ratio;
        }

        if (isNumber(data.height)) {
          cropBoxData.height = data.height * ratio;
        }

        _this.setCropBoxData(cropBoxData);
      }

      return _this;
    },

    /**
     * Get the container size data
     *
     * @return {Object} data
     */
    getContainerData: function () {
      var _this = this;

      return _this.built ? _this.containerData : {};
    },

    /**
     * Get the image position and size data
     *
     * @return {Object} data
     */
    getImageData: function () {
      var _this = this;

      return _this.ready ? _this.imageData : {};
    },

    /**
     * Get the canvas position and size data
     *
     * @return {Object} data
     */
    getCanvasData: function () {
      var _this = this;
      var canvasData = _this.canvasData;
      var data = {};

      if (_this.built) {
        each([
          'left',
          'top',
          'width',
          'height',
          'naturalWidth',
          'naturalHeight'
        ], function (n) {
          data[n] = canvasData[n];
        });
      }

      return data;
    },

    /**
     * Set the canvas position and size with new data
     *
     * @param {Object} data
     */
    setCanvasData: function (data) {
      var _this = this;
      var canvasData = _this.canvasData;
      var aspectRatio = canvasData.aspectRatio;

      if (isFunction(data)) {
        data = data.call(_this.element);
      }

      if (_this.built && !_this.disabled && isPlainObject(data)) {
        if (isNumber(data.left)) {
          canvasData.left = data.left;
        }

        if (isNumber(data.top)) {
          canvasData.top = data.top;
        }

        if (isNumber(data.width)) {
          canvasData.width = data.width;
          canvasData.height = data.width / aspectRatio;
        } else if (isNumber(data.height)) {
          canvasData.height = data.height;
          canvasData.width = data.height * aspectRatio;
        }

        _this.renderCanvas(true);
      }

      return _this;
    },

    /**
     * Get the crop box position and size data
     *
     * @return {Object} data
     */
    getCropBoxData: function () {
      var _this = this;
      var cropBoxData = _this.cropBoxData;
      var data;

      if (_this.built && _this.cropped) {
        data = {
          left: cropBoxData.left,
          top: cropBoxData.top,
          width: cropBoxData.width,
          height: cropBoxData.height
        };
      }

      return data || {};
    },

    /**
     * Set the crop box position and size with new data
     *
     * @param {Object} data
     */
    setCropBoxData: function (data) {
      var _this = this;
      var cropBoxData = _this.cropBoxData;
      var aspectRatio = _this.options.aspectRatio;
      var widthChanged;
      var heightChanged;

      if (isFunction(data)) {
        data = data.call(_this.element);
      }

      if (_this.built && _this.cropped && !_this.disabled && isPlainObject(data)) {

        if (isNumber(data.left)) {
          cropBoxData.left = data.left;
        }

        if (isNumber(data.top)) {
          cropBoxData.top = data.top;
        }

        if (isNumber(data.width)) {
          widthChanged = true;
          cropBoxData.width = data.width;
        }

        if (isNumber(data.height)) {
          heightChanged = true;
          cropBoxData.height = data.height;
        }

        if (aspectRatio) {
          if (widthChanged) {
            cropBoxData.height = cropBoxData.width / aspectRatio;
          } else if (heightChanged) {
            cropBoxData.width = cropBoxData.height * aspectRatio;
          }
        }

        _this.renderCropBox();
      }

      return _this;
    },

    /**
     * Get a canvas drawn the cropped image
     *
     * @param {Object} options (optional)
     * @return {HTMLCanvasElement} canvas
     */
    getCroppedCanvas: function (options) {
      var _this = this;
      var originalWidth;
      var originalHeight;
      var canvasWidth;
      var canvasHeight;
      var scaledWidth;
      var scaledHeight;
      var scaledRatio;
      var aspectRatio;
      var canvas;
      var context;
      var data;

      if (!_this.built || !_this.cropped || !SUPPORT_CANVAS) {
        return;
      }

      if (!isPlainObject(options)) {
        options = {};
      }

      data = _this.getData();
      originalWidth = data.width;
      originalHeight = data.height;
      aspectRatio = originalWidth / originalHeight;

      if (isPlainObject(options)) {
        scaledWidth = options.width;
        scaledHeight = options.height;

        if (scaledWidth) {
          scaledHeight = scaledWidth / aspectRatio;
          scaledRatio = scaledWidth / originalWidth;
        } else if (scaledHeight) {
          scaledWidth = scaledHeight * aspectRatio;
          scaledRatio = scaledHeight / originalHeight;
        }
      }

      // The canvas element will use `Math.floor` on a float number, so floor first
      canvasWidth = floor(scaledWidth || originalWidth);
      canvasHeight = floor(scaledHeight || originalHeight);

      canvas = createElement('canvas');
      canvas.width = canvasWidth;
      canvas.height = canvasHeight;
      context = canvas.getContext('2d');

      if (options.fillColor) {
        context.fillStyle = options.fillColor;
        context.fillRect(0, 0, canvasWidth, canvasHeight);
      }

      // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D.drawImage
      context.drawImage.apply(context, (function () {
        var source = getSourceCanvas(_this.image, _this.imageData);
        var sourceWidth = source.width;
        var sourceHeight = source.height;
        var args = [source];

        // Source canvas
        var srcX = data.x;
        var srcY = data.y;
        var srcWidth;
        var srcHeight;

        // Destination canvas
        var dstX;
        var dstY;
        var dstWidth;
        var dstHeight;

        if (srcX <= -originalWidth || srcX > sourceWidth) {
          srcX = srcWidth = dstX = dstWidth = 0;
        } else if (srcX <= 0) {
          dstX = -srcX;
          srcX = 0;
          srcWidth = dstWidth = min(sourceWidth, originalWidth + srcX);
        } else if (srcX <= sourceWidth) {
          dstX = 0;
          srcWidth = dstWidth = min(originalWidth, sourceWidth - srcX);
        }

        if (srcWidth <= 0 || srcY <= -originalHeight || srcY > sourceHeight) {
          srcY = srcHeight = dstY = dstHeight = 0;
        } else if (srcY <= 0) {
          dstY = -srcY;
          srcY = 0;
          srcHeight = dstHeight = min(sourceHeight, originalHeight + srcY);
        } else if (srcY <= sourceHeight) {
          dstY = 0;
          srcHeight = dstHeight = min(originalHeight, sourceHeight - srcY);
        }

        args.push(floor(srcX), floor(srcY), floor(srcWidth), floor(srcHeight));

        // Scale destination sizes
        if (scaledRatio) {
          dstX *= scaledRatio;
          dstY *= scaledRatio;
          dstWidth *= scaledRatio;
          dstHeight *= scaledRatio;
        }

        // Avoid "IndexSizeError" in IE and Firefox
        if (dstWidth > 0 && dstHeight > 0) {
          args.push(floor(dstX), floor(dstY), floor(dstWidth), floor(dstHeight));
        }

        return args;
      }).call(_this));

      return canvas;
    },

    /**
     * Change the aspect ratio of the crop box
     *
     * @param {Number} aspectRatio
     */
    setAspectRatio: function (aspectRatio) {
      var _this = this;
      var options = _this.options;

      if (!_this.disabled && !isUndefined(aspectRatio)) {

        // 0 -> NaN
        options.aspectRatio = max(0, aspectRatio) || NaN;

        if (_this.built) {
          _this.initCropBox();

          if (_this.cropped) {
            _this.renderCropBox();
          }
        }
      }

      return _this;
    },

    /**
     * Change the drag mode
     *
     * @param {String} mode (optional)
     */
    setDragMode: function (mode) {
      var _this = this;
      var options = _this.options;
      var dragBox = _this.dragBox;
      var face = _this.face;
      var croppable;
      var movable;

      if (_this.ready && !_this.disabled) {
        croppable = mode === ACTION_CROP;
        movable = options.movable && mode === ACTION_MOVE;
        mode = (croppable || movable) ? mode : ACTION_NONE;

        setData(dragBox, DATA_ACTION, mode);
        toggleClass(dragBox, CLASS_CROP, croppable);
        toggleClass(dragBox, CLASS_MOVE, movable);

        if (!options.cropBoxMovable) {

          // Sync drag mode to crop box when it is not movable
          setData(face, DATA_ACTION, mode);
          toggleClass(face, CLASS_CROP, croppable);
          toggleClass(face, CLASS_MOVE, movable);
        }
      }

      return _this;
    }
  };

  Cropper.DEFAULTS = {

    // Define the view mode of the cropper
    viewMode: 0, // 0, 1, 2, 3

    // Define the dragging mode of the cropper
    dragMode: 'crop', // 'crop', 'move' or 'none'

    // Define the aspect ratio of the crop box
    aspectRatio: NaN,

    // An object with the previous cropping result data
    data: null,

    // A selector for adding extra containers to preview
    preview: '',

    // Re-render the cropper when resize the window
    responsive: true,

    // Restore the cropped area after resize the window
    restore: true,

    // Check if the current image is a cross-origin image
    checkCrossOrigin: true,

    // Check the current image's Exif Orientation information
    checkOrientation: true,

    // Show the black modal
    modal: true,

    // Show the dashed lines for guiding
    guides: true,

    // Show the center indicator for guiding
    center: true,

    // Show the white modal to highlight the crop box
    highlight: true,

    // Show the grid background
    background: true,

    // Enable to crop the image automatically when initialize
    autoCrop: true,

    // Define the percentage of automatic cropping area when initializes
    autoCropArea: 0.8,

    // Enable to move the image
    movable: true,

    // Enable to rotate the image
    rotatable: true,

    // Enable to scale the image
    scalable: true,

    // Enable to zoom the image
    zoomable: true,

    // Enable to zoom the image by dragging touch
    zoomOnTouch: true,

    // Enable to zoom the image by wheeling mouse
    zoomOnWheel: true,

    // Define zoom ratio when zoom the image by wheeling mouse
    wheelZoomRatio: 0.1,

    // Enable to move the crop box
    cropBoxMovable: true,

    // Enable to resize the crop box
    cropBoxResizable: true,

    // Toggle drag mode between "crop" and "move" when click twice on the cropper
    toggleDragModeOnDblclick: true,

    // Size limitation
    minCanvasWidth: 0,
    minCanvasHeight: 0,
    minCropBoxWidth: 0,
    minCropBoxHeight: 0,
    minContainerWidth: 200,
    minContainerHeight: 100,

    // Shortcuts of events
    build: null,
    built: null,
    cropstart: null,
    cropmove: null,
    cropend: null,
    crop: null,
    zoom: null
  };

  Cropper.TEMPLATE = (function (source, words) {
    words = words.split(',');

    return source.replace(/\d+/g, function (i) {
      return words[i];
    });
  })('<0 6="5-container"><0 6="5-wrap-9"><0 6="5-canvas"></0></0><0 6="5-drag-9"></0><0 6="5-crop-9"><1 6="5-view-9"></1><1 6="5-8 8-h"></1><1 6="5-8 8-v"></1><1 6="5-center"></1><1 6="5-face"></1><1 6="5-7 7-e" 3-2="e"></1><1 6="5-7 7-n" 3-2="n"></1><1 6="5-7 7-w" 3-2="w"></1><1 6="5-7 7-s" 3-2="s"></1><1 6="5-4 4-e" 3-2="e"></1><1 6="5-4 4-n" 3-2="n"></1><1 6="5-4 4-w" 3-2="w"></1><1 6="5-4 4-s" 3-2="s"></1><1 6="5-4 4-ne" 3-2="ne"></1><1 6="5-4 4-nw" 3-2="nw"></1><1 6="5-4 4-sw" 3-2="sw"></1><1 6="5-4 4-se" 3-2="se"></1></0></0>', 'div,span,action,data,point,cropper,class,line,dashed,box');

  /*Cropper.TEMPLATE = (
    '<div class="cropper-container">' +
      '<div class="cropper-wrap-box">' +
        '<div class="cropper-canvas"></div>' +
      '</div>' +
      '<div class="cropper-drag-box"></div>' +
      '<div class="cropper-crop-box">' +
        '<span class="cropper-view-box"></span>' +
        '<span class="cropper-dashed dashed-h"></span>' +
        '<span class="cropper-dashed dashed-v"></span>' +
        '<span class="cropper-center"></span>' +
        '<span class="cropper-face"></span>' +
        '<span class="cropper-line line-e" data-action="e"></span>' +
        '<span class="cropper-line line-n" data-action="n"></span>' +
        '<span class="cropper-line line-w" data-action="w"></span>' +
        '<span class="cropper-line line-s" data-action="s"></span>' +
        '<span class="cropper-point point-e" data-action="e"></span>' +
        '<span class="cropper-point point-n" data-action="n"></span>' +
        '<span class="cropper-point point-w" data-action="w"></span>' +
        '<span class="cropper-point point-s" data-action="s"></span>' +
        '<span class="cropper-point point-ne" data-action="ne"></span>' +
        '<span class="cropper-point point-nw" data-action="nw"></span>' +
        '<span class="cropper-point point-sw" data-action="sw"></span>' +
        '<span class="cropper-point point-se" data-action="se"></span>' +
      '</div>' +
    '</div>'
  );*/

  var _Cropper = window.Cropper;

  Cropper.noConflict = function () {
    window.Cropper = _Cropper;
    return Cropper;
  };

  Cropper.setDefaults = function (options) {
    extend(Cropper.DEFAULTS, options);
  };

  if (typeof define === 'function' && define.amd) {
    define('cropper', [], function () {
      return Cropper;
    });
  }

  if (!noGlobal) {
    window.Cropper = Cropper;
  }

  return Cropper;

});
</script>

<dom-module id="nuxeo-image-viewer" assetpath="bower_components/nuxeo-ui-elements/viewers/">
  <template><style>.cropper-container{font-size:0;line-height:0;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;direction:ltr !important;-ms-touch-action:none;touch-action:none;-webkit-tap-highlight-color:transparent;-webkit-touch-callout:none;}.cropper-container img{display:block;width:100%;min-width:0 !important;max-width:none !important;height:100%;min-height:0 !important;max-height:none !important;image-orientation:0deg !important;}.cropper-wrap-box,
.cropper-canvas,
.cropper-drag-box,
.cropper-crop-box,
.cropper-modal{position:absolute;top:0;right:0;bottom:0;left:0;}.cropper-wrap-box{overflow:hidden;}.cropper-drag-box{opacity:0;background-color:#fff;filter:alpha(opacity=0);}.cropper-modal{opacity:.5;background-color:#000;filter:alpha(opacity=50);}.cropper-view-box{display:block;overflow:hidden;width:100%;height:100%;outline:1px solid #39f;outline-color:rgba(51, 153, 255, .75);}.cropper-dashed{position:absolute;display:block;opacity:.5;border:0 dashed #eee;filter:alpha(opacity=50);}.cropper-dashed.dashed-h{top:33.33333%;left:0;width:100%;height:33.33333%;border-top-width:1px;border-bottom-width:1px;}.cropper-dashed.dashed-v{top:0;left:33.33333%;width:33.33333%;height:100%;border-right-width:1px;border-left-width:1px;}.cropper-center{position:absolute;top:50%;left:50%;display:block;width:0;height:0;opacity:.75;filter:alpha(opacity=75);}.cropper-center:before,
.cropper-center:after{position:absolute;display:block;content:' ';background-color:#eee;}.cropper-center:before{top:0;left:-3px;width:7px;height:1px;}.cropper-center:after{top:-3px;left:0;width:1px;height:7px;}.cropper-face,
.cropper-line,
.cropper-point{position:absolute;display:block;width:100%;height:100%;opacity:.1;filter:alpha(opacity=10);}.cropper-face{top:0;left:0;background-color:#fff;}.cropper-line{background-color:#39f;}.cropper-line.line-e{top:0;right:-3px;width:5px;cursor:e-resize;}.cropper-line.line-n{top:-3px;left:0;height:5px;cursor:n-resize;}.cropper-line.line-w{top:0;left:-3px;width:5px;cursor:w-resize;}.cropper-line.line-s{bottom:-3px;left:0;height:5px;cursor:s-resize;}.cropper-point{width:5px;height:5px;opacity:.75;background-color:#39f;filter:alpha(opacity=75);}.cropper-point.point-e{top:50%;right:-3px;margin-top:-3px;cursor:e-resize;}.cropper-point.point-n{top:-3px;left:50%;margin-left:-3px;cursor:n-resize;}.cropper-point.point-w{top:50%;left:-3px;margin-top:-3px;cursor:w-resize;}.cropper-point.point-s{bottom:-3px;left:50%;margin-left:-3px;cursor:s-resize;}.cropper-point.point-ne{top:-3px;right:-3px;cursor:ne-resize;}.cropper-point.point-nw{top:-3px;left:-3px;cursor:nw-resize;}.cropper-point.point-sw{bottom:-3px;left:-3px;cursor:sw-resize;}.cropper-point.point-se{right:-3px;bottom:-3px;width:20px;height:20px;cursor:se-resize;opacity:1;filter:alpha(opacity=100);}.cropper-point.point-se:before{position:absolute;right:-50%;bottom:-50%;display:block;width:200%;height:200%;content:' ';opacity:0;background-color:#39f;filter:alpha(opacity=0);}@media (min-width: 768px){.cropper-point.point-se{width:15px;height:15px;}}@media (min-width: 992px){.cropper-point.point-se{width:10px;height:10px;}}@media (min-width: 1200px){.cropper-point.point-se{width:5px;height:5px;opacity:.75;filter:alpha(opacity=75);}}.cropper-invisible{opacity:0;filter:alpha(opacity=0);}.cropper-bg{background-image:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQAQMAAAAlPW0iAAAAA3NCSVQICAjb4U/gAAAABlBMVEXMzMz////TjRV2AAAACXBIWXMAAArrAAAK6wGCiw1aAAAAHHRFWHRTb2Z0d2FyZQBBZG9iZSBGaXJld29ya3MgQ1M26LyyjAAAABFJREFUCJlj+M/AgBVhF/0PAH6/D/HkDxOGAAAAAElFTkSuQmCC");}.cropper-hide{position:absolute;display:block;width:0;height:0;}.cropper-hidden{display:none !important;}.cropper-move{cursor:move;}.cropper-crop{cursor:crosshair;}.cropper-disabled .cropper-drag-box,
.cropper-disabled .cropper-face,
.cropper-disabled .cropper-line,
.cropper-disabled .cropper-point{cursor:not-allowed;}</style>
    <style>
      :host {
        display: block;
        position: relative;
      }

      #canvas {
        position: absolute;
        width: 100%;
        height: 100%;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
      }

      #toolbar {
        position: absolute;
        bottom: 16px;
        max-width: 300px;
        left: 50%;
        transform: translateX(-50%);
        color: #fff;
        z-index: 25;
        text-align: center;
        padding: 2px;
        border-radius: 4px;
        background-color: rgba(0, 0, 0, 0.5);
      }

      paper-icon-button {
        width: 34px;
        height: 34px;
        color: white !important;
        --paper-icon-button-ink-color: white;
      }

      #image {
        display: none;
        max-width: 100%;
        max-height: 100%;
      }
    </style>

    <div id="canvas">
      <img id="image" src$="[[src]]" on-load="_init">
      <dom-if if="[[controls]]">
        <template>
          <div id="toolbar">
            <paper-icon-button on-click="_click" icon="zoom-out" data-action="zoom-out"></paper-icon-button>
            <paper-icon-button on-click="_click" icon="[[_getFitIcon(_fitToRealSize)]]" data-action$="[[_computeFitAction(_fitToRealSize)]]"></paper-icon-button>
            <paper-icon-button on-click="_click" icon="zoom-in" data-action="zoom-in"></paper-icon-button>
            <paper-icon-button on-click="_click" icon="image:rotate-left" data-action="rotate-left"></paper-icon-button>
            <paper-icon-button on-click="_click" icon="image:rotate-right" data-action="rotate-right"></paper-icon-button>
          </div>
        </template>
      </dom-if>
    </div>
  </template>

  <script>
    {
      /**
       * An element for viewing images.
       *
       * Example:
       *
       *     <nuxeo-image-viewer src="[[document.properties.file:content.data]]"
       *                         controls
       *                         responsive>
       *     </nuxeo-image-viewer>
       *
       * @appliesMixin Polymer.IronResizableBehavior
       * @memberof Nuxeo
       * @demo demo/nuxeo-image-viewer/index.html
       */
      class ImageViewer extends Polymer.mixinBehaviors([Polymer.IronResizableBehavior], Nuxeo.Element) {

        static get is() {
          return 'nuxeo-image-viewer';
        }

        static get properties() {
          return {
            /**
             * The URL of an image.
             */
            src: {
              type: String,
            },

            /**
             * If true, controls for the user to interact with are displayed.
             */
            controls: {
              type: Boolean,
              value: false,
            },

            /**
             * If true, allows to zoom the image by wheeling mouse.
             */
            zoomOnWheel: {
              type: Boolean,
              value: false,
            },

            /**
             * If true, the element exhibits responsive resize behavior.
             */
            responsive: {
              type: Boolean,
              value: false,
            },

            /**
             * If false, the element will show the image in order to fit the viewer.
             * If true, the element will show the image in real size.
             */
            _fitToRealSize: {
              type: Boolean,
              value: false,
            },
          };
        }

        ready() {
          super.ready();
          this.addEventListener('iron-resize', this._resize);
        }

        _init() {
          if (this._el) {
            this._el.destroy();
          }

          if (this.src) {
            const options = {
              autoCrop: false,
              background: false,
              checkCrossOrigin: false,
              checkOrientation: false,
              dragMode: 'move',
              responsive: false,
              restore: false,
              toggleDragModeOnDblclick: false,
              viewMode: 1,
              zoomOnWheel: this.zoomOnWheel,
              zoom: (data) => this._verifyZoomRatio(data),
            };
            this._el = new Cropper(this.$.image, options);
          }
        }

        _click(event) {
          const action = event.target.dataset.action || event.target.parentNode.dataset.action;
          switch (action) {
            case 'zoom-in':
              this._el.zoom(0.1);
              break;
            case 'zoom-out':
              this._el.zoom(-0.1);
              break;
            case 'fit-to-viewer':
              this._el.zoomTo(this._getOriginalZoomRatio());
              break;
            case 'fit-to-real-size':
              this._el.zoomTo(1);
              break;
            case 'rotate-left':
              this._el.rotate(-90);
              break;
            case 'rotate-right':
              this._el.rotate(90);
              break;
            default:
              // do nothing
          }
        }

        _computeFitAction(fitToRealSize) {
          return fitToRealSize ? 'fit-to-viewer' : 'fit-to-real-size';
        }

        _getFitIcon(fitToRealSize) {
          return `nuxeo:${this._computeFitAction(fitToRealSize)}`;
        }

        _getOriginalZoomRatio() {
          if (this._el) {
            const canvasData = this._el.initialCanvasData;
            return canvasData.width / canvasData.naturalWidth;
          }
        }

        _resize() {
          if (this._el) {
            this._el.resize();
            this._fitToRealSize = false;
          }
        }

        _verifyZoomRatio(data) {
          if (this._el) {
            // Cropper.js not always return the same number of decimal places and rounding.
            // In order to ensure our calculations, we will use 5 decimal places.
            const decimalPlaces = 5;
            this._fitToRealSize = this._getOriginalZoomRatio().toFixed(decimalPlaces) !== data.ratio.toFixed(decimalPlaces);
          }
        }
      }

      customElements.define(ImageViewer.is, ImageViewer);
      Nuxeo.ImageViewer = ImageViewer;
    }
  </script>
</dom-module>
<dom-module id="nuxeo-pdf-viewer" assetpath="bower_components/nuxeo-ui-elements/viewers/">

  <template>
    <style>
      :host {
        display: block;
        @apply --nuxeo-pdf-viewer-layout;
      }

      iframe {
        width: 100%;
        height: 100%;
        border: 0;
        @apply --nuxeo-pdf-viewer-iframe;
      }
    </style>

    <iframe src$="[[_path(src)]]"></iframe>

  </template>

  <script>
    {
      /**
       * An element for viewing PDF files.
       *
       * Example:
       *
       *     <nuxeo-pdf-viewer src="sample.pdf"></nuxeo-pdf-viewer>
       *
       * ### Styling
       *
       * The following custom properties and mixins are available for styling:
       *
       * Custom property | Description | Default
       * ----------------|-------------|----------
       * `--nuxeo-pdf-viewer-layout` | Mixin applied to the viewer | `{}`
       * `--nuxeo-pdf-viewer-iframe` | Mixin applied to the iframe enclosing pdfjs | `{}`
       *
       *
       * @memberof Nuxeo
       * @demo demo/nuxeo-pdf-viewer/index.html
       */
      class PDFViewer extends Nuxeo.Element {

        static get is() {
          return 'nuxeo-pdf-viewer';
        }

        static get properties() {
          return {
            /**
             * The path to the pdf file to display.
             */
            src: {
              type: String,
            },
          };
        }

        _path(file) {
          // get an absolute href
          const el = document.createElement('a');
          el.href = file;
          return this.resolveUrl(`pdfjs/web/viewer.html?file=${encodeURI(el.href)}`);
        }

      }

      customElements.define(PDFViewer.is, PDFViewer);
      Nuxeo.PDFViewer = PDFViewer;
    }
  </script>
</dom-module>
<dom-module id="nuxeo-video-viewer" assetpath="bower_components/nuxeo-ui-elements/viewers/">
  <template>
    <style>
      :host {
        display: block;
      }

      #container {
        display: block;
        width: 100%;
        height: 100%;
        @apply --layout-vertical;
      }

      #video {
        background: var(--primary-background-color);
        max-height: 100%;
        width: 100%;
        outline: none;
        @apply --layout-flex;
      }

      #video.hasStoryboard {
        max-height: calc(100% - 85px);
      }

      #storyboard {
        background: var(--primary-background-color);
      }

      #thumbnails {
        overflow-x: auto;
        @apply --layout-horizontal;
      }

      .thumbnail {
        cursor: pointer;
        height: 85px;
        padding: 4px 4px 2px 0;
      }
    </style>

    <div id="container">
      <video id="video" controls$="[[controls]]" width="[[width]]" height="[[height]]" preload="[[preload]]" poster="[[poster]]">
        <dom-repeat items="[[sources]]" as="source">
          <template>
            <source src="[[source.data]]" type="[[source.type]]">
          </template>
        </dom-repeat>
      </video>

      <dom-if if="[[_hasStoryboard(storyboard)]]">
        <template>
          <div id="storyboard">
            <div id="thumbnails">
              <dom-repeat items="[[storyboard]]" as="thumbnail">
                <template>
                  <img class="thumbnail" on-click="_jumpTo" src="[[thumbnail.content.data]]">
                </template>
              </dom-repeat>
            </div>
          </div>
        </template>
      </dom-if>
    </div>
  </template>

  <script>
    {
      /**
       * An element for viewing videos.
       *
       * Example:
       *
       *     <nuxeo-video-viewer sources="[[sources]]" controls preload="auto"></nuxeo-video-viewer>
       *
       * @memberof Nuxeo
       * @demo demo/nuxeo-video-viewer/index.html
       */
      class VideoViewer extends Nuxeo.Element {

        static get is() {
          return 'nuxeo-video-viewer';
        }

        static get properties() {
          return {
            /**
             * The `preload` attribute specifies if/how the video should be loaded.
             */
            preload: {
              type: String,
              value: 'auto',
            },

            /**
             * If true, controls for the user to interact with are displayed.
             */
            controls: {
              type: Boolean,
              value: false,
            },

            /**
             * The `poster` attribute specifies an image shown while downloading.
             */
            poster: String,

            /**
             * The `sources` to be displayed.
             */
            sources: Object,

            /**
             * The storyboard (array of thumbnails) for video navigation. If null or empty, the storyboard is not shown.
             */
            storyboard: {
              type: Array,
              value: [],
            },
          };
        }

        play() {
          this.$.video.play();
        }

        stop() {
          this.$.video.pause();
          this.$.video.currentTime = 0;
        }

        pause() {
          this.$.video.pause();
        }

        isPaused() {
          return this.$.video.paused;
        }

        _hasStoryboard() {
          const hasStoryboard = this.storyboard && this.storyboard.length > 0;
          if (hasStoryboard) {
            this.$.video.classList.add('hasStoryboard');
          } else {
            this.$.video.classList.remove('hasStoryboard');
          }
          return hasStoryboard;
        }

        _jumpTo(e) {
          this.$.video.currentTime = e.model.thumbnail.timecode;
        }

      }

      customElements.define(VideoViewer.is, VideoViewer);
      Nuxeo.VideoViewer = VideoViewer;
    }
  </script>
</dom-module>
<dom-module id="nuxeo-document-preview" assetpath="bower_components/nuxeo-ui-elements/">
  <template>
    <style>
      :host {
        display: block;
      }

      nuxeo-image-viewer {
        width: 100%;
        height: 100%;
        min-height: var(--nuxeo-viewer-min-height, 60vh);
      }

      nuxeo-video-viewer {
        width: 100%;
        height: 100%;
      }

      audio {
        width: calc(100% - 16px);
        margin: 8px;
      }

      marked-element {
        background-color: white;
      }

      nuxeo-pdf-viewer {
        width: 100%;
        height: 100%;
        min-height: var(--nuxeo-viewer-min-height, 60vh);
      }

      iframe {
        height: 100%;
        min-height: var(--nuxeo-viewer-min-height, 60vh);
        width: 100%;
        border: none;
        padding: 0;
        margin: 0;
      }

      #xml {
        font-family: monospace;
        white-space: pre;
      }

      #preview {
        border: none;
        width: 100%;
        height: 100%;
      }

    </style>

    <template mime-pattern="image.*|application/photoshop|illustrator|postscript">
      <nuxeo-image-viewer src="[[_computeImageSource(_blob)]]" controls="" responsive=""></nuxeo-image-viewer>
    </template>

    <template mime-pattern="video.*|application/(g|m)xf">
      <nuxeo-video-viewer id="video" controls="" sources="[[_computeVideoSources(_blob)]]" storyboard="[[_computeStoryboard(_blob)]]"></nuxeo-video-viewer>
    </template>

    <template mime-pattern="audio.*">
      <audio id="audio" controls=""><source src="[[_computeAudioSource(_blob)]]">AUDIO</audio>
    </template>

    <template mime-pattern="text/(?:.*-)?(markdown|html|plain)">
      <marked-element markdown="[[_blob.text]]"></marked-element>
    </template>

    <template mime-pattern="text/xml">
      <div id="xml">[[_blob.text]]</div>
    </template>

    <template mime-pattern="application/pdf">
      <nuxeo-pdf-viewer src="[[_blob.data]]"></nuxeo-pdf-viewer>
    </template>

    <template mime-pattern=".*">
      <iframe id="frame" src="[[_computeIFrameSource(_blob)]]"></iframe>
    </template>

    <div id="preview"></div>

  </template>

  <script>
    {
      /**
       * An element to display a preview of a document.
       *
       * Example:
       *
       *     <nuxeo-document-preview document="[[document]]"></nuxeo-document-preview>
       *
       * @appliesMixin Polymer.Templatizer
       * @appliesMixin Polymer.IronResizableBehavior
       * @memberof Nuxeo
       * @demo demo/nuxeo-document-preview/index.html
       */
      class DocumentPreview
        extends Polymer.mixinBehaviors([Polymer.Templatizer, Polymer.IronResizableBehavior], Nuxeo.Element) {

        static get is() {
          return 'nuxeo-document-preview';
        }

        static get properties() {
          return {
            /**
             * Document
             */
            document: Object,

            /**
             * By default it will display a preview of the main file.
             * For example using `xpath="files:files/0/file"` will display the preview of the document's first attachment.
             */
            xpath: {
              type: String,
              value: 'file:content',
            },

            _blob: Object,
          };
        }

        static get observers() {
          return [
            '_updateBlob(document, xpath)',
          ];
        }

        ready() {
          super.ready();
          this.addEventListener('iron-resize', this._onResize);
        }

        stop() {
          const video = this.$$('#video');
          if (video) {
            video.stop();
          }

          const audio = this.$$('#audio');
          if (audio) {
            audio.pause();
            audio.currentTime = 0;
          }
        }

        _updateBlob() {
          if (this.document) {
            // adapt the Note to mimic a Blob
            if (this.document.type === 'Note' && this.xpath === 'file:content') {
              this._blob = {
                text: this.document.properties['note:note'],
                'mime-type': this.document.properties['note:mime_type'],
              };
            } else {
              // by default just use the field at xpath as a Blob
              this._blob = this.document && this._deepFind(this.document.properties, this.xpath);
            }
            // update our previewer
            this._updatePreview();
          }
        }

        _updatePreview() {
          // clear current previewer
          while (this.$.preview.firstChild) {
            this.$.preview.removeChild(this.$.preview.firstChild);
          }

          // lookup the preview according to the blob's mimetype
          const previewers = Polymer.dom(this.root).querySelectorAll('template');
          for (let i = 0; i < previewers.length; i++) {
            const previewer = previewers[i];
            const mimetype = previewer.getAttribute('mime-pattern');
            const mimetypeRegex = new RegExp(mimetype);
            if (mimetypeRegex.test(this._blob && this._blob['mime-type']) &&
               (!mimetype.startsWith('text/') || 'text' in this._blob)) {
              // Insert our previewer
              delete previewer.__templatizeOwner;
              this.templatize(previewer);
              const instance = this.stamp();
              Object.keys(this.constructor.properties).forEach((prop) => instance._setPendingProperty(prop, this[prop]));
              instance._flushProperties();
              this.$.preview.appendChild(instance.root);
              break;
            }
          }
        }

        _deepFind(obj, props) {
          for (let i = 0, path = props.split('/'), len = path.length; i < len; i++) {
            if (!obj || obj === []) {
              break;
            }
            obj = obj[path[i]];
          }
          return obj;
        }

        _computeImageSource() {
          if (this.document && this.document.properties && this.document.properties['picture:views']
              && this.xpath === 'file:content') {
            const filteredViews = this.document.properties['picture:views'].filter((view) => view.title === 'FullHD');
            if (filteredViews.length > 0) {
              return filteredViews[0].content.data;
            }
          }
          if (this.xpath) {
            if (this._blob && this._blob['mime-type'] && this._blob['mime-type'].match('image.*')) {
              return this._blob.data;
            }
          }
        }

        _computeVideoSources() {
          if (this.document && this.document.properties && this.document.properties['vid:transcodedVideos']
              && this.xpath === 'file:content') {
            const conversions = [];
            this.document.properties['vid:transcodedVideos'].forEach((conversion) => {
              if (conversion && conversion.content && conversion.content.data && conversion.content['mime-type']) {
                conversions.push({
                  data: conversion.content.data,
                  type: conversion.content['mime-type'],
                });
              }
            });
            return conversions;
          }
          // fallback to blob data if there are no transcoded videos (e.g. video documents managed by liveconnect)
          if (this.xpath) {
            if (this._blob && this._blob['mime-type'] && this._blob['mime-type'].match('video.*|application/(g|m)xf')) {
              return [{
                data: this._blob.data,
                type: this._blob['mime-type'],
              }];
            }
          }
        }

        _computeStoryboard() {
          if (this.document && this.document.properties && this.document.properties['vid:storyboard']
              && this.xpath === 'file:content') {
            return this.document.properties['vid:storyboard'];
          }
        }

        _computeAudioSource() {
          if (this._blob) {
            return this._blob.data;
          }
        }

        _computeIFrameSource() {
          if (this.document && this.document.contextParameters && this.document.contextParameters.preview) {
            let url = this.document.contextParameters.preview.url;
            if (this.xpath !== 'file:content') {
              url = url.replace('/@preview/', `/@blob/${this.xpath}/@preview/`);
            }
            return url;
          } else if (this._blob) {
            return this._blob.data;
          }
        }

        /**
         * Automatically pauses the audio/video if the document preview is not visible anymore.
         */
        _onResize() {
          if (!this._isVisible) {
            const audio = this.$$('#audio');
            if (audio && !audio.paused) {
              audio.pause();
              return;
            }
            const video = this.$$('#video');
            if (video && !video.isPaused()) {
              video.pause();
            }
          }
        }

        get _isVisible() {
          return Boolean(this.offsetWidth || this.offsetHeight);
        }

      }

      customElements.define(DocumentPreview.is, DocumentPreview);
      Nuxeo.DocumentPreview = DocumentPreview;
    }
  </script>
</dom-module>
<script>
  /* eslint-disable no-var, no-use-before-define */
  var Nuxeo = Nuxeo || {};
  (() => {

    /**
     * @polymerBehavior Nuxeo.AggregationBehavior
     */
    Nuxeo.AggregationBehavior = {
      properties: {

        data: {
          type: Object,
        },

        value: {
          type: Array,
          value: [],
          notify: true,
        },

        buckets: {
          type: Object,
          computed: '_computeBuckets(data)',
        },

        _isEmpty: {
          type: Boolean,
          value: true,
        },

        /**
         * Sort buckets by label instead of doc count.
         */
        sortByLabel: Boolean,

        /**
         * Function used to format the label of the aggregate entry.
         */
        labelFormatter: {
          type: Function,
          value() {
            return this._computeLabel.bind(this);
          },
        },

      },

      observers: [
        '_observeData(data)',
      ],

      _observeData() {
        if (this.data && this.data.extendedBuckets) {
          this._isEmpty = this.data.extendedBuckets.length === 0;
        } else {
          this._isEmpty = true;
        }
      },

      _computeBuckets(data) {
        if (data) {
          const buckets = data.extendedBuckets;
          const selectedBuckets = data.selection;
          buckets.forEach((item) => {
            item.checked = selectedBuckets.indexOf(item.key) >= 0;
            item.label = this.labelFormatter(item);
          });
          if (this.sortByLabel) {
            buckets.sort((a, b) => {
              if (a.label < b.label) {
                return -1;
              } else if (a.label > b.label) {
                return 1;
              }
              return 0;
            });
          }
          return buckets;
        }
      },

      _computeValues() {
        const values = [];
        this.buckets.forEach((item) => {
          if (item.checked) {
            values.push(item.key);
          }
        });
        this.value = values;
      },

      _computeLabel(item) {
        let i18nKey;
        if (item.fetchedKey) {
          const entry = item.fetchedKey;
          if (entry['entity-type'] === 'directoryEntry') {
            return this.labelForDirectoryEntry(entry);
          } else if (entry['entity-type'] === 'user') {
            return this.labelForUserEntry(entry);
          } else if (entry['entity-type'] === 'document') {
            return entry.properties['dc:title'] || this.i18n('aggregation.format.document.field.unknown', 'dc:title');
          } else {
            i18nKey = this.i18n(`label.ui.aggregate.${item.key}`);
            return i18nKey === `label.ui.aggregate.${item.key}` ? item.key : i18nKey;
          }
        } else {
          i18nKey = this.i18n(`label.ui.aggregate.${item.key}`);
          return i18nKey === `label.ui.aggregate.${item.key}` ? item.key : i18nKey;
        }
      },

      labelForDirectoryEntry(entry) {
        let lang = window.nuxeo.I18n.language || 'en';
        if (lang.indexOf('-') > -1) {
          lang = lang.split('-')[0];
        }
        const labels = [];
        while (entry) {
          if (entry.properties[`label_${lang}`]) {
            labels.push(entry.properties[`label_${lang}`]);
          } else if (entry.properties.label) {
            labels.push(entry.properties.label);
          } else if (entry.properties.label_en) {
            labels.push(entry.properties.label_en);
          } else {
            labels.push(entry.properties.id);
          }
          entry = entry.properties.parent;
        }
        return labels.reverse().join('/');
      },

      labelForUserEntry(entry) {
        if (entry.properties === undefined) {
          return entry.id;
        } else if (entry.properties.firstName && entry.properties.firstName.length > 0
         && entry.properties.lastName && entry.properties.lastName.length > 0) {
          return `${entry.properties.firstName} ${entry.properties.lastName}`;
        } else {
          return entry.properties.username;
        }
      },

    };
  })();
</script>
<dom-module id="nuxeo-checkbox-aggregation" assetpath="bower_components/nuxeo-ui-elements/nuxeo-aggregation/">
 <template>
   <style>
     :host {
       @apply --layout-vertical;
     }
     paper-checkbox {
       --paper-checkbox-label-spacing: 10px;
       margin-bottom: 5px;
     }
   </style>

    <dom-repeat items="{{buckets}}">
      <template>
        <paper-checkbox noink="" checked="{{item.checked}}" on-change="_computeValues">
          [[item.label]] ([[item.docCount]])
        </paper-checkbox>
      </template>
    </dom-repeat>
    <dom-if if="[[_isEmpty]]">
      <template>
        <label>[[i18n('checkboxAggregation.noResults')]]</label>
      </template>
    </dom-if>

 </template>
 <script>
   {
     /**
      * An element to interact with page provider aggregations as checkboxes.
      *
      *     <nuxeo-page-provider provider="default_search" auto
      *                          aggregations="{{aggregations}}"
      *                          params="[[params]]">
      *     </nuxeo-page-provider>
      *
      *     <nuxeo-checkbox-aggregation data="[[aggregations.dc_created_agg]]"
      *                                 value="{{params.dc_created_agg}}">
      *     </nuxeo-checkbox-aggregation>
      *
      * @appliesMixin Nuxeo.I18nBehavior
      * @appliesMixin Nuxeo.AggregationBehavior
      * @memberof Nuxeo
      * @demo demo/nuxeo-checkbox-aggregation/index.html
      */
     class CheckboxAggregation
       extends Polymer.mixinBehaviors([Nuxeo.I18nBehavior, Nuxeo.AggregationBehavior], Nuxeo.Element) {

       static get is() {
         return 'nuxeo-checkbox-aggregation';
       }
     }

     customElements.define(CheckboxAggregation.is, CheckboxAggregation);
     Nuxeo.CheckboxAggregation = CheckboxAggregation;
   }
 </script>
</dom-module>
<dom-module id="nuxeo-dropdown-aggregation" assetpath="bower_components/nuxeo-ui-elements/nuxeo-aggregation/">
  <template>
    <style>
      :host {
        display: block;
        width: 100%;
      }

      [hidden] {
        display: none;
      }
    </style>

    <nuxeo-selectivity data="[[_computeData(buckets)]]" min-chars="[[minChars]]" multiple="[[multiple]]" placeholder="[[placeholder]]" value="{{value}}">
    </nuxeo-selectivity>

  </template>
  <script>
    {
      /**
       * An element to interact with page provider aggregations as suggestions.
       *
       *     <nuxeo-page-provider provider="default_search" auto
       *                          aggregations="{{aggregations}}"
       *                          params="[[params]]">
       *     </nuxeo-page-provider>
       *
       *     <nuxeo-dropdown-aggregation data="[[aggregations.dc_creator_agg]]" multiple
       *                                 value="{{params.dc_creator_agg}}">
       *     </nuxeo-dropdown-aggregation>
       *
       * @appliesMixin Nuxeo.I18nBehavior
       * @appliesMixin Nuxeo.AggregationBehavior
       * @memberof Nuxeo
       * @demo demo/nuxeo-dropdown-aggregation/index.html
       */
      class DropdownAggregation
        extends Polymer.mixinBehaviors([Nuxeo.I18nBehavior, Nuxeo.AggregationBehavior], Nuxeo.Element) {

        static get is() {
          return 'nuxeo-dropdown-aggregation';
        }

        static get properties() {
          return {
            value: {
              type: Array,
              value: [],
              notify: true,
            },

            multiple: {
              type: Boolean,
              value: false,
            },

            minChars: {
              type: Number,
              value: 0,
            },

            placeholder: String,
          };
        }

        _computeData(buckets) {
          if (buckets) {
            return buckets.map((item) => {
              const label = `${item.label} (${item.docCount})`;
              return {
                id: item.key,
                text: label,
                displayLabel: label,
              };
            });
          } else {
            return [];
          }
        }

      }

      customElements.define(DropdownAggregation.is, DropdownAggregation);
      Nuxeo.DropdownAggregation = DropdownAggregation;
    }
  </script>
</dom-module>
<dom-module id="nuxeo-data-grid" assetpath="bower_components/nuxeo-ui-elements/nuxeo-data-grid/">
  <template>

    <style>
      :host {
        display: block;
        min-height: 500px;
        position: relative;
      }

      /* scrollbars */
      :host ::-webkit-scrollbar-track {
        width: 12px !important;
        height: 3px;
      }
      :host ::-webkit-scrollbar {
        background-color: rgba(0, 0, 0, 0.03);
        width: 12px !important;
        height: 3px;
      }
      :host ::-webkit-scrollbar-thumb {
        background-color: rgba(0, 0, 0, 0.15);
        border-radius: 1px !important;
      }

      #container {
        @apply --layout-vertical;
        @apply --layout-fit;
      }

      .header {
        @apply --layout-horizontal;
        @apply --layout-center;
      }

      .emptyResult {
        opacity: .5;
        display: block;
        font-weight: 300;
        padding: 1.5em .7em;
        text-align: center;
        font-size: 1.1rem;
      }

      .filters > * {
        margin: 1em 0 0 2.3em;
      }

      .filter {
        display: inline-block;
        background-color: var(--nuxeo-tag-background);
        padding: .2rem .4rem;
        margin: 0 .3em .1em 0;
        font-size: .8rem;
        border-radius: 2.5em;
        line-height: initial;
      }

      .filter .remove:hover {
        cursor: pointer;
      }

      iron-list {
        height: 100%;
      }

      nuxeo-aggregation-navigation {
        position: absolute;
        top: 82px;
        bottom: 0;
        right: 12px;
      }

      :host([draggable]) ::slotted([selected]) {
        cursor: -webkit-grab;
        cursor: grab;
      }
    </style>

    <div id="container">

      <slot name="nuxeo-selection-toolbar"></slot>

      <div class="header">

        <div id="filters" class="filters">
          <dom-repeat items="[[filters]]" as="filter">
            <template>
              <span class="tag filter">
                [[filter.name]]: [[filter.value]]
                <iron-icon icon="nuxeo:remove" class="remove" on-click="_removeFilter"></iron-icon>
              </span>
            </template>
          </dom-repeat>
        </div>
      </div>

      <dom-if if="[[_isEmpty]]">
        <template>
          <div class="emptyResult">[[_computedEmptyLabel]]</div>
        </template>
      </dom-if>

      <iron-list id="list" items="[[items]]" as="[[as]]" grid="" selection-enabled="" selected-item="{{selectedItem}}" selected-items="{{selectedItems}}" on-scroll="_scrollChanged">
        <slot></slot>
      </iron-list>

      <dom-if if="[[displayNavigation]]">
        <template>
          <nuxeo-aggregation-navigation buckets="[[buckets]]" on-scroll-to="_onScrollTo"></nuxeo-aggregation-navigation>
        </template>
      </dom-if>

    </div>

  </template>

  <script>
    {
      /**
       * An element to display page provider results as a grid with infinite scrolling.
       *
       *     <nuxeo-page-provider id="cvProvider" auto
       *                          provider="default_search"
       *                          page-size="40"
       *                          enrichers="thumbnail"
       *                          params='{"ecm_path": ["/default-domain/workspaces"]}'>
       *     </nuxeo-page-provider>
       *
       *     <nuxeo-data-grid nx-provider="nxProvider" selection-enabled>
       *       <template>
       *         <div class="list-item-box vertical layout">
       *           <div class="list-item-info horizontal layout center">
       *             <div class="vertical layout center">
       *               <img class="nxicon" src="[[_thumbnail(item)]]">
       *             </div>
       *             <span class="list-item-title">[[item.title]]</span>
       *           </div>
       *           <div class="list-item-detail">
       *             <div class="layout center">
       *               <span class="list-item-property">
       *                 [[item.type]]
       *               </span>
       *             </div>
       *           </div>
       *         </div>
       *       </template>
       *     </nuxeo-data-grid>
       *
       * @appliesMixin Polymer.IronResizableBehavior
       * @appliesMixin Nuxeo.PageProviderDisplayBehavior
       * @appliesMixin Nuxeo.DraggableListBehavior
       * @memberof Nuxeo
       * @demo demo/nuxeo-data-grid/index.html
       */
      class DataGrid
        extends Polymer.mixinBehaviors([Polymer.IronResizableBehavior, Nuxeo.PageProviderDisplayBehavior,
          Nuxeo.DraggableListBehavior], Nuxeo.Element) {

        static get is() {
          return 'nuxeo-data-grid';
        }

        static get properties() {
          return {
            /**
             * If enabled, it allows to select multiple documents and apply an action on them,
             * like moving them to trash, to favorites or to a collection.
             */
            multiSelection: {
              type: Boolean,
              value: true,
            },
            /**
             * If enabled, it allows the aggregation navigation on the right side of the search results view.
             * For instance, if you use grid view you can filter using a timeline.
             * This parameter only works when list sorted by histogram aggregations.
             */
            displayNavigation: {
              type: Boolean,
              value: false,
            },
          };
        }

        _removeFilter(e) {
          this.dispatchEvent(new CustomEvent('column-filter-changed', {
            composed: true,
            bubbles: true,
            detail: { value: '', filterBy: e.model.filter.path },
          }));
        }

        _onScrollTo(e) {
          this.scrollToIndex(e.detail.index);
        }

        draggableFilter(el) {
          return el.selected;
        }

        get visible() {
          return Boolean(this.offsetWidth || this.offsetHeight);
        }

      }

      customElements.define(DataGrid.is, DataGrid);
      Nuxeo.DataGrid = DataGrid;
    }
  </script>

</dom-module>
<script>
  /* eslint-disable no-new-func,no-restricted-syntax,guard-for-in */

  {
    /**
     * Stamps the template if and only if all of its conditions are met.
     *
     * Evaluation context includes `document` and `user` which need to be set if used.
     *
     * Example:
     *
     *     <nuxeo-filter document="[[document]]" type="Picture"
     *                   user="[[user]]" group="Administrator">
     *       <template>
     *         ...
     *       </template>
     *     </nuxeo-filter>
     *
     * @appliesMixin Polymer.Templatizer
     * @appliesMixin Nuxeo.FiltersBehavior
     * @memberof Nuxeo
     * @demo demo/nuxeo-filter/index.html
     */
    class Filter extends Polymer.mixinBehaviors([Polymer.Templatizer, Nuxeo.FiltersBehavior], Nuxeo.Element) {

      static get is() {
        return 'nuxeo-filter';
      }

      static get properties() {
        return {
          /**
           * The context document
           */
          document: {
            type: Object,
            value: {},
          },

          /**
           * The context user
           */
          user: {
            type: Object,
            value: {},
          },

          /**
           * Document has one of these types
           */
          type: {
            type: String,
            value: '',
            _filter: {
              ctx: ['document'], // the context made available to the filter function
              fn: 'hasType', // the filter function name
              multiple: true, // flag to indicate if the property takes csv values
            },
          },

          /**
           * Document has one of these facets
           */
          facet: {
            type: String,
            value: '',
            _filter: {
              ctx: ['document'],
              fn: 'hasFacet',
              multiple: true,
            },
          },

          /**
           * Document state
           */
          state: {
            type: String,
            value: '',
            _filter: {
              ctx: ['document'],
              fn: 'hasState',
              multiple: true,
            },
          },

          /**
           * Document path starts with
           */
          path: {
            type: String,
            value: '',
            _filter: {
              ctx: ['document'],
              fn: 'pathStartsWith',
            },
          },

          /**
           * User has one of these permissions in the document
           */
          permission: {
            type: String,
            value: '',
            _filter: {
              ctx: ['document'],
              fn: 'hasPermission',
              multiple: true,
            },
          },

          /**
           * Javascript expression to evaluate
           */
          expression: {
            type: String,
            value: '',
            _filter: {
              ctx: ['document', 'user'],
              fn: '_evaluate',
            },
          },

          /**
           * User is member of one of these groups
           */
          group: {
            type: String,
            value: '',
            _filter: {
              ctx: ['user'],
              fn: 'isMember',
              multiple: true,
            },
          },
        };
      }

      static get observers() {
        return [
          '_update(document, user, facet, type, state, path, permission, expression, group)',
        ];
      }

      _evaluate(document, user, expression) {
        try {
          const fn = new Function(['document', 'user'], `return ${expression};`);
          return fn.apply(this, [document, user]);
        } catch (err) {
          return false;
        }
      }

      // Evaluate the filter
      check() {
        for (const k in this.constructor.properties) {
          const v = this[k];
          const filter = this.constructor.properties[k]._filter;
          if (v && filter) {
            const args = filter.ctx.map((arg) => this[arg]);
            // if filter supports multiple values apply the function to each one
            const values = filter.multiple ? v.trim().split(/\s*,\s*/) : [v];
            const fn = this[filter.fn];

            // pass if any check returns true, basically Array.some()
            let pass = false;
            for (let i = 0; i < values.length; i++) {
              if ((pass = fn.apply(this, args.concat(values[i])))) {
                break;
              }
            }

            // if any of the filters fail the check fails
            if (!pass) {
              return false;
            }
          }
        }
        return true;
      }

      _update() {
        this.__renderDebouncer = Polymer.Debouncer.debounce(this.__renderDebouncer, Polymer.Async.microTask, () => {
          if (this.check()) {
            this._render();
          } else {
            this._clear();
          }
        });
        // enqueuing is needed for testing, as it allows content to be stamped on flush
        Polymer.enqueueDebouncer(this.__renderDebouncer);
      }

      _render() {
        if (this._instance) {
          return;
        }
        const parentNode = Polymer.dom(this).parentNode;
        if (parentNode) {
          const template = Polymer.dom(this).querySelector('template');
          const parent = Polymer.dom(parentNode);
          if (template) {
            delete template.__templatizeOwner;
            this.templatize(template);
            this._instance = this.stamp();
            for (const prop in this.constructor.properties) {
              this._instance._setPendingProperty(prop, this[prop]);
            }
            this._instance._flushProperties();
            const root = this._instance.root;
            parent.insertBefore(root, this);
          }
        }
      }

      connectedCallback() {
        super.connectedCallback();
        this._update();
      }

      disconnectedCallback() {
        super.disconnectedCallback();
        this._clear();
      }

      _clear() {
        if (this._instance) {
          const c$ = this._instance.children;
          if (c$ && c$.length) {
            // use first child parent, for case when dom-if may have been detached
            const parent = Polymer.dom(Polymer.dom(c$[0]).parentNode);
            for (let i = 0, n; (i < c$.length) && (n = c$[i]); i++) {
              parent.removeChild(n);
            }
          }
          this._instance = null;
        }
      }

      _forwardHostPropV2(prop, value) {
        if (this._instance) {
          this._instance.forwardHostProp(prop, value);
        }
      }

    }

    customElements.define(Filter.is, Filter);
    Nuxeo.Filter = Filter;
  }
</script>
<dom-module id="paper-material-shared-styles" assetpath="bower_components/paper-material/">
  <template>
    <style>
      :host {
        display: block;
        position: relative;
      }

      :host([elevation="1"]) {
        @apply --shadow-elevation-2dp;
      }

      :host([elevation="2"]) {
        @apply --shadow-elevation-4dp;
      }

      :host([elevation="3"]) {
        @apply --shadow-elevation-6dp;
      }

      :host([elevation="4"]) {
        @apply --shadow-elevation-8dp;
      }

      :host([elevation="5"]) {
        @apply --shadow-elevation-16dp;
      }
    </style>
  </template>
</dom-module>
<dom-module id="paper-material" assetpath="bower_components/paper-material/">
  <template>
    <style include="paper-material-shared-styles"></style>
    <style>
      :host([animated]) {
        @apply --shadow-transition;
      }
      :host {
        @apply --paper-material;
      }
    </style>

    <slot></slot>
  </template>
</dom-module>
<script>
  Polymer({
    is: 'paper-material',

    properties: {
      /**
       * The z-depth of this element, from 0-5. Setting to 0 will remove the
       * shadow, and each increasing number greater than 0 will be "deeper"
       * than the last.
       *
       * @attribute elevation
       * @type number
       * @default 1
       */
      elevation: {
        type: Number,
        reflectToAttribute: true,
        value: 1
      },

      /**
       * Set this to true to animate the shadow when setting a new
       * `elevation` value.
       *
       * @attribute animated
       * @type boolean
       * @default false
       */
      animated: {
        type: Boolean,
        reflectToAttribute: true,
        value: false
      }
    }
  });
</script>
<dom-module id="paper-typeahead" assetpath="bower_components/paper-typeahead/">
  <template>
    <style>
      :host {
        @apply --paper-font-common-base;
        --paper-input-container-label: {
          z-index: -1;
        };

        --paper-input-container-underline: {
          z-index: -1;
        };

        --paper-input-container-shared-input-style: {
          position: relative; /* to make a stacking context */
          outline: none;
          box-shadow: none;
          padding: 0;
          width: 100%;
          max-width: 100%;
          background: transparent;
          border: none;
          color: var(--paper-input-container-input-color, var(--primary-text-color));
          -webkit-appearance: none;
          text-align: inherit;
          vertical-align: bottom;

          @apply --paper-font-subhead;
        };

        display: block;
      }
      input {
        @apply --paper-input-container-shared-input-style;
      }
      input::-webkit-input-placeholder {
        color: var(--paper-input-container-color, var(--secondary-text-color));
      }
      input:-moz-placeholder {
        color: var(--paper-input-container-color, var(--secondary-text-color));
      }
      input::-moz-placeholder {
        color: var(--paper-input-container-color, var(--secondary-text-color));
      }
      input:-ms-input-placeholder {
        color: var(--paper-input-container-color, var(--secondary-text-color));
      }
      paper-material {
        border-radius: 0 0 2px 2px;
        width: 100%;
        margin-top: 2px;
        position: absolute;
        overflow: auto;
        -webkit-overflow-scrolling: touch;
        max-height: var(--paper-typeahead-results-layer-max-height, auto);
        @apply --paper-typeahead-results;
      }
      .iron-selected:not(paper-input-container) {
        background: var(--paper-typeahead-result-selected-background, var(--paper-indigo-50));
      }
      paper-item[pressed] {
        @apply --paper-typeahead-result-pressed;
      }
      paper-item {
        cursor: pointer;
        position: relative;
        background: #fff;
        @apply --paper-typeahead-result;
        --paper-item-min-height: var(--paper-typeahead-result-min-height, 30px);
        --paper-item-selected-weight: var(--paper-typeahead-selected-weight, normal);
        --paper-item-selected: var(--paper-typeahead-result-selected);
        --paper-item-focused: var(--paper-typeahead-result-focused);
      }
      paper-item:not(:last-of-type) {
        border-bottom: solid 1px var(--paper-typeahead-divider-color, var(--divider-color));
      }
      paper-item:focus:before {
        display: none;
      }
      [hidden] {
        display: none;
      }
    </style>
    <paper-input-container class="selectable" no-label-float="[[noLabelFloat]]" always-float-label="[[_computeAlwaysFloatLabel(alwaysFloatLabel,placeholder)]]" auto-validate$="[[autoValidate]]" disabled$="[[disabled]]" invalid="[[invalid]]">
      <label slot="label" hidden$="[[!label]]" on-tap="_onLabelTap">[[label]]</label>
      <iron-input slot="input" aria-labelledby$="[[_ariaLabelledBy]]" aria-describedby$="[[_ariaDescribedBy]]" bind-value="{{value}}" prevent-invalid-input="[[preventInvalidInput]]" allowed-pattern="[[allowedPattern]]" invalid="{{invalid}}" validator="[[validator]]" on-change="_onChange">
        <input id="input" autocomplete$="[[autocomplete]]" autocapitalize$="[[autocapitalize]]" autocorrect$="on" autofocus$="[[autofocus]]" disabled$="[[disabled]]" value="{{typedValue::input}}" inputmode$="[[inputmode]]" minlength$="[[minlength]]" maxlength$="[[maxlength]]" min$="[[min]]" max$="[[max]]" required$="[[required]]" step$="[[step]]" name$="[[name]]" placeholder$="[[placeholder]]" readonly$="[[readonly]]" size$="[[size]]" type$="[[type]]" pattern$="[[pattern]]">
      </iron-input>
        <paper-material slot="add-on" hidden$="[[_hideResults]]" elevation="[[elevation]]" on-mousedown="_mouseDownItems" on-mouseleave="_mouseleaveItems" tabindex="-1">
          <iron-selector id="selector" selected="{{selected}}" items="[[selectorItems]]">
            <dom-repeat id="item-list" sort="[[sortFn]]" items="[[filteredItems]]" on-dom-change="_updateItems">
            </dom-repeat>
          </iron-selector>
        </paper-material>
        <paper-input-error slot="add-on" tabindex="-1">[[errorMessage]]</paper-input-error>
    </paper-input-container>

    <template id="defaultTmpl">
      <paper-item on-mouseenter="_mouseenterItem" class="result-item selectable" tabindex="-1">
        <span>[[getDataDisplayValue(item, dataKey)]]</span>
      </paper-item>
    </template>
  </template>
</dom-module>
<script>/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

(function() {
  'use strict';

  Polymer({
    is: 'paper-typeahead',

    behaviors: [
      Polymer.IronA11yKeysBehavior,
      Polymer.PaperInputBehavior,
      Polymer.IronControlState,
      Polymer.IronFormElementBehavior,
      Polymer.Templatizer,
    ],

    properties: {
      sortFn: {
        type: Function
      },

      arrowsUpdateInput: {
        type: Boolean,
        value: false
      },

      /**
       * Allows a user to show all typeahead results even when there is no input.
       */
      showEmptyResults: {
        type: Boolean,
        value: false
      },

      typedValue: {
        type: String,
        value: '',
        notify: true
      },

      elevation: {
        type: Number,
        value: 1
      },

      keyEventTarget: {
        type: Object,
        value: function() {
          return this;
        }
      },

      typeaheadDisabled: {
        type: Boolean,
        value: false
      },

      /**
       * If defined by a user, function is invoked on every keypress. The result of the function
       * is expected to be a Promise that resolves the a data array.
       * @type {Function<Promise<Array<?>>>|Boolean}
       */
      fetchData: {
        value: false
      },

      data: {
        type: Array,
        value: function() { return []; }
      },

      /**
       * dataKey provides a way to index into your data objects and use a property for display.
       *
       * For instance if you had an array [{color: 'red'}, {color: 'pink'}], you would set the dataKey to 'color'
       * In more complex situations you can do the following, 'color.name' which will extract from {color: {name: 'red'}}.
       */
      dataKey: {
        type: String,
        value: '',
      },

      /**
       * The max number of results to show to pick from when showing selectable items.
       */
      maxResults: {
        type: Number,
        value: 10
      },

      filteredItems: {
        type: Array,
        notify: true,
        value: [],
      },

      filterFn: {
        type: Function,
        value: function() {
          return function(data, value, dataKey) {
            var r = RegExp(value, 'i');

            if (value === '') {
              return this.showEmptyResults ? data : [];
            }

            return data.filter(v => {
              const normalizedData = this._getDataItemValue(v, dataKey);
              return (r.test(normalizedData) ? normalizedData : null);
            });
          };
        }
      },

      selectorItems: {
        type: Array
      },

      // private because we don't want the user to
      // set it true if there is no results
      _hideResults: {
        type: Boolean,
        value: true
      },
    },

    keyBindings: {
      'up': '_upPressed',
      'down': '_downPressed',
      'esc': 'closeResults',
      'enter': '_enterPressed'
    },

    listeners: {
      'iron-activate': '_itemPressed',
      'focus': '_onFocus',
      'blur': '_onBlur',
    },

    observers: [
      '_calculateFilteredData(data.*, typedValue, filterFn, maxResults,' +
      'typeaheadDisabled, dataKey, fetchData)',
    ],

    attached: function() {
      if (!this.ctor) {
        const tmpl = this.queryEffectiveChildren('template') || this.$.defaultTmpl;
        const items = this.$['item-list'];
        items.appendChild(tmpl);
      }
    },

    /**
     * @private
     * @param {Event} e
     */
    _itemPressed: function(e) {
      this.selectResult(e.detail.selected);
    },

    /**
     * @private
     * @param {Event} e
     */
    _upPressed: function(e) {
      e.preventDefault();

      if (!this._hideResults) {
        this.$.selector.selectPrevious();
        this.value = this.selected && this.arrowsUpdateInput ?
          this.filteredItems[this.selected] : this.typedValue;
      }
    },

    /**
     * @private
     * @param {Event} e
     */
    _downPressed: function(e) {
      e.preventDefault();

      if (!this._hideResults) {
        this.$.selector.selectNext();
        this.value = this.selected && this.arrowsUpdateInput ?
          this.filteredItems[this.selected] : this.typedValue;
        // if there are results and they are hide
      } else if (this.filteredItems.length) {
        // show them and select the first one
        this._hideResults = false;
        this.selected = 0;
      }
    },

    /**
     * @private
     */
    _enterPressed: function() {
      return this.selectResult(this.selected);
    },

    /**
     * @private
     */
    _mouseenterItem: function(e) {
      this.selected = this.$.selector.indexOf(e.target);
    },

    /**
     * @private
     */
    _mouseleaveItems: function() {
      this.selected = 0;
    },

    /**
     * @private
     * @param {{base: Array<?>}} data
     * @param {string} typedValue
     * @param {Function<Array>} filterFn
     * @param {number} maxResults
     * @param {boolean} typeaheadDisabled
     * @param {string} dataKey
     * @param {Function<Promise<Array<?>>>|Boolean} fetchData
     */
    _calculateFilteredData: function(
      data,
      typedValue,
      filterFn,
      maxResults,
      typeaheadDisabled,
      dataKey,
      fetchData
    ) {
      Promise.resolve().then(() => {
        if (typeaheadDisabled) {
          return [];
        }

        if (typeof fetchData === 'function') {
          let fetcher = /** @type{Function<Promise<Array<?>>>} */ (
              this.fetchData);

          return fetcher(typedValue);
        }

        return data.base;
      }).then(results => {
        const filteredItems = filterFn.call(
          this, results, typedValue, dataKey).slice(0, maxResults);

        this.set('filteredItems', filteredItems);
        this.set('_hideResults', !this._canShowResults(filteredItems));
      });
    },

    /**
     * @private
     * @param {!Array<?>} results
     * @return {boolean}
     */
    _canShowResults: function(results) {
      let elmActive = (document.activeElement === this.$.input ||
          this.root.activeElement === this.$.input);

      return elmActive && results && results.length > 0;
    },

    _updateItems: function() {
      this.selectorItems = Array.from(
          Polymer.dom(this.root).querySelectorAll('.selectable'));
      this.selected = 0;
    },

    /**
     * Select a Result in the filteredItems array by index then
     * close the results.
     *
     * @param {!number} itemIndex The index of the item to select
     */
    selectResult: function(itemIndex) {
      // Since the results can be sorted we need to normalize here.
      var targetResult = this.filteredItems.sort(
          this.sortFn || function() {})[itemIndex];

      if (targetResult === undefined) {
        this.fire('customvalentered', {target: this.typedValue});
      } else {
        this.value = this._getDataItemValue(
          targetResult, this.dataKey);
        this.fire('selected', {target: this.value, targetResult: targetResult});
        this.closeResults();
      }
    },

    /**
     * Manually display the results if the filteredItems array is not empty.
     *
     * @return {boolean} True if the results are displayed.
     */
    tryDisplayResults: function() {
      var items = this.filteredItems;

      if (this._hideResults && this._canShowResults(items)) {
        this.set('_hideResults', false);
      }

      return !this._hideResults;
    },

    getDataDisplayValue: function(data, dataKey) {
      return this._getDataItemValue(data, dataKey);
    },

    /**
     * Manually hide the results and reset selected item.
     */
    closeResults: function() {
      this._hideResults = true;
      this.selected = 0;
    },

    /**
     * Stop the _onBlur event from firing when scrollbar is clicked.
     *
     * @param {!Event} e
     */
    _mouseDownItems: function(e) {
      e.preventDefault();
    },

    /**
     * @private
     */
    _onFocus: function() {
      this.tryDisplayResults();
    },

    /**
     * @private
     */
    _onBlur: function() {
      this.closeResults();
    },

    /**
     * @private
     */
    _onLabelTap: function() {
      this.$.input.focus();
    },

    /**
     * @private
     * @param {!string|!Object} data
     * @param {!string} dataKey
     */
    _getDataItemValue: function(data, dataKey) {
      if (this.dataKey === '') {
        return data;
      }

      const splitKey = this.dataKey.split('.');

      if (splitKey.length === 1) {
        return /** @type {!Object} */ (data)[dataKey];
      }

      return splitKey.slice(1).reduce((prev, curr) => {
        return /** @type {!Object} */ (prev)[curr];
      }, data[splitKey[0]]);
    },
  });
})();
</script>
<dom-module id="nuxeo-path-suggestion" assetpath="bower_components/nuxeo-ui-elements/nuxeo-path-suggestion/">
  <template>
    <style>
      :host {
        display: block;
        padding-bottom: 8px;
      }

      paper-typeahead {
        --paper-typeahead-results: {
          background-color: white;
          z-index: 100;
          @apply --nuxeo-path-suggestion-results;
        };

        --paper-typeahead-result: {
          display: block;
          overflow: hidden;
          white-space: nowrap;
          direction: rtl;
          text-align: left;
          @apply --nuxeo-path-suggestion-result;
        };

        --paper-input-container-underline: {
          z-index: 0;
        };
      }

      paper-typeahead:focus {
        outline: none;
        @apply --nuxeo-path-suggestion-focus;
      }

      label {
        @apply --nuxeo-label;
      }
    </style>
    <nuxeo-page-provider id="provider" provider="nxql_search" params="[[params]]" page-size="20" current-page="{{children}}"></nuxeo-page-provider>
    <nuxeo-document id="parent" enrichers="[[enrichers]]"></nuxeo-document>

    <dom-if if="[[label]]">
      <template>
        <label>[[label]]</label>
      </template>
    </dom-if>

    <paper-typeahead id="typeahead" value="{{value}}" data="[[data]]" allowed-pattern="[[allowedPattern]]" auto-validate="[[autoValidate]]" on-focus="_onFocus" disabled$="[[disabled]]" no-label-float=""></paper-typeahead>
  </template>
  <script>
    {
      /**
       * An element that provides path auto completion to nuxeo folderish documents.
       *
       *     <nuxeo-path-suggestion value="/"></nuxeo-path-suggestion>
       *
       * ### Styling
       *
       * The following custom properties and mixins are available for styling:
       *
       * Custom property | Description | Default
       * ----------------|-------------|----------
       * `--nuxeo-path-suggestion-results` | Mixin applied to the results pane | `{}`
       * `--nuxeo-path-suggestion-result` | Mixin applied to the result items | `{}`
       *
       * @memberof Nuxeo
       * @demo demo/nuxeo-path-suggestion/index.html
       */
      class PathSuggestion extends Nuxeo.Element {

        static get is() {
          return 'nuxeo-path-suggestion';
        }

        static get properties() {
          return {
            parent: {
              type: Object,
              notify: true,
            },

            query: String,

            params: Object,

            /**
             * List of content enrichers to use.
             */
            enrichers: {
              type: String,
              value: '',
            },

            value: {
              type: String,
              observer: '_valueChanged',
              notify: true,
            },

            data: Object,

            children: {
              type: Array,
              observer: '_childrenChanged',
              notify: true,
            },

            label: String,

            autoValidate: {
              type: Boolean,
              value: true,
            },

            allowedPattern: {
              type: String,
              value: '[^()\\+*%]',
            },

            disabled: {
              type: Boolean,
              observer: '_disabledChanged',
              reflectToAttribute: true,
            },
          };
        }

        displayResults() {
          this.$.typeahead.tryDisplayResults();
        }

        hideResults() {
          this.$.typeahead.closeResults();
        }

        _onFocus() {
          this.$.typeahead.typedValue = this.value;
          this.displayResults();
        }

        _childrenChanged() {
          if (this.children) {
            if (this.children.length === 1 && this.children[0].path === this.$.typeahead.typedValue) {
              this.hideResults();
            } else {
              this.data = this.children.map((child) => `${child.path}/`);
              this.displayResults();
            }
          }
        }

        _valueChanged() {
          if (this.value && !this.disabled) {
            const idx = this.value.lastIndexOf('/');
            if (idx > -1) {
              const newParentPath = (idx === 0 ? '/' : this.value.substring(0, idx));
              this._updateParent(newParentPath).then(() => {
                this._queryChildren(this.parent, this.value.substring(idx + 1));
              }).catch((err) => {
                if (err.status === 403) {
                  this.children = [];
                }
              });
            }
          }
        }

        _updateParent(newParentPath) {
          if (!this.parent || newParentPath !== this.$.parent.docPath) {
            this.$.parent.docPath = newParentPath;
            return this.$.parent.get().then((response) => {
              this.parent = response;
            }).catch((error) => {
              if (!(error.code === 'org.nuxeo.ecm.core.api.DocumentNotFoundException' &&
                  error.message === newParentPath)) {
                throw error;
              }
            });
          } else {
            return new Promise(((resolve) => {
              resolve();
            }));
          }
        }

        _queryChildren(parent, term) {
          this.params = {
            queryParams: `SELECT * FROM Document WHERE ecm:parentId = '${parent.uid}' ` +
            `AND ecm:name LIKE '${term}%' AND ecm:mixinType = 'Folderish' ` +
            'AND ecm:mixinType != \'HiddenInNavigation\' AND ecm:isVersion = 0 ' +
            'AND ecm:isTrashed = 0',
          };
          return this.$.provider.fetch();
        }

        _disabledChanged() {
          if (!this.disabled) {
            this._valueChanged();
          }
        }

      }

      customElements.define(PathSuggestion.is, PathSuggestion);
      Nuxeo.PathSuggestion = PathSuggestion;
    }
  </script>
</dom-module>
<dom-module id="nuxeo-tree-node" assetpath="bower_components/nuxeo-ui-elements/nuxeo-tree/">
  <template>
    <style>
      :host {
        display: block;
        @apply --nuxeo-tree-node-theme;
      }

      ::slotted(iron-collapse) {
        padding-left: 1em;
        @apply --nuxeo-tree-children-theme;
      }

      ::slotted(.more) {
        @apply --nuxeo-tree-node-more-theme;
      }

      ::slotted(#content) {
        position: relative;
        margin: .1rem 0 .2rem;
      }

      ::slotted(#content iron-icon) {
        margin-top: -0.25rem;
      }

      ::slotted(span iron-icon) {
        width: .95rem;
        margin: 0 .1rem .3rem 0;
      }

    </style>

    <slot></slot>

  </template>
  <script>
    {
      /**
       * @appliesMixin Polymer.Templatizer
       * @appliesMixin Nuxeo.I18nBehavior
       * @memberof Nuxeo
       */
      class TreeNode extends Polymer.mixinBehaviors([Polymer.Templatizer, Nuxeo.I18nBehavior], Nuxeo.Element) {

        static get is() {
          return 'nuxeo-tree-node';
        }

        static get properties() {
          return {
            data: Object,

            _children: {
              type: Array,
            },

            /**
             * An object for accessing information for rendering a tree node.
             *
             * getChildren(node) : Promise<Array<Object>>
             * isLeaf(node) : Boolean
             */
            controller: Object,

            opened: {
              type: Boolean,
              value: false,
              observer: '_openedChanged',
            },

            loading: {
              type: Boolean,
              value: false,
              observer: '_loadingChanged',
            },

            /**
             * Template used to render each tree node.
             */
            template: Object,

            nodeKey: {
              type: String,
              value: 'id',
            },
            page: {
              type: Number,
              value: 1,
            },
            isNextAvailable: {
              type: Boolean,
              value: false,
            },

            _parentModel: {
              type: Boolean,
              value: true,
            },
          };
        }

        static get observers() {
          return [
            '_renderNodeContent(data)',
          ];
        }

        toggle() {
          if (this._updated) {
            this.opened = !this.opened;
          } else {
            this._fetchChildren();
            this.opened = true;
          }
        }

        _selectNode(e) {
          let detail;
          if (!e.detail.item) {
            detail = { item: this.data };
          } else {
            detail = { item: e.detail.item };
          }
          this.dispatchEvent(new CustomEvent('select', {
            composed: true,
            bubbles: true,
            detail,
          }));
        }

        open() {
          this.opened = true;
          if (!this._updated) {
            return this._fetchChildren();
          }
          return Promise.resolve();
        }

        close() {
          this.opened = false;
        }

        _renderNodeContent() {
          if (this.template) {
            if (this._instance) {
              // re-render if data changes
              this._teardownInstance();
              this._fetchChildren();
            }
            this.template.__templatizeOwner = null; // XXX: find a way to remove this line
            // templatize must be called once before stamp is called
            this.templatize(this.template, true);
            // stamp and prepare bindings
            this._instance = this.stamp({});
            this._instance.item = this.data;
            this._instance.opened = this.opened;
            this._instance.loading = this.loading;
            this._instance.isLeaf = this.controller.isLeaf(this.data);
            this.dataset[this.nodeKey] = this.data[this.nodeKey];

            const content = document.createElement('div');
            content.id = 'content';
            Polymer.dom(content).appendChild(this._instance.root);
            Polymer.dom(this).appendChild(content);

            const children = document.createElement('iron-collapse');
            children.id = 'children';
            children.opened = this.opened;
            children.loading = this.loading;
            children.noAnimation = 'true';
            Polymer.dom(this).appendChild(children);

            Polymer.dom.flush();
            // append node content
            // this.$.content.appendChild(this._instance.root);
            this._setupToggleListener();
          }
        }

        _renderChildNodes() {
          if (this.template) {
            return new Promise(((resolve) => {
              // clear <iron-collapse> content in case we are re-rendering
              const children = Polymer.dom(this).querySelector('#children');
              while (children.lastChild) {
                children.removeChild(children.lastChild);
              }

              const items = this._children || [];
              for (let i = 0; i < items.length; i++) {
                const el = document.createElement('nuxeo-tree-node');
                el.controller = this.controller;
                el.template = this.template;
                el.nodeKey = this.nodeKey;
                el.dataHost = this._instance._rootDataHost;
                el.data = items[i];
                children.appendChild(el);
              }
              if (this.isNextAvailable) {
                const addMore = document.createElement('a');
                addMore.setAttribute('class', 'more');
                addMore.appendChild(document.createTextNode(this.i18n('tree.loadMore')));
                this.listen(addMore, 'click', '_loadMoreData');
                children.appendChild(addMore);
              }
              resolve();
              this.loading = false;
            }));
          }
        }

        _loadMoreData() {
          if (this.isNextAvailable && !this.loading) {
            this.page = this.page + 1;
            this._fetchChildren();
          }
        }

        _fetchChildren() {
          this.loading = true;
          if (this.page === 1) {
            this._children = [];
            this.isNextAvailable = true;
          }
          if (this.isNextAvailable) {
            return this.controller.getChildren(this.data, this.page).then((results) => {
              if (results.items) {
                results.items.forEach((doc) => {
                  this.push('_children', doc);
                });
                this.isNextAvailable = results.isNextAvailable;
              } else {
                this._children = results;
                this.isNextAvailable = false;
              }
              this._updated = true;
              return this._renderChildNodes();
            });
          }
        }

        _setupToggleListener() {
          Polymer.dom.flush();
          const selectElts = Polymer.dom(this).querySelector('#content').querySelectorAll('[select]');
          for (let i = 0; i < selectElts.length; i++) {
            this.listen(selectElts[i], 'click', '_selectNode');
          }
          const toggleEls = Polymer.dom(this).querySelector('#content').querySelectorAll('[toggle]');
          for (let i = 0; i < toggleEls.length; i++) {
            this.listen(toggleEls[i], 'click', 'toggle');
          }
        }

        // Implements extension point from Templatizer mixin
        // Called as side-effect of a host property change, responsible for
        // notifying parent.<prop> path change on instance
        _forwardParentProp(prop, value) {
          if (this._instance) {
            this._instance[prop] = value;
          }
        }

        _teardownInstance() {
          const children = this._instance.children;
          if (children && children.length) {
            const parent = Polymer.dom(Polymer.dom(children[0]).parentNode);
            for (let i = 0; i < children.length; i++) {
              parent.removeChild(children[i]);
            }
          }
          this._instance = null;
          this._updated = false;
        }

        _openedChanged() {
          if (this._instance) {
            Polymer.dom(this).querySelector('#children').opened = this.opened;
            this._instance.notifyPath('opened', this.opened);
            this._setupToggleListener();
          }
        }

        _loadingChanged() {
          if (this._instance) {
            Polymer.dom(this).querySelector('#children').loading = this.loading;
            this._instance.notifyPath('loading', this.loading);
          }
        }

        removeSelf() {
          this.remove();
          return Promise.resolve();
        }

      }

      customElements.define(TreeNode.is, TreeNode);
      Nuxeo.TreeNode = TreeNode;
    }
  </script>
</dom-module>
<dom-module id="nuxeo-tree" assetpath="bower_components/nuxeo-ui-elements/nuxeo-tree/">
  <template>
    <style>
      :host {
        display: block;
        @apply --nuxeo-tree-theme;
      }
    </style>

    <slot></slot>
  </template>
  <script>
    {
      /**
       * An element to display a tree.
       *
       * + The template represents the DOM to create for the nodes
       * + The `data` property specifies the model of a node
       * + The `controller` provides helpers to render a given node, and these methods __must__ be implemented.
       *
       * ### Template model
       *
       * Given the following `data` array:
       *
       * ##### data.json
       *
       * ```js
       * [
       *   title: 'root',
       *   children: [
       *     {
       *       title: 'a',
       *       children: []
       *     },
       *     {
       *       title: 'b',
       *       children: [
       *         {title: 'x'},
       *         {title: 'y'}
       *       ]
       *     }
       *   ]
       * ]
       * ```
       *
       * The following code would render the tree (note the `title` property is bound from the model
       * object provided to the template scope, and there are also other properties such as `opened`
       * and `isLeaf` which are added to the binding scope):
       *
       * ```html
       * <nuxeo-tree data="[[data]]" controller="[[controller]]">
       *   <template>
       *     <template is="dom-if" if="[[!opened]]">
       *       <iron-icon icon="hardware:keyboard-arrow-right" toggle></iron-icon>
       *     </template>
       *     <template is="dom-if" if="[[opened]]">
       *       <iron-icon icon="hardware:keyboard-arrow-down" toggle></iron-icon>
       *     </template>
       *     <span select>My title is: [[item.title]]</span>
       *     <span>Am I a leaf? [[isLeaf]]</span>
       *   </template>
       * </nuxeo-tree>
       * ```
       *
       * The attribute `[toggle]` can be added to any element in the template to toggle a node between opened and closed.
       *
       * The attribute `[select]` can be added to any element in the template to select a node when clicking the element.
       * It will result in the tree firing a 'select' event having the node data as item of the event's detail.
       *
       * In addition to the template, you must also provide a `controller`.
       * For example, for the previous sample:
       *
       * ```js
       * controller = {
       *   // How to get children of a node. Returns a promise.
       *   getChildren: function(node) {
       *     return Promise.resolve(node.children);
       *   },
       *
       *   // Logics you may want to have to control if a node is a leaf.
       *   isLeaf: function(node) {
       *     return node.children.length === 0;
       *   }
       * };
       * ```
       *
       * `nuxeo-tree`
       * @memberof Nuxeo
       * @demo demo/nuxeo-tree/index.html
       */
      class Tree extends Nuxeo.Element {

        static get is() {
          return 'nuxeo-tree';
        }

        static get properties() {
          return {
            data: Object,

            /**
             * An object for accessing information for rendering a tree item.
             *
             * getChildren(node) : Promise<Array<Object>>
             * isLeaf(node) : Boolean
             */
            controller: Object,

            /**
             * Template used to render each tree item.
             */
            template: Object,

            nodeKey: {
              type: String,
              value: 'id',
            },
          };
        }

        static get observers() {
          return [
            '_update(data, controller)',
          ];
        }

        /**
         * Initializes the tree whenever the data and/or controller changes.
         */
        _update() {
          if (this.data && this.controller) {
            const template = Polymer.dom(this).querySelector('template');
            if (this._root) {
              Polymer.dom(this).removeChild(this._root);
            }
            this._root = document.createElement('nuxeo-tree-node');
            this._root.id = 'root';
            this._root.template = template;
            this._root.dataHost = this.dataHost;
            this._root.controller = this.controller;
            this._root.nodeKey = this.nodeKey;
            this._root.data = this.data;
            this._root.dataset[this.nodeKey] = this.data[this.nodeKey];
            Polymer.dom(this).appendChild(this._root);
            this._root.open();
          }
        }

        /**
         * Find and open a set of nodes given a set of keys.
         * Nodes keys must be sorted in terms of hierarchy, otherwise some nodes
         * might not be rendered yet.
         */
        open() {
          this._openNodes(arguments); // eslint-disable-line prefer-rest-params
        }

        /**
         * Recursively opens a set of nodes.
         */
        _openNodes(keys) {
          if (!keys || keys.length === 0) {
            return;
          }
          const node = this._find(keys[0]);
          if (node) {
            node.open().then(() => {
              this._openNodes(Array.prototype.slice.call(keys, 1));
            });
          }
        }

        /**
         * Find a node by key.
         */
        _find(key) {
          return this.querySelector(`[data-${this.nodeKey}="${key}"]`);
        }

        removeNodes(keys) {
          if (!keys || keys.length === 0) {
            return;
          }
          const node = this._find(keys[0]);
          if (node) {
            node.removeSelf().then(() => {
              this.removeNodes(Array.prototype.slice.call(keys, 1));
            });
          }
        }

      }

      customElements.define(Tree.is, Tree);
      Nuxeo.Tree = Tree;
    }
  </script>
</dom-module>
<dom-module id="nuxeo-justified-grid" assetpath="bower_components/nuxeo-ui-elements/nuxeo-justified-grid/">
  <template>
    <style>
      :host {
        display: block;
      }

      #container {
        position: relative;
        height: 100%;
        width: 100%;
      }

      #list {
        @apply --layout-fit;
      }

      #list::after {
        content: '';
        flex-grow: 999999999;
      }

      #list .row {
        display: flex;
        flex-direction: row;
      }

      #list .item {
        position: relative;
        box-shadow: 0 3px 5px rgba(0, 0, 0, 0.04);
        border: 2px solid transparent;
        cursor: pointer;
        outline: none;
      }

      #list .item[selected], #list .item:hover, #list .item:focus {
        border: 2px solid var(--nuxeo-grid-selected, transparent);
        background-color: var(--nuxeo-grid-selected, transparent);
        color: white;
      }

      #list .item paper-icon-button {
        position: absolute;
        left: 10px;
        top: 10px;
        background-color: rgba(255, 255, 255, 0.95);
        border: 2px solid var(--nuxeo-grid-selected);
        border-radius: 50%;
        width: 32px;
        height: 32px;
        padding: 2px;
        color: var(--nuxeo-grid-selected);
        display: none;
      }

      #list .item[selected] paper-icon-button {
        border: 2px solid var(--nuxeo-grid-selected);
        background-color: var(--nuxeo-grid-selected);
        color: white;
        display: block;
      }

      #list .item:hover paper-icon-button,
      #list .item paper-icon-button[selection-mode] {
        display: block;
      }

      [hidden] {
        display: none !important;
      }

      .emptyResult {
        opacity: .5;
        display: block;
        font-weight: 300;
        padding: 1.5em .7em;
        text-align: center;
        font-size: 1.1rem;
      }
    </style>

    <dom-if if="[[_isEmpty]]">
      <template>
        <div class="emptyResult">[[_computedEmptyLabel]]</div>
      </template>
    </dom-if>

    <div id="container">
      <iron-list id="list" items="[[rows]]" as="row" on-iron-resize="_resize">
        <template>
          <div class="row">
            <dom-repeat items="[[row]]">
              <template>
                <div class="item" tabindex="0" on-click="_click" selected$="[[_isSelected(item, selectedItems.*)]]" style$="height: [[item._view.height]]px; width: [[item._view.width]]px;">
                  <div id="item-[[item._view.index]]"></div>[[_itemChanged(item, item._view.width, item._view.height)]]
                  <paper-icon-button noink="" icon="icons:check" selection-mode$="[[selectionMode]]" hidden$="[[!selectionEnabled]]" on-click="_check"></paper-icon-button>
                </div>
              </template>
            </dom-repeat>
          </div>
        </template>
      </iron-list>

      <iron-scroll-threshold id="scrollThreshold" scroll-target="list" on-lower-threshold="fetch"></iron-scroll-threshold>
      <array-selector id="selector" items="{{items}}" selected="{{selectedItems}}" multi=""></array-selector>
    </div>
  </template>
  <script>
    {
      /**
       * An element for displaying page provider results in a justified grid with infinite scrolling.
       *
       * @memberof Nuxeo
       * @appliesMixin Polymer.IronResizableBehavior
       * @appliesMixin Polymer.Templatizer
       * @appliesMixin Nuxeo.PageProviderDisplayBehavior
       * @appliesMixin Nuxeo.RoutingBehavior
       * @demo demo/nuxeo-justified-grid/index.html
       */
      class JustifiedGrid
        extends Polymer.mixinBehaviors([Polymer.IronResizableBehavior, Polymer.Templatizer,
          Nuxeo.PageProviderDisplayBehavior, Nuxeo.RoutingBehavior], Nuxeo.Element) {

        static get is() {
          return 'nuxeo-justified-grid';
        }

        static get properties() {
          return {
            /**
             * Height of each result line in pixels.
             */
            rowHeight: {
              type: Number,
              value: 196,
            },
            /**
             * Page number the search result starts from.
             */
            page: {
              type: Number,
              value: 1,
            },
            /**
             * Number of results per page. The maximum number recommended is 200 if results display thumbnails.
             */
            pageSize: {
              type: Number,
              value: 50,
            },

            rows: {
              type: Array,
              value: [],
            },

            _isFetching: {
              type: Boolean,
              value: false,
            },

            _templateElement: {
              type: Object,
            },
          };
        }

        static get observers() {
          return [
            '_selectedItemsChanged(selectedItems.splices)',
          ];
        }

        ready() {
          super.ready();
          const template = Polymer.dom(this).querySelector('template');
          if (template) {
            this.templatize(template);
            this._templateElement = this.stamp().root.firstElementChild;
          }
        }

        disconnectedCallback() {
          super.disconnectedCallback();
          this._templateElement = null;
        }

        _itemChanged(item) {
          if (this._templateElement && item && item._view) {
            Polymer.RenderStatus.afterNextRender(this, () => {
              const el = this.$$(`#item-${item._view.index}`);
              if (el) {
                if (el.childNodes.length > 0) {
                  el.childNodes[0].set('document', item);
                } else {
                  const clone = this._templateElement.cloneNode(true);
                  clone.set('document', item);
                  el.appendChild(clone);
                }
              }
            });
          }
        }

        // overridden from Nuxeo.PageProviderDisplayBehavior
        reset() {
          this.set('items', []);
          this.set('rows', []);
          this.page = 1;
          this.$.scrollThreshold.clearTriggers();
        }

        // overridden from Nuxeo.PageProviderDisplayBehavior
        fetch() {
          if (this._isFetching || !this._hasPageProvider() || this.page > this.nxProvider.numberOfPages) {
            this.$.scrollThreshold.clearTriggers();
            this._isFetching = false;
            return Promise.resolve();
          }
          this._isFetching = true;
          return this._fetchPage(this.page, this.pageSize).then((response) => {
            this._addItems(response.entries);
            this.page += 1;
            this.$.scrollThreshold.clearTriggers();
            this._isFetching = false;
          });
        }

        // overridden from Nuxeo.PageProviderDisplayBehavior
        getSelectedItems() {
          return this.$.selector.selected;
        }

        // overridden from Nuxeo.PageProviderDisplayBehavior
        selectItem(item) {
          if (this.selectionEnabled) {
            this.$.selector.select(item);
            this._updateFlags();
          }
        }

        // overridden from Nuxeo.PageProviderDisplayBehavior
        selectIndex(index) {
          if (this.selectionEnabled) {
            this.$.selector.selectIndex(index);
            this._updateFlags();
          }
        }

        // overridden from Nuxeo.PageProviderDisplayBehavior
        selectItems(items) {
          if (this.selectionEnabled && items && items.length > 0) {
            items.forEach((item) => this.$.selector.select(item));
            this._updateFlags();
          }
        }

        // overridden from Nuxeo.PageProviderDisplayBehavior
        deselectItem(item) {
          if (this.selectionEnabled) {
            this.$.selector.deselect(item);
            this._updateFlags();
          }
        }

        // overridden from Nuxeo.PageProviderDisplayBehavior
        deselectIndex(index) {
          if (this.selectionEnabled) {
            this.$.selector.deselectIndex(index);
            this._updateFlags();
          }
        }

        // overridden from Nuxeo.PageProviderDisplayBehavior
        selectAll() {
          this.items.forEach((item) => this.$.selector.select(item));
          this._updateFlags();
        }

        // overridden from Nuxeo.PageProviderDisplayBehavior
        clearSelection() {
          this.$.selector.clearSelection();
          this._updateFlags();
        }

        _check(e) {
          if (this.selectionEnabled) {
            this.selectionMode = true;
            this._click(e);
          }
        }

        _click(e) {
          const index = e.model.item._view.index;
          if (this.selectionEnabled && this.selectionMode) {
            // since we are using Object.assign() when creating items for the grid, we cannot really use
            // selector.selectItem()/deselectItem() because it relies on indexOf and since the e.model.item is not a
            // reference of the original item, it doesn't work.
            if (this._isIndexSelected(index)) {
              this.deselectIndex(index);
            } else {
              this.selectIndex(index);
            }
          } else {
            this.dispatchEvent(new CustomEvent('navigate', {
              composed: true,
              bubbles: true,
              detail: { doc: this.items[index], index },
            }));
          }
          e.stopPropagation();
        }

        _selectedItemsChanged() {
          this.selectionMode = this.selectedItems && this.selectedItems.length > 0;
        }

        _isSelected(item) {
          return this._isIndexSelected(item._view.index);
        }

        _isIndexSelected(index) {
          return this.selectedItems.indexOf(this.items[index]) > -1;
        }

        /**
         * Adds a list of items to the grid. The `items` are computed and transformed into rows.
         * This is the ideal way to add new items to the grid (e.g. when loading more items with infinite scroll behavior).
         */
        _addItems(newItems) {
          let items = newItems;
          // recompute last row before adding new items
          if (this.rows.length > 0) {
            // get last row items
            const lastRowItems = this.rows[this.rows.length - 1].map((item) => this.items[item._view.index]);
            // append last row items to `newItems` param
            items = lastRowItems.concat(items);
            // drop last row
            this.pop('rows');
          }
          this._computeRows(items).forEach((row) => this.push('rows', row));
          this.$.scrollThreshold.clearTriggers();
        }

        /**
         * Given a set of items, computes a list of rows. The goal is to compute each row by trying to add items until
         * they fit. When a row doesn't have space to fit another item, we increase the height of the current row to take
         * advantage of the remaining width space to avoid cropping images.
         * Currently relies on `picture:info` to get the dimensions of a video/image. Fallbacks to square dimensions if the
         * document doesn't have the `picture` schema.
         */
        _computeRows(items) {
          const gridWidth = this.$.list.offsetWidth;
          const rows = [];
          let currentRowWidth = 0;
          let currentRow = [];
          items.forEach((item, idx) => {
            const clone = Object.assign({}, item);
            // fallback to square dimensions if item doesn't have a size object in it's model
            clone.size = clone.properties['picture:info'] || { width: 1, height: 1 };
            clone.size.width = clone.size.width || 1;
            clone.size.height = clone.size.height || 1;
            clone._view = {};
            clone._view.index = this.items.indexOf(item);

            // compute item width to fit a row with `rowHeight`
            // new width = original width * rowHeight / original height
            clone._view.width = clone.size.width * this.rowHeight / clone.size.height;
            clone._view.height = this.rowHeight;

            // if item fits, add it to current row
            if (currentRowWidth + clone._view.width <= gridWidth) {
              currentRow.push(clone);
              currentRowWidth += clone._view.width;
            } else {
              // current item doesn't fit in current row
              // fit items do width and push current row to rows
              rows.push(this._fitItemsToWidth(currentRow, currentRowWidth, gridWidth));
              // append current item (that didn't fit in current row) to a new row
              currentRow = [clone];
              currentRowWidth = clone._view.width;
            }

            if (idx === (items.length - 1)) {
              // fit items do width and push current row to rows
              rows.push(this._fitItemsToWidth(currentRow, currentRowWidth, gridWidth));
            }
          });
          return rows;
        }

        /**
         * Computes the ideal height of current row in order to increase the width of items and take advantage of the
         * remaining width space.
         */
        _fitItemsToWidth(currentRow, currentRowWidth, gridWidth) {
          const computedHeight = gridWidth * this.rowHeight / currentRowWidth;
          currentRow.forEach((item) => {
            item._view.height = computedHeight;
            item._view.width = item._view.width / currentRowWidth * gridWidth;
          });
          return currentRow;
        }

        /**
         * Recomputes rows when the browser window is resized.
         */
        _resize() {
          if (this.$.list.offsetWidth || this.$.list.offsetHeight) {
            this._debouncer = Polymer.Debouncer.debounce(
              this._debouncer,
              Polymer.Async.timeOut.after(150), () => {
                this.rows = this._computeRows(this.items);
              },
            );
          }
        }

      }

      customElements.define(JustifiedGrid.is, JustifiedGrid);
      Nuxeo.JustifiedGrid = JustifiedGrid;
    }
  </script>
</dom-module>
<dom-module id="nuxeo-justified-grid-item" assetpath="bower_components/nuxeo-ui-elements/nuxeo-justified-grid/">
  <template>
    <style>
      :host {
        display: block;
      }

      [hidden] {
        display: none !important;
      }

      .item {
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
      }

      .item iron-image {
        width: 100%;
        height: 100%;
        --iron-image-placeholder: {
          background: #fafafa;
        };
      }

      .item .overlay {
        display: none;
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        padding: 24px 10px 8px;
        background: rgba(0, 0, 0, 0.4);
        background: -webkit-linear-gradient(rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.4));
        background: -o-linear-gradient(rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.4));
        background: -moz-linear-gradient(rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.4));
        background: linear-gradient(rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.4));
        text-shadow: -1px 0 rgba(0, 0, 0, 0.4), 0 1px rgba(0, 0, 0, 0.4), 1px 0 rgba(0, 0, 0, 0.4), 0 -1px rgba(0, 0, 0, 0.4);
      }

      .item:hover .overlay {
        display: block;
      }

    </style>

    <div class="item">
      <iron-image src="[[_url(document)]]" sizing="cover" preload="" fade=""></iron-image>
      <div class="overlay">[[document.title]]</div>
    </div>

  </template>

  <script>
    {
      /**
       * An element for displaying an item in nuxeo-justified-grid.
       *
       * @memberof Nuxeo
       * @demo demo/nuxeo-justified-grid/index.html
       */
      class JustifiedGridItem extends Nuxeo.Element {

        static get is() {
          return 'nuxeo-justified-grid-item';
        }

        static get properties() {
          return {
            document: Object,
          };
        }

        _url(doc) {
          return doc && doc.contextParameters && doc.contextParameters.thumbnail && doc.contextParameters.thumbnail.url
            ? doc.contextParameters.thumbnail.url : '';
        }

      }

      customElements.define(JustifiedGridItem.is, JustifiedGridItem);
      Nuxeo.JustifiedGridItem = JustifiedGridItem;
    }
  </script>
</dom-module>
<dom-module id="nuxeo-actions-menu" assetpath="bower_components/nuxeo-ui-elements/widgets/">
  <template>
    <style>
      :host, #main {
        @apply --layout-horizontal;
        @apply --layout-center;
      }

      [hidden] {
        display: none !important;
      }

      #reparent, #reparent > * {
        width: 0;
        height: 0;
        overflow: hidden;
      }

      #slot::slotted(*), /* chrome, safari */
      #main::slotted(*) { /* firefox, edge */
        @apply --nuxeo-actions-menu-main;
      }

      #dropdown::slotted(*), /* chrome, safari */
      paper-listbox::slotted(*) { /* firefox, edge */
        outline: none;
        user-select: none;
        @apply --nuxeo-actions-menu-dropdown;
      }

      paper-menu-button {
        --paper-menu-button: {
          padding: 0;
        }
      }

      paper-listbox {
        @apply --layout-vertical;
      }
    </style>
    
    <div id="main">
      <slot id="slot"></slot>
    </div>
    <div id="reparent"></div>
    <paper-menu-button id="dropdownButton" close-on-activate="" no-overlap="" horizontal-align="right">
      <paper-icon-button icon="icons:more-vert" slot="dropdown-trigger" alt="dropdown"></paper-icon-button>
      <paper-listbox slot="dropdown-content">
        <slot id="dropdown" name="dropdown"></slot>
      </paper-listbox>
    </paper-menu-button>
    <paper-tooltip for="dropdownButton">[[i18n('actionsMenu.more')]]</paper-tooltip>

  </template>

  <script>
    {
      /**
       * A responsive menu that only displays elements fitting the available space. Remaining elements will be placed
       * in a dropdown menu.
       *
       * Example:
       *
       *     <nuxeo-actions-menu>
       *       <nuxeo-add-to-collection-button document="[[document]]"></nuxeo-add-to-collection-button>
       *       <nuxeo-preview-button document="[[document]]"></nuxeo-preview-button>
       *       <nuxeo-favorites-toggle-button document="[[document]]"></nuxeo-favorites-toggle-button>
       *     </nuxeo-actions-menu>
       *
       * @appliesMixin Polymer.IronResizableBehavior
       * @memberof Nuxeo
       * @demo demo/nuxeo-actions-menu/index.html
       */
      class ActionsMenu extends Polymer.mixinBehaviors([Polymer.IronResizableBehavior, Nuxeo.I18nBehavior], Nuxeo.Element) {

        static get is() {
          return 'nuxeo-actions-menu';
        }

        connectedCallback() {
          super.connectedCallback();
          this._observer = new Polymer.FlattenedNodesObserver(this, ({addedNodes, removedNodes}) => {
            // mark unresolved custom elements
            const unresolved = addedNodes.filter((node) => node.tagName && node.tagName.includes('-') &&
              !customElements.get(node.tagName.toLowerCase()));
            // defer rendering for non resolved elements
            unresolved.forEach((node) =>
              customElements.whenDefined(node.tagName.toLowerCase()).then(this._layout.bind(this)));
            if ((addedNodes.length > 0 && unresolved.length === 0) || removedNodes.length > 0) {
              // do instant rendering if we're removing nodes or adding at least one resolved element
              this._layout();
            }
          });
          this.addEventListener('iron-resize', this._layout);
          this.addEventListener('dom-change', this._layout);
          this.addEventListener('iron-overlay-opened', this._reparent);
        }

        disconnectedCallback() {
          super.disconnectedCallback();
          this._observer.disconnect();
          this.removeEventListener('iron-resize', this._layout);
          this.removeEventListener('dom-change', this._layout);
          this.removeEventListener('iron-overlay-opened', this._reparent);
        }

        ready() {
          super.ready();
        }

        get contentWidth() {
          return this._getMenuElements().reduce((sum, current) => sum + current.clientWidth, 0);
        }

        _reparent(e) {
          const src = e.composedPath()[0];
          if ((src.tagName === 'NUXEO-DIALOG' || src.tagName === 'PAPER-DIALOG') && e.target.slot === 'dropdown') {
            const parent = e.target.parentElement;
            const sibling = e.target.nextElementSibling;
            const action = e.target;
            /**
             * XXX: Instead of reparenting dialogs, this handler reparents the actions that trigger dialogs instead, to
             * prevent issues with stacking contexts. The goal is threefold:
             *  1) to prevent the backdrop from overlaping the dialog
             *  2) to prevent the dialog from disappearing when the dropdown is closed
             *  3) to preserve the dialogs inside the actions, which might need to be accessible for custom logics
             */
            Polymer.Async.idlePeriod.run(() => {
              this.$.reparent.appendChild(action);
              action._actionsMenuReparent = action._actionsMenuReparent || ((evt) => {
                let path = evt.composedPath();
                if (path[0].tagName !== 'NUXEO-DIALOG' && path[0].tagName !== 'PAPER-DIALOG') {
                  // we don't want to move the action back if the event is comming from a non-dialog element
                  return;
                }
                path = path.slice(0, path.findIndex((el) => el === action));
                if (path.filter((el) => el.tagName === 'NUXEO-DIALOG' || el.tagName === 'PAPER-DIALOG').length > 1) {
                  // nor if it comes from an inner dialog
                  return;
                }
                parent.insertBefore(action, sibling);
              });
              action.addEventListener('iron-overlay-closed', action._actionsMenuReparent);
            });
          }
        }

        _getMenuElements() {
          return this.$.slot.assignedNodes({flatten: true}).filter((node) => node.nodeType === Node.ELEMENT_NODE);
        }

        _getDropdownElements() {
          return this.$.dropdown.assignedNodes({flatten: true}).filter((node) => node.nodeType === Node.ELEMENT_NODE);
        }

        _moveToMenu(el) {
          el.slot = '';
          el.removeAttribute('show-label');
        }

        _moveToDropdown(el) {
          el.slot = 'dropdown';
          el.setAttribute('show-label', '');
        }

        _layout(e) {
          if (e && e.type && e.composedPath().find((el) => el.id === 'reparent' || el.id === 'dropdownButton')) {
            return; // skip events from within reparented actions
          }
          this.__layoutDebouncer = Polymer.Debouncer.debounce(
            this.__layoutDebouncer, Polymer.Async.microTask,
            () => {
              let els = this._getDropdownElements();
              /**
               * XXX: We're using this.contentWidth instead of this.scrollWidth because it takes too much time to be
               * updated on polyfilled browsers (Firex and Edge), leading to an empty menu if there's a single element
               * that doesn't fit on the menu.
               */
              while (els.length && this.contentWidth <= this.clientWidth) {
                this._moveToMenu(els.shift());
              }
              if (!els.length) {
                this.$.dropdownButton.hidden = true;
              }
              // let's move any element in the menu to the "dropdown" slot if it doesn't fit
              els = this._getMenuElements();
              while (els.length && (this.contentWidth + this.$.dropdownButton.offsetWidth) > this.clientWidth) {
                this._moveToDropdown(els.pop());
                if (this.$.dropdownButton.hidden) {
                  this.$.dropdownButton.hidden = false;
                }
              }
            },
          );
        }
      }

      customElements.define(ActionsMenu.is, ActionsMenu);
      Nuxeo.ActionsMenu = ActionsMenu;
    }
  </script>
</dom-module>
<script>
  /* eslint-disable no-var, no-use-before-define */
  var Nuxeo = Nuxeo || {};
  (() => {

    /**
     * `Nuxeo.DirectoryWidgetBehavior` provides helpers to build a widget to select Nuxeo vocabulary entrie(s).
     *
     * @polymerBehavior
     */
    Nuxeo.DirectoryWidgetBehavior = [Nuxeo.I18nBehavior, Polymer.IronFormElementBehavior,
      Polymer.IronValidatableBehavior, {

        properties: {
          /**
           * Name of the directory.
           */
          directoryName: {
            type: String,
          },

          /**
           * Checking this option means that the labels are localized with translations provided
           * in the directory itself (i.e. in fields). Otherwise labels are translated as usual
           * picking values in messages*.properties files.
           */
          dbl10n: { type: Boolean, value: false },

          /**
           * Label.
           */
          label: String,

          /**
           * In case of hierarchical vocabulary, if true, parent item can be selected.
           */
          canSelectParent: Boolean,

          /**
           * Set to `true` for read only mode.
           */
          readonly: {
            type: Boolean,
            value: false,
          },

          /**
           * Function used to get the id from the choice object.
           */
          idFunction: {
            type: Function,
            value() {
              return this._idFunction.bind(this);
            },
          },

          /**
           * Error message to show when `invalid` is true.
           */
          errorMessage: String,

          /**
           * Formatter for the entries.
           */
          format: {
            type: Function,
            value() {
              return this._formatter.bind(this);
            },
          },

          /**
           * Fired when the directory entries are loaded.
           *
           * @event directory-entries-loaded
           */

          _entries: Array,
        },

        observers: [
          '_fetchEntries(directoryName)',
        ],

        _fetchEntries() {
          if (this.directoryName) {
            this.value = [];
            this.async(() => {
              this.$.op.params = {
                directoryName: this.directoryName,
                dbl10n: this.dbl10n,
                canSelectParent: this.canSelectParent,
                localize: true,
                lang: (window.nuxeo.I18n.language) ? window.nuxeo.I18n.language.split('-')[0] : 'en',
              };
              this.$.op.execute().then((resp) => {
                this._entries = [];
                resp.forEach((entry) => {
                  this._populate(entry);
                });
                this.dispatchEvent(new CustomEvent('directory-entries-loaded', {
                  composed: true,
                  bubbles: true,
                }));
              });
            });
          }
        },

        _formatter(entry) {
          return entry.absoluteLabel || entry.displayLabel;
        },

        _idFunction(item) {
          return item.id || item.computedId || item.uid;
        },

        _populate(entry) {
          if (this.canSelectParent || !entry.children) {
            entry.checked = this._isChecked(entry);
            this._entries.push(entry);
          }
          if (entry.children) {
            entry.children.forEach((child) => {
              this._populate(child);
            });
          }
        },
      }];
  })();
</script>
<dom-module id="nuxeo-directory-checkbox" assetpath="bower_components/nuxeo-ui-elements/widgets/">
  <template>
    <style include="iron-flex iron-flex-alignment">
      :host {
        display: block;
        position: relative;
        padding-bottom: 8px;
      }

      [hidden] {
        display: none !important;
      }

      :host([invalid]) .label,
      .error {
        color: var(--paper-input-container-invalid-color, red);
      }

      :host([invalid]) .error {
        opacity: 1;
        font-size: .923rem;
      }

      .label {
         @apply --nuxeo-label;
      }

      .label[required]::after {
        display: inline-block;
        content: '*';
        margin-left: 4px;
        color: var(--paper-input-container-invalid-color, red);
        font-size: 1.2em;
      }

      paper-checkbox {
        margin-top: 10px
      }

    </style>

    <nuxeo-operation id="op" op="Directory.SuggestEntries">
    </nuxeo-operation>

    <label class="label" hidden$="[[!label]]" required$="[[required]]">[[label]]</label>

    <iron-selector attr-for-selected="name" multi="" selected-attribute="checked" class="layout vertical flex" selected-values="{{_selected}}" on-selected-items-changed="_updateItems">
      <dom-repeat items="[[_entries]]">
        <template>
          <paper-checkbox name="[[idFunction(item)]]" data-index="[[index]]" checked="[[item.checked]]" disabled="[[readonly]]">
            [[format(item)]]
          </paper-checkbox>
        </template>
      </dom-repeat>
    </iron-selector>

    <label class="error" hidden$="[[!invalid]]">[[errorMessage]]</label>

  </template>

  <script>
    {
      /**
       * An element for selecting one or more directory entries with checkboxes.
       *
       *     <nuxeo-directory-checkbox directory-name="country" value="{{value}}"></nuxeo-directory-checkbox>
       *
       * @appliesMixin Nuxeo.DirectoryWidgetBehavior
       * @memberof Nuxeo
       * @demo demo/nuxeo-directory-checkbox/index.html
       */
      class DirectoryCheckbox extends Polymer.mixinBehaviors([Nuxeo.DirectoryWidgetBehavior], Nuxeo.Element) {

        static get is() {
          return 'nuxeo-directory-checkbox';
        }

        static get properties() {
          return {
            /**
             * Selected entries.
             */
            selectedItems: {
              type: Array,
              notify: true,
            },

            /**
             * Selected ids.
             */
            value: {
              type: Array,
              notify: true,
            },

            _selected: {
              type: Array,
              value: [],
            },
          };
        }

        _updateItems(e) {
          const tmp = [];
          const tmpIds = [];
          if (e.detail.value) {
            for (let i = 0; i < e.detail.value.length; i++) {
              const item = this._entries[e.detail.value[i].dataIndex];
              tmp.push(item);
              tmpIds.push(this.idFunction(item));
            }
          }
          this.selectedItems = tmp;
          this.value = tmpIds;
        }

        /* Override method from Polymer.IronValidatableBehavior. */
        _getValidity() {
          if (this.required) {
            return this.value && this.value.length > 0;
          }
          return true;
        }

        _isChecked(entry) {
          const value = this.value || this.selectedItems;
          return value && value.some((el) => {
            if (this.idFunction(el) === this.idFunction(entry)) {
              this._selected.push(this.idFunction(entry));
              return true;
            }
            return false;
          });
        }

      }

      customElements.define(DirectoryCheckbox.is, DirectoryCheckbox);
      Nuxeo.DirectoryCheckbox = DirectoryCheckbox;
    }
  </script>
</dom-module>
<dom-module id="nuxeo-directory-radio-group" assetpath="bower_components/nuxeo-ui-elements/widgets/">
  <template>
    <style>
      :host {
        display: block;
        position: relative;
        padding-bottom: 8px;
      }

      [hidden] {
        display: none !important;
      }

      :host([invalid]) .label,
      .error {
        color: var(--paper-input-container-invalid-color, red);
      }

      :host([invalid]) .error {
        opacity: 1;
        font-size: .923rem;
      }

      .label {
         @apply --nuxeo-label;
      }

      .label[required]::after {
        display: inline-block;
        content: '*';
        margin-left: 4px;
        color: var(--paper-input-container-invalid-color, red);
        font-size: 1.2em;
      }

      paper-checkbox {
        margin-top: 10px
      }

    </style>

    <nuxeo-operation id="op" op="Directory.SuggestEntries">
    </nuxeo-operation>

    <label class="label" hidden$="[[!label]]" required$="[[required]]">[[label]]</label>

    <paper-radio-group on-selected-item-changed="_updateItem" selected="{{_selected}}">
      <dom-repeat items="[[_entries]]">
        <template>
          <paper-radio-button name="[[idFunction(item)]]" data-index="[[index]]" checked="[[item.checked]]" disabled="[[readonly]]">
            [[format(item)]]
          </paper-radio-button>
        </template>
      </dom-repeat>
    </paper-radio-group>

    <label class="error" hidden$="[[!invalid]]">[[errorMessage]]</label>

  </template>

  <script>
    {
      /**
       * An element for selecting one directory entry with a radio group widget.
       *
       *     <nuxeo-directory-radio-group directory-name="country" value="{{value}}"></nuxeo-directory-radio-group>
       *
       * @appliesMixin Nuxeo.DirectoryWidgetBehavior
       * @memberof Nuxeo
       * @demo demo/nuxeo-directory-radio-group/index.html
       */
      class DirectoryRadioGroup extends Polymer.mixinBehaviors([Nuxeo.DirectoryWidgetBehavior], Nuxeo.Element) {

        static get is() {
          return 'nuxeo-directory-radio-group';
        }

        static get properties() {
          return {
            /**
             * Selected entry.
             */
            selectedItem: {
              type: Object,
              notify: true,
            },

            /**
             * Selected id.
             */
            value: {
              type: String,
              notify: true,
            },

            _selected: String,
          };
        }

        _updateItem(e) {
          if (e.detail && e.detail.value) {
            this.set('selectedItem', this._entries[e.detail.value.dataIndex]);
            this.set('value', this.idFunction(this.selectedItem));
          }
        }

        /* Override method from Polymer.IronValidatableBehavior. */
        _getValidity() {
          if (this.required) {
            return !!this.value;
          }
          return true;
        }

        _isChecked(entry) {
          const value = this.value || this.selectedItem;
          if (value && this.idFunction(value) === this.idFunction(entry)) {
            this._selected = this.idFunction(entry);
            return true;
          }
          return false;
        }

      }

      customElements.define(DirectoryRadioGroup.is, DirectoryRadioGroup);
      Nuxeo.DirectoryRadioGroup = DirectoryRadioGroup;
    }
  </script>
</dom-module>
<dom-module id="nuxeo-directory-suggestion" assetpath="bower_components/nuxeo-ui-elements/widgets/">
  <template>

    <style>
      :host {
        display: block;
      }

      :host([hidden]) {
        display: none;
      }
    </style>

    <nuxeo-selectivity id="s2" operation="[[operation]]" label="[[label]]" min-chars="[[minChars]]" frequency="[[frequency]]" multiple="[[multiple]]" params="[[_computeParams(params.*, directoryName, dbl10n)]]" placeholder="[[placeholder]]" error-message="[[errorMessage]]" readonly="[[readonly]]" value="{{value}}" selected-items="{{selectedItems}}" selected-item="{{selectedItem}}" selection-formatter="[[selectionFormatter]]" required="[[required]]" invalid="[[invalid]]" resolve-entry="[[resolveEntry]]" stay-open-on-select="[[stayOpenOnSelect]]" id-function="[[idFunction]]" query-results-filter="[[queryResultsFilter]]">
    </nuxeo-selectivity>

  </template>
  <script>
    {
      /**
       * An element for selecting one or more entries from a given directory.
       *
       *     <nuxeo-directory-suggestion directory-name="l10nsubjects"
       *                                 multiple="true"
       *                                 dbl10n="true"
       *                                 value="{{suggestions}}"></nuxeo-directory-suggestion>
       *
       * @appliesMixin Nuxeo.I18nBehavior
       * @appliesMixin Nuxeo.FormatBehavior
       * @appliesMixin Polymer.IronFormElementBehavior
       * @appliesMixin Polymer.IronValidatableBehavior
       * @memberof Nuxeo
       * @demo demo/nuxeo-directory-suggestion/index.html
       */
      class DirectorySuggestion
        extends Polymer.mixinBehaviors([Nuxeo.I18nBehavior, Nuxeo.FormatBehavior, Polymer.IronFormElementBehavior,
          Polymer.IronValidatableBehavior], Nuxeo.Element) {

        static get is() {
          return 'nuxeo-directory-suggestion';
        }

        static get properties() {
          return {
            /**
             * Name of the directory.
             */
            directoryName: {
              type: String,
            },

            /**
             * Checking this option means that the labels are localized with translations provided
             * in the directory itself (i.e. in fields). Otherwise labels are translated as usual
             * picking values in messages*.properties files.
             */
            dbl10n: { type: Boolean, value: false },

            /**
             * Label.
             */
            label: String,

            /**
             * In case of hierarchical vocabulary, if true, parent item can be selected.
             */
            canSelectParent: Boolean,

            /**
             * Operation to call for suggestions.
             */
            operation: {
              type: String,
              value: 'Directory.SuggestEntries',
            },

            /**
             * Parameters for the operation.
             */
            params: Object,

            /**
             * Selected value(s).
             */
            value: {
              type: String,
              notify: true,
            },

            /**
             * Set to `true` to allow multiple selection.
             */
            multiple: {
              type: Boolean,
              value: false,
            },

            /**
             * If true, the dropdown stays open after a selection is made.
             */
            stayOpenOnSelect: {
              type: Boolean,
              value: false,
            },

            /**
             * Set to `true` for read only mode.
             */
            readonly: {
              type: Boolean,
              value: false,
            },

            /**
             * Function used to get the id from the choice object.
             */
            idFunction: {
              type: Function,
              value() {
                return this._idFunction.bind(this);
              },
            },

            /**
             * Minimum number of chars to trigger the suggestions.
             */
            minChars: {
              type: Number,
              value: 3,
            },

            /**
             * Time in ms used to debounce requests.
             */
            frequency: Number,

            /**
             * Placeholder.
             */
            placeholder: String,

            /**
             * Error message to show when `invalid` is true.
             */
            errorMessage: String,

            /**
             * Selected items.
             */
            selectedItems: {
              type: Array,
              notify: true,
            },

            /**
             * Selected item.
             */
            selectedItem: {
              type: Object,
              notify: true,
            },

            /**
             * Formatter for a selected entry.
             */
            selectionFormatter: {
              type: Function,
              value() {
                return this._selectionFormatter.bind(this);
              },
            },

            /**
             * Separator used for hierachical vocabulary entry's label.
             */
            separator: {
              type: String,
              value: '/',
            },

            /**
             * Function that transforms the entries added using the value property into object
             */
            resolveEntry: {
              type: Function,
              value() {
                return this._resolveEntry.bind(this);
              },
            },

            /**
             * Results filtering function (optional).
             */
            queryResultsFilter: Function,
          };
        }

        /* Override method from Polymer.IronValidatableBehavior. */
        _getValidity() {
          return this.$.s2._getValidity();
        }

        _computeParams() {
          return Object.assign({}, {
            directoryName: this.directoryName,
            dbl10n: this.dbl10n,
            canSelectParent: this.canSelectParent,
            localize: true,
            lang: (window.nuxeo.I18n.language) ? window.nuxeo.I18n.language.split('-')[0] : 'en',
          }, this.params);
        }

        _selectionFormatter(entry) {
          return entry.absoluteLabel || entry.displayLabel;
        }

        _resolveEntry(entry) {
          if (entry && entry['entity-type'] && entry['entity-type'] === 'directoryEntry') {
            if (entry.properties) {
              return {
                id: entry.properties.id,
                displayLabel: this.formatDirectory(entry, this.separator),
              };
            }
          }
          return {
            id: entry,
            displayLabel: entry,
          };
        }

        _idFunction(item) {
          return item.computedId || item.id || item.uid;
        }

      }

      customElements.define(DirectorySuggestion.is, DirectorySuggestion);
      Nuxeo.DirectorySuggestion = DirectorySuggestion;
    }
  </script>
</dom-module>
<dom-module id="nuxeo-document-suggestion" assetpath="bower_components/nuxeo-ui-elements/widgets/">
  <template>

    <style>
      :host {
        display: block;
      }

      :host([hidden]) {
        display: none;
      }
    </style>

    <nuxeo-operation id="op" op="Document.FetchByProperty"></nuxeo-operation>

    <nuxeo-selectivity id="s2" operation="[[operation]]" label="[[label]]" min-chars="[[minChars]]" frequency="[[frequency]]" multiple="[[multiple]]" params="[[_computeParams(params.*, pageProvider, schemas, repository)]]" placeholder="[[placeholder]]" error-message="[[errorMessage]]" readonly="[[readonly]]" value="{{value}}" selected-items="{{selectedItems}}" selected-item="{{selectedItem}}" selection-formatter="[[selectionFormatter]]" result-formatter="[[resultFormatter]]" required="[[required]]" invalid="[[invalid]]" init-selection="[[initSelection]]" id-function="[[_idFunction]]" stay-open-on-select="[[stayOpenOnSelect]]" enrichers="[[enrichers]]">
    </nuxeo-selectivity>

  </template>

  <script>
    {
      /**
       * An element for selecting one or more documents.
       *
       *     <nuxeo-document-suggestion></nuxeo-document-suggestion>
       *
       * @appliesMixin Polymer.IronFormElementBehavior
       * @appliesMixin Polymer.IronValidatableBehavior
       * @appliesMixin Nuxeo.RoutingBehavior
       * @memberof Nuxeo
       * @demo demo/nuxeo-document-suggestion/index.html
       */
      class DocumentSuggestion extends
        Polymer.mixinBehaviors([Polymer.IronFormElementBehavior, Polymer.IronValidatableBehavior,
          Nuxeo.RoutingBehavior], Nuxeo.Element) {

        static get is() {
          return 'nuxeo-document-suggestion';
        }

        static get properties() {
          return {
            /**
             * Page provider to use for looking up suggestions.
             */
            pageProvider: {
              type: String,
              value: 'default_document_suggestion',
            },

            /**
             * Document schemas.
             */
            schemas: {
              type: Array,
              value: ['*'],
            },

            /**
             * Repository.
             */
            repository: {
              type: String,
              value: 'default',
            },

            /**
             * Label.
             */
            label: String,

            /**
             * Operation to call for suggestions.
             */
            operation: {
              type: String,
              value: 'Repository.PageProvider',
            },

            /**
             * Parameters for the operation.
             */
            params: Object,

            /**
             * Selected value(s).
             */
            value: {
              type: String,
              notify: true,
            },

            /**
             * Set to `true` to allow multiple selection.
             */
            multiple: {
              type: Boolean,
              value: false,
            },

            /**
             * If true, the dropdown stays open after a selection is made.
             */
            stayOpenOnSelect: {
              type: Boolean,
              value: false,
            },

            /**
             * Set to `true` for read only mode.
             */
            readonly: {
              type: Boolean,
              value: false,
            },

            /**
             * Minimum number of chars to trigger the suggestions.
             */
            minChars: {
              type: Number,
              value: 3,
            },

            /**
             * Time in ms used to debounce requests.
             */
            frequency: Number,

            /**
             * Placeholder.
             */
            placeholder: String,

            /**
             * Error message to show when `invalid` is true.
             */
            errorMessage: String,

            /**
             * Selected items.
             */
            selectedItems: {
              type: Array,
              notify: true,
            },

            /**
             * Selected item.
             */
            selectedItem: {
              type: Object,
              notify: true,
            },

            /**
             * Formatter for a selected entry.
             */
            selectionFormatter: {
              type: Function,
              value() {
                return this._selectionFormatter.bind(this);
              },
            },

            /**
             * Formatter for suggested entries.
             */
            resultFormatter: {
              type: Function,
              value() {
                return this._resultFormatter.bind(this);
              },
            },

            /**
             * Name of the Document property that should be used
             * to define the ID of entry.
             * */
            idProperty: {
              type: String,
              value: 'ecm:uuid',
            },

            /**
             * Function used to get the id from the choice document.
             */
            _idFunction: {
              type: Function,
              value() {
                return this._docIdFunction.bind(this);
              },
            },

            /**
             * Formatter for initial selection.
             */
            initSelection: {
              type: Function,
              value() {
                return this._initSelection.bind(this);
              },
            },

            /**
             * The `content enricher` of the operation.
             */
            enrichers: {
              type: String,
              value: '',
            },
          };
        }

        /* Override method from Polymer.IronValidatableBehavior. */
        _getValidity() {
          return this.$.s2._getValidity();
        }

        _computeParams() {
          return Object.assign({}, {
            documentSchemas: this.schemas,
            repository: this.repository,
            providerName: this.pageProvider,
            pageProviderName: this.pageProvider,
            page: 0,
            pageSize: 20,
          }, this.params);
        }

        _selectionFormatter(doc) {
          return `<a href="${this.urlFor('browse', doc.path)}">${doc.title}</a>`;
        }

        _resultFormatter(doc) {
          return `${doc.title}<br/>${doc.path}`;
        }


        _initSelection(element, callback) {
          if (element) {
            if (this.multiple) {
              if (element.length > 0) {
                if (element[0].title) {
                  return callback(element);
                } else if (typeof element[0] === 'string' && element[0].length > 0) {
                  return this._resolveDocs(element, callback);
                }
              } else {
                return callback([]);
              }
            } else if (element.title) {
              return callback(element);
            } else if (typeof element === 'string') {
              if (element.length > 0) {
                return this._resolveDocs(element, callback);
              } else {
                return callback('');
              }
            }
            console.log('Unable to resolve such entry. Write your own resolver');
          }
        }

        _resolveDocs(docs, callback) {
          this.$.op.params = {
            values: this.value,
            property: this.idProperty,
          };
          this.$.op.execute().then((res) => {
            if (this.multiple) {
              callback(res.entries);
            } else {
              callback(res.entries.length > 0 ? res.entries[0] : null);
            }
          });
        }

        _docIdFunction(doc) {
          if (this.idProperty === 'ecm:uuid') {
            return doc.uid;
          } else {
            return doc.properties[this.idProperty];
          }
        }

      }

      customElements.define(DocumentSuggestion.is, DocumentSuggestion);
      Nuxeo.DocumentSuggestion = DocumentSuggestion;
    }
  </script>
</dom-module>
<dom-module id="nuxeo-tag-suggestion" assetpath="bower_components/nuxeo-ui-elements/widgets/">
  <template>

    <style>
      :host {
        display: block;
      }

      :host([hidden]) {
        display: none;
      }
    </style>

    <nuxeo-selectivity id="s2" operation="[[operation]]" label="[[label]]" min-chars="[[minChars]]" tagging$="[[allowNewTags]]" multiple="" params="[[params]]" placeholder="[[placeholder]]" error-message="[[errorMessage]]" readonly="[[readonly]]" value="{{value}}" selected-items="{{selectedItems}}" required="[[required]]" invalid="[[invalid]]" new-entry-formatter="[[newEntryFormatter]]" result-formatter="[[resultFormatter]]" added-entry-handler="[[addedTagHandler]]" removed-entry-handler="[[removedTagHandler]]" init-selection="[[initSelection]]" stay-open-on-select="[[stayOpenOnSelect]]">
    </nuxeo-selectivity>

    <nuxeo-operation id="addTagOp" op="Services.TagDocument" input="[[document.uid]]">
    </nuxeo-operation>

    <nuxeo-operation id="removeTagOp" op="Services.UntagDocument" input="[[document.uid]]">
    </nuxeo-operation>

    <paper-toast id="toast"></paper-toast>

  </template>

  <script>
    {
      /**
       * `nuxeo-tag-suggestion` allows selecting one or more tags.
       *
       *     <nuxeo-tag-suggestion document="[[document]]"
       *       placeholder="Search for Tags"
       *       value="{{tags}}" allow-new-tags>
       *     </nuxeo-tag-suggestion>
       *
       * @memberof Nuxeo
       * @demo demo/nuxeo-tag-suggestion/index.html
       */
      class TagSuggestion
        extends Polymer.mixinBehaviors([Nuxeo.I18nBehavior, Polymer.IronFormElementBehavior,
          Polymer.IronValidatableBehavior], Nuxeo.Element) {

        static get is() {
          return 'nuxeo-tag-suggestion';
        }

        static get properties() {
          return {
            /**
             * Label.
             */
            label: String,

            /**
             * Operation to call for suggestions.
             */
            operation: {
              type: String,
              value: 'Tag.Suggestion',
            },

            /**
             * Parameters for the operation.
             */
            params: Object,

            /**
             * The document to add / remove tags from.
             */
            document: {
              type: Object,
              observer: '_observeDocument',
            },

            /*
         * Set to true for allowing to add new tags.
         */
            allowNewTags: Boolean,

            /**
             * Selected value(s).
             */
            value: {
              type: String,
              notify: true,
            },

            /**
             * Set to `true` for read only mode.
             */
            readonly: {
              type: Boolean,
              value: false,
            },

            /**
             * Minimum number of chars to trigger the suggestions.
             */
            minChars: {
              type: Number,
              value: 1,
            },

            /**
             * Placeholder.
             */
            placeholder: String,

            /**
             * If true, the dropdown stays open after a selection is made.
             */
            stayOpenOnSelect: {
              type: Boolean,
              value: false,
            },

            /**
             * Error message to show when `invalid` is true.
             */
            errorMessage: String,

            /**
             * Selected items.
             */
            selectedItems: {
              type: Object,
              notify: true,
            },

            /**
             * Formatter for suggested entries.
             */
            resultFormatter: {
              type: Function,
              value() {
                return this._resultFormatter.bind(this);
              },
            },

            /**
             * Formatter for initial selection.
             */
            initSelection: {
              type: Function,
              value() {
                return this._initSelection.bind(this);
              },
            },

            /**
             * Formatter for new suggested entries.
             */
            newEntryFormatter: {
              type: Function,
              value() {
                return this._newEntryFormatter.bind(this);
              },
            },

            /**
             * Handler called when a tag is added.
             */
            addedTagHandler: {
              type: Function,
              value() {
                return this._addedTagHandler.bind(this);
              },
            },

            /**
             * Handler called when a tag is removed.
             */
            removedTagHandler: {
              type: Function,
              value() {
                return this._removedTagHandler.bind(this);
              },
            },
          };
        }

        /* Override method from Polymer.IronValidatableBehavior. */
        _getValidity() {
          return this.$.s2._getValidity();
        }

        _resultFormatter(tag) {
          if (tag.newTag) {
            return `<span class='s2newTag'>+ ${this.$.s2.escapeHTML(tag.displayLabel)}</span>`;
          } else {
            return `<span class='s2existingTag'>${this.$.s2.escapeHTML(tag.displayLabel)}</span>`;
          }
        }

        _newEntryFormatter(term) {
          return { id: term, displayLabel: term, newTag: true };
        }

        _addedTagHandler(entry) {
          if (this.document) {
            this.$.addTagOp.params = { tags: entry.id };
            this.$.addTagOp.execute().then(() => {
              this.$.toast.hide();
              this.$.toast.text = this.i18n('tags.addedToDocument', entry.id);
              this.$.toast.open();
            });
          }
        }

        _removedTagHandler(entry) {
          if (this.document) {
            this.$.removeTagOp.params = { tags: entry.id };
            this.$.removeTagOp.execute().then(() => {
              this.$.toast.hide();
              this.$.toast.text = this.i18n('tags.removedFromDocument', entry.id);
              this.$.toast.open();
            });
          }
        }

        _initSelection(element, callback) {
          return callback(this.value.map((entry) => {
            return { id: entry, displayLabel: entry };
          }));
        }

        _observeDocument() {
          if (this.document) {
            if (this.document.contextParameters && this.document.contextParameters.tags) {
              this.value = this.document.contextParameters.tags;
            } else {
              this.value = [];
              console.warn('Cannot use nuxeo-tag-element on a document that has no tag in its contextParameters. ' +
                  "Make sure you use the 'tags' enricher to fetch the document");
            }
          } else {
            this.value = [];
          }
        }

      }

      customElements.define(TagSuggestion.is, TagSuggestion);
      Nuxeo.TagSuggestion = TagSuggestion;
    }
  </script>
</dom-module>
<dom-module id="nuxeo-file" assetpath="bower_components/nuxeo-ui-elements/widgets/">
  <template>
    <style>
    :host {
      @apply --layout-flex;
    }

    [hidden] {
      display: none;
    }

    #dropZone.hover {
      @apply --nuxeo-drop-zone-hover;
    }

    a {
      @apply --nuxeo-link;
    }

    a:hover {
      @apply --nuxeo-link-hover;
    }

    :host([required]) #button::after {
      display: inline-block;
      content: '*';
      margin-left: 4px;
      color: var(--paper-input-container-invalid-color, red);
    }

    :host([invalid]) paper-button {
      color: var(--paper-input-container-invalid-color, red);
      margin-bottom: 5px;
    }

    :host([invalid]) .error {
      color: var(--paper-input-container-invalid-color, red);
    }

    #button {
      margin-bottom: 5px;
    }

    iron-icon {
      cursor: pointer;
    }
    </style>

    <nuxeo-connection id="nx"></nuxeo-connection>

    <input hidden="" id="input" type="file" multiple$="[[multiple]]" accept$="[[accept]]" on-change="_filesChanged" required$="[[required]]">

    <div id="dropZone" hidden$="[[readonly]]">
      <dom-if if="[[!uploading]]">
        <template>
          <paper-button id="button" raised="" on-click="_pick">
            <iron-icon icon="nuxeo:upload"></iron-icon>
            <span>[[i18n('file.upload')]]</span>
          </paper-button>
        </template>
      </dom-if>
    </div>

    <label class="error" hidden$="[[!invalid]]">[[errorMessage]]</label>

    <dom-if if="[[_hasSingleValue(multiple, value)]]">
      <template>
        <div class="file">
          <div class="layout horizontal">
            <a href$="[[_data(value)]]" download="[[_fileName(value)]]">[[_fileName(value)]]</a>
            <iron-icon icon="nuxeo:remove" title="[[i18n('command.remove')]]" on-click="remove" hidden$="[[readonly]]"></iron-icon>
          </div>
        </div>
      </template>
    </dom-if>

    <dom-if if="[[multiple]]">
      <template>
        <dom-repeat items="[[value]]" as="file">
          <template>
            <div class="file">
              <div class="layout horizontal">
                <a href$="[[_data(file)]]" download="[[_fileName(file)]]">[[_fileName(file)]]</a>
                <iron-icon icon="nuxeo:remove" title="[[i18n('command.remove')]]" on-click="remove" hidden$="[[readonly]]"></iron-icon>
              </div>
            </div>
          </template>
        </dom-repeat>
      </template>
    </dom-if>

    <dom-if if="[[readonly]]">
      <template>
        <label class="empty" hidden$="[[!_hasValue(value)]]">[[emptyLabel]]</label>
      </template>
    </dom-if>


  </template>

  <script>
    {
      /**
       * An element for uploading blobs using the batch upload API.
       *
       *     <nuxeo-file value="{{document.properties.file:content}}"></nuxeo-file>
       *
       * @appliesMixin Nuxeo.UploaderBehavior
       * @memberof Nuxeo
       * @demo demo/nuxeo-file/index.html
       */
      class File extends Polymer.mixinBehaviors([Nuxeo.UploaderBehavior, Nuxeo.I18nBehavior,
        Polymer.IronFormElementBehavior, Polymer.IronValidatableBehavior], Nuxeo.Element) {

        static get is() {
          return 'nuxeo-file';
        }

        static get properties() {
          return {
            /**
             * Blob reference (`upload-batch` and `upload-fileId).
             */
            value: {
              type: Object,
              notify: true,
            },

            /**
             * Set to `true` to allow uploading multiple files.
             */
            multiple: {
              type: Boolean,
              value: false,
            },

            /**
             * Read only.
             */
            readonly: {
              type: Boolean,
              value: false,
              reflectToAttribute: true,
            },

            /**
             * Required.
             */
            required: {
              type: Boolean,
              value: false,
              reflectToAttribute: true,
            },

            /**
             * Empty message to show when no uploaded files in readonly mode.
             */
            emptyLabel: String,

            /**
             * Error message to show when `invalid` is true.
             */
            errorMessage: String,
          };
        }

        ready() {
          super.ready();
          this.connection = this.$.nx;
          this.setupDropZone(this.$.dropZone);
          this.addEventListener('batchFinished', this._updateValue);
        }

        disconnectedCallback() {
          super.disconnectedCallback();
          this.teardownDropZone();
        }

        _filesChanged(e) {
          this.uploadFiles(e.target.files);
        }

        _pick() {
          this.$.input.click();
        }

        _updateValue() {
          if (this.multiple) {
            if (!this.value || !Array.isArray(this.value)) {
              this.value = [];
            }
            for (let i = 0; i < this.files.length; i++) {
              this.push('value', {
                'upload-batch': this.batchId,
                'upload-fileId': i.toString(),
              });
            }

          } else {
            this.value = {
              'upload-batch': this.batchId,
              'upload-fileId': (this.files.length - 1).toString(),
            };
          }
        }

        remove(e) {
          if (this.multiple) {
            this.splice('value', e.model.__data.index, 1);
          } else {
            this.value = null;
            this.files = null;
          }
        }

        _fileName(file) {
          return file.name || ('upload-fileId' in file && this.files[Number(file['upload-fileId'])].name);
        }

        _data(file) {
          return file.data || ('upload-fileId' in file && URL.createObjectURL(this.files[Number(file['upload-fileId'])]));
        }

        _getValidity() {
          return !this.required || this._hasValue();
        }

        _hasSingleValue() {
          return !this.multiple && this._hasValue();
        }

        _hasValue() {
          return this.multiple ? !!this.value && this.value.length > 0 : !!this.value;
        }

      }

      customElements.define(File.is, File);
      Nuxeo.File = File;
    }
  </script>
</dom-module>
<dom-module id="nuxeo-operation-button" assetpath="bower_components/nuxeo-ui-elements/widgets/">
  <template>
    <style include="nuxeo-action-button-styles"></style>

    <nuxeo-operation id="op" op="[[operation]]" input="[[input]]" params="[[params]]" sync-indexing$="[[syncIndexing]]" async$="[[async]]" poll-interval="[[pollInterval]]">
    </nuxeo-operation>

    <div class="action" on-click="_execute">
      <paper-icon-button id="bt" icon="[[icon]]"></paper-icon-button>
      <span class="label" hidden$="[[!showLabel]]">[[i18n(label)]]</span>
    </div>
    <nuxeo-tooltip>[[i18n(_tooltip)]]</nuxeo-tooltip>
  </template>

  <script>
    {
      /**
       * An element for running an operation.
       *
       * Example:
       *
       *     <nuxeo-operation-button
       *         icon="icons:account-box" label="Get user"
       *         operation="User.Get" response="{{operationResponse}}">
       *     </nuxeo-operation-button>
       *
       * @appliesMixin Nuxeo.I18nBehavior
       * @memberof Nuxeo
       * @demo demo/nuxeo-operation-button/index.html
       */
      class OperationButton extends Polymer.mixinBehaviors([Nuxeo.I18nBehavior], Nuxeo.Element) {

        static get is() {
          return 'nuxeo-operation-button';
        }

        static get properties() {
          return {
            /* Icon name, can be anything taken from the [material icons](https://material.io/icons/), e.g. "chat", "description". */
            icon: String,

            /* Label (shown inside menu dropdowns and on tooltips) */
            label: String,

            /* Tooltip label. If `undefined`, `label` will be used instead. */
            tooltip: String,

            /**
             * `true` if the action should display the label, `false` otherwise.
             */
            showLabel: {
              type: Boolean,
              value: false,
            },

            /* The id of the operation, automation chain or script to call. */
            operation: String,

            /* Pass contextual information that will be forwarded to the operation,
             * automation chain or script triggered as the input for the first
             * operation. Possible options depend on the slot chosen.
             * [Documentation](https://doc.nuxeo.com/nxdoc/web-ui-slots)
             */
            input: Object,

            /**
             * If true, documents changed by the operation call will be reindexed synchronously server side.
             */
            syncIndexing: Boolean,

            /* The parameters to send. */
            params: {
              type: Object,
              value() {
                return {};
              },
            },

            /* The response from the server. */
            response: {
              type: Object,
              value: null,
              notify: true,
            },

            /* The text or i18n key to display in the notification. */
            notification: {
              type: String,
            },

            /* Trigger download of Blob response. */
            download: {
              type: Boolean,
              value: false,
            },

            /* The event type to fire on completion. */
            event: {
              type: String,
              value: 'operation-executed',
            },

            /* The detail of the event fired on completion.  */
            detail: {
              type: String,
            },

            /**
             * If true, execute the operation asynchronously.
             */
            async: {
              type: Boolean,
              value: false,
            },

            /**
             * Poll interval in ms.
             */
            pollInterval: {
              type: Number,
              value: 1000,
            },

            /**
             * A custom label to be displayed if there is an error during the operation execution. If `undefined`, the
             * original error message is shown. The label can receive a placeholder (i.e. `{0}`) to display the original
             * error message.
             */
            errorLabel: {
              type: String,
            },

            _tooltip: {
              type: String,
              computed: '_computeTooltip(tooltip, label)',
            },
          };
        }

        _execute() {
          this.$.op.execute().then((response) => {
            if (this.notification) {
              this.dispatchEvent(new CustomEvent('notify', {
                composed: true,
                bubbles: true,
                detail: { message: this.i18n(this.notification) },
              }));
            }
            let detail = { response };
            if (this.detail) {
              // if the supplied params are a string, parse them as JSON
              detail = typeof this.detail === 'string' ? JSON.parse(this.detail) : this.detail;
            }
            this.dispatchEvent(new CustomEvent(this.event, {
              composed: true,
              bubbles: true,
              detail,
            }));

            if (this.download) {
              return this._download(response);
            }
          })
            .catch((error) => {
              this.dispatchEvent(new CustomEvent('notify', {
                composed: true,
                bubbles: true,
                detail: { message: this.errorLabel ? this.i18n(this.errorLabel, error) : error },
              }));
              if (error.status !== 404) {
                throw error;
              }
            });
        }

        // https://jira.nuxeo.com/browse/ELEMENTS-370
        _download(response) {
          const contentDisposition = response.headers.get('Content-Disposition');
          if (contentDisposition) {
            const filenameMatches = contentDisposition
              .match(/filename[^;=\n]*=([^;\n]*''([^;\n]*)|[^;\n]*)/).filter((match) => !!match);
            const filename = decodeURI(filenameMatches[filenameMatches.length - 1]);
            return response.blob().then((blob) => {
              if (navigator.msSaveBlob) {
                // handle IE11 and Edge
                navigator.msSaveBlob(blob, filename);
              } else {
                const a = document.createElement('a');
                a.style = 'display: none';
                a.download = filename;
                a.href = URL.createObjectURL(blob);
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(a.href);
              }
            });
          } else {
            return Promise.reject(new Error('missing Content-Disposition header'));
          }
        }

        _computeTooltip(tooltip, label) {
          return tooltip || label;
        }

      }

      customElements.define(OperationButton.is, OperationButton);
      Nuxeo.OperationButton = OperationButton;
    }
  </script>
</dom-module>
<dom-module id="nuxeo-tags" assetpath="bower_components/nuxeo-ui-elements/widgets/">
  <template>
    <style>
        :host {
          display: inline-block;
        }
      </style>
    <dom-repeat items="[[items]]" as="item">
      <template>
        <dom-if if="[[_type('tag')]]">
          <template>
            <nuxeo-tag>[[item]]</nuxeo-tag>
          </template>
        </dom-if>
        <dom-if if="[[_type('user')]]">
          <template>
            <nuxeo-user-tag user="[[item]]"></nuxeo-user-tag>
          </template>
        </dom-if>
        <dom-if if="[[_type('group')]]">
          <template>
            <nuxeo-group-tag group="[[item]]"></nuxeo-group-tag>
          </template>
        </dom-if>
      </template>
    </dom-repeat>
  </template>

  <script>
    {
      /**
       * An element to display a list of tags.
       *
       * Example:
       *
       *     <nuxeo-tags type="user" tags='["User 1", "User 2", "User 3"]'></nuxeo-tags>
       *
       * @memberof Nuxeo
       * @demo demo/nuxeo-tags/index.html
       */
      class Tags extends Nuxeo.Element {

        static get is() {
          return 'nuxeo-tags';
        }

        static get properties() {
          return {
            /**
             * Type ("tag", "user", "group").
             */
            type: {
              type: String,
              value: 'tag',
            },

            /**
             * Array of user/group entities or strings.
             */
            items: {
              type: Array,
            },
          };
        }

        _type(value) {
          return this.type === value;
        }

      }

      customElements.define(Tags.is, Tags);
      Nuxeo.Tags = Tags;
    }
  </script>

</dom-module>
<script type="text/javascript">
  CKEDITOR.config.customConfig = ''; // skip loading config.js
  CKEDITOR.config.language = 'en'; // force en locale since it is the only one being vulcanized
  AlloyEditor._langResourceRequested = true; // skip loading of language file
</script>

<script type="text/javascript">/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or http://ckeditor.com/license
 */

CKEDITOR.editorConfig = function( config ) {
	// Define changes to default configuration here.
	// For complete reference see:
	// http://docs.ckeditor.com/#!/api/CKEDITOR.config

	// The toolbar groups arrangement, optimized for a single toolbar row.
	config.toolbarGroups = [
		{ name: 'document',	   groups: [ 'mode', 'document', 'doctools' ] },
		{ name: 'clipboard',   groups: [ 'clipboard', 'undo' ] },
		{ name: 'editing',     groups: [ 'find', 'selection', 'spellchecker' ] },
		{ name: 'forms' },
		{ name: 'basicstyles', groups: [ 'basicstyles', 'cleanup' ] },
		{ name: 'paragraph',   groups: [ 'list', 'indent', 'blocks', 'align', 'bidi' ] },
		{ name: 'links' },
		{ name: 'insert' },
		{ name: 'styles' },
		{ name: 'colors' },
		{ name: 'tools' },
		{ name: 'others' },
		{ name: 'about' }
	];

	// The default plugins included in the basic setup define some buttons that
	// are not needed in a basic editor. They are removed here.
	config.removeButtons = 'Cut,Copy,Paste,Undo,Redo,Anchor,Underline,Strike,Subscript,Superscript';

	// Dialog windows are also simplified.
	config.removeDialogTabs = 'link:advanced';
};
</script>
<script type="text/javascript">/*
Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
For licensing, see LICENSE.md or http://ckeditor.com/license
*/
CKEDITOR.lang['en']={"editor":"Rich Text Editor","editorPanel":"Rich Text Editor panel","common":{"editorHelp":"Press ALT 0 for help","browseServer":"Browse Server","url":"URL","protocol":"Protocol","upload":"Upload","uploadSubmit":"Send it to the Server","image":"Image","flash":"Flash","form":"Form","checkbox":"Checkbox","radio":"Radio Button","textField":"Text Field","textarea":"Textarea","hiddenField":"Hidden Field","button":"Button","select":"Selection Field","imageButton":"Image Button","notSet":"<not set>","id":"Id","name":"Name","langDir":"Language Direction","langDirLtr":"Left to Right (LTR)","langDirRtl":"Right to Left (RTL)","langCode":"Language Code","longDescr":"Long Description URL","cssClass":"Stylesheet Classes","advisoryTitle":"Advisory Title","cssStyle":"Style","ok":"OK","cancel":"Cancel","close":"Close","preview":"Preview","resize":"Resize","generalTab":"General","advancedTab":"Advanced","validateNumberFailed":"This value is not a number.","confirmNewPage":"Any unsaved changes to this content will be lost. Are you sure you want to load new page?","confirmCancel":"You have changed some options. Are you sure you want to close the dialog window?","options":"Options","target":"Target","targetNew":"New Window (_blank)","targetTop":"Topmost Window (_top)","targetSelf":"Same Window (_self)","targetParent":"Parent Window (_parent)","langDirLTR":"Left to Right (LTR)","langDirRTL":"Right to Left (RTL)","styles":"Style","cssClasses":"Stylesheet Classes","width":"Width","height":"Height","align":"Alignment","alignLeft":"Left","alignRight":"Right","alignCenter":"Center","alignJustify":"Justify","alignTop":"Top","alignMiddle":"Middle","alignBottom":"Bottom","alignNone":"None","invalidValue":"Invalid value.","invalidHeight":"Height must be a number.","invalidWidth":"Width must be a number.","invalidCssLength":"Value specified for the \"%1\" field must be a positive number with or without a valid CSS measurement unit (px, %, in, cm, mm, em, ex, pt, or pc).","invalidHtmlLength":"Value specified for the \"%1\" field must be a positive number with or without a valid HTML measurement unit (px or %).","invalidInlineStyle":"Value specified for the inline style must consist of one or more tuples with the format of \"name : value\", separated by semi-colons.","cssLengthTooltip":"Enter a number for a value in pixels or a number with a valid CSS unit (px, %, in, cm, mm, em, ex, pt, or pc).","unavailable":"%1<span class=\"cke_accessibility\">, unavailable</span>","keyboard":{"8":"Backspace","13":"Enter","16":"Shift","17":"Ctrl","18":"Alt","32":"Space","35":"End","36":"Home","46":"Delete","224":"Command"},"keyboardShortcut":"Keyboard shortcut"},"basicstyles":{"bold":"Bold","italic":"Italic","strike":"Strikethrough","subscript":"Subscript","superscript":"Superscript","underline":"Underline"},"blockquote":{"toolbar":"Block Quote"},"clipboard":{"copy":"Copy","copyError":"Your browser security settings don't permit the editor to automatically execute copying operations. Please use the keyboard for that (Ctrl/Cmd+C).","cut":"Cut","cutError":"Your browser security settings don't permit the editor to automatically execute cutting operations. Please use the keyboard for that (Ctrl/Cmd+X).","paste":"Paste","pasteArea":"Paste Area","pasteMsg":"Please paste inside the following box using the keyboard (<strong>Ctrl/Cmd+V</strong>) and hit OK","securityMsg":"Because of your browser security settings, the editor is not able to access your clipboard data directly. You are required to paste it again in this window.","title":"Paste"},"horizontalrule":{"toolbar":"Insert Horizontal Line"},"indent":{"indent":"Increase Indent","outdent":"Decrease Indent"},"justify":{"block":"Justify","center":"Center","left":"Align Left","right":"Align Right"},"list":{"bulletedlist":"Insert/Remove Bulleted List","numberedlist":"Insert/Remove Numbered List"},"pastefromword":{"confirmCleanup":"The text you want to paste seems to be copied from Word. Do you want to clean it before pasting?","error":"It was not possible to clean up the pasted data due to an internal error","title":"Paste from Word","toolbar":"Paste from Word"},"removeformat":{"toolbar":"Remove Format"},"undo":{"redo":"Redo","undo":"Undo"},"widget":{"move":"Click and drag to move","label":"%1 widget"}};</script>
<script type="text/javascript">AlloyEditor.Strings = {"alignCenter":"Center","alignJustify":"Justify","alignLeft":"Left","alignRight":"Right","bold":"Bold","bulletedlist":"Insert/Remove Bulleted List","cancel":"Cancel","horizontalrule":"Insert Horizontal Line","italic":"Italic","numberedlist":"Insert/Remove Numbered List","quote":"Block Quote","removeformat":"Remove Format","strike":"Strikethrough","subscript":"Subscript","superscript":"Superscript","underline":"Underline","formatted":"Formatted","h1":"Heading 1","h2":"Heading 2","normal":"Normal","indent":"Increase Indent","outdent":"Decrease Indent","blockStyles":"Block Styles","inlineStyles":"Inline Styles","objectStyles":"Object Styles","styles":"Styles","cell":"Cell","cellDelete":"Delete Cells","cellInsertAfter":"Insert Cell After","cellInsertBefore":"Insert Cell Before","cellMerge":"Merge Cells","cellMergeDown":"Merge Down","cellMergeRight":"Merge Right","cellSplitHorizontal":"Split Cell Horizontally","cellSplitVertical":"Split Cell Vertically","column":"Column","columnDelete":"Delete Columns","columnInsertAfter":"Insert Column After","columnInsertBefore":"Insert Column Before","deleteTable":"Delete Table","headers":"Headers","headersBoth":"Both","headersColumn":"First column","headersNone":"None","headersRow":"First Row","row":"Row","rowDelete":"Delete Rows","rowInsertAfter":"Insert Row After","rowInsertBefore":"Insert Row Before","add":"Add","ariaUpdateNoToolbar":"No toolbars are available","ariaUpdateOneToolbar":"{toolbars} toolbar is available. Press ALT+F10 to focus.","ariaUpdateManyToolbars":"{toolbars} toolbars are available. Press ALT+F10 to focus.","camera":"Insert Image from Camera","cameraDisabled":"The browser does not support this action, or it is available on https only (Chrome).","cite":"Cite","clearInput":"Clear Input Field","code":"Code","columns":"Cols","confirm":"Confirm","deleteEmbed":"Delete embed","editLink":"Type or paste link here","image":"Insert Image","link":"Link","linkTargetBlank":"_blank (new tab)","linkTargetDefault":"default","linkTargetParent":"_parent","linkTargetSelf":"_self (same tab)","linkTargetTop":"_top","removeLink":"Remove link","rows":"Rows","table":"Insert Table"};</script>
<script type="text/javascript">/**
 * Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or http://ckeditor.com/license
 */

// This file contains style definitions that can be used by CKEditor plugins.
//
// The most common use for it is the "stylescombo" plugin which shows the Styles drop-down
// list containing all styles in the editor toolbar. Other plugins, like
// the "div" plugin, use a subset of the styles for their features.
//
// If you do not have plugins that depend on this file in your editor build, you can simply
// ignore it. Otherwise it is strongly recommended to customize this file to match your
// website requirements and design properly.
//
// For more information refer to: http://docs.ckeditor.com/#!/guide/dev_styles-section-style-rules

CKEDITOR.stylesSet.add( 'default', [
	/* Block styles */

	// These styles are already available in the "Format" drop-down list ("format" plugin),
	// so they are not needed here by default. You may enable them to avoid
	// placing the "Format" combo in the toolbar, maintaining the same features.
	/*
	{ name: 'Paragraph',		element: 'p' },
	{ name: 'Heading 1',		element: 'h1' },
	{ name: 'Heading 2',		element: 'h2' },
	{ name: 'Heading 3',		element: 'h3' },
	{ name: 'Heading 4',		element: 'h4' },
	{ name: 'Heading 5',		element: 'h5' },
	{ name: 'Heading 6',		element: 'h6' },
	{ name: 'Preformatted Text',element: 'pre' },
	{ name: 'Address',			element: 'address' },
	*/

	{ name: 'Italic Title',		element: 'h2', styles: { 'font-style': 'italic' } },
	{ name: 'Subtitle',			element: 'h3', styles: { 'color': '#aaa', 'font-style': 'italic' } },
	{
		name: 'Special Container',
		element: 'div',
		styles: {
			padding: '5px 10px',
			background: '#eee',
			border: '1px solid #ccc'
		}
	},

	/* Inline styles */

	// These are core styles available as toolbar buttons. You may opt enabling
	// some of them in the Styles drop-down list, removing them from the toolbar.
	// (This requires the "stylescombo" plugin.)
	/*
	{ name: 'Strong',			element: 'strong', overrides: 'b' },
	{ name: 'Emphasis',			element: 'em'	, overrides: 'i' },
	{ name: 'Underline',		element: 'u' },
	{ name: 'Strikethrough',	element: 'strike' },
	{ name: 'Subscript',		element: 'sub' },
	{ name: 'Superscript',		element: 'sup' },
	*/

	{ name: 'Marker',			element: 'span', attributes: { 'class': 'marker' } },

	{ name: 'Big',				element: 'big' },
	{ name: 'Small',			element: 'small' },
	{ name: 'Typewriter',		element: 'tt' },

	{ name: 'Computer Code',	element: 'code' },
	{ name: 'Keyboard Phrase',	element: 'kbd' },
	{ name: 'Sample Text',		element: 'samp' },
	{ name: 'Variable',			element: 'var' },

	{ name: 'Deleted Text',		element: 'del' },
	{ name: 'Inserted Text',	element: 'ins' },

	{ name: 'Cited Work',		element: 'cite' },
	{ name: 'Inline Quotation',	element: 'q' },

	{ name: 'Language: RTL',	element: 'span', attributes: { 'dir': 'rtl' } },
	{ name: 'Language: LTR',	element: 'span', attributes: { 'dir': 'ltr' } },

	/* Object styles */

	{
		name: 'Styled Image (left)',
		element: 'img',
		attributes: { 'class': 'left' }
	},

	{
		name: 'Styled Image (right)',
		element: 'img',
		attributes: { 'class': 'right' }
	},

	{
		name: 'Compact Table',
		element: 'table',
		attributes: {
			cellpadding: '5',
			cellspacing: '0',
			border: '1',
			bordercolor: '#ccc'
		},
		styles: {
			'border-collapse': 'collapse'
		}
	},

	{ name: 'Borderless Table',		element: 'table',	styles: { 'border-style': 'hidden', 'background-color': '#E6E6FA' } },
	{ name: 'Square Bulleted List',	element: 'ul',		styles: { 'list-style-type': 'square' } },

	/* Widget styles */

	{ name: 'Clean Image', type: 'widget', widget: 'image', attributes: { 'class': 'image-clean' } },
	{ name: 'Grayscale Image', type: 'widget', widget: 'image', attributes: { 'class': 'image-grayscale' } },

	{ name: 'Featured Snippet', type: 'widget', widget: 'codeSnippet', attributes: { 'class': 'code-featured' } },

	{ name: 'Featured Formula', type: 'widget', widget: 'mathjax', attributes: { 'class': 'math-featured' } },

	{ name: '240p', type: 'widget', widget: 'embedSemantic', attributes: { 'class': 'embed-240p' } },
	{ name: '360p', type: 'widget', widget: 'embedSemantic', attributes: { 'class': 'embed-360p' } },
	{ name: '480p', type: 'widget', widget: 'embedSemantic', attributes: { 'class': 'embed-480p' } },
	{ name: '720p', type: 'widget', widget: 'embedSemantic', attributes: { 'class': 'embed-720p' } },
	{ name: '1080p', type: 'widget', widget: 'embedSemantic', attributes: { 'class': 'embed-1080p' } },

	// Adding space after the style name is an intended workaround. For now, there
	// is no option to create two styles with the same name for different widget types. See #16664.
	{ name: '240p ', type: 'widget', widget: 'embed', attributes: { 'class': 'embed-240p' } },
	{ name: '360p ', type: 'widget', widget: 'embed', attributes: { 'class': 'embed-360p' } },
	{ name: '480p ', type: 'widget', widget: 'embed', attributes: { 'class': 'embed-480p' } },
	{ name: '720p ', type: 'widget', widget: 'embed', attributes: { 'class': 'embed-720p' } },
	{ name: '1080p ', type: 'widget', widget: 'embed', attributes: { 'class': 'embed-1080p' } }

] );

</script><style>
  @font-face {
    font-family: 'alloyeditor-ocean';
    src:url("bower_components/nuxeo-ui-elements/widgets/alloy/fonts/alloyeditor-ocean.eot");
    src:url("bower_components/nuxeo-ui-elements/widgets/alloy/fonts/alloyeditor-ocean.eot?#iefix") format('embedded-opentype'),
    url("bower_components/nuxeo-ui-elements/widgets/alloy/fonts/alloyeditor-ocean.woff") format('woff'),
    url("bower_components/nuxeo-ui-elements/widgets/alloy/fonts/alloyeditor-ocean.ttf") format('truetype'),
    url("bower_components/nuxeo-ui-elements/widgets/alloy/fonts/alloyeditor-ocean.svg#alloyeditor-ocean") format('svg');
    font-weight: normal;
    font-style: normal;
  }
</style>

<dom-module id="alloy-ocean" assetpath="bower_components/nuxeo-ui-elements/widgets/alloy/">
  <template>
    <style>
      [class*="ae-icon-"], [class*=" ae-icon-"] {
        display: block;
        font-family: 'alloyeditor-ocean';
        speak: none;
        font-size: 20px;
        font-style: normal;
        font-weight: normal;
        font-variant: normal;
        text-transform: none;
        line-height: 1.2;

        /* Better Font Rendering =========== */
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }


      .ae-icon-add:before {
        content: "\";
      }

      .ae-icon-align-center:before {
        content: "\";
      }

      .ae-icon-align-justified:before {
        content: "\";
      }

      .ae-icon-align-left:before {
        content: "\";
      }

      .ae-icon-align-right:before {
        content: "\";
      }

      .ae-icon-arrow:before {
        content: "\";
      }

      .ae-icon-audio:before {
        content: "\";
      }

      .ae-icon-bin:before {
        content: "\";
      }

      .ae-icon-bold:before {
        content: "\";
      }

      .ae-icon-bulleted-list:before {
        content: "\";
      }

      .ae-icon-camera:before {
        content: "\";
      }

      .ae-icon-cell:before {
        content: "\";
      }

      .ae-icon-close:before {
        content: "\";
      }

      .ae-icon-code:before {
        content: "\";
      }

      .ae-icon-column:before {
        content: "\";
      }

      .ae-icon-embed:before {
        content: "\";
      }

      .ae-icon-folder:before {
        content: "\";
      }

      .ae-icon-h1:before {
        content: "\";
      }

      .ae-icon-h2:before {
        content: "\";
      }

      .ae-icon-image:before {
        content: "\";
      }

      .ae-icon-indent-block:before {
        content: "\";
      }

      .ae-icon-italic:before {
        content: "\";
      }

      .ae-icon-link:before {
        content: "\";
      }

      .ae-icon-numbered-list:before {
        content: "\";
      }

      .ae-icon-ok:before {
        content: "\";
      }

      .ae-icon-outdent-block:before {
        content: "\";
      }

      .ae-icon-quote:before {
        content: "\";
      }

      .ae-icon-redo:before {
        content: "\";
      }

      .ae-icon-remove:before {
        content: "\";
      }

      .ae-icon-removeformat:before {
        content: "\";
      }

      .ae-icon-row:before {
        content: "\";
      }

      .ae-icon-separator:before {
        content: "\";
      }

      .ae-icon-strike:before {
        content: "\";
      }

      .ae-icon-subscript:before {
        content: "\";
      }

      .ae-icon-superscript:before {
        content: "\";
      }

      .ae-icon-table:before {
        content: "\";
      }

      .ae-icon-twitter:before {
        content: "\";
      }

      .ae-icon-underline:before {
        content: "\";
      }

      .ae-icon-undo:before {
        content: "\";
      }

      .ae-icon-unlink:before {
        content: "\";
      }

      .ae-icon-video:before {
        content: "\";
      }
      @charset "UTF-8";
      /** GENERAL VARIABLES */
      /** COMPONENT VARIABLES **/
      /** DROPDOWN-LISTBOX **/
      /** DROPDOWN-LISTBOX HEADER **/
      /** DROPDOWN-LISTBOX ITEM */
      /**
       * The order of imports is as follow:
       * CSS for outer (parent) components should precede
       * the CSS of nested components or components which
       * stay on the same level in the hierarchy.
       */
      .ae-placeholder:not(:focus):before {
        content: attr(data-placeholder);
        position: absolute; }

      .ae-twitter-link {
        padding: 0 5px; }
      .ae-twitter-link:after {
        display: inline-block;
        margin: 0 0 0 4px;
        vertical-align: middle; }

      .ae-sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        border: 0; }

      .ae-ui IE10-PLUS::-ms-reveal, .ae-ui [class^=ae-toolbar] {
        height: auto;
        box-sizing: content-box; }

      .ae-ui .ae-toolbar, .ae-ui [class^=ae-toolbar-] {
        line-height: 1;
        padding: 10px;
        position: absolute; }
      .ae-ui .ae-toolbar input, .ae-ui .ae-toolbar textarea, .ae-ui .ae-toolbar keygen, .ae-ui .ae-toolbar select, .ae-ui .ae-toolbar button, .ae-ui [class^=ae-toolbar-] input, .ae-ui [class^=ae-toolbar-] textarea, .ae-ui [class^=ae-toolbar-] keygen, .ae-ui [class^=ae-toolbar-] select, .ae-ui [class^=ae-toolbar-] button {
        font-size: 14px; }
      .ae-ui .ae-toolbar.ae-toolbar-transition, .ae-ui [class^=ae-toolbar-].ae-toolbar-transition {
        -webkit-transition-property: height, left, opacity, top;
        -moz-transition-property: height, left, opacity, top;
        transition-property: height, left, opacity, top;
        -webkit-transition-duration: 0.15s;
        -moz-transition-duration: 0.15s;
        transition-duration: 0.15s;
        -webkit-transition-timing-function: ease-out;
        -moz-transition-timing-function: ease-out;
        transition-timing-function: ease-out; }
      .ae-ui .ae-toolbar .ae-button, .ae-ui .ae-toolbar .ae-toolbar-element, .ae-ui [class^=ae-toolbar-] .ae-button, .ae-ui [class^=ae-toolbar-] .ae-toolbar-element {
        border-width: 0;
        color: inherit;
        cursor: pointer;
        margin: 0;
        padding: 0; }
      .ae-ui .ae-toolbar .ae-button:hover:disabled, .ae-ui .ae-toolbar .ae-button:hover.ae-button-disabled, .ae-ui .ae-toolbar .ae-button:focus:disabled, .ae-ui .ae-toolbar .ae-button:focus.ae-button-disabled, .ae-ui .ae-toolbar .ae-toolbar-element:hover:disabled, .ae-ui .ae-toolbar .ae-toolbar-element:hover.ae-button-disabled, .ae-ui .ae-toolbar .ae-toolbar-element:focus:disabled, .ae-ui .ae-toolbar .ae-toolbar-element:focus.ae-button-disabled, .ae-ui [class^=ae-toolbar-] .ae-button:hover:disabled, .ae-ui [class^=ae-toolbar-] .ae-button:hover.ae-button-disabled, .ae-ui [class^=ae-toolbar-] .ae-button:focus:disabled, .ae-ui [class^=ae-toolbar-] .ae-button:focus.ae-button-disabled, .ae-ui [class^=ae-toolbar-] .ae-toolbar-element:hover:disabled, .ae-ui [class^=ae-toolbar-] .ae-toolbar-element:hover.ae-button-disabled, .ae-ui [class^=ae-toolbar-] .ae-toolbar-element:focus:disabled, .ae-ui [class^=ae-toolbar-] .ae-toolbar-element:focus.ae-button-disabled {
        color: inherit; }
      .ae-ui .ae-toolbar .ae-button:disabled, .ae-ui .ae-toolbar .ae-button.ae-button-disabled, .ae-ui .ae-toolbar .ae-toolbar-element:disabled, .ae-ui .ae-toolbar .ae-toolbar-element.ae-button-disabled, .ae-ui [class^=ae-toolbar-] .ae-button:disabled, .ae-ui [class^=ae-toolbar-] .ae-button.ae-button-disabled, .ae-ui [class^=ae-toolbar-] .ae-toolbar-element:disabled, .ae-ui [class^=ae-toolbar-] .ae-toolbar-element.ae-button-disabled {
        cursor: auto;
        opacity: 0.3; }
      .ae-ui .ae-toolbar .ae-button, .ae-ui [class^=ae-toolbar-] .ae-button {
        height: 24px;
        width: 24px; }

      .ae-ui .ae-toolbar-add {
        border: solid 0 transparent;
        padding: 0; }
      .ae-ui .ae-toolbar-add .ae-button {
        height: 24px;
        width: 24px; }

      .ae-ui .ae-toolbar-styles {
        box-sizing: border-box;
        max-width: 100%; }

      .ae-ui .ae-arrow-box:after {
        content: '';
        margin: auto;
        position: absolute; }

      .ae-ui .ae-arrow-box.ae-arrow-box-bottom:after {
        height: 0;
        width: 0;
        border-left: 5px solid transparent;
        border-right: 5px solid transparent;
        border-top: 4px solid currentColor;
        left: 0;
        right: 0;
        top: 100%; }

      .ae-ui .ae-arrow-box.ae-arrow-box-top:after {
        height: 0;
        width: 0;
        border-bottom: 4px solid currentColor;
        border-left: 5px solid transparent;
        border-right: 5px solid transparent;
        left: 0;
        right: 0;
        top: -4px; }

      .ae-ui .ae-arrow-box.ae-arrow-box-top-left:after {
        height: 0;
        width: 0;
        border-bottom: 4px solid currentColor;
        border-left: 5px solid transparent;
        border-right: 5px solid transparent;
        left: 15px;
        top: -4px; }

      .ae-ui .ae-arrow-box.ae-arrow-box-top-right:after {
        height: 0;
        width: 0;
        border-bottom: 4px solid currentColor;
        border-left: 5px solid transparent;
        border-right: 5px solid transparent;
        right: 15px;
        top: -4px; }

      .ae-ui .ae-arrow-box.ae-arrow-box-left:after {
        height: 0;
        width: 0;
        border-bottom: 5px solid transparent;
        border-right: 4px solid currentColor;
        border-top: 5px solid transparent;
        left: -4px;
        top: 0;
        bottom: 0; }

      .ae-ui .ae-arrow-box.ae-arrow-box-right:after {
        height: 0;
        width: 0;
        border-bottom: 5px solid transparent;
        border-left: 4px solid currentColor;
        border-top: 5px solid transparent;
        right: -4px;
        top: 0;
        bottom: 0; }

      .ae-ui .ae-container, .ae-ui [class^=ae-container-] {
        -webkit-box-align: center;
        -moz-box-align: center;
        box-align: center;
        -webkit-align-items: center;
        -moz-align-items: center;
        -ms-align-items: center;
        -o-align-items: center;
        align-items: center;
        -ms-flex-align: center;
        display: -webkit-inline-box;
        display: -moz-inline-box;
        display: inline-box;
        display: -webkit-inline-flex;
        display: -moz-inline-flex;
        display: -ms-inline-flexbox;
        display: inline-flex;
        -webkit-box-orient: horizontal;
        -moz-box-orient: horizontal;
        box-orient: horizontal;
        -webkit-box-direction: normal;
        -moz-box-direction: normal;
        box-direction: normal;
        -webkit-flex-direction: row;
        -moz-flex-direction: row;
        flex-direction: row;
        -ms-flex-direction: row;
        -webkit-box-lines: multiple;
        -moz-box-lines: multiple;
        box-lines: multiple;
        -webkit-flex-wrap: wrap;
        -moz-flex-wrap: wrap;
        -ms-flex-wrap: wrap;
        flex-wrap: wrap;
        box-sizing: border-box; }
      .ae-ui .ae-container *, .ae-ui .ae-container *:after, .ae-ui .ae-container *:before, .ae-ui [class^=ae-container-] *, .ae-ui [class^=ae-container-] *:after, .ae-ui [class^=ae-container-] *:before {
        box-sizing: inherit;
        color: inherit; }
      .ae-ui .ae-container input, .ae-ui .ae-container textarea, .ae-ui .ae-container keygen, .ae-ui .ae-container select, .ae-ui .ae-container button, .ae-ui [class^=ae-container-] input, .ae-ui [class^=ae-container-] textarea, .ae-ui [class^=ae-container-] keygen, .ae-ui [class^=ae-container-] select, .ae-ui [class^=ae-container-] button {
        color: initial; }
      .ae-ui .ae-container .ae-container, .ae-ui .ae-container [class^=ae-container-], .ae-ui .ae-container .ae-button, .ae-ui .ae-container .ae-toolbar-element, .ae-ui .ae-container label, .ae-ui [class^=ae-container-] .ae-container, .ae-ui [class^=ae-container-] [class^=ae-container-], .ae-ui [class^=ae-container-] .ae-button, .ae-ui [class^=ae-container-] .ae-toolbar-element, .ae-ui [class^=ae-container-] label {
        font-size: 14px;
        margin: 0;
        position: relative; }
      .ae-ui .ae-container .ae-container:not(:last-child), .ae-ui .ae-container [class^=ae-container-]:not(:last-child), .ae-ui .ae-container .ae-button:not(:last-child), .ae-ui .ae-container .ae-toolbar-element:not(:last-child), .ae-ui .ae-container label:not(:last-child), .ae-ui [class^=ae-container-] .ae-container:not(:last-child), .ae-ui [class^=ae-container-] [class^=ae-container-]:not(:last-child), .ae-ui [class^=ae-container-] .ae-button:not(:last-child), .ae-ui [class^=ae-container-] .ae-toolbar-element:not(:last-child), .ae-ui [class^=ae-container-] label:not(:last-child) {
        margin-right: 10px; }

      .ae-ui .ae-container-edit-link, .ae-ui .ae-container-edit-table {
        height: 24px \9; }
      .ae-ui .ae-container-edit-link *, .ae-ui .ae-container-edit-table * {
        float: left \9; }
      .ae-ui .ae-container-edit-link label, .ae-ui .ae-container-edit-table label {
        padding: 0;
        position: relative \9;
        top: 25% \9;
        transform: translateY(-50%) \9; }
      .ae-ui .ae-container-edit-link IE10-PLUS::-ms-reveal, .ae-ui .ae-container-edit-link label, .ae-ui .ae-container-edit-table IE10-PLUS::-ms-reveal, .ae-ui .ae-container-edit-table label {
        top: 0;
        transform: translateY(0); }

      .ae-ui .ae-container-input {
        -webkit-box-lines: single;
        -moz-box-lines: single;
        box-lines: single;
        -webkit-flex-wrap: nowrap;
        -moz-flex-wrap: nowrap;
        -ms-flex-wrap: nowrap;
        flex-wrap: nowrap;
        width: 192px; }
      .ae-ui .ae-container-input.xxl {
        width: 336px; }
      .ae-ui .ae-container-input.medium {
        width: 72px; }
      .ae-ui .ae-container-input.small {
        width: 36px; }
      .ae-ui .ae-container-input input, .ae-ui .ae-container-input .ae-input {
        -webkit-box-flex: 1;
        -moz-box-flex: 1;
        box-flex: 1;
        -webkit-flex: 1;
        -moz-flex: 1;
        -ms-flex: 1;
        flex: 1;
        height: 24px;
        margin: 0;
        max-width: 100%;
        padding: 0 0 0 4px;
        display: inline-block \9;
        width: 168px \9; }
      .ae-ui .ae-container-input .ae-container-dropdown {
        padding-left: 10px; }
      .ae-ui .ae-container-input .ae-icon-remove {
        float: right \9; }

      .ae-ui .ae-container-dropdown, .ae-ui [class^=ae-container-dropdown-] {
        float: left \9;
        width: 120px !important; }
      .ae-ui .ae-container-dropdown > .ae-toolbar-element, .ae-ui [class^=ae-container-dropdown-] > .ae-toolbar-element {
        float: left \9;
        height: 24px;
        text-align: left;
        width: 100%; }
      .ae-ui .ae-container-dropdown > .ae-toolbar-element .ae-container, .ae-ui [class^=ae-container-dropdown-] > .ae-toolbar-element .ae-container {
        padding: 0;
        height: 100% \9;
        width: 100%; }
      .ae-ui .ae-container-dropdown > .ae-toolbar-element .ae-container .ae-icon-arrow, .ae-ui [class^=ae-container-dropdown-] > .ae-toolbar-element .ae-container .ae-icon-arrow {
        -webkit-transform: rotate(90deg);
        -moz-transform: rotate(90deg);
        -ms-transform: rotate(90deg);
        -o-transform: rotate(90deg);
        transform: rotate(90deg);
        float: right \9;
        position: absolute \9;
        right: 0 \9;
        top: 0 \9; }
      .ae-ui .ae-container-dropdown > .ae-toolbar-element .ae-container .ae-container-dropdown-selected-item, .ae-ui [class^=ae-container-dropdown-] > .ae-toolbar-element .ae-container .ae-container-dropdown-selected-item {
        -webkit-box-flex: 1;
        -moz-box-flex: 1;
        box-flex: 1;
        -webkit-flex: 1;
        -moz-flex: 1;
        -ms-flex: 1;
        flex: 1;
        display: inline-block;
        line-height: 24px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        position: relative \9; }
      .ae-ui .ae-container-dropdown > .ae-toolbar-element .ae-container IE10-PLUS::-ms-reveal, .ae-ui .ae-container-dropdown > .ae-toolbar-element .ae-container .ae-container-dropdown-selected-item, .ae-ui [class^=ae-container-dropdown-] > .ae-toolbar-element .ae-container IE10-PLUS::-ms-reveal, .ae-ui [class^=ae-container-dropdown-] > .ae-toolbar-element .ae-container .ae-container-dropdown-selected-item {
        top: 0;
        transform: translateY(0); }

      .ae-ui .ae-container-dropdown-small {
        width: 48px !important; }

      .ae-ui .ae-container-dropdown-medium {
        width: 96px !important; }

      .ae-ui .ae-container-dropdown-xl {
        width: 192px !important; }

      .ae-ui .ae-button-bridge [class*="ae-icon-"], .ae-ui .ae-button-bridge [class*=" ae-icon-"] {
        background-repeat: no-repeat;
        display: block;
        height: 16px;
        width: 16px;
        margin-left: 4px; }

      .ae-ui .ae-has-dropdown {
        display: block;
        float: left \9;
        /* Set width here (not min-width) to prevent the dropdown container from moving when expanding/collapsing the it */
        width: 24px; }

      .ae-ui .ae-dropdown, .ae-ui [class^=ae-dropdown-] {
        left: 0;
        padding: 4px;
        position: absolute;
        z-index: 0;
        top: 34px; }
      .ae-ui .ae-dropdown .ae-list-header, .ae-ui [class^=ae-dropdown-] .ae-list-header {
        display: inline-block;
        margin: 10px 0 0 0; }
      .ae-ui .ae-dropdown .ae-list-header:first-child, .ae-ui [class^=ae-dropdown-] .ae-list-header:first-child {
        margin-top: 10px; }
      .ae-ui .ae-dropdown .ae-listbox, .ae-ui [class^=ae-dropdown-] .ae-listbox {
        list-style: none;
        margin: 0;
        min-height: 44px;
        min-width: 132px;
        padding: 0; }
      .ae-ui .ae-dropdown .ae-listbox .ae-toolbar-element:hover, .ae-ui [class^=ae-dropdown-] .ae-listbox .ae-toolbar-element:hover {
        color: #1888c3;
      }
      .ae-ui .ae-dropdown .ae-listbox .ae-toolbar-element, .ae-ui [class^=ae-dropdown-] .ae-listbox .ae-toolbar-element {
        color: #000;
        font-size: inherit;
        height: 3em;
        line-height: inherit;
        margin-right: 0;
        max-height: inherit;
        min-width: 100%;
        padding: 0 0 0 8px;
        overflow: hidden;
        text-align: left;
        text-overflow: ellipsis;
        white-space: nowrap;
        width: auto; }
      .ae-ui .ae-dropdown .ae-listbox .ae-toolbar-element *, .ae-ui [class^=ae-dropdown-] .ae-listbox .ae-toolbar-element * {
        display: inline; }
      .ae-ui .ae-dropdown .ae-listbox .ae-toolbar-element[class^=ae-icon-]:before, .ae-ui [class^=ae-dropdown-] .ae-listbox .ae-toolbar-element[class^=ae-icon-]:before {
        padding-right: 10px;
        vertical-align: middle; }
      .ae-ui .ae-dropdown *, .ae-ui [class^=ae-dropdown-] * {
        display: block \9; }

      .ae-ui .ae-camera {
        align-items: center;
        display: flex;
        flex-flow: column;
        justify-content: center; }
      .ae-ui .ae-camera .ae-camera-canvas {
        left: -10000px;
        position: absolute;
        top: -10000px; }
      .ae-ui .ae-camera .ae-camera-shoot {
        margin-top: 10px; }

      /** GENERAL VARIABLES **/
      /**
       * AUTOGENERATED FONT ICON MAP
       *
       * This map is autogenerated in build-time based on the contents
       * of the icons/svg folder. It maps the generated icon names with
       * their corresponding glyphs.
       *
       * Use this for consistency in any skin where an icon needs to be
       * referenced from within the css like this:
       *
       * .ae-some-link:after {
       *     content: map-get($font-icon-map, iconName);
       * }
       */
      /** COLOR PALETTE **/
      /** COMPONENT VARIABLES **/
      /** DROPDOWN-LIST **/
      .ae-editable ::-moz-selection {
        background: #e6f1fa !important;
        color: inherit;
        text-shadow: none; }

      .ae-editable ::selection {
        background: #e6f1fa !important;
        color: inherit;
        text-shadow: none; }

      .ae-twitter-link {
        background-color: #f8f8f8; }
      .ae-twitter-link:after {
        content: "";
        font-family: alloyeditor-ocean; }

      .ae-ui .ae-arrow-box.ae-arrow-box-bottom:after {
        color: #32a8e6; }

      .ae-ui .ae-arrow-box.ae-arrow-box-top:after {
        color: #32a8e6; }

      .ae-ui .ae-arrow-box.ae-arrow-box-top-left:after {
        color: #32a8e6; }

      .ae-ui .ae-arrow-box.ae-arrow-box-top-right:after {
        color: #32a8e6; }

      .ae-ui .ae-arrow-box.ae-arrow-box-left:after {
        color: #32a8e6; }

      .ae-ui .ae-arrow-box.ae-arrow-box-right:after {
        color: #32a8e6; }

      .ae-ui .ae-container-dropdown > .ae-toolbar-element .ae-container .ae-icon-arrow, .ae-ui [class^=ae-container-dropdown-] > .ae-toolbar-element .ae-container .ae-icon-arrow {
        -webkit-transform: rotate(90deg);
        -moz-transform: rotate(90deg);
        -ms-transform: rotate(90deg);
        -o-transform: rotate(90deg);
        transform: rotate(90deg); }

      .ae-ui .ae-container-input {
        background-color: #fff;
        border-radius: 0; }
      .ae-ui .ae-container-input .ae-icon-remove {
        color: #000;
        font-size: 24px;
        line-height: 24px; }
      .ae-ui .ae-container-input .ae-container-dropdown {
        background-color: #fff;
        color: #000; }
      .ae-ui .ae-container-input input, .ae-ui .ae-container-input .ae-input {
        border-radius: 0;
        border-width: 0;
        color: #000;
        font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
        font-size: 14px;
        line-height: 14px;
        outline: none; }
      .ae-ui .ae-container-input input::-webkit-input-placeholder, .ae-ui .ae-container-input .ae-input::-webkit-input-placeholder {
        color: #999; }
      .ae-ui .ae-container-input input::-moz-placeholder, .ae-ui .ae-container-input .ae-input::-moz-placeholder {
        color: #999; }
      .ae-ui .ae-container-input input:-moz-placeholder, .ae-ui .ae-container-input .ae-input:-moz-placeholder {
        color: #999; }
      .ae-ui .ae-container-input input:-ms-input-placeholder, .ae-ui .ae-container-input .ae-input:-ms-input-placeholder {
        color: #999; }
      .ae-ui .ae-container-input input:focus, .ae-ui .ae-container-input .ae-input:focus {
        box-shadow: none; }
      .ae-ui .ae-container-input input::-ms-clear, .ae-ui .ae-container-input .ae-input::-ms-clear {
        display: none; }

      .ae-ui .ae-button-bridge [class*="ae-icon-"], .ae-ui .ae-button-bridge [class*=" ae-icon-"] {
        -webkit-filter: brightness(0) invert(100%);
        filter: brightness(0) invert(100%); }
      .ae-ui .ae-button-bridge [class*="ae-icon-"]:hover, .ae-ui .ae-button-bridge [class*=" ae-icon-"]:hover {
        -webkit-filter: sepia(80%) hue-rotate(-20deg) invert(90%) saturate(8);
        filter: sepia(80%) hue-rotate(-20deg) invert(90%) saturate(8); }

      .ae-ui .ae-dropdown, .ae-ui [class^=ae-dropdown-] {
        background-color: #fcfcfc;
        border: 1px solid rgba(0, 0, 0, 0.1);
        border-radius: 0 0 4px 4px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        color: #000; }
      .ae-ui .ae-dropdown.ae-arrow-box:after, .ae-ui [class^=ae-dropdown-].ae-arrow-box:after {
        color: #fcfcfc;
        display: none; }
      .ae-ui .ae-dropdown .ae-list-header, .ae-ui [class^=ae-dropdown-] .ae-list-header {
        color: #999;
        font-size: small;
        font-style: italic; }
      .ae-ui .ae-dropdown .ae-listbox .ae-toolbar-element:hover, .ae-ui [class^=ae-dropdown-] .ae-listbox .ae-toolbar-element:hover {
        background-color: #fcfcfc; }
      .ae-ui .ae-dropdown .ae-listbox .ae-toolbar-element.active, .ae-ui [class^=ae-dropdown-] .ae-listbox .ae-toolbar-element.active {
        color: #32a8e6; }

      .ae-ui .ae-toolbar, .ae-ui [class^=ae-toolbar-] {
        background-color: #32a8e6;
        border-radius: 4px;
        color: #fff;
        font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; }
      .ae-ui .ae-toolbar .ae-button, .ae-ui .ae-toolbar .ae-toolbar-element, .ae-ui [class^=ae-toolbar-] .ae-button, .ae-ui [class^=ae-toolbar-] .ae-toolbar-element {
        background-color: transparent; }
      .ae-ui .ae-toolbar .ae-button:hover, .ae-ui .ae-toolbar .ae-toolbar-element:hover, .ae-ui [class^=ae-toolbar-] .ae-button:hover, .ae-ui [class^=ae-toolbar-] .ae-toolbar-element:hover {
        color: #1888c3; }
      .ae-ui .ae-toolbar .ae-button.ae-button-pressed, .ae-ui .ae-toolbar .ae-toolbar-element.ae-button-pressed, .ae-ui [class^=ae-toolbar-] .ae-button.ae-button-pressed, .ae-ui [class^=ae-toolbar-] .ae-toolbar-element.ae-button-pressed {
        background-color: #1a95d5; }
      .ae-ui .ae-toolbar .ae-button.ae-button-pressed:hover, .ae-ui .ae-toolbar .ae-toolbar-element.ae-button-pressed:hover, .ae-ui [class^=ae-toolbar-] .ae-button.ae-button-pressed:hover, .ae-ui [class^=ae-toolbar-] .ae-toolbar-element.ae-button-pressed:hover {
        color: #1888c3; }
      .ae-ui .ae-toolbar .ae-button.ae-button-disabled, .ae-ui .ae-toolbar .ae-toolbar-element.ae-button-disabled, .ae-ui [class^=ae-toolbar-] .ae-button.ae-button-disabled, .ae-ui [class^=ae-toolbar-] .ae-toolbar-element.ae-button-disabled {
        opacity: 0.3; }

      .ae-ui .ae-toolbar-add {
        background-color: #32a8e6;
        border-color: transparent;
        border-radius: 12px;
        color: #fff; }
      .ae-ui .ae-toolbar-add:hover, .ae-ui .ae-toolbar-add:focus {
        opacity: 0.7; }
      .ae-ui .ae-toolbar-add .ae-button-add:hover, .ae-ui .ae-toolbar-add .ae-button-add:focus {
        color: inherit; }
      .ae-ui .ae-toolbar-add .ae-button-add .ae-icon-add {
        font-size: 12px;
        line-height: 12px; }

    </style>
  </template>
</dom-module><dom-module id="nuxeo-html-editor" assetpath="bower_components/nuxeo-ui-elements/widgets/">
  <template>
    <style include="alloy-ocean">
      #editor {
        outline: none;
        height: 100%;
        min-height: 30em;
      }

      .ae-placeholder:empty:not(:focus):before {
        color: grey;
        font-style: italic;
      }

      div#editor > * {
        margin-top: 0;
      }
    </style>

    <div id="editor" data-placeholder$="[[placeholder]]"></div>
  </template>
  <script>
    {
      /**
       * `nuxeo-html-editor`
       * @memberof Nuxeo
       * @demo demo/nuxeo-html-editor/index.html
       */
      class HTMLEditor extends Nuxeo.Element {

        static get is() {
          return 'nuxeo-html-editor';
        }

        static get properties() {
          return {
            element: Object,

            value: {
              type: String,
              notify: true,
              observer: '_valueChanged',
            },

            placeholder: {
              type: String,
              value: 'Type here...',
            },

            readOnly: Boolean,

            hideToolbars: Boolean,
          };
        }

        connectedCallback() {
          super.connectedCallback();
          setTimeout(() => {
            this._init();
          }, 100);
        }

        _init() {
          // init editor
          const toolbars = this.hideToolbars ? {} : {
            add: {
              buttons: ['image', 'camera', 'hline', 'table'],
              tabIndex: 2,
            },
            styles: {
              selections: [
                {
                  name: 'link',
                  buttons: ['linkEdit'],
                  test: AlloyEditor.SelectionTest.link,
                },
                {
                  name: 'image',
                  buttons: ['imageLeft', 'imageCenter', 'imageRight'],
                  test: AlloyEditor.SelectionTest.image,
                },
                {
                  name: 'text',
                  buttons: ['styles', 'bold', 'italic', 'underline', 'strike', 'paragraphLeft', 'paragraphCenter',
                    'paragraphJustify', 'ul', 'ol', 'quote', 'link', 'removeFormat'],
                  test: AlloyEditor.SelectionTest.text,
                },
                {
                  name: 'table',
                  buttons: ['tableRow', 'tableColumn', 'tableCell', 'tableRemove'],
                  getArrowBoxClasses: AlloyEditor.SelectionGetArrowBoxClasses.table,
                  setPosition: AlloyEditor.SelectionSetPosition.table,
                  test: AlloyEditor.SelectionTest.table,
                },
              ],
              tabIndex: 1,
            },
          };
          const editor = AlloyEditor.editable(this.$.editor, {
            readOnly: this.readOnly,
            uiNode: this.root,
            toolbars,
          });
          this.element = editor.get('nativeEditor');
          // set initial value
          this.element.setData(this.value);

          this.element.on('change', this._updateValue.bind(this));

          this.element.on('actionPerformed', this._updateValue.bind(this));
        }

        _updateValue() {
          this._internalChange = true;
          this.value = this.element.getData();
          this._internalChange = false;
        }

        _valueChanged() {
          if (this.element && !this._internalChange) {
            this.element.setData(this.value);
          }
        }

      }

      customElements.define(HTMLEditor.is, HTMLEditor);
      Nuxeo.HTMLEditor = HTMLEditor;
    }
  </script>
</dom-module>
<dom-module id="nuxeo-es-search" assetpath="bower_components/nuxeo-dataviz-elements/">
  <template>
    <style>
      :host {
        display: none;
      }
    </style>
    <nuxeo-connection id="nx" connection-id="[[connectionId]]"></nuxeo-connection>
  </template>

  <script>
    {
      /**
       * An element allowing querying the Nuxeo ES passthrough.
       *
       * Example:
       *
       *    <nuxeo-es-search></nuxeo-es-search>
       *
       * @memberof Nuxeo
       */
      class ESSearch extends Nuxeo.Element {

        static get is() {
          return 'nuxeo-es-search';
        }

        static get properties() {
          return {
            /**
             * The id of a nuxeo-connection to use.
             */
            connectionId: {
              type: String,
              value: 'nx',
            },

            /**
             * If true, automatically execute the operation when either `path` or `params` changes.
             */
            auto: {
              type: Boolean,
              value: false,
            },

            index: {
              type: String,
              value: 'nuxeo',
            },

            query: Object,

            aggregates: Object,

            type: String,

            aggregations: {
              type: Object,
              notify: true,
              readOnly: true,
            },

            hits: {
              type: Object,
              notify: true,
              readOnly: true,
            },
          };
        }

        static get observers() {
          return [
            '_auto(connectionId, auto, index, query, aggregates)',
          ];
        }

        /**
         * Fired if an error occurs while performing the query.
         *
         * @event error
         */

        /**
         * Fired when a query is performed.
         *
         * @event results
         */

        _auto() {
          if (this.auto && this.query && this.aggregates) {
            this.execute();
          }
        }

        execute() {
          return this.$.nx.connect().then(this._send.bind(this));
        }

        _send() {
          let url = [this.$.nx.client._baseURL, 'site/es', this.index, '_search'].join('/');
          url = url.replace(/(^\/+)|([^:])\/\/+/g, '$2/');

          if (this.type) {
            url += `?search_type=${this.type}`;
          }
          const options = {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: {
              query: this.query,
              aggs: this.aggregates,
            },
            url,
          };
          return this.$.nx.request().then((request) => request.execute(options)
            .then(this._handleResponse.bind(this))
            .catch(this._handleError.bind(this)));
        }

        _handleError(request, error) {
          console.error(error);
          this.dispatchEvent(new CustomEvent('error', {
            bubbles: true,
            composed: true,
            detail: {
              request,
              error,
            },
          }));
        }

        _handleResponse(response) {
          this._setHits(response.hits);
          this._setAggregations(response.aggregations);
          this.dispatchEvent(new CustomEvent('results', {
            bubbles: true,
            composed: true,
            detail: {
              response,
            },
          }));
          return response;
        }
      }

      customElements.define(ESSearch.is, ESSearch);
      Nuxeo.ESSearch = ESSearch;
    }
  </script>
</dom-module>
<script>
  window.Nuxeo = window.Nuxeo || {};
  /**
   * `Nuxeo.AggregateDataBehavior` provides the shared aggregate data behavior.
   *
   * @polymerBehavior Nuxeo.AggregateDataBehavior
   */
  Nuxeo.AggregateDataBehavior = {
    properties: {
      /**
       * The id of a nuxeo-connection to use.
       */
      connectionId: {
        type: String,
        value: 'nx',
      },

      /**
       * The index to query.
       */
      index: {
        type: String,
        value: 'nuxeo',
      },

      /**
       * Filter terms
       */
      where: {
        type: Object,
        value: () => {
          return {};
        },
      },


      /**
       * Top level term aggregation(s).
       * Comma-separated values..
       */
      groupedBy: {
        type: String,
        value: '',
      },

      /**
       * Limit number of buckets for the top level term aggregation.
       */
      groupLimit: {
        type: Number,
        value: -1,
      },

      /**
       * An object with the field as key and an array of ranges to use in the nested range aggregation as value.
       */
      withRanges: {
        type: Object,
        value: () => {
          return {};
        },
      },

      /**
       * Filter by start date.
       */
      startDate: {
        type: String,
        value: '',
      },

      /**
       * Filter by end date.
       */
      endDate: {
        type: String,
        value: '',
      },

      /**
       * Date field to use
       */
      dateField: {
        type: String,
        value: 'dc:created',
      },

      /**
       * Interval to use for the nested date histogram aggregation
       */
      withDateIntervals: {
        type: String,
        value: '',
      },

      /**
       * Date format to use as key in the date intervals aggregates
       */
      dateFormat: {
        type: String,
        value: 'yyyy-MM-dd',
      },

      /**
       * Skip building buckets for the whole date interval on the histogram aggregation
       */
      withoutExtendedBounds: {
        type: Boolean,
        value: false,
      },

      /**
       * The field to use in the single-value metrics aggregation.
       * This can be just the field name or include the `metrics-op` to use as well, ex: `avg(field)`
       */
      metrics: {
        type: String,
        value: '',
      },

      /**
       * The single-value metrics aggregation to use.
       * Can be one of: `avg`, `min`, `max.
       * It not set default is `count` which returns the `doc_count`
       */
      metricsOperator: {
        type: String,
        value: 'count',
      },

      query: Object,

      aggregates: Object,

      data: {
        type: Array,
        value: () => [],
        notify: true,
      },

    },

    observers: [
      // update the aggregates
      '_aggregates(groupedBy, groupLimit, withRanges, withDateIntervals, metrics, metricsOperator, startDate, endDate)',
      // trigger the request
      '_doFetch(index, query, aggregates)',
    ],

    ready() {
      // build our search request
      this._query();
      this._aggregates();
    },

    get _metricsAggregation() {
      const parts = this.metrics.match(/[^()]+/g);

      if (!parts) return;

      let metricsOn;
      let metricsOp;
      if (parts.length === 1) {
        [metricsOn] = parts;
        metricsOp = this.metricsOperator;
      } else if (parts.length === 2) {
        [metricsOp, metricsOn] = parts;
      } else {
        throw new Error('Invalid metrics');
      }

      const field = this._fieldFor(metricsOn) || this._fieldFor(this.aggregatedOn);

      if (metricsOp === 'count') {
        metricsOp = 'terms';
      }

      const agg = {};
      let metrics;

      // make the count/terms work as a regular aggregation
      if (metricsOp === 'terms') {
        metrics = agg.by = {};
      } else {
        metrics = agg.metrics = {};
      }

      metrics[metricsOp] = {
        field,
      };
      return agg;
    },

    _getNestedAggregation() {
      if (this.withDateIntervals) {
        const histogram = {
          field: this.dateField,
          interval: this.withDateIntervals,
          format: this.dateFormat,
          min_doc_count: 0,
        };

        if (!this.withoutExtendedBounds) {
          if (this.startDate && this.endDate) {
            histogram.extended_bounds = {
              min: this.startDate,
              max: this.endDate,
            };
          } else {
            console.warn('Both start and end date should be set when using date aggregation with extended bounds');
          }
        }

        return {
          by: {
            date_histogram: histogram,
          },
        };
      }

      const key = Object.keys(this.withRanges)[0];
      if (key) {
        return {
          by: {
            range: {
              field: this._fieldFor(key),
              ranges: this.withRanges[key],
            },
          },
        };
      }

    },

    // return ordered list of top level term aggregations
    get _topLevelAggregations() {
      const aggs = this.groupedBy.split(',').map((term) => {
        return {
          by: {
            terms: {
              field: this._fieldFor(term.trim()),
            },
          },
        };
      });

      // set max number of buckets to return
      if (this.groupLimit !== -1 && aggs.length) {
        aggs[0].by.terms.size = this.groupLimit;
      }

      return aggs;
    },

    _aggregates() {

      const levels = [];

      if (this.groupedBy) {
        Array.prototype.push.apply(levels, this._topLevelAggregations);
      }
      if (this.withDateIntervals || this.withRanges) {
        levels.push(this._getNestedAggregation());
      }
      if (this.metrics) {
        levels.push(this._metricsAggregation);
      }

      const result = {};
      let current = result;
      levels.forEach((level) => {
        if (level) {
          const key = Object.keys(level)[0];
          current.aggs = level;
          current = level[key];
        }
      });

      this.aggregates = result.aggs;
    },

    /**
     * Fetch aggregation.
     */
    fetch() {
      // template is not stamped & data system not initialized until the element has been connected :(
      if (!this._search) {
        this._search = document.createElement('nuxeo-es-search');
        this._attachDom(this._search);
      }
      this._search.connectionId = this.connectionId;
      this._search.index = this.index;
      this._search.query = this.query;
      this._search.aggregates = this.aggregates;

      return this._search.execute().then(this._onResults.bind(this));
    },

    _doFetch() {
      if (this.index && this.query && this.aggregates) {
        this.debounce('do-fetch', this.fetch.bind(this));
      }
    },

    _onResults(result) {
      if (result && result.aggregations) {
        this.data = this._unwrapAggregation(result.aggregations);
      }
    },

    _unwrapAggregation(bucket) {
      const key = bucket.key_as_string || bucket.key;
      let value;
      if (bucket.by) {
        value = bucket.by.buckets.map(this._unwrapAggregation.bind(this));
      } else {
        value = this._getMetricsValue(bucket);
      }
      return key !== undefined ? { key, value } : value;
    },

    // unwrap out metrics value
    _getMetricsValue(bucket) {
      return bucket.metrics ? bucket.metrics.value : bucket.doc_count;
    },

    // Helper functions

    get _dateRange() {
      if (!this.startDate && !this.endDate) {
        return;
      }
      const term = {range: {}};
      const range = term.range[this.dateField] = {};
      if (this.startDate) {
        range.gte = this.startDate;
      }
      if (this.endDate) {
        range.lte = this.endDate;
      }
      return term;
    },

    _fieldFor(column) {
      return column;
    },

    _buildTerms(terms) {
      if (Array.isArray(this.where)) {
        this.where.forEach((term) => {
          terms.push(term);
        });
      } else {
        Object.keys(this.where).forEach((key) => {
          const term = {};
          term[key] = this.where[key];
          terms.push({ term });
        }, this);
      }
      return {bool: {must: terms}};
    },
  };
</script>
<script>
  /**
   * @appliesMixin Nuxeo.AggregateDataBehavior
   * @memberof Nuxeo
   */
  Nuxeo.AggregateDataElement = Polymer.mixinBehaviors([Nuxeo.AggregateDataBehavior], Nuxeo.Element);
</script>
<script>
  {
    /**
     * An element providing data from the audit index.
     *
     * The possible values for `event-id` are available as contributions to the `event` extension point of the `org.nuxeo.ecm.platform.audit.service.NXAuditEventsService` service.
     *
     * A query supports additional terms:
     *
     * - `where`: array of additional terms for the `must` clause
     *
     * A query is a configurable nested aggregation with 2 aggregation levels:
     *
     * - `grouped-by`: top level term aggregations (comma-separated values)
     * - `metrics`: leaf single-value metrics aggregation (max, min, avg, sum)
     *
     * Example:
     *
     *     <nuxeo-audit-data event-id="eventId"
     *                       where='[{"term": {"downloadReason": "download"}},{"term": {"blobXPath": "blobholder:0"}}]'
     *                       grouped-by="field"
     *                       group-limit=[[groupLimit]]
     *                       metrics="sum(amount)"
     *                       start-date="[[startDate]]"
     *                       end-date="[[endDate]]"
     *                       data="{{data}}">
     *     </nuxeo-audit-data>
     *
     * If all the aggregation levels are configured it will produce a query like:
     *
     *     {
     *       query: { bool: { must: [...] },
     *       aggs: {
     *         by: { // aggregated-on
     *           terms: {
     *             field: "extended.action"
     *           },
     *           aggs: {
     *             by: {  // with-ranges | with-date-intervals
     *               range : {
     *                 field : "extended.duration",
     *                 ranges: [...]
     *               },
     *               aggs: {
     *                 metric: { // metric
     *                   sum: {
     *                     field : "extended.workflowVariables.amount"
     *                   }
     *                 }
     *               }
     *             }
     *           }
     *         }
     *       }
     *     }
     *
     * @memberof Nuxeo
     * @demo demo/audit.html
     */
    class AuditData extends Nuxeo.AggregateDataElement {

      static get is() {
        return 'nuxeo-audit-data';
      }

      static get properties() {
        return {
          /**
           * the name of the index
           */
          index: {
            type: String,
            value: 'audit',
          },

          /**
           * the name of the event to filter by
           */
          eventId: {
            type: String,
            value: '',
          },

          /**
           * Date field to use
           */
          // @override
          dateField: {
            type: String,
            value: 'eventDate',
          },
        };
      }

      static get observers() {
        return [
          '_query(eventId, where, startDate, endDate)',
          '_aggregates(groupedBy, withRanges, withDateIntervals, metrics, metricsOperator, startDate, endDate)',
        ];
      }

      _query() {
        const terms = [
          {term: {eventId: this.eventId}},
        ];

        if (this._dateRange) {
          terms.push(this._dateRange);
        }

        this.query = this._buildTerms(terms);
      }
    }

    customElements.define(AuditData.is, AuditData);
    Nuxeo.AuditData = AuditData;
  }
</script>
<script>
  {
    /**
     * An element providing metrics on repository data.
     *
     * A `metrics` query is a configurable nested aggregation with 3 aggregation levels:
     *
     * - `grouped-by`: top level term aggregations (comma-separated values)
     * - `with-*`: nested multi-bucket aggregation (with-ranges | with-date-intervals)
     * - `metrics`: leaf single-value metrics aggregation (count, max, min, avg, sum)
     *
     * Filtering of the data is possible by using the document property helper attributes: `ecm-primary-type`, `ecm-lifecycle-state` or `ecm-mixin-type`
     *
     * It is also possible to use a `where` attribute which takes a list of clauses to include in query.
     *
     * Example:
     *
     *     <nuxeo-repository-data ecm-primary-type="Note"
     *                            where='[{"range": {"dc:created": {"gte": startDate, "lte": endDate}}}]'
     *                            grouped-by="dc:creator"
     *                            data="{{data}}">
     *     </nuxeo-repository-data>
     *
     * The previous example would produce a query like:
     *
     *     {
     *       query: {
     *         bool: {
     *           must:[
     *             {term: {"ecm:primaryType": "File"}}, // ecm-primary-type
     *             {"range": {"dc:created": {"gte": start, "lte": end}}} // where
     *           ]
     *         }
     *       }
     *       aggs: {
     *         by: { // grouped-by
     *           terms: {
     *             field: "dc:creator"
     *           }
     *         }
     *       }
     *     }
     *
     * @memberof Nuxeo
     * @demo demo/repository.html
     */
    class RepositoryData extends Nuxeo.AggregateDataElement {

      static get is() {
        return 'nuxeo-repository-data';
      }

      static get properties() {
        return {
          index: {
            type: String,
            value: 'nuxeo',
          },

          /**
           * Date field to use
           */
          dateField: {
            type: String,
            value: 'dc:created',
          },


          // Document property filter terms helpers
          /**
           * Filter by ecm:primaryType`
           */
          ecmPrimaryType: {
            type: String,
            value: '',
          },

          /**
           * Filter by ecm:lifecycleState`
           */
          ecmLifecycleState: {
            type: String,
            value: '',
          },

          /**
           * Filter by ecm:mixinType`
           */
          ecmMixinType: {
            type: String,
            value: '',
          },
        };
      }

      static get observers() {
        return [
          '_query(ecmPrimaryType, ecmLifecycleState, ecmMixinType, where, startDate, endDate)',
          '_aggregates(groupedBy, groupLimit, withRanges, withDateIntervals, metrics, metricsOperator, startDate, endDate)', // eslint-disable-line max-len
        ];
      }

      _query() {
        // TODO: clone our query to allow setting it explicitly as well
        const terms = [];

        // push document properties terms
        if (this.ecmPrimaryType) {
          terms.push({terms: {'ecm:primaryType': this._splitTerms(this.ecmPrimaryType)}});
        }
        if (this.ecmLifecycleState) {
          terms.push({terms: {'ecm:currentLifeCycleState': this._splitTerms(this.ecmLifecycleState)}});
        }
        if (this.ecmMixinType) {
          terms.push({terms: {'ecm:mixinType': this._splitTerms(this.ecmMixinType)}});
        }

        // filter by date (dc:created by default)
        if (this._dateRange) {
          terms.push(this._dateRange);
        }

        this.query = this._buildTerms(terms);
      }

      _splitTerms(terms) {
        if (terms) {
          return terms.split(',').map((t) => t.trim());
        }
      }
    }

    customElements.define(RepositoryData.is, RepositoryData);
    Nuxeo.RepositoryData = RepositoryData;
  }
</script>
<script>
  {
    /**
     * An element providing metrics data on searches.
     *
     * A query is a configurable nested aggregation with 3 aggregation levels:
     *
     * - `grouped-by`: top level term aggregations (comma-separated values)
     * - `with-*`: nested multi-bucket aggregation (with-ranges | with-date-intervals)
     * - `metrics`: leaf single-value metrics aggregation (max, min, avg, sum)
     *
     * Example:
     *
     *     <nuxeo-search-data grouped-by="pageProviderName"
     *                        with-ranges='{
     *                          "resultsCount":[
     *                            {"key":"no result", "to":"0"},
     *                            {"key":"less than 50", "from" : 1, "to": 50}
     *                            {"key":"more than 50", "from" : 51}
     *                        ]}'
     *                        metrics="avg(executionTimeMs)"
     *                        start-date="[[startDate]]"
     *                        end-date="[[endDate]]"
     *                        data="{{data}}">
     *     </nuxeo-search-data>
     *
     * If all the aggregation levels are configured it will produce a query like:
     *
     *     {
     *       query: { bool: { must: [...] },
     *       aggs: {
     *         by: { // grouped-by
     *           terms: {
     *             field: "extended.resultsCount"
     *           },
     *           aggs: {
     *             by: {  // with-ranges | with-date-intervals
     *               range : {
     *                 field : "extended.resultsCount",
     *                 ranges: [...]
     *               },
     *               aggs: {
     *                 metric: { // metric
     *                   avg: {
     *                     field : "extended.executionTimeMs"
     *                   }
     *                 }
     *               }
     *             }
     *           }
     *         }
     *       }
     *     }
     *
     * @memberof Nuxeo
     * @demo demo/search.html
     */
    class SearchData extends Nuxeo.AggregateDataElement {

      static get is() {
        return 'nuxeo-search-data';
      }

      static get properties() {
        return {
          index: {
            type: String,
            value: 'audit',
          },

          /**
           * the page provider name
           */
          pageProvider: String,

          /**
           * Date field to use
           */
          dateField: {
            type: String,
            value: 'eventDate',
          },
        };
      }

      static get observers() {
        return [
          '_query(startDate, endDate)',
        ];
      }

      _query() {
        const terms = [
          {term: {eventId: 'search'}},
        ];

        if (this.pageProvider) {
          terms.push({term: {'extended.pageProviderName': this.pageProvider}});
        }

        if (this._dateRange) {
          terms.push(this._dateRange);
        }

        this.query = this._buildTerms(terms);
      }

      // @override
      _fieldFor(column) {
        return `extended.${column}`;
      }

    }

    customElements.define(SearchData.is, SearchData);
    Nuxeo.SearchData = SearchData;
  }
</script>
<script>
  {
    /**
     * An element providing metrics data on workflows.
     *
     * A query is a configurable nested aggregation with 3 aggregation levels:
     *
     * - `grouped-by`: top level term aggregations (comma-separated values)
     * - `with-*`: nested multi-bucket aggregation (with-ranges | with-date-intervals)
     * - `metrics`: leaf single-value metrics aggregation (max, min, avg, sum)
     *
     * Example:
     *
     *     <nuxeo-workflow-data workflow="worflowModelName"
     *                             task="taskName"
     *                             grouped-by="action"
     *                             with-ranges='{
     *                               "duration":[
     *                                 {"key":"quick", "to":"1500"},
     *                                 {"key":"slow", "from":"1500"}
     *                               ]}'
     *                             metrics="sum(amount)"
     *                             start-date="[[startDate]]"
     *                             end-date="[[endDate]]"
     *                             data="{{data}}">
     *     </nuxeo-workflow-data>
     *
     * If all the aggregation levels are configured it will produce a query like:
     *
     *     {
     *       query: { bool: { must: [...] },
     *       aggs: {
     *         by: { // aggregated-on
     *           terms: {
     *             field: "extended.action"
     *           },
     *           aggs: {
     *             by: {  // with-ranges | with-date-intervals
     *               range : {
     *                 field : "extended.duration",
     *                 ranges: [...]
     *               },
     *               aggs: {
     *                 metric: { // metric
     *                   sum: {
     *                     field : "extended.workflowVariables.amount"
     *                   }
     *                 }
     *               }
     *             }
     *           }
     *         }
     *       }
     *     }
     *
     * @memberof Nuxeo
     * @demo demo/workflow.html
     */
    class WorkflowData extends Nuxeo.AggregateDataElement {

      static get is() {
        return 'nuxeo-workflow-data';
      }

      static get properties() {
        return {
          index: {
            type: String,
            value: 'audit_wf',
          },

          /**
           * the name of the event to filter by
           */
          event: {
            type: String,
            value: '',
          },

          /**
           * the workflow model name
           */
          workflow: String,

          /**
           * the name of the task to filter by
           */
          task: {
            type: String,
            value: '',
          },

          /**
           * Date field to use
           */
          dateField: {
            type: String,
            value: 'eventDate',
          },
        };
      }

      static get observers() {
        return [
          '_query(workflow, startDate, endDate)',
          '_aggregates(groupedBy, withRanges, withDateIntervals, metrics, metricsOperator, startDate, endDate)',
        ];
      }

      _query() {
        const event = this.event || (this.task ? 'afterWorkflowTaskEnded' : 'afterWorkflowFinish');

        const terms = [
          {term: {eventId: event}},
          {term: {'extended.modelName': this.workflow}},
        ];

        if (this.task) {
          terms.push({term: {'extended.taskName': this.task}});
        }
        if (this._dateRange) {
          terms.push(this._dateRange);
        }

        this.query = this._buildTerms(terms);
      }

      // @override
      _fieldFor(column) {
        // TODO: limit 'exposed' fields to system field (ex: 'user', 'taskName', 'action', etc) and 'workflowVariables.*'
        return `extended.${column}`;
      }

    }

    customElements.define(WorkflowData.is, WorkflowData);
    Nuxeo.WorkflowData = WorkflowData;
  }
</script>
<script>/*!
 * Chart.js
 * http://chartjs.org/
 * Version: 2.7.3
 *
 * Copyright 2018 Chart.js Contributors
 * Released under the MIT license
 * https://github.com/chartjs/Chart.js/blob/master/LICENSE.md
 */
!function(t){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=t();else if("function"==typeof define&&define.amd)define([],t);else{("undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this).Chart=t()}}(function(){return function o(r,s,l){function u(e,t){if(!s[e]){if(!r[e]){var i="function"==typeof require&&require;if(!t&&i)return i(e,!0);if(d)return d(e,!0);var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}var a=s[e]={exports:{}};r[e][0].call(a.exports,function(t){return u(r[e][1][t]||t)},a,a.exports,o,r,s,l)}return s[e].exports}for(var d="function"==typeof require&&require,t=0;t<l.length;t++)u(l[t]);return u}({1:[function(t,e,i){},{}],2:[function(t,e,i){var o=t(6);function n(t){if(t){var e=[0,0,0],i=1,n=t.match(/^#([a-fA-F0-9]{3})$/i);if(n){n=n[1];for(var a=0;a<e.length;a++)e[a]=parseInt(n[a]+n[a],16)}else if(n=t.match(/^#([a-fA-F0-9]{6})$/i)){n=n[1];for(a=0;a<e.length;a++)e[a]=parseInt(n.slice(2*a,2*a+2),16)}else if(n=t.match(/^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i)){for(a=0;a<e.length;a++)e[a]=parseInt(n[a+1]);i=parseFloat(n[4])}else if(n=t.match(/^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i)){for(a=0;a<e.length;a++)e[a]=Math.round(2.55*parseFloat(n[a+1]));i=parseFloat(n[4])}else if(n=t.match(/(\w+)/)){if("transparent"==n[1])return[0,0,0,0];if(!(e=o[n[1]]))return}for(a=0;a<e.length;a++)e[a]=d(e[a],0,255);return i=i||0==i?d(i,0,1):1,e[3]=i,e}}function a(t){if(t){var e=t.match(/^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/);if(e){var i=parseFloat(e[4]);return[d(parseInt(e[1]),0,360),d(parseFloat(e[2]),0,100),d(parseFloat(e[3]),0,100),d(isNaN(i)?1:i,0,1)]}}}function r(t){if(t){var e=t.match(/^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/);if(e){var i=parseFloat(e[4]);return[d(parseInt(e[1]),0,360),d(parseFloat(e[2]),0,100),d(parseFloat(e[3]),0,100),d(isNaN(i)?1:i,0,1)]}}}function s(t,e){return void 0===e&&(e=void 0!==t[3]?t[3]:1),"rgba("+t[0]+", "+t[1]+", "+t[2]+", "+e+")"}function l(t,e){return"rgba("+Math.round(t[0]/255*100)+"%, "+Math.round(t[1]/255*100)+"%, "+Math.round(t[2]/255*100)+"%, "+(e||t[3]||1)+")"}function u(t,e){return void 0===e&&(e=void 0!==t[3]?t[3]:1),"hsla("+t[0]+", "+t[1]+"%, "+t[2]+"%, "+e+")"}function d(t,e,i){return Math.min(Math.max(e,t),i)}function c(t){var e=t.toString(16).toUpperCase();return e.length<2?"0"+e:e}e.exports={getRgba:n,getHsla:a,getRgb:function(t){var e=n(t);return e&&e.slice(0,3)},getHsl:function(t){var e=a(t);return e&&e.slice(0,3)},getHwb:r,getAlpha:function(t){var e=n(t);{if(e)return e[3];if(e=a(t))return e[3];if(e=r(t))return e[3]}},hexString:function(t){return"#"+c(t[0])+c(t[1])+c(t[2])},rgbString:function(t,e){if(e<1||t[3]&&t[3]<1)return s(t,e);return"rgb("+t[0]+", "+t[1]+", "+t[2]+")"},rgbaString:s,percentString:function(t,e){if(e<1||t[3]&&t[3]<1)return l(t,e);var i=Math.round(t[0]/255*100),n=Math.round(t[1]/255*100),a=Math.round(t[2]/255*100);return"rgb("+i+"%, "+n+"%, "+a+"%)"},percentaString:l,hslString:function(t,e){if(e<1||t[3]&&t[3]<1)return u(t,e);return"hsl("+t[0]+", "+t[1]+"%, "+t[2]+"%)"},hslaString:u,hwbString:function(t,e){void 0===e&&(e=void 0!==t[3]?t[3]:1);return"hwb("+t[0]+", "+t[1]+"%, "+t[2]+"%"+(void 0!==e&&1!==e?", "+e:"")+")"},keyword:function(t){return h[t.slice(0,3)]}};var h={};for(var f in o)h[o[f]]=f},{6:6}],3:[function(t,e,i){var d=t(5),n=t(2),r=function(t){return t instanceof r?t:this instanceof r?(this.valid=!1,this.values={rgb:[0,0,0],hsl:[0,0,0],hsv:[0,0,0],hwb:[0,0,0],cmyk:[0,0,0,0],alpha:1},void("string"==typeof t?(e=n.getRgba(t))?this.setValues("rgb",e):(e=n.getHsla(t))?this.setValues("hsl",e):(e=n.getHwb(t))&&this.setValues("hwb",e):"object"==typeof t&&(void 0!==(e=t).r||void 0!==e.red?this.setValues("rgb",e):void 0!==e.l||void 0!==e.lightness?this.setValues("hsl",e):void 0!==e.v||void 0!==e.value?this.setValues("hsv",e):void 0!==e.w||void 0!==e.whiteness?this.setValues("hwb",e):void 0===e.c&&void 0===e.cyan||this.setValues("cmyk",e)))):new r(t);var e};r.prototype={isValid:function(){return this.valid},rgb:function(){return this.setSpace("rgb",arguments)},hsl:function(){return this.setSpace("hsl",arguments)},hsv:function(){return this.setSpace("hsv",arguments)},hwb:function(){return this.setSpace("hwb",arguments)},cmyk:function(){return this.setSpace("cmyk",arguments)},rgbArray:function(){return this.values.rgb},hslArray:function(){return this.values.hsl},hsvArray:function(){return this.values.hsv},hwbArray:function(){var t=this.values;return 1!==t.alpha?t.hwb.concat([t.alpha]):t.hwb},cmykArray:function(){return this.values.cmyk},rgbaArray:function(){var t=this.values;return t.rgb.concat([t.alpha])},hslaArray:function(){var t=this.values;return t.hsl.concat([t.alpha])},alpha:function(t){return void 0===t?this.values.alpha:(this.setValues("alpha",t),this)},red:function(t){return this.setChannel("rgb",0,t)},green:function(t){return this.setChannel("rgb",1,t)},blue:function(t){return this.setChannel("rgb",2,t)},hue:function(t){return t&&(t=(t%=360)<0?360+t:t),this.setChannel("hsl",0,t)},saturation:function(t){return this.setChannel("hsl",1,t)},lightness:function(t){return this.setChannel("hsl",2,t)},saturationv:function(t){return this.setChannel("hsv",1,t)},whiteness:function(t){return this.setChannel("hwb",1,t)},blackness:function(t){return this.setChannel("hwb",2,t)},value:function(t){return this.setChannel("hsv",2,t)},cyan:function(t){return this.setChannel("cmyk",0,t)},magenta:function(t){return this.setChannel("cmyk",1,t)},yellow:function(t){return this.setChannel("cmyk",2,t)},black:function(t){return this.setChannel("cmyk",3,t)},hexString:function(){return n.hexString(this.values.rgb)},rgbString:function(){return n.rgbString(this.values.rgb,this.values.alpha)},rgbaString:function(){return n.rgbaString(this.values.rgb,this.values.alpha)},percentString:function(){return n.percentString(this.values.rgb,this.values.alpha)},hslString:function(){return n.hslString(this.values.hsl,this.values.alpha)},hslaString:function(){return n.hslaString(this.values.hsl,this.values.alpha)},hwbString:function(){return n.hwbString(this.values.hwb,this.values.alpha)},keyword:function(){return n.keyword(this.values.rgb,this.values.alpha)},rgbNumber:function(){var t=this.values.rgb;return t[0]<<16|t[1]<<8|t[2]},luminosity:function(){for(var t=this.values.rgb,e=[],i=0;i<t.length;i++){var n=t[i]/255;e[i]=n<=.03928?n/12.92:Math.pow((n+.055)/1.055,2.4)}return.2126*e[0]+.7152*e[1]+.0722*e[2]},contrast:function(t){var e=this.luminosity(),i=t.luminosity();return i<e?(e+.05)/(i+.05):(i+.05)/(e+.05)},level:function(t){var e=this.contrast(t);return 7.1<=e?"AAA":4.5<=e?"AA":""},dark:function(){var t=this.values.rgb;return(299*t[0]+587*t[1]+114*t[2])/1e3<128},light:function(){return!this.dark()},negate:function(){for(var t=[],e=0;e<3;e++)t[e]=255-this.values.rgb[e];return this.setValues("rgb",t),this},lighten:function(t){var e=this.values.hsl;return e[2]+=e[2]*t,this.setValues("hsl",e),this},darken:function(t){var e=this.values.hsl;return e[2]-=e[2]*t,this.setValues("hsl",e),this},saturate:function(t){var e=this.values.hsl;return e[1]+=e[1]*t,this.setValues("hsl",e),this},desaturate:function(t){var e=this.values.hsl;return e[1]-=e[1]*t,this.setValues("hsl",e),this},whiten:function(t){var e=this.values.hwb;return e[1]+=e[1]*t,this.setValues("hwb",e),this},blacken:function(t){var e=this.values.hwb;return e[2]+=e[2]*t,this.setValues("hwb",e),this},greyscale:function(){var t=this.values.rgb,e=.3*t[0]+.59*t[1]+.11*t[2];return this.setValues("rgb",[e,e,e]),this},clearer:function(t){var e=this.values.alpha;return this.setValues("alpha",e-e*t),this},opaquer:function(t){var e=this.values.alpha;return this.setValues("alpha",e+e*t),this},rotate:function(t){var e=this.values.hsl,i=(e[0]+t)%360;return e[0]=i<0?360+i:i,this.setValues("hsl",e),this},mix:function(t,e){var i=this,n=t,a=void 0===e?.5:e,o=2*a-1,r=i.alpha()-n.alpha(),s=((o*r==-1?o:(o+r)/(1+o*r))+1)/2,l=1-s;return this.rgb(s*i.red()+l*n.red(),s*i.green()+l*n.green(),s*i.blue()+l*n.blue()).alpha(i.alpha()*a+n.alpha()*(1-a))},toJSON:function(){return this.rgb()},clone:function(){var t,e,i=new r,n=this.values,a=i.values;for(var o in n)n.hasOwnProperty(o)&&(t=n[o],"[object Array]"===(e={}.toString.call(t))?a[o]=t.slice(0):"[object Number]"===e?a[o]=t:console.error("unexpected color value:",t));return i}},r.prototype.spaces={rgb:["red","green","blue"],hsl:["hue","saturation","lightness"],hsv:["hue","saturation","value"],hwb:["hue","whiteness","blackness"],cmyk:["cyan","magenta","yellow","black"]},r.prototype.maxes={rgb:[255,255,255],hsl:[360,100,100],hsv:[360,100,100],hwb:[360,100,100],cmyk:[100,100,100,100]},r.prototype.getValues=function(t){for(var e=this.values,i={},n=0;n<t.length;n++)i[t.charAt(n)]=e[t][n];return 1!==e.alpha&&(i.a=e.alpha),i},r.prototype.setValues=function(t,e){var i,n,a=this.values,o=this.spaces,r=this.maxes,s=1;if(this.valid=!0,"alpha"===t)s=e;else if(e.length)a[t]=e.slice(0,t.length),s=e[t.length];else if(void 0!==e[t.charAt(0)]){for(i=0;i<t.length;i++)a[t][i]=e[t.charAt(i)];s=e.a}else if(void 0!==e[o[t][0]]){var l=o[t];for(i=0;i<t.length;i++)a[t][i]=e[l[i]];s=e.alpha}if(a.alpha=Math.max(0,Math.min(1,void 0===s?a.alpha:s)),"alpha"===t)return!1;for(i=0;i<t.length;i++)n=Math.max(0,Math.min(r[t][i],a[t][i])),a[t][i]=Math.round(n);for(var u in o)u!==t&&(a[u]=d[t][u](a[t]));return!0},r.prototype.setSpace=function(t,e){var i=e[0];return void 0===i?this.getValues(t):("number"==typeof i&&(i=Array.prototype.slice.call(e)),this.setValues(t,i),this)},r.prototype.setChannel=function(t,e,i){var n=this.values[t];return void 0===i?n[e]:(i===n[e]||(n[e]=i,this.setValues(t,n)),this)},"undefined"!=typeof window&&(window.Color=r),e.exports=r},{2:2,5:5}],4:[function(t,e,i){function a(t){var e,i,n=t[0]/255,a=t[1]/255,o=t[2]/255,r=Math.min(n,a,o),s=Math.max(n,a,o),l=s-r;return s==r?e=0:n==s?e=(a-o)/l:a==s?e=2+(o-n)/l:o==s&&(e=4+(n-a)/l),(e=Math.min(60*e,360))<0&&(e+=360),i=(r+s)/2,[e,100*(s==r?0:i<=.5?l/(s+r):l/(2-s-r)),100*i]}function n(t){var e,i,n=t[0],a=t[1],o=t[2],r=Math.min(n,a,o),s=Math.max(n,a,o),l=s-r;return i=0==s?0:l/s*1e3/10,s==r?e=0:n==s?e=(a-o)/l:a==s?e=2+(o-n)/l:o==s&&(e=4+(n-a)/l),(e=Math.min(60*e,360))<0&&(e+=360),[e,i,s/255*1e3/10]}function o(t){var e=t[0],i=t[1],n=t[2];return[a(t)[0],100*(1/255*Math.min(e,Math.min(i,n))),100*(n=1-1/255*Math.max(e,Math.max(i,n)))]}function s(t){var e,i=t[0]/255,n=t[1]/255,a=t[2]/255;return[100*((1-i-(e=Math.min(1-i,1-n,1-a)))/(1-e)||0),100*((1-n-e)/(1-e)||0),100*((1-a-e)/(1-e)||0),100*e]}function l(t){return S[JSON.stringify(t)]}function u(t){var e=t[0]/255,i=t[1]/255,n=t[2]/255;return[100*(.4124*(e=.04045<e?Math.pow((e+.055)/1.055,2.4):e/12.92)+.3576*(i=.04045<i?Math.pow((i+.055)/1.055,2.4):i/12.92)+.1805*(n=.04045<n?Math.pow((n+.055)/1.055,2.4):n/12.92)),100*(.2126*e+.7152*i+.0722*n),100*(.0193*e+.1192*i+.9505*n)]}function d(t){var e=u(t),i=e[0],n=e[1],a=e[2];return n/=100,a/=108.883,i=.008856<(i/=95.047)?Math.pow(i,1/3):7.787*i+16/116,[116*(n=.008856<n?Math.pow(n,1/3):7.787*n+16/116)-16,500*(i-n),200*(n-(a=.008856<a?Math.pow(a,1/3):7.787*a+16/116))]}function c(t){var e,i,n,a,o,r=t[0]/360,s=t[1]/100,l=t[2]/100;if(0==s)return[o=255*l,o,o];e=2*l-(i=l<.5?l*(1+s):l+s-l*s),a=[0,0,0];for(var u=0;u<3;u++)(n=r+1/3*-(u-1))<0&&n++,1<n&&n--,o=6*n<1?e+6*(i-e)*n:2*n<1?i:3*n<2?e+(i-e)*(2/3-n)*6:e,a[u]=255*o;return a}function h(t){var e=t[0]/60,i=t[1]/100,n=t[2]/100,a=Math.floor(e)%6,o=e-Math.floor(e),r=255*n*(1-i),s=255*n*(1-i*o),l=255*n*(1-i*(1-o));n*=255;switch(a){case 0:return[n,l,r];case 1:return[s,n,r];case 2:return[r,n,l];case 3:return[r,s,n];case 4:return[l,r,n];case 5:return[n,r,s]}}function f(t){var e,i,n,a,o=t[0]/360,s=t[1]/100,l=t[2]/100,u=s+l;switch(1<u&&(s/=u,l/=u),n=6*o-(e=Math.floor(6*o)),0!=(1&e)&&(n=1-n),a=s+n*((i=1-l)-s),e){default:case 6:case 0:r=i,g=a,b=s;break;case 1:r=a,g=i,b=s;break;case 2:r=s,g=i,b=a;break;case 3:r=s,g=a,b=i;break;case 4:r=a,g=s,b=i;break;case 5:r=i,g=s,b=a}return[255*r,255*g,255*b]}function p(t){var e=t[0]/100,i=t[1]/100,n=t[2]/100,a=t[3]/100;return[255*(1-Math.min(1,e*(1-a)+a)),255*(1-Math.min(1,i*(1-a)+a)),255*(1-Math.min(1,n*(1-a)+a))]}function m(t){var e,i,n,a=t[0]/100,o=t[1]/100,r=t[2]/100;return i=-.9689*a+1.8758*o+.0415*r,n=.0557*a+-.204*o+1.057*r,e=.0031308<(e=3.2406*a+-1.5372*o+-.4986*r)?1.055*Math.pow(e,1/2.4)-.055:e*=12.92,i=.0031308<i?1.055*Math.pow(i,1/2.4)-.055:i*=12.92,n=.0031308<n?1.055*Math.pow(n,1/2.4)-.055:n*=12.92,[255*(e=Math.min(Math.max(0,e),1)),255*(i=Math.min(Math.max(0,i),1)),255*(n=Math.min(Math.max(0,n),1))]}function v(t){var e=t[0],i=t[1],n=t[2];return i/=100,n/=108.883,e=.008856<(e/=95.047)?Math.pow(e,1/3):7.787*e+16/116,[116*(i=.008856<i?Math.pow(i,1/3):7.787*i+16/116)-16,500*(e-i),200*(i-(n=.008856<n?Math.pow(n,1/3):7.787*n+16/116))]}function x(t){var e,i,n,a,o=t[0],r=t[1],s=t[2];return a=o<=8?(i=100*o/903.3)/100*7.787+16/116:(i=100*Math.pow((o+16)/116,3),Math.pow(i/100,1/3)),[e=e/95.047<=.008856?e=95.047*(r/500+a-16/116)/7.787:95.047*Math.pow(r/500+a,3),i,n=n/108.883<=.008859?n=108.883*(a-s/200-16/116)/7.787:108.883*Math.pow(a-s/200,3)]}function y(t){var e,i=t[0],n=t[1],a=t[2];return(e=360*Math.atan2(a,n)/2/Math.PI)<0&&(e+=360),[i,Math.sqrt(n*n+a*a),e]}function k(t){return m(x(t))}function M(t){var e,i=t[0],n=t[1];return e=t[2]/360*2*Math.PI,[i,n*Math.cos(e),n*Math.sin(e)]}function w(t){return C[t]}e.exports={rgb2hsl:a,rgb2hsv:n,rgb2hwb:o,rgb2cmyk:s,rgb2keyword:l,rgb2xyz:u,rgb2lab:d,rgb2lch:function(t){return y(d(t))},hsl2rgb:c,hsl2hsv:function(t){var e=t[0],i=t[1]/100,n=t[2]/100;return 0!==n?[e,100*(2*(i*=(n*=2)<=1?n:2-n)/(n+i)),100*((n+i)/2)]:[0,0,0]},hsl2hwb:function(t){return o(c(t))},hsl2cmyk:function(t){return s(c(t))},hsl2keyword:function(t){return l(c(t))},hsv2rgb:h,hsv2hsl:function(t){var e,i,n=t[0],a=t[1]/100,o=t[2]/100;return e=a*o,[n,100*(e=(e/=(i=(2-a)*o)<=1?i:2-i)||0),100*(i/=2)]},hsv2hwb:function(t){return o(h(t))},hsv2cmyk:function(t){return s(h(t))},hsv2keyword:function(t){return l(h(t))},hwb2rgb:f,hwb2hsl:function(t){return a(f(t))},hwb2hsv:function(t){return n(f(t))},hwb2cmyk:function(t){return s(f(t))},hwb2keyword:function(t){return l(f(t))},cmyk2rgb:p,cmyk2hsl:function(t){return a(p(t))},cmyk2hsv:function(t){return n(p(t))},cmyk2hwb:function(t){return o(p(t))},cmyk2keyword:function(t){return l(p(t))},keyword2rgb:w,keyword2hsl:function(t){return a(w(t))},keyword2hsv:function(t){return n(w(t))},keyword2hwb:function(t){return o(w(t))},keyword2cmyk:function(t){return s(w(t))},keyword2lab:function(t){return d(w(t))},keyword2xyz:function(t){return u(w(t))},xyz2rgb:m,xyz2lab:v,xyz2lch:function(t){return y(v(t))},lab2xyz:x,lab2rgb:k,lab2lch:y,lch2lab:M,lch2xyz:function(t){return x(M(t))},lch2rgb:function(t){return k(M(t))}};var C={aliceblue:[240,248,255],antiquewhite:[250,235,215],aqua:[0,255,255],aquamarine:[127,255,212],azure:[240,255,255],beige:[245,245,220],bisque:[255,228,196],black:[0,0,0],blanchedalmond:[255,235,205],blue:[0,0,255],blueviolet:[138,43,226],brown:[165,42,42],burlywood:[222,184,135],cadetblue:[95,158,160],chartreuse:[127,255,0],chocolate:[210,105,30],coral:[255,127,80],cornflowerblue:[100,149,237],cornsilk:[255,248,220],crimson:[220,20,60],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgoldenrod:[184,134,11],darkgray:[169,169,169],darkgreen:[0,100,0],darkgrey:[169,169,169],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkseagreen:[143,188,143],darkslateblue:[72,61,139],darkslategray:[47,79,79],darkslategrey:[47,79,79],darkturquoise:[0,206,209],darkviolet:[148,0,211],deeppink:[255,20,147],deepskyblue:[0,191,255],dimgray:[105,105,105],dimgrey:[105,105,105],dodgerblue:[30,144,255],firebrick:[178,34,34],floralwhite:[255,250,240],forestgreen:[34,139,34],fuchsia:[255,0,255],gainsboro:[220,220,220],ghostwhite:[248,248,255],gold:[255,215,0],goldenrod:[218,165,32],gray:[128,128,128],green:[0,128,0],greenyellow:[173,255,47],grey:[128,128,128],honeydew:[240,255,240],hotpink:[255,105,180],indianred:[205,92,92],indigo:[75,0,130],ivory:[255,255,240],khaki:[240,230,140],lavender:[230,230,250],lavenderblush:[255,240,245],lawngreen:[124,252,0],lemonchiffon:[255,250,205],lightblue:[173,216,230],lightcoral:[240,128,128],lightcyan:[224,255,255],lightgoldenrodyellow:[250,250,210],lightgray:[211,211,211],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightsalmon:[255,160,122],lightseagreen:[32,178,170],lightskyblue:[135,206,250],lightslategray:[119,136,153],lightslategrey:[119,136,153],lightsteelblue:[176,196,222],lightyellow:[255,255,224],lime:[0,255,0],limegreen:[50,205,50],linen:[250,240,230],magenta:[255,0,255],maroon:[128,0,0],mediumaquamarine:[102,205,170],mediumblue:[0,0,205],mediumorchid:[186,85,211],mediumpurple:[147,112,219],mediumseagreen:[60,179,113],mediumslateblue:[123,104,238],mediumspringgreen:[0,250,154],mediumturquoise:[72,209,204],mediumvioletred:[199,21,133],midnightblue:[25,25,112],mintcream:[245,255,250],mistyrose:[255,228,225],moccasin:[255,228,181],navajowhite:[255,222,173],navy:[0,0,128],oldlace:[253,245,230],olive:[128,128,0],olivedrab:[107,142,35],orange:[255,165,0],orangered:[255,69,0],orchid:[218,112,214],palegoldenrod:[238,232,170],palegreen:[152,251,152],paleturquoise:[175,238,238],palevioletred:[219,112,147],papayawhip:[255,239,213],peachpuff:[255,218,185],peru:[205,133,63],pink:[255,192,203],plum:[221,160,221],powderblue:[176,224,230],purple:[128,0,128],rebeccapurple:[102,51,153],red:[255,0,0],rosybrown:[188,143,143],royalblue:[65,105,225],saddlebrown:[139,69,19],salmon:[250,128,114],sandybrown:[244,164,96],seagreen:[46,139,87],seashell:[255,245,238],sienna:[160,82,45],silver:[192,192,192],skyblue:[135,206,235],slateblue:[106,90,205],slategray:[112,128,144],slategrey:[112,128,144],snow:[255,250,250],springgreen:[0,255,127],steelblue:[70,130,180],tan:[210,180,140],teal:[0,128,128],thistle:[216,191,216],tomato:[255,99,71],turquoise:[64,224,208],violet:[238,130,238],wheat:[245,222,179],white:[255,255,255],whitesmoke:[245,245,245],yellow:[255,255,0],yellowgreen:[154,205,50]},S={};for(var _ in C)S[JSON.stringify(C[_])]=_},{}],5:[function(t,e,i){var a=t(4),o=function(){return new u};for(var n in a){o[n+"Raw"]=function(e){return function(t){return"number"==typeof t&&(t=Array.prototype.slice.call(arguments)),a[e](t)}}(n);var r=/(\w+)2(\w+)/.exec(n),s=r[1],l=r[2];(o[s]=o[s]||{})[l]=o[n]=function(n){return function(t){"number"==typeof t&&(t=Array.prototype.slice.call(arguments));var e=a[n](t);if("string"==typeof e||void 0===e)return e;for(var i=0;i<e.length;i++)e[i]=Math.round(e[i]);return e}}(n)}var u=function(){this.convs={}};u.prototype.routeSpace=function(t,e){var i=e[0];return void 0===i?this.getValues(t):("number"==typeof i&&(i=Array.prototype.slice.call(e)),this.setValues(t,i))},u.prototype.setValues=function(t,e){return this.space=t,this.convs={},this.convs[t]=e,this},u.prototype.getValues=function(t){var e=this.convs[t];if(!e){var i=this.space,n=this.convs[i];e=o[i][t](n),this.convs[t]=e}return e},["rgb","hsl","hsv","cmyk","keyword"].forEach(function(e){u.prototype[e]=function(t){return this.routeSpace(e,arguments)}}),e.exports=o},{4:4}],6:[function(t,e,i){"use strict";e.exports={aliceblue:[240,248,255],antiquewhite:[250,235,215],aqua:[0,255,255],aquamarine:[127,255,212],azure:[240,255,255],beige:[245,245,220],bisque:[255,228,196],black:[0,0,0],blanchedalmond:[255,235,205],blue:[0,0,255],blueviolet:[138,43,226],brown:[165,42,42],burlywood:[222,184,135],cadetblue:[95,158,160],chartreuse:[127,255,0],chocolate:[210,105,30],coral:[255,127,80],cornflowerblue:[100,149,237],cornsilk:[255,248,220],crimson:[220,20,60],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgoldenrod:[184,134,11],darkgray:[169,169,169],darkgreen:[0,100,0],darkgrey:[169,169,169],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkseagreen:[143,188,143],darkslateblue:[72,61,139],darkslategray:[47,79,79],darkslategrey:[47,79,79],darkturquoise:[0,206,209],darkviolet:[148,0,211],deeppink:[255,20,147],deepskyblue:[0,191,255],dimgray:[105,105,105],dimgrey:[105,105,105],dodgerblue:[30,144,255],firebrick:[178,34,34],floralwhite:[255,250,240],forestgreen:[34,139,34],fuchsia:[255,0,255],gainsboro:[220,220,220],ghostwhite:[248,248,255],gold:[255,215,0],goldenrod:[218,165,32],gray:[128,128,128],green:[0,128,0],greenyellow:[173,255,47],grey:[128,128,128],honeydew:[240,255,240],hotpink:[255,105,180],indianred:[205,92,92],indigo:[75,0,130],ivory:[255,255,240],khaki:[240,230,140],lavender:[230,230,250],lavenderblush:[255,240,245],lawngreen:[124,252,0],lemonchiffon:[255,250,205],lightblue:[173,216,230],lightcoral:[240,128,128],lightcyan:[224,255,255],lightgoldenrodyellow:[250,250,210],lightgray:[211,211,211],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightsalmon:[255,160,122],lightseagreen:[32,178,170],lightskyblue:[135,206,250],lightslategray:[119,136,153],lightslategrey:[119,136,153],lightsteelblue:[176,196,222],lightyellow:[255,255,224],lime:[0,255,0],limegreen:[50,205,50],linen:[250,240,230],magenta:[255,0,255],maroon:[128,0,0],mediumaquamarine:[102,205,170],mediumblue:[0,0,205],mediumorchid:[186,85,211],mediumpurple:[147,112,219],mediumseagreen:[60,179,113],mediumslateblue:[123,104,238],mediumspringgreen:[0,250,154],mediumturquoise:[72,209,204],mediumvioletred:[199,21,133],midnightblue:[25,25,112],mintcream:[245,255,250],mistyrose:[255,228,225],moccasin:[255,228,181],navajowhite:[255,222,173],navy:[0,0,128],oldlace:[253,245,230],olive:[128,128,0],olivedrab:[107,142,35],orange:[255,165,0],orangered:[255,69,0],orchid:[218,112,214],palegoldenrod:[238,232,170],palegreen:[152,251,152],paleturquoise:[175,238,238],palevioletred:[219,112,147],papayawhip:[255,239,213],peachpuff:[255,218,185],peru:[205,133,63],pink:[255,192,203],plum:[221,160,221],powderblue:[176,224,230],purple:[128,0,128],rebeccapurple:[102,51,153],red:[255,0,0],rosybrown:[188,143,143],royalblue:[65,105,225],saddlebrown:[139,69,19],salmon:[250,128,114],sandybrown:[244,164,96],seagreen:[46,139,87],seashell:[255,245,238],sienna:[160,82,45],silver:[192,192,192],skyblue:[135,206,235],slateblue:[106,90,205],slategray:[112,128,144],slategrey:[112,128,144],snow:[255,250,250],springgreen:[0,255,127],steelblue:[70,130,180],tan:[210,180,140],teal:[0,128,128],thistle:[216,191,216],tomato:[255,99,71],turquoise:[64,224,208],violet:[238,130,238],wheat:[245,222,179],white:[255,255,255],whitesmoke:[245,245,245],yellow:[255,255,0],yellowgreen:[154,205,50]}},{}],7:[function(t,e,i){var n=t(30)();n.helpers=t(46),t(28)(n),n.Animation=t(22),n.animationService=t(23),n.defaults=t(26),n.Element=t(27),n.elements=t(41),n.Interaction=t(29),n.layouts=t(31),n.platform=t(49),n.plugins=t(32),n.Scale=t(33),n.scaleService=t(34),n.Ticks=t(35),n.Tooltip=t(36),t(24)(n),t(25)(n),t(56)(n),t(54)(n),t(55)(n),t(57)(n),t(58)(n),t(59)(n),t(15)(n),t(16)(n),t(17)(n),t(18)(n),t(19)(n),t(20)(n),t(21)(n),t(8)(n),t(9)(n),t(10)(n),t(11)(n),t(12)(n),t(13)(n),t(14)(n);var a=t(50);for(var o in a)a.hasOwnProperty(o)&&n.plugins.register(a[o]);n.platform.initialize(),e.exports=n,"undefined"!=typeof window&&(window.Chart=n),n.Legend=a.legend._element,n.Title=a.title._element,n.pluginService=n.plugins,n.PluginBase=n.Element.extend({}),n.canvasHelpers=n.helpers.canvas,n.layoutService=n.layouts},{10:10,11:11,12:12,13:13,14:14,15:15,16:16,17:17,18:18,19:19,20:20,21:21,22:22,23:23,24:24,25:25,26:26,27:27,28:28,29:29,30:30,31:31,32:32,33:33,34:34,35:35,36:36,41:41,46:46,49:49,50:50,54:54,55:55,56:56,57:57,58:58,59:59,8:8,9:9}],8:[function(t,e,i){"use strict";e.exports=function(i){i.Bar=function(t,e){return e.type="bar",new i(t,e)}}},{}],9:[function(t,e,i){"use strict";e.exports=function(i){i.Bubble=function(t,e){return e.type="bubble",new i(t,e)}}},{}],10:[function(t,e,i){"use strict";e.exports=function(i){i.Doughnut=function(t,e){return e.type="doughnut",new i(t,e)}}},{}],11:[function(t,e,i){"use strict";e.exports=function(i){i.Line=function(t,e){return e.type="line",new i(t,e)}}},{}],12:[function(t,e,i){"use strict";e.exports=function(i){i.PolarArea=function(t,e){return e.type="polarArea",new i(t,e)}}},{}],13:[function(t,e,i){"use strict";e.exports=function(i){i.Radar=function(t,e){return e.type="radar",new i(t,e)}}},{}],14:[function(t,e,i){"use strict";e.exports=function(i){i.Scatter=function(t,e){return e.type="scatter",new i(t,e)}}},{}],15:[function(t,e,i){"use strict";var n=t(26),a=t(41),S=t(46);n._set("bar",{hover:{mode:"label"},scales:{xAxes:[{type:"category",categoryPercentage:.8,barPercentage:.9,offset:!0,gridLines:{offsetGridLines:!0}}],yAxes:[{type:"linear"}]}}),n._set("horizontalBar",{hover:{mode:"index",axis:"y"},scales:{xAxes:[{type:"linear",position:"bottom"}],yAxes:[{position:"left",type:"category",categoryPercentage:.8,barPercentage:.9,offset:!0,gridLines:{offsetGridLines:!0}}]},elements:{rectangle:{borderSkipped:"left"}},tooltips:{callbacks:{title:function(t,e){var i="";return 0<t.length&&(t[0].yLabel?i=t[0].yLabel:0<e.labels.length&&t[0].index<e.labels.length&&(i=e.labels[t[0].index])),i},label:function(t,e){return(e.datasets[t.datasetIndex].label||"")+": "+t.xLabel}},mode:"index",axis:"y"}}),e.exports=function(e){e.controllers.bar=e.DatasetController.extend({dataElementType:a.Rectangle,initialize:function(){var t;e.DatasetController.prototype.initialize.apply(this,arguments),(t=this.getMeta()).stack=this.getDataset().stack,t.bar=!0},update:function(t){var e,i,n=this.getMeta().data;for(this._ruler=this.getRuler(),e=0,i=n.length;e<i;++e)this.updateElement(n[e],e,t)},updateElement:function(t,e,i){var n=this,a=n.chart,o=n.getMeta(),r=n.getDataset(),s=t.custom||{},l=a.options.elements.rectangle;t._xScale=n.getScaleForId(o.xAxisID),t._yScale=n.getScaleForId(o.yAxisID),t._datasetIndex=n.index,t._index=e,t._model={datasetLabel:r.label,label:a.data.labels[e],borderSkipped:s.borderSkipped?s.borderSkipped:l.borderSkipped,backgroundColor:s.backgroundColor?s.backgroundColor:S.valueAtIndexOrDefault(r.backgroundColor,e,l.backgroundColor),borderColor:s.borderColor?s.borderColor:S.valueAtIndexOrDefault(r.borderColor,e,l.borderColor),borderWidth:s.borderWidth?s.borderWidth:S.valueAtIndexOrDefault(r.borderWidth,e,l.borderWidth)},n.updateElementGeometry(t,e,i),t.pivot()},updateElementGeometry:function(t,e,i){var n=this,a=t._model,o=n.getValueScale(),r=o.getBasePixel(),s=o.isHorizontal(),l=n._ruler||n.getRuler(),u=n.calculateBarValuePixels(n.index,e),d=n.calculateBarIndexPixels(n.index,e,l);a.horizontal=s,a.base=i?r:u.base,a.x=s?i?r:u.head:d.center,a.y=s?d.center:i?r:u.head,a.height=s?d.size:void 0,a.width=s?void 0:d.size},getValueScaleId:function(){return this.getMeta().yAxisID},getIndexScaleId:function(){return this.getMeta().xAxisID},getValueScale:function(){return this.getScaleForId(this.getValueScaleId())},getIndexScale:function(){return this.getScaleForId(this.getIndexScaleId())},_getStacks:function(t){var e,i,n=this.chart,a=this.getIndexScale().options.stacked,o=void 0===t?n.data.datasets.length:t+1,r=[];for(e=0;e<o;++e)(i=n.getDatasetMeta(e)).bar&&n.isDatasetVisible(e)&&(!1===a||!0===a&&-1===r.indexOf(i.stack)||void 0===a&&(void 0===i.stack||-1===r.indexOf(i.stack)))&&r.push(i.stack);return r},getStackCount:function(){return this._getStacks().length},getStackIndex:function(t,e){var i=this._getStacks(t),n=void 0!==e?i.indexOf(e):-1;return-1===n?i.length-1:n},getRuler:function(){var t,e,i=this.getIndexScale(),n=this.getStackCount(),a=this.index,o=i.isHorizontal(),r=o?i.left:i.top,s=r+(o?i.width:i.height),l=[];for(t=0,e=this.getMeta().data.length;t<e;++t)l.push(i.getPixelForValue(null,t,a));return{min:S.isNullOrUndef(i.options.barThickness)?function(t,e){var i,n,a,o,r=t.isHorizontal()?t.width:t.height,s=t.getTicks();for(a=1,o=e.length;a<o;++a)r=Math.min(r,e[a]-e[a-1]);for(a=0,o=s.length;a<o;++a)n=t.getPixelForTick(a),r=0<a?Math.min(r,n-i):r,i=n;return r}(i,l):-1,pixels:l,start:r,end:s,stackCount:n,scale:i}},calculateBarValuePixels:function(t,e){var i,n,a,o,r,s,l=this.chart,u=this.getMeta(),d=this.getValueScale(),c=l.data.datasets,h=d.getRightValue(c[t].data[e]),f=d.options.stacked,g=u.stack,p=0;if(f||void 0===f&&void 0!==g)for(i=0;i<t;++i)(n=l.getDatasetMeta(i)).bar&&n.stack===g&&n.controller.getValueScaleId()===d.id&&l.isDatasetVisible(i)&&(a=d.getRightValue(c[i].data[e]),(h<0&&a<0||0<=h&&0<a)&&(p+=a));return o=d.getPixelForValue(p),{size:s=((r=d.getPixelForValue(p+h))-o)/2,base:o,head:r,center:r+s/2}},calculateBarIndexPixels:function(t,e,i){var n,a,o,r,s,l,u,d,c,h,f,g,p,m,v,b,x,y=i.scale.options,k="flex"===y.barThickness?(c=e,f=y,p=(h=i).pixels,m=p[c],v=0<c?p[c-1]:null,b=c<p.length-1?p[c+1]:null,x=f.categoryPercentage,null===v&&(v=m-(null===b?h.end-m:b-m)),null===b&&(b=m+m-v),g=m-(m-v)/2*x,{chunk:(b-v)/2*x/h.stackCount,ratio:f.barPercentage,start:g}):(n=e,a=i,l=(o=y).barThickness,u=a.stackCount,d=a.pixels[n],s=S.isNullOrUndef(l)?(r=a.min*o.categoryPercentage,o.barPercentage):(r=l*u,1),{chunk:r/u,ratio:s,start:d-r/2}),M=this.getStackIndex(t,this.getMeta().stack),w=k.start+k.chunk*M+k.chunk/2,C=Math.min(S.valueOrDefault(y.maxBarThickness,1/0),k.chunk*k.ratio);return{base:w-C/2,head:w+C/2,center:w,size:C}},draw:function(){var t=this.chart,e=this.getValueScale(),i=this.getMeta().data,n=this.getDataset(),a=i.length,o=0;for(S.canvas.clipArea(t.ctx,t.chartArea);o<a;++o)isNaN(e.getRightValue(n.data[o]))||i[o].draw();S.canvas.unclipArea(t.ctx)}}),e.controllers.horizontalBar=e.controllers.bar.extend({getValueScaleId:function(){return this.getMeta().xAxisID},getIndexScaleId:function(){return this.getMeta().yAxisID}})}},{26:26,41:41,46:46}],16:[function(t,e,i){"use strict";var n=t(26),a=t(41),g=t(46);n._set("bubble",{hover:{mode:"single"},scales:{xAxes:[{type:"linear",position:"bottom",id:"x-axis-0"}],yAxes:[{type:"linear",position:"left",id:"y-axis-0"}]},tooltips:{callbacks:{title:function(){return""},label:function(t,e){var i=e.datasets[t.datasetIndex].label||"",n=e.datasets[t.datasetIndex].data[t.index];return i+": ("+t.xLabel+", "+t.yLabel+", "+n.r+")"}}}}),e.exports=function(t){t.controllers.bubble=t.DatasetController.extend({dataElementType:a.Point,update:function(i){var n=this,t=n.getMeta().data;g.each(t,function(t,e){n.updateElement(t,e,i)})},updateElement:function(t,e,i){var n=this,a=n.getMeta(),o=t.custom||{},r=n.getScaleForId(a.xAxisID),s=n.getScaleForId(a.yAxisID),l=n._resolveElementOptions(t,e),u=n.getDataset().data[e],d=n.index,c=i?r.getPixelForDecimal(.5):r.getPixelForValue("object"==typeof u?u:NaN,e,d),h=i?s.getBasePixel():s.getPixelForValue(u,e,d);t._xScale=r,t._yScale=s,t._options=l,t._datasetIndex=d,t._index=e,t._model={backgroundColor:l.backgroundColor,borderColor:l.borderColor,borderWidth:l.borderWidth,hitRadius:l.hitRadius,pointStyle:l.pointStyle,rotation:l.rotation,radius:i?0:l.radius,skip:o.skip||isNaN(c)||isNaN(h),x:c,y:h},t.pivot()},setHoverStyle:function(t){var e=t._model,i=t._options;t.$previousStyle={backgroundColor:e.backgroundColor,borderColor:e.borderColor,borderWidth:e.borderWidth,radius:e.radius},e.backgroundColor=g.valueOrDefault(i.hoverBackgroundColor,g.getHoverColor(i.backgroundColor)),e.borderColor=g.valueOrDefault(i.hoverBorderColor,g.getHoverColor(i.borderColor)),e.borderWidth=g.valueOrDefault(i.hoverBorderWidth,i.borderWidth),e.radius=i.radius+i.hoverRadius},_resolveElementOptions:function(t,e){var i,n,a,o=this.chart,r=o.data.datasets[this.index],s=t.custom||{},l=o.options.elements.point,u=g.options.resolve,d=r.data[e],c={},h={chart:o,dataIndex:e,dataset:r,datasetIndex:this.index},f=["backgroundColor","borderColor","borderWidth","hoverBackgroundColor","hoverBorderColor","hoverBorderWidth","hoverRadius","hitRadius","pointStyle","rotation"];for(i=0,n=f.length;i<n;++i)c[a=f[i]]=u([s[a],r[a],l[a]],h,e);return c.radius=u([s.radius,d?d.r:void 0,r.radius,l.radius],h,e),c}})}},{26:26,41:41,46:46}],17:[function(t,e,i){"use strict";var n=t(26),a=t(41),A=t(46);n._set("doughnut",{animation:{animateRotate:!0,animateScale:!1},hover:{mode:"single"},legendCallback:function(t){var e=[];e.push('<ul class="'+t.id+'-legend">');var i=t.data,n=i.datasets,a=i.labels;if(n.length)for(var o=0;o<n[0].data.length;++o)e.push('<li><span style="background-color:'+n[0].backgroundColor[o]+'"></span>'),a[o]&&e.push(a[o]),e.push("</li>");return e.push("</ul>"),e.join("")},legend:{labels:{generateLabels:function(l){var u=l.data;return u.labels.length&&u.datasets.length?u.labels.map(function(t,e){var i=l.getDatasetMeta(0),n=u.datasets[0],a=i.data[e],o=a&&a.custom||{},r=A.valueAtIndexOrDefault,s=l.options.elements.arc;return{text:t,fillStyle:o.backgroundColor?o.backgroundColor:r(n.backgroundColor,e,s.backgroundColor),strokeStyle:o.borderColor?o.borderColor:r(n.borderColor,e,s.borderColor),lineWidth:o.borderWidth?o.borderWidth:r(n.borderWidth,e,s.borderWidth),hidden:isNaN(n.data[e])||i.data[e].hidden,index:e}}):[]}},onClick:function(t,e){var i,n,a,o=e.index,r=this.chart;for(i=0,n=(r.data.datasets||[]).length;i<n;++i)(a=r.getDatasetMeta(i)).data[o]&&(a.data[o].hidden=!a.data[o].hidden);r.update()}},cutoutPercentage:50,rotation:-.5*Math.PI,circumference:2*Math.PI,tooltips:{callbacks:{title:function(){return""},label:function(t,e){var i=e.labels[t.index],n=": "+e.datasets[t.datasetIndex].data[t.index];return A.isArray(i)?(i=i.slice())[0]+=n:i+=n,i}}}}),n._set("pie",A.clone(n.doughnut)),n._set("pie",{cutoutPercentage:0}),e.exports=function(t){t.controllers.doughnut=t.controllers.pie=t.DatasetController.extend({dataElementType:a.Arc,linkScales:A.noop,getRingIndex:function(t){for(var e=0,i=0;i<t;++i)this.chart.isDatasetVisible(i)&&++e;return e},update:function(i){var n=this,t=n.chart,e=t.chartArea,a=t.options,o=a.elements.arc,r=e.right-e.left-o.borderWidth,s=e.bottom-e.top-o.borderWidth,l=Math.min(r,s),u={x:0,y:0},d=n.getMeta(),c=a.cutoutPercentage,h=a.circumference;if(h<2*Math.PI){var f=a.rotation%(2*Math.PI),g=(f+=2*Math.PI*(f>=Math.PI?-1:f<-Math.PI?1:0))+h,p=Math.cos(f),m=Math.sin(f),v=Math.cos(g),b=Math.sin(g),x=f<=0&&0<=g||f<=2*Math.PI&&2*Math.PI<=g,y=f<=.5*Math.PI&&.5*Math.PI<=g||f<=2.5*Math.PI&&2.5*Math.PI<=g,k=f<=-Math.PI&&-Math.PI<=g||f<=Math.PI&&Math.PI<=g,M=f<=.5*-Math.PI&&.5*-Math.PI<=g||f<=1.5*Math.PI&&1.5*Math.PI<=g,w=c/100,C=k?-1:Math.min(p*(p<0?1:w),v*(v<0?1:w)),S=M?-1:Math.min(m*(m<0?1:w),b*(b<0?1:w)),_=x?1:Math.max(p*(0<p?1:w),v*(0<v?1:w)),D=y?1:Math.max(m*(0<m?1:w),b*(0<b?1:w)),P=.5*(_-C),I=.5*(D-S);l=Math.min(r/P,s/I),u={x:-.5*(_+C),y:-.5*(D+S)}}t.borderWidth=n.getMaxBorderWidth(d.data),t.outerRadius=Math.max((l-t.borderWidth)/2,0),t.innerRadius=Math.max(c?t.outerRadius/100*c:0,0),t.radiusLength=(t.outerRadius-t.innerRadius)/t.getVisibleDatasetCount(),t.offsetX=u.x*t.outerRadius,t.offsetY=u.y*t.outerRadius,d.total=n.calculateTotal(),n.outerRadius=t.outerRadius-t.radiusLength*n.getRingIndex(n.index),n.innerRadius=Math.max(n.outerRadius-t.radiusLength,0),A.each(d.data,function(t,e){n.updateElement(t,e,i)})},updateElement:function(t,e,i){var n=this,a=n.chart,o=a.chartArea,r=a.options,s=r.animation,l=(o.left+o.right)/2,u=(o.top+o.bottom)/2,d=r.rotation,c=r.rotation,h=n.getDataset(),f=i&&s.animateRotate?0:t.hidden?0:n.calculateCircumference(h.data[e])*(r.circumference/(2*Math.PI)),g=i&&s.animateScale?0:n.innerRadius,p=i&&s.animateScale?0:n.outerRadius,m=A.valueAtIndexOrDefault;A.extend(t,{_datasetIndex:n.index,_index:e,_model:{x:l+a.offsetX,y:u+a.offsetY,startAngle:d,endAngle:c,circumference:f,outerRadius:p,innerRadius:g,label:m(h.label,e,a.data.labels[e])}});var v=t._model,b=t.custom||{},x=A.valueAtIndexOrDefault,y=this.chart.options.elements.arc;v.backgroundColor=b.backgroundColor?b.backgroundColor:x(h.backgroundColor,e,y.backgroundColor),v.borderColor=b.borderColor?b.borderColor:x(h.borderColor,e,y.borderColor),v.borderWidth=b.borderWidth?b.borderWidth:x(h.borderWidth,e,y.borderWidth),i&&s.animateRotate||(v.startAngle=0===e?r.rotation:n.getMeta().data[e-1]._model.endAngle,v.endAngle=v.startAngle+v.circumference),t.pivot()},calculateTotal:function(){var i,n=this.getDataset(),t=this.getMeta(),a=0;return A.each(t.data,function(t,e){i=n.data[e],isNaN(i)||t.hidden||(a+=Math.abs(i))}),a},calculateCircumference:function(t){var e=this.getMeta().total;return 0<e&&!isNaN(t)?2*Math.PI*(Math.abs(t)/e):0},getMaxBorderWidth:function(t){for(var e,i,n=0,a=this.index,o=t.length,r=0;r<o;r++)n=(n=n<(e=t[r]._model?t[r]._model.borderWidth:0)?e:n)<(i=t[r]._chart?t[r]._chart.config.data.datasets[a].hoverBorderWidth:0)?i:n;return n}})}},{26:26,41:41,46:46}],18:[function(t,e,i){"use strict";var n=t(26),a=t(41),g=t(46);n._set("line",{showLines:!0,spanGaps:!1,hover:{mode:"label"},scales:{xAxes:[{type:"category",id:"x-axis-0"}],yAxes:[{type:"linear",id:"y-axis-0"}]}}),e.exports=function(t){function f(t,e){return g.valueOrDefault(t.showLine,e.showLines)}t.controllers.line=t.DatasetController.extend({datasetElementType:a.Line,dataElementType:a.Point,update:function(t){var e,i,n,a=this,o=a.getMeta(),r=o.dataset,s=o.data||[],l=a.chart.options,u=l.elements.line,d=a.getScaleForId(o.yAxisID),c=a.getDataset(),h=f(c,l);for(h&&(n=r.custom||{},void 0!==c.tension&&void 0===c.lineTension&&(c.lineTension=c.tension),r._scale=d,r._datasetIndex=a.index,r._children=s,r._model={spanGaps:c.spanGaps?c.spanGaps:l.spanGaps,tension:n.tension?n.tension:g.valueOrDefault(c.lineTension,u.tension),backgroundColor:n.backgroundColor?n.backgroundColor:c.backgroundColor||u.backgroundColor,borderWidth:n.borderWidth?n.borderWidth:c.borderWidth||u.borderWidth,borderColor:n.borderColor?n.borderColor:c.borderColor||u.borderColor,borderCapStyle:n.borderCapStyle?n.borderCapStyle:c.borderCapStyle||u.borderCapStyle,borderDash:n.borderDash?n.borderDash:c.borderDash||u.borderDash,borderDashOffset:n.borderDashOffset?n.borderDashOffset:c.borderDashOffset||u.borderDashOffset,borderJoinStyle:n.borderJoinStyle?n.borderJoinStyle:c.borderJoinStyle||u.borderJoinStyle,fill:n.fill?n.fill:void 0!==c.fill?c.fill:u.fill,steppedLine:n.steppedLine?n.steppedLine:g.valueOrDefault(c.steppedLine,u.stepped),cubicInterpolationMode:n.cubicInterpolationMode?n.cubicInterpolationMode:g.valueOrDefault(c.cubicInterpolationMode,u.cubicInterpolationMode)},r.pivot()),e=0,i=s.length;e<i;++e)a.updateElement(s[e],e,t);for(h&&0!==r._model.tension&&a.updateBezierControlPoints(),e=0,i=s.length;e<i;++e)s[e].pivot()},getPointBackgroundColor:function(t,e){var i=this.chart.options.elements.point.backgroundColor,n=this.getDataset(),a=t.custom||{};return a.backgroundColor?i=a.backgroundColor:n.pointBackgroundColor?i=g.valueAtIndexOrDefault(n.pointBackgroundColor,e,i):n.backgroundColor&&(i=n.backgroundColor),i},getPointBorderColor:function(t,e){var i=this.chart.options.elements.point.borderColor,n=this.getDataset(),a=t.custom||{};return a.borderColor?i=a.borderColor:n.pointBorderColor?i=g.valueAtIndexOrDefault(n.pointBorderColor,e,i):n.borderColor&&(i=n.borderColor),i},getPointBorderWidth:function(t,e){var i=this.chart.options.elements.point.borderWidth,n=this.getDataset(),a=t.custom||{};return isNaN(a.borderWidth)?!isNaN(n.pointBorderWidth)||g.isArray(n.pointBorderWidth)?i=g.valueAtIndexOrDefault(n.pointBorderWidth,e,i):isNaN(n.borderWidth)||(i=n.borderWidth):i=a.borderWidth,i},getPointRotation:function(t,e){var i=this.chart.options.elements.point.rotation,n=this.getDataset(),a=t.custom||{};return isNaN(a.rotation)?isNaN(n.pointRotation)&&!g.isArray(n.pointRotation)||(i=g.valueAtIndexOrDefault(n.pointRotation,e,i)):i=a.rotation,i},updateElement:function(t,e,i){var n,a,o=this,r=o.getMeta(),s=t.custom||{},l=o.getDataset(),u=o.index,d=l.data[e],c=o.getScaleForId(r.yAxisID),h=o.getScaleForId(r.xAxisID),f=o.chart.options.elements.point;void 0!==l.radius&&void 0===l.pointRadius&&(l.pointRadius=l.radius),void 0!==l.hitRadius&&void 0===l.pointHitRadius&&(l.pointHitRadius=l.hitRadius),n=h.getPixelForValue("object"==typeof d?d:NaN,e,u),a=i?c.getBasePixel():o.calculatePointY(d,e,u),t._xScale=h,t._yScale=c,t._datasetIndex=u,t._index=e,t._model={x:n,y:a,skip:s.skip||isNaN(n)||isNaN(a),radius:s.radius||g.valueAtIndexOrDefault(l.pointRadius,e,f.radius),pointStyle:s.pointStyle||g.valueAtIndexOrDefault(l.pointStyle,e,f.pointStyle),rotation:o.getPointRotation(t,e),backgroundColor:o.getPointBackgroundColor(t,e),borderColor:o.getPointBorderColor(t,e),borderWidth:o.getPointBorderWidth(t,e),tension:r.dataset._model?r.dataset._model.tension:0,steppedLine:!!r.dataset._model&&r.dataset._model.steppedLine,hitRadius:s.hitRadius||g.valueAtIndexOrDefault(l.pointHitRadius,e,f.hitRadius)}},calculatePointY:function(t,e,i){var n,a,o,r=this.chart,s=this.getMeta(),l=this.getScaleForId(s.yAxisID),u=0,d=0;if(l.options.stacked){for(n=0;n<i;n++)if(a=r.data.datasets[n],"line"===(o=r.getDatasetMeta(n)).type&&o.yAxisID===l.id&&r.isDatasetVisible(n)){var c=Number(l.getRightValue(a.data[e]));c<0?d+=c||0:u+=c||0}var h=Number(l.getRightValue(t));return h<0?l.getPixelForValue(d+h):l.getPixelForValue(u+h)}return l.getPixelForValue(t)},updateBezierControlPoints:function(){var t,e,i,n,a=this.getMeta(),o=this.chart.chartArea,r=a.data||[];function s(t,e,i){return Math.max(Math.min(t,i),e)}if(a.dataset._model.spanGaps&&(r=r.filter(function(t){return!t._model.skip})),"monotone"===a.dataset._model.cubicInterpolationMode)g.splineCurveMonotone(r);else for(t=0,e=r.length;t<e;++t)i=r[t]._model,n=g.splineCurve(g.previousItem(r,t)._model,i,g.nextItem(r,t)._model,a.dataset._model.tension),i.controlPointPreviousX=n.previous.x,i.controlPointPreviousY=n.previous.y,i.controlPointNextX=n.next.x,i.controlPointNextY=n.next.y;if(this.chart.options.elements.line.capBezierPoints)for(t=0,e=r.length;t<e;++t)(i=r[t]._model).controlPointPreviousX=s(i.controlPointPreviousX,o.left,o.right),i.controlPointPreviousY=s(i.controlPointPreviousY,o.top,o.bottom),i.controlPointNextX=s(i.controlPointNextX,o.left,o.right),i.controlPointNextY=s(i.controlPointNextY,o.top,o.bottom)},draw:function(){var t,e=this.chart,i=this.getMeta(),n=i.data||[],a=e.chartArea,o=n.length,r=0;for(f(this.getDataset(),e.options)&&(t=(i.dataset._model.borderWidth||0)/2,g.canvas.clipArea(e.ctx,{left:a.left,right:a.right,top:a.top-t,bottom:a.bottom+t}),i.dataset.draw(),g.canvas.unclipArea(e.ctx));r<o;++r)n[r].draw(a)},setHoverStyle:function(t){var e=this.chart.data.datasets[t._datasetIndex],i=t._index,n=t.custom||{},a=t._model;t.$previousStyle={backgroundColor:a.backgroundColor,borderColor:a.borderColor,borderWidth:a.borderWidth,radius:a.radius},a.backgroundColor=n.hoverBackgroundColor||g.valueAtIndexOrDefault(e.pointHoverBackgroundColor,i,g.getHoverColor(a.backgroundColor)),a.borderColor=n.hoverBorderColor||g.valueAtIndexOrDefault(e.pointHoverBorderColor,i,g.getHoverColor(a.borderColor)),a.borderWidth=n.hoverBorderWidth||g.valueAtIndexOrDefault(e.pointHoverBorderWidth,i,a.borderWidth),a.radius=n.hoverRadius||g.valueAtIndexOrDefault(e.pointHoverRadius,i,this.chart.options.elements.point.hoverRadius)}})}},{26:26,41:41,46:46}],19:[function(t,e,i){"use strict";var n=t(26),a=t(41),k=t(46);n._set("polarArea",{scale:{type:"radialLinear",angleLines:{display:!1},gridLines:{circular:!0},pointLabels:{display:!1},ticks:{beginAtZero:!0}},animation:{animateRotate:!0,animateScale:!0},startAngle:-.5*Math.PI,legendCallback:function(t){var e=[];e.push('<ul class="'+t.id+'-legend">');var i=t.data,n=i.datasets,a=i.labels;if(n.length)for(var o=0;o<n[0].data.length;++o)e.push('<li><span style="background-color:'+n[0].backgroundColor[o]+'"></span>'),a[o]&&e.push(a[o]),e.push("</li>");return e.push("</ul>"),e.join("")},legend:{labels:{generateLabels:function(s){var l=s.data;return l.labels.length&&l.datasets.length?l.labels.map(function(t,e){var i=s.getDatasetMeta(0),n=l.datasets[0],a=i.data[e].custom||{},o=k.valueAtIndexOrDefault,r=s.options.elements.arc;return{text:t,fillStyle:a.backgroundColor?a.backgroundColor:o(n.backgroundColor,e,r.backgroundColor),strokeStyle:a.borderColor?a.borderColor:o(n.borderColor,e,r.borderColor),lineWidth:a.borderWidth?a.borderWidth:o(n.borderWidth,e,r.borderWidth),hidden:isNaN(n.data[e])||i.data[e].hidden,index:e}}):[]}},onClick:function(t,e){var i,n,a,o=e.index,r=this.chart;for(i=0,n=(r.data.datasets||[]).length;i<n;++i)(a=r.getDatasetMeta(i)).data[o].hidden=!a.data[o].hidden;r.update()}},tooltips:{callbacks:{title:function(){return""},label:function(t,e){return e.labels[t.index]+": "+t.yLabel}}}}),e.exports=function(t){t.controllers.polarArea=t.DatasetController.extend({dataElementType:a.Arc,linkScales:k.noop,update:function(i){var t,e,n,a=this,o=a.getDataset(),r=a.getMeta(),s=a.chart.options.startAngle||0,l=a._starts=[],u=a._angles=[];for(a._updateRadius(),r.count=a.countVisibleElements(),t=0,e=o.data.length;t<e;t++)l[t]=s,n=a._computeAngle(t),s+=u[t]=n;k.each(r.data,function(t,e){a.updateElement(t,e,i)})},_updateRadius:function(){var t=this,e=t.chart,i=e.chartArea,n=e.options,a=n.elements.arc,o=Math.min(i.right-i.left,i.bottom-i.top);e.outerRadius=Math.max((o-a.borderWidth/2)/2,0),e.innerRadius=Math.max(n.cutoutPercentage?e.outerRadius/100*n.cutoutPercentage:1,0),e.radiusLength=(e.outerRadius-e.innerRadius)/e.getVisibleDatasetCount(),t.outerRadius=e.outerRadius-e.radiusLength*t.index,t.innerRadius=t.outerRadius-e.radiusLength},updateElement:function(t,e,i){var n=this,a=n.chart,o=n.getDataset(),r=a.options,s=r.animation,l=a.scale,u=a.data.labels,d=l.xCenter,c=l.yCenter,h=r.startAngle,f=t.hidden?0:l.getDistanceFromCenterForValue(o.data[e]),g=n._starts[e],p=g+(t.hidden?0:n._angles[e]),m=s.animateScale?0:l.getDistanceFromCenterForValue(o.data[e]);k.extend(t,{_datasetIndex:n.index,_index:e,_scale:l,_model:{x:d,y:c,innerRadius:0,outerRadius:i?m:f,startAngle:i&&s.animateRotate?h:g,endAngle:i&&s.animateRotate?h:p,label:k.valueAtIndexOrDefault(u,e,u[e])}});var v=this.chart.options.elements.arc,b=t.custom||{},x=k.valueAtIndexOrDefault,y=t._model;y.backgroundColor=b.backgroundColor?b.backgroundColor:x(o.backgroundColor,e,v.backgroundColor),y.borderColor=b.borderColor?b.borderColor:x(o.borderColor,e,v.borderColor),y.borderWidth=b.borderWidth?b.borderWidth:x(o.borderWidth,e,v.borderWidth),t.pivot()},countVisibleElements:function(){var i=this.getDataset(),t=this.getMeta(),n=0;return k.each(t.data,function(t,e){isNaN(i.data[e])||t.hidden||n++}),n},_computeAngle:function(t){var e=this,i=this.getMeta().count,n=e.getDataset(),a=e.getMeta();if(isNaN(n.data[t])||a.data[t].hidden)return 0;var o={chart:e.chart,dataIndex:t,dataset:n,datasetIndex:e.index};return k.options.resolve([e.chart.options.elements.arc.angle,2*Math.PI/i],o,t)}})}},{26:26,41:41,46:46}],20:[function(t,e,i){"use strict";var n=t(26),a=t(41),u=t(46);n._set("radar",{scale:{type:"radialLinear"},elements:{line:{tension:0}}}),e.exports=function(t){t.controllers.radar=t.DatasetController.extend({datasetElementType:a.Line,dataElementType:a.Point,linkScales:u.noop,update:function(i){var n=this,t=n.getMeta(),e=t.dataset,a=t.data,o=e.custom||{},r=n.getDataset(),s=n.chart.options.elements.line,l=n.chart.scale;void 0!==r.tension&&void 0===r.lineTension&&(r.lineTension=r.tension),u.extend(t.dataset,{_datasetIndex:n.index,_scale:l,_children:a,_loop:!0,_model:{tension:o.tension?o.tension:u.valueOrDefault(r.lineTension,s.tension),backgroundColor:o.backgroundColor?o.backgroundColor:r.backgroundColor||s.backgroundColor,borderWidth:o.borderWidth?o.borderWidth:r.borderWidth||s.borderWidth,borderColor:o.borderColor?o.borderColor:r.borderColor||s.borderColor,fill:o.fill?o.fill:void 0!==r.fill?r.fill:s.fill,borderCapStyle:o.borderCapStyle?o.borderCapStyle:r.borderCapStyle||s.borderCapStyle,borderDash:o.borderDash?o.borderDash:r.borderDash||s.borderDash,borderDashOffset:o.borderDashOffset?o.borderDashOffset:r.borderDashOffset||s.borderDashOffset,borderJoinStyle:o.borderJoinStyle?o.borderJoinStyle:r.borderJoinStyle||s.borderJoinStyle}}),t.dataset.pivot(),u.each(a,function(t,e){n.updateElement(t,e,i)},n),n.updateBezierControlPoints()},updateElement:function(t,e,i){var n=this,a=t.custom||{},o=n.getDataset(),r=n.chart.scale,s=n.chart.options.elements.point,l=r.getPointPositionForValue(e,o.data[e]);void 0!==o.radius&&void 0===o.pointRadius&&(o.pointRadius=o.radius),void 0!==o.hitRadius&&void 0===o.pointHitRadius&&(o.pointHitRadius=o.hitRadius),u.extend(t,{_datasetIndex:n.index,_index:e,_scale:r,_model:{x:i?r.xCenter:l.x,y:i?r.yCenter:l.y,tension:a.tension?a.tension:u.valueOrDefault(o.lineTension,n.chart.options.elements.line.tension),radius:a.radius?a.radius:u.valueAtIndexOrDefault(o.pointRadius,e,s.radius),backgroundColor:a.backgroundColor?a.backgroundColor:u.valueAtIndexOrDefault(o.pointBackgroundColor,e,s.backgroundColor),borderColor:a.borderColor?a.borderColor:u.valueAtIndexOrDefault(o.pointBorderColor,e,s.borderColor),borderWidth:a.borderWidth?a.borderWidth:u.valueAtIndexOrDefault(o.pointBorderWidth,e,s.borderWidth),pointStyle:a.pointStyle?a.pointStyle:u.valueAtIndexOrDefault(o.pointStyle,e,s.pointStyle),rotation:a.rotation?a.rotation:u.valueAtIndexOrDefault(o.pointRotation,e,s.rotation),hitRadius:a.hitRadius?a.hitRadius:u.valueAtIndexOrDefault(o.pointHitRadius,e,s.hitRadius)}}),t._model.skip=a.skip?a.skip:isNaN(t._model.x)||isNaN(t._model.y)},updateBezierControlPoints:function(){var a=this.chart.chartArea,o=this.getMeta();u.each(o.data,function(t,e){var i=t._model,n=u.splineCurve(u.previousItem(o.data,e,!0)._model,i,u.nextItem(o.data,e,!0)._model,i.tension);i.controlPointPreviousX=Math.max(Math.min(n.previous.x,a.right),a.left),i.controlPointPreviousY=Math.max(Math.min(n.previous.y,a.bottom),a.top),i.controlPointNextX=Math.max(Math.min(n.next.x,a.right),a.left),i.controlPointNextY=Math.max(Math.min(n.next.y,a.bottom),a.top),t.pivot()})},setHoverStyle:function(t){var e=this.chart.data.datasets[t._datasetIndex],i=t.custom||{},n=t._index,a=t._model;t.$previousStyle={backgroundColor:a.backgroundColor,borderColor:a.borderColor,borderWidth:a.borderWidth,radius:a.radius},a.radius=i.hoverRadius?i.hoverRadius:u.valueAtIndexOrDefault(e.pointHoverRadius,n,this.chart.options.elements.point.hoverRadius),a.backgroundColor=i.hoverBackgroundColor?i.hoverBackgroundColor:u.valueAtIndexOrDefault(e.pointHoverBackgroundColor,n,u.getHoverColor(a.backgroundColor)),a.borderColor=i.hoverBorderColor?i.hoverBorderColor:u.valueAtIndexOrDefault(e.pointHoverBorderColor,n,u.getHoverColor(a.borderColor)),a.borderWidth=i.hoverBorderWidth?i.hoverBorderWidth:u.valueAtIndexOrDefault(e.pointHoverBorderWidth,n,a.borderWidth)}})}},{26:26,41:41,46:46}],21:[function(t,e,i){"use strict";t(26)._set("scatter",{hover:{mode:"single"},scales:{xAxes:[{id:"x-axis-1",type:"linear",position:"bottom"}],yAxes:[{id:"y-axis-1",type:"linear",position:"left"}]},showLines:!1,tooltips:{callbacks:{title:function(){return""},label:function(t){return"("+t.xLabel+", "+t.yLabel+")"}}}}),e.exports=function(t){t.controllers.scatter=t.controllers.line}},{26:26}],22:[function(t,e,i){"use strict";var n=t(27);i=e.exports=n.extend({chart:null,currentStep:0,numSteps:60,easing:"",render:null,onAnimationProgress:null,onAnimationComplete:null});Object.defineProperty(i.prototype,"animationObject",{get:function(){return this}}),Object.defineProperty(i.prototype,"chartInstance",{get:function(){return this.chart},set:function(t){this.chart=t}})},{27:27}],23:[function(t,e,i){"use strict";var n=t(26),o=t(46);n._set("global",{animation:{duration:1e3,easing:"easeOutQuart",onProgress:o.noop,onComplete:o.noop}}),e.exports={frameDuration:17,animations:[],dropFrames:0,request:null,addAnimation:function(t,e,i,n){var a,o,r=this.animations;for(e.chart=t,n||(t.animating=!0),a=0,o=r.length;a<o;++a)if(r[a].chart===t)return void(r[a]=e);r.push(e),1===r.length&&this.requestAnimationFrame()},cancelAnimation:function(e){var t=o.findIndex(this.animations,function(t){return t.chart===e});-1!==t&&(this.animations.splice(t,1),e.animating=!1)},requestAnimationFrame:function(){var t=this;null===t.request&&(t.request=o.requestAnimFrame.call(window,function(){t.request=null,t.startDigest()}))},startDigest:function(){var t=this,e=Date.now(),i=0;1<t.dropFrames&&(i=Math.floor(t.dropFrames),t.dropFrames=t.dropFrames%1),t.advance(1+i);var n=Date.now();t.dropFrames+=(n-e)/t.frameDuration,0<t.animations.length&&t.requestAnimationFrame()},advance:function(t){for(var e,i,n=this.animations,a=0;a<n.length;)i=(e=n[a]).chart,e.currentStep=(e.currentStep||0)+t,e.currentStep=Math.min(e.currentStep,e.numSteps),o.callback(e.render,[i,e],i),o.callback(e.onAnimationProgress,[e],i),e.currentStep>=e.numSteps?(o.callback(e.onAnimationComplete,[e],i),i.animating=!1,n.splice(a,1)):++a}}},{26:26,46:46}],24:[function(t,e,i){"use strict";var s=t(22),l=t(23),c=t(26),h=t(46),a=t(29),o=t(31),f=t(49),g=t(32),p=t(34),n=t(36);e.exports=function(u){function d(t){return"top"===t||"bottom"===t}u.types={},u.instances={},u.controllers={},h.extend(u.prototype,{construct:function(t,e){var i,n,a=this;(n=(i=(i=e)||{}).data=i.data||{}).datasets=n.datasets||[],n.labels=n.labels||[],i.options=h.configMerge(c.global,c[i.type],i.options||{}),e=i;var o=f.acquireContext(t,e),r=o&&o.canvas,s=r&&r.height,l=r&&r.width;a.id=h.uid(),a.ctx=o,a.canvas=r,a.config=e,a.width=l,a.height=s,a.aspectRatio=s?l/s:null,a.options=e.options,a._bufferedRender=!1,(a.chart=a).controller=a,u.instances[a.id]=a,Object.defineProperty(a,"data",{get:function(){return a.config.data},set:function(t){a.config.data=t}}),o&&r?(a.initialize(),a.update()):console.error("Failed to create chart: can't acquire context from the given item")},initialize:function(){var t=this;return g.notify(t,"beforeInit"),h.retinaScale(t,t.options.devicePixelRatio),t.bindEvents(),t.options.responsive&&t.resize(!0),t.ensureScalesHaveIDs(),t.buildOrUpdateScales(),t.initToolTip(),g.notify(t,"afterInit"),t},clear:function(){return h.canvas.clear(this),this},stop:function(){return l.cancelAnimation(this),this},resize:function(t){var e=this,i=e.options,n=e.canvas,a=i.maintainAspectRatio&&e.aspectRatio||null,o=Math.max(0,Math.floor(h.getMaximumWidth(n))),r=Math.max(0,Math.floor(a?o/a:h.getMaximumHeight(n)));if((e.width!==o||e.height!==r)&&(n.width=e.width=o,n.height=e.height=r,n.style.width=o+"px",n.style.height=r+"px",h.retinaScale(e,i.devicePixelRatio),!t)){var s={width:o,height:r};g.notify(e,"resize",[s]),e.options.onResize&&e.options.onResize(e,s),e.stop(),e.update({duration:e.options.responsiveAnimationDuration})}},ensureScalesHaveIDs:function(){var t=this.options,e=t.scales||{},i=t.scale;h.each(e.xAxes,function(t,e){t.id=t.id||"x-axis-"+e}),h.each(e.yAxes,function(t,e){t.id=t.id||"y-axis-"+e}),i&&(i.id=i.id||"scale")},buildOrUpdateScales:function(){var r=this,t=r.options,s=r.scales||{},e=[],l=Object.keys(s).reduce(function(t,e){return t[e]=!1,t},{});t.scales&&(e=e.concat((t.scales.xAxes||[]).map(function(t){return{options:t,dtype:"category",dposition:"bottom"}}),(t.scales.yAxes||[]).map(function(t){return{options:t,dtype:"linear",dposition:"left"}}))),t.scale&&e.push({options:t.scale,dtype:"radialLinear",isDefault:!0,dposition:"chartArea"}),h.each(e,function(t){var e=t.options,i=e.id,n=h.valueOrDefault(e.type,t.dtype);d(e.position)!==d(t.dposition)&&(e.position=t.dposition),l[i]=!0;var a=null;if(i in s&&s[i].type===n)(a=s[i]).options=e,a.ctx=r.ctx,a.chart=r;else{var o=p.getScaleConstructor(n);if(!o)return;a=new o({id:i,type:n,options:e,ctx:r.ctx,chart:r}),s[a.id]=a}a.mergeTicksOptions(),t.isDefault&&(r.scale=a)}),h.each(l,function(t,e){t||delete s[e]}),r.scales=s,p.addScalesToLayout(this)},buildOrUpdateControllers:function(){var o=this,r=[],s=[];return h.each(o.data.datasets,function(t,e){var i=o.getDatasetMeta(e),n=t.type||o.config.type;if(i.type&&i.type!==n&&(o.destroyDatasetMeta(e),i=o.getDatasetMeta(e)),i.type=n,r.push(i.type),i.controller)i.controller.updateIndex(e),i.controller.linkScales();else{var a=u.controllers[i.type];if(void 0===a)throw new Error('"'+i.type+'" is not a chart type.');i.controller=new a(o,e),s.push(i.controller)}},o),s},resetElements:function(){var i=this;h.each(i.data.datasets,function(t,e){i.getDatasetMeta(e).controller.reset()},i)},reset:function(){this.resetElements(),this.tooltip.initialize()},update:function(t){var e,i,n=this;if(t&&"object"==typeof t||(t={duration:t,lazy:arguments[1]}),i=(e=n).options,h.each(e.scales,function(t){o.removeBox(e,t)}),i=h.configMerge(u.defaults.global,u.defaults[e.config.type],i),e.options=e.config.options=i,e.ensureScalesHaveIDs(),e.buildOrUpdateScales(),e.tooltip._options=i.tooltips,e.tooltip.initialize(),g._invalidate(n),!1!==g.notify(n,"beforeUpdate")){n.tooltip._data=n.data;var a=n.buildOrUpdateControllers();h.each(n.data.datasets,function(t,e){n.getDatasetMeta(e).controller.buildOrUpdateElements()},n),n.updateLayout(),n.options.animation&&n.options.animation.duration&&h.each(a,function(t){t.reset()}),n.updateDatasets(),n.tooltip.initialize(),n.lastActive=[],g.notify(n,"afterUpdate"),n._bufferedRender?n._bufferedRequest={duration:t.duration,easing:t.easing,lazy:t.lazy}:n.render(t)}},updateLayout:function(){!1!==g.notify(this,"beforeLayout")&&(o.update(this,this.width,this.height),g.notify(this,"afterScaleUpdate"),g.notify(this,"afterLayout"))},updateDatasets:function(){if(!1!==g.notify(this,"beforeDatasetsUpdate")){for(var t=0,e=this.data.datasets.length;t<e;++t)this.updateDataset(t);g.notify(this,"afterDatasetsUpdate")}},updateDataset:function(t){var e=this.getDatasetMeta(t),i={meta:e,index:t};!1!==g.notify(this,"beforeDatasetUpdate",[i])&&(e.controller.update(),g.notify(this,"afterDatasetUpdate",[i]))},render:function(t){var e=this;t&&"object"==typeof t||(t={duration:t,lazy:arguments[1]});var i=t.duration,n=t.lazy;if(!1!==g.notify(e,"beforeRender")){var a=e.options.animation,o=function(t){g.notify(e,"afterRender"),h.callback(a&&a.onComplete,[t],e)};if(a&&(void 0!==i&&0!==i||void 0===i&&0!==a.duration)){var r=new s({numSteps:(i||a.duration)/16.66,easing:t.easing||a.easing,render:function(t,e){var i=h.easing.effects[e.easing],n=e.currentStep,a=n/e.numSteps;t.draw(i(a),a,n)},onAnimationProgress:a.onProgress,onAnimationComplete:o});l.addAnimation(e,r,i,n)}else e.draw(),o(new s({numSteps:0,chart:e}));return e}},draw:function(t){var e=this;e.clear(),h.isNullOrUndef(t)&&(t=1),e.transition(t),e.width<=0||e.height<=0||!1!==g.notify(e,"beforeDraw",[t])&&(h.each(e.boxes,function(t){t.draw(e.chartArea)},e),e.scale&&e.scale.draw(),e.drawDatasets(t),e._drawTooltip(t),g.notify(e,"afterDraw",[t]))},transition:function(t){for(var e=0,i=(this.data.datasets||[]).length;e<i;++e)this.isDatasetVisible(e)&&this.getDatasetMeta(e).controller.transition(t);this.tooltip.transition(t)},drawDatasets:function(t){var e=this;if(!1!==g.notify(e,"beforeDatasetsDraw",[t])){for(var i=(e.data.datasets||[]).length-1;0<=i;--i)e.isDatasetVisible(i)&&e.drawDataset(i,t);g.notify(e,"afterDatasetsDraw",[t])}},drawDataset:function(t,e){var i=this.getDatasetMeta(t),n={meta:i,index:t,easingValue:e};!1!==g.notify(this,"beforeDatasetDraw",[n])&&(i.controller.draw(e),g.notify(this,"afterDatasetDraw",[n]))},_drawTooltip:function(t){var e=this.tooltip,i={tooltip:e,easingValue:t};!1!==g.notify(this,"beforeTooltipDraw",[i])&&(e.draw(),g.notify(this,"afterTooltipDraw",[i]))},getElementAtEvent:function(t){return a.modes.single(this,t)},getElementsAtEvent:function(t){return a.modes.label(this,t,{intersect:!0})},getElementsAtXAxis:function(t){return a.modes["x-axis"](this,t,{intersect:!0})},getElementsAtEventForMode:function(t,e,i){var n=a.modes[e];return"function"==typeof n?n(this,t,i):[]},getDatasetAtEvent:function(t){return a.modes.dataset(this,t,{intersect:!0})},getDatasetMeta:function(t){var e=this.data.datasets[t];e._meta||(e._meta={});var i=e._meta[this.id];return i||(i=e._meta[this.id]={type:null,data:[],dataset:null,controller:null,hidden:null,xAxisID:null,yAxisID:null}),i},getVisibleDatasetCount:function(){for(var t=0,e=0,i=this.data.datasets.length;e<i;++e)this.isDatasetVisible(e)&&t++;return t},isDatasetVisible:function(t){var e=this.getDatasetMeta(t);return"boolean"==typeof e.hidden?!e.hidden:!this.data.datasets[t].hidden},generateLegend:function(){return this.options.legendCallback(this)},destroyDatasetMeta:function(t){var e=this.id,i=this.data.datasets[t],n=i._meta&&i._meta[e];n&&(n.controller.destroy(),delete i._meta[e])},destroy:function(){var t,e,i=this,n=i.canvas;for(i.stop(),t=0,e=i.data.datasets.length;t<e;++t)i.destroyDatasetMeta(t);n&&(i.unbindEvents(),h.canvas.clear(i),f.releaseContext(i.ctx),i.canvas=null,i.ctx=null),g.notify(i,"destroy"),delete u.instances[i.id]},toBase64Image:function(){return this.canvas.toDataURL.apply(this.canvas,arguments)},initToolTip:function(){var t=this;t.tooltip=new n({_chart:t,_chartInstance:t,_data:t.data,_options:t.options.tooltips},t)},bindEvents:function(){var e=this,i=e._listeners={},n=function(){e.eventHandler.apply(e,arguments)};h.each(e.options.events,function(t){f.addEventListener(e,t,n),i[t]=n}),e.options.responsive&&(n=function(){e.resize()},f.addEventListener(e,"resize",n),i.resize=n)},unbindEvents:function(){var i=this,t=i._listeners;t&&(delete i._listeners,h.each(t,function(t,e){f.removeEventListener(i,e,t)}))},updateHoverStyle:function(t,e,i){var n,a,o,r=i?"setHoverStyle":"removeHoverStyle";for(a=0,o=t.length;a<o;++a)(n=t[a])&&this.getDatasetMeta(n._datasetIndex).controller[r](n)},eventHandler:function(t){var e=this,i=e.tooltip;if(!1!==g.notify(e,"beforeEvent",[t])){e._bufferedRender=!0,e._bufferedRequest=null;var n=e.handleEvent(t);i&&(n=i._start?i.handleEvent(t):n|i.handleEvent(t)),g.notify(e,"afterEvent",[t]);var a=e._bufferedRequest;return a?e.render(a):n&&!e.animating&&(e.stop(),e.render({duration:e.options.hover.animationDuration,lazy:!0})),e._bufferedRender=!1,e._bufferedRequest=null,e}},handleEvent:function(t){var e,i=this,n=i.options||{},a=n.hover;return i.lastActive=i.lastActive||[],"mouseout"===t.type?i.active=[]:i.active=i.getElementsAtEventForMode(t,a.mode,a),h.callback(n.onHover||n.hover.onHover,[t.native,i.active],i),"mouseup"!==t.type&&"click"!==t.type||n.onClick&&n.onClick.call(i,t.native,i.active),i.lastActive.length&&i.updateHoverStyle(i.lastActive,a.mode,!1),i.active.length&&a.mode&&i.updateHoverStyle(i.active,a.mode,!0),e=!h.arrayEquals(i.active,i.lastActive),i.lastActive=i.active,e}}),u.Controller=u}},{22:22,23:23,26:26,29:29,31:31,32:32,34:34,36:36,46:46,49:49}],25:[function(t,e,i){"use strict";var s=t(46);e.exports=function(t){var o=["push","pop","shift","splice","unshift"];function r(e,t){var i=e._chartjs;if(i){var n=i.listeners,a=n.indexOf(t);-1!==a&&n.splice(a,1),0<n.length||(o.forEach(function(t){delete e[t]}),delete e._chartjs)}}t.DatasetController=function(t,e){this.initialize(t,e)},s.extend(t.DatasetController.prototype,{datasetElementType:null,dataElementType:null,initialize:function(t,e){this.chart=t,this.index=e,this.linkScales(),this.addElements()},updateIndex:function(t){this.index=t},linkScales:function(){var t=this,e=t.getMeta(),i=t.getDataset();null!==e.xAxisID&&e.xAxisID in t.chart.scales||(e.xAxisID=i.xAxisID||t.chart.options.scales.xAxes[0].id),null!==e.yAxisID&&e.yAxisID in t.chart.scales||(e.yAxisID=i.yAxisID||t.chart.options.scales.yAxes[0].id)},getDataset:function(){return this.chart.data.datasets[this.index]},getMeta:function(){return this.chart.getDatasetMeta(this.index)},getScaleForId:function(t){return this.chart.scales[t]},reset:function(){this.update(!0)},destroy:function(){this._data&&r(this._data,this)},createMetaDataset:function(){var t=this.datasetElementType;return t&&new t({_chart:this.chart,_datasetIndex:this.index})},createMetaData:function(t){var e=this.dataElementType;return e&&new e({_chart:this.chart,_datasetIndex:this.index,_index:t})},addElements:function(){var t,e,i=this.getMeta(),n=this.getDataset().data||[],a=i.data;for(t=0,e=n.length;t<e;++t)a[t]=a[t]||this.createMetaData(t);i.dataset=i.dataset||this.createMetaDataset()},addElementAndReset:function(t){var e=this.createMetaData(t);this.getMeta().data.splice(t,0,e),this.updateElement(e,t,!0)},buildOrUpdateElements:function(){var a,t,e=this,i=e.getDataset(),n=i.data||(i.data=[]);e._data!==n&&(e._data&&r(e._data,e),t=e,(a=n)._chartjs?a._chartjs.listeners.push(t):(Object.defineProperty(a,"_chartjs",{configurable:!0,enumerable:!1,value:{listeners:[t]}}),o.forEach(function(t){var i="onData"+t.charAt(0).toUpperCase()+t.slice(1),n=a[t];Object.defineProperty(a,t,{configurable:!0,enumerable:!1,value:function(){var e=Array.prototype.slice.call(arguments),t=n.apply(this,e);return s.each(a._chartjs.listeners,function(t){"function"==typeof t[i]&&t[i].apply(t,e)}),t}})})),e._data=n),e.resyncElements()},update:s.noop,transition:function(t){for(var e=this.getMeta(),i=e.data||[],n=i.length,a=0;a<n;++a)i[a].transition(t);e.dataset&&e.dataset.transition(t)},draw:function(){var t=this.getMeta(),e=t.data||[],i=e.length,n=0;for(t.dataset&&t.dataset.draw();n<i;++n)e[n].draw()},removeHoverStyle:function(t){s.merge(t._model,t.$previousStyle||{}),delete t.$previousStyle},setHoverStyle:function(t){var e=this.chart.data.datasets[t._datasetIndex],i=t._index,n=t.custom||{},a=s.valueAtIndexOrDefault,o=s.getHoverColor,r=t._model;t.$previousStyle={backgroundColor:r.backgroundColor,borderColor:r.borderColor,borderWidth:r.borderWidth},r.backgroundColor=n.hoverBackgroundColor?n.hoverBackgroundColor:a(e.hoverBackgroundColor,i,o(r.backgroundColor)),r.borderColor=n.hoverBorderColor?n.hoverBorderColor:a(e.hoverBorderColor,i,o(r.borderColor)),r.borderWidth=n.hoverBorderWidth?n.hoverBorderWidth:a(e.hoverBorderWidth,i,r.borderWidth)},resyncElements:function(){var t=this.getMeta(),e=this.getDataset().data,i=t.data.length,n=e.length;n<i?t.data.splice(n,i-n):i<n&&this.insertElements(i,n-i)},insertElements:function(t,e){for(var i=0;i<e;++i)this.addElementAndReset(t+i)},onDataPush:function(){this.insertElements(this.getDataset().data.length-1,arguments.length)},onDataPop:function(){this.getMeta().data.pop()},onDataShift:function(){this.getMeta().data.shift()},onDataSplice:function(t,e){this.getMeta().data.splice(t,e),this.insertElements(t,arguments.length-2)},onDataUnshift:function(){this.insertElements(0,arguments.length)}}),t.DatasetController.extend=s.inherits}},{46:46}],26:[function(t,e,i){"use strict";var n=t(46);e.exports={_set:function(t,e){return n.merge(this[t]||(this[t]={}),e)}}},{46:46}],27:[function(t,e,i){"use strict";var g=t(3),n=t(46);var a=function(t){n.extend(this,t),this.initialize.apply(this,arguments)};n.extend(a.prototype,{initialize:function(){this.hidden=!1},pivot:function(){var t=this;return t._view||(t._view=n.clone(t._model)),t._start={},t},transition:function(t){var e=this,i=e._model,n=e._start,a=e._view;return i&&1!==t?(a||(a=e._view={}),n||(n=e._start={}),function(t,e,i,n){var a,o,r,s,l,u,d,c,h,f=Object.keys(i);for(a=0,o=f.length;a<o;++a)if(u=i[r=f[a]],e.hasOwnProperty(r)||(e[r]=u),(s=e[r])!==u&&"_"!==r[0]){if(t.hasOwnProperty(r)||(t[r]=s),(d=typeof u)==typeof(l=t[r]))if("string"===d){if((c=g(l)).valid&&(h=g(u)).valid){e[r]=h.mix(c,n).rgbString();continue}}else if("number"===d&&isFinite(l)&&isFinite(u)){e[r]=l+(u-l)*n;continue}e[r]=u}}(n,a,i,t)):(e._view=i,e._start=null),e},tooltipPosition:function(){return{x:this._model.x,y:this._model.y}},hasValue:function(){return n.isNumber(this._model.x)&&n.isNumber(this._model.y)}}),a.extend=n.inherits,e.exports=a},{3:3,46:46}],28:[function(t,e,i){"use strict";var n=t(3),a=t(26),g=t(46),l=t(34);e.exports=function(){function d(t,e,i){var n;return"string"==typeof t?(n=parseInt(t,10),-1!==t.indexOf("%")&&(n=n/100*e.parentNode[i])):n=t,n}function c(t){return null!=t&&"none"!==t}function e(t,e,i){var n=document.defaultView,a=g._getParentNode(t),o=n.getComputedStyle(t)[e],r=n.getComputedStyle(a)[e],s=c(o),l=c(r),u=Number.POSITIVE_INFINITY;return s||l?Math.min(s?d(o,t,i):u,l?d(r,a,i):u):"none"}g.configMerge=function(){return g.merge(g.clone(arguments[0]),[].slice.call(arguments,1),{merger:function(t,e,i,n){var a=e[t]||{},o=i[t];"scales"===t?e[t]=g.scaleMerge(a,o):"scale"===t?e[t]=g.merge(a,[l.getScaleDefaults(o.type),o]):g._merger(t,e,i,n)}})},g.scaleMerge=function(){return g.merge(g.clone(arguments[0]),[].slice.call(arguments,1),{merger:function(t,e,i,n){if("xAxes"===t||"yAxes"===t){var a,o,r,s=i[t].length;for(e[t]||(e[t]=[]),a=0;a<s;++a)r=i[t][a],o=g.valueOrDefault(r.type,"xAxes"===t?"category":"linear"),a>=e[t].length&&e[t].push({}),!e[t][a].type||r.type&&r.type!==e[t][a].type?g.merge(e[t][a],[l.getScaleDefaults(o),r]):g.merge(e[t][a],r)}else g._merger(t,e,i,n)}})},g.where=function(t,e){if(g.isArray(t)&&Array.prototype.filter)return t.filter(e);var i=[];return g.each(t,function(t){e(t)&&i.push(t)}),i},g.findIndex=Array.prototype.findIndex?function(t,e,i){return t.findIndex(e,i)}:function(t,e,i){i=void 0===i?t:i;for(var n=0,a=t.length;n<a;++n)if(e.call(i,t[n],n,t))return n;return-1},g.findNextWhere=function(t,e,i){g.isNullOrUndef(i)&&(i=-1);for(var n=i+1;n<t.length;n++){var a=t[n];if(e(a))return a}},g.findPreviousWhere=function(t,e,i){g.isNullOrUndef(i)&&(i=t.length);for(var n=i-1;0<=n;n--){var a=t[n];if(e(a))return a}},g.isNumber=function(t){return!isNaN(parseFloat(t))&&isFinite(t)},g.almostEquals=function(t,e,i){return Math.abs(t-e)<i},g.almostWhole=function(t,e){var i=Math.round(t);return i-e<t&&t<i+e},g.max=function(t){return t.reduce(function(t,e){return isNaN(e)?t:Math.max(t,e)},Number.NEGATIVE_INFINITY)},g.min=function(t){return t.reduce(function(t,e){return isNaN(e)?t:Math.min(t,e)},Number.POSITIVE_INFINITY)},g.sign=Math.sign?function(t){return Math.sign(t)}:function(t){return 0===(t=+t)||isNaN(t)?t:0<t?1:-1},g.log10=Math.log10?function(t){return Math.log10(t)}:function(t){var e=Math.log(t)*Math.LOG10E,i=Math.round(e);return t===Math.pow(10,i)?i:e},g.toRadians=function(t){return t*(Math.PI/180)},g.toDegrees=function(t){return t*(180/Math.PI)},g.getAngleFromPoint=function(t,e){var i=e.x-t.x,n=e.y-t.y,a=Math.sqrt(i*i+n*n),o=Math.atan2(n,i);return o<-.5*Math.PI&&(o+=2*Math.PI),{angle:o,distance:a}},g.distanceBetweenPoints=function(t,e){return Math.sqrt(Math.pow(e.x-t.x,2)+Math.pow(e.y-t.y,2))},g.aliasPixel=function(t){return t%2==0?0:.5},g.splineCurve=function(t,e,i,n){var a=t.skip?e:t,o=e,r=i.skip?e:i,s=Math.sqrt(Math.pow(o.x-a.x,2)+Math.pow(o.y-a.y,2)),l=Math.sqrt(Math.pow(r.x-o.x,2)+Math.pow(r.y-o.y,2)),u=s/(s+l),d=l/(s+l),c=n*(u=isNaN(u)?0:u),h=n*(d=isNaN(d)?0:d);return{previous:{x:o.x-c*(r.x-a.x),y:o.y-c*(r.y-a.y)},next:{x:o.x+h*(r.x-a.x),y:o.y+h*(r.y-a.y)}}},g.EPSILON=Number.EPSILON||1e-14,g.splineCurveMonotone=function(t){var e,i,n,a,o,r,s,l,u,d=(t||[]).map(function(t){return{model:t._model,deltaK:0,mK:0}}),c=d.length;for(e=0;e<c;++e)if(!(n=d[e]).model.skip){if(i=0<e?d[e-1]:null,(a=e<c-1?d[e+1]:null)&&!a.model.skip){var h=a.model.x-n.model.x;n.deltaK=0!==h?(a.model.y-n.model.y)/h:0}!i||i.model.skip?n.mK=n.deltaK:!a||a.model.skip?n.mK=i.deltaK:this.sign(i.deltaK)!==this.sign(n.deltaK)?n.mK=0:n.mK=(i.deltaK+n.deltaK)/2}for(e=0;e<c-1;++e)n=d[e],a=d[e+1],n.model.skip||a.model.skip||(g.almostEquals(n.deltaK,0,this.EPSILON)?n.mK=a.mK=0:(o=n.mK/n.deltaK,r=a.mK/n.deltaK,(l=Math.pow(o,2)+Math.pow(r,2))<=9||(s=3/Math.sqrt(l),n.mK=o*s*n.deltaK,a.mK=r*s*n.deltaK)));for(e=0;e<c;++e)(n=d[e]).model.skip||(i=0<e?d[e-1]:null,a=e<c-1?d[e+1]:null,i&&!i.model.skip&&(u=(n.model.x-i.model.x)/3,n.model.controlPointPreviousX=n.model.x-u,n.model.controlPointPreviousY=n.model.y-u*n.mK),a&&!a.model.skip&&(u=(a.model.x-n.model.x)/3,n.model.controlPointNextX=n.model.x+u,n.model.controlPointNextY=n.model.y+u*n.mK))},g.nextItem=function(t,e,i){return i?e>=t.length-1?t[0]:t[e+1]:e>=t.length-1?t[t.length-1]:t[e+1]},g.previousItem=function(t,e,i){return i?e<=0?t[t.length-1]:t[e-1]:e<=0?t[0]:t[e-1]},g.niceNum=function(t,e){var i=Math.floor(g.log10(t)),n=t/Math.pow(10,i);return(e?n<1.5?1:n<3?2:n<7?5:10:n<=1?1:n<=2?2:n<=5?5:10)*Math.pow(10,i)},g.requestAnimFrame="undefined"==typeof window?function(t){t()}:window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(t){return window.setTimeout(t,1e3/60)},g.getRelativePosition=function(t,e){var i,n,a=t.originalEvent||t,o=t.target||t.srcElement,r=o.getBoundingClientRect(),s=a.touches;n=s&&0<s.length?(i=s[0].clientX,s[0].clientY):(i=a.clientX,a.clientY);var l=parseFloat(g.getStyle(o,"padding-left")),u=parseFloat(g.getStyle(o,"padding-top")),d=parseFloat(g.getStyle(o,"padding-right")),c=parseFloat(g.getStyle(o,"padding-bottom")),h=r.right-r.left-l-d,f=r.bottom-r.top-u-c;return{x:i=Math.round((i-r.left-l)/h*o.width/e.currentDevicePixelRatio),y:n=Math.round((n-r.top-u)/f*o.height/e.currentDevicePixelRatio)}},g.getConstraintWidth=function(t){return e(t,"max-width","clientWidth")},g.getConstraintHeight=function(t){return e(t,"max-height","clientHeight")},g._calculatePadding=function(t,e,i){return-1<(e=g.getStyle(t,e)).indexOf("%")?i/parseInt(e,10):parseInt(e,10)},g._getParentNode=function(t){var e=t.parentNode;return e&&e.host&&(e=e.host),e},g.getMaximumWidth=function(t){var e=g._getParentNode(t);if(!e)return t.clientWidth;var i=e.clientWidth,n=i-g._calculatePadding(e,"padding-left",i)-g._calculatePadding(e,"padding-right",i),a=g.getConstraintWidth(t);return isNaN(a)?n:Math.min(n,a)},g.getMaximumHeight=function(t){var e=g._getParentNode(t);if(!e)return t.clientHeight;var i=e.clientHeight,n=i-g._calculatePadding(e,"padding-top",i)-g._calculatePadding(e,"padding-bottom",i),a=g.getConstraintHeight(t);return isNaN(a)?n:Math.min(n,a)},g.getStyle=function(t,e){return t.currentStyle?t.currentStyle[e]:document.defaultView.getComputedStyle(t,null).getPropertyValue(e)},g.retinaScale=function(t,e){var i=t.currentDevicePixelRatio=e||"undefined"!=typeof window&&window.devicePixelRatio||1;if(1!==i){var n=t.canvas,a=t.height,o=t.width;n.height=a*i,n.width=o*i,t.ctx.scale(i,i),n.style.height||n.style.width||(n.style.height=a+"px",n.style.width=o+"px")}},g.fontString=function(t,e,i){return e+" "+t+"px "+i},g.longestText=function(e,t,i,n){var a=(n=n||{}).data=n.data||{},o=n.garbageCollect=n.garbageCollect||[];n.font!==t&&(a=n.data={},o=n.garbageCollect=[],n.font=t),e.font=t;var r=0;g.each(i,function(t){null!=t&&!0!==g.isArray(t)?r=g.measureText(e,a,o,r,t):g.isArray(t)&&g.each(t,function(t){null==t||g.isArray(t)||(r=g.measureText(e,a,o,r,t))})});var s=o.length/2;if(s>i.length){for(var l=0;l<s;l++)delete a[o[l]];o.splice(0,s)}return r},g.measureText=function(t,e,i,n,a){var o=e[a];return o||(o=e[a]=t.measureText(a).width,i.push(a)),n<o&&(n=o),n},g.numberOfLabelLines=function(t){var e=1;return g.each(t,function(t){g.isArray(t)&&t.length>e&&(e=t.length)}),e},g.color=n?function(t){return t instanceof CanvasGradient&&(t=a.global.defaultColor),n(t)}:function(t){return console.error("Color.js not found!"),t},g.getHoverColor=function(t){return t instanceof CanvasPattern?t:g.color(t).saturate(.5).darken(.1).rgbString()}}},{26:26,3:3,34:34,46:46}],29:[function(t,e,i){"use strict";var n=t(46);function s(t,e){return t.native?{x:t.x,y:t.y}:n.getRelativePosition(t,e)}function l(t,e){var i,n,a,o,r;for(n=0,o=t.data.datasets.length;n<o;++n)if(t.isDatasetVisible(n))for(a=0,r=(i=t.getDatasetMeta(n)).data.length;a<r;++a){var s=i.data[a];s._view.skip||e(s)}}function u(t,e){var i=[];return l(t,function(t){t.inRange(e.x,e.y)&&i.push(t)}),i}function d(t,n,a,o){var r=Number.POSITIVE_INFINITY,s=[];return l(t,function(t){if(!a||t.inRange(n.x,n.y)){var e=t.getCenterPoint(),i=o(n,e);i<r?(s=[t],r=i):i===r&&s.push(t)}}),s}function c(t){var a=-1!==t.indexOf("x"),o=-1!==t.indexOf("y");return function(t,e){var i=a?Math.abs(t.x-e.x):0,n=o?Math.abs(t.y-e.y):0;return Math.sqrt(Math.pow(i,2)+Math.pow(n,2))}}function a(n,t,e){var i=s(t,n);e.axis=e.axis||"x";var a=c(e.axis),o=e.intersect?u(n,i):d(n,i,!1,a),r=[];return o.length?(n.data.datasets.forEach(function(t,e){if(n.isDatasetVisible(e)){var i=n.getDatasetMeta(e).data[o[0]._index];i&&!i._view.skip&&r.push(i)}}),r):[]}e.exports={modes:{single:function(t,e){var i=s(e,t),n=[];return l(t,function(t){if(t.inRange(i.x,i.y))return n.push(t),n}),n.slice(0,1)},label:a,index:a,dataset:function(t,e,i){var n=s(e,t);i.axis=i.axis||"xy";var a=c(i.axis),o=i.intersect?u(t,n):d(t,n,!1,a);return 0<o.length&&(o=t.getDatasetMeta(o[0]._datasetIndex).data),o},"x-axis":function(t,e){return a(t,e,{intersect:!1})},point:function(t,e){return u(t,s(e,t))},nearest:function(t,e,i){var n=s(e,t);i.axis=i.axis||"xy";var a=c(i.axis),o=d(t,n,i.intersect,a);return 1<o.length&&o.sort(function(t,e){var i=t.getArea()-e.getArea();return 0===i&&(i=t._datasetIndex-e._datasetIndex),i}),o.slice(0,1)},x:function(t,e,i){var n=s(e,t),a=[],o=!1;return l(t,function(t){t.inXRange(n.x)&&a.push(t),t.inRange(n.x,n.y)&&(o=!0)}),i.intersect&&!o&&(a=[]),a},y:function(t,e,i){var n=s(e,t),a=[],o=!1;return l(t,function(t){t.inYRange(n.y)&&a.push(t),t.inRange(n.x,n.y)&&(o=!0)}),i.intersect&&!o&&(a=[]),a}}}},{46:46}],30:[function(t,e,i){"use strict";t(26)._set("global",{responsive:!0,responsiveAnimationDuration:0,maintainAspectRatio:!0,events:["mousemove","mouseout","click","touchstart","touchmove"],hover:{onHover:null,mode:"nearest",intersect:!0,animationDuration:400},onClick:null,defaultColor:"rgba(0,0,0,0.1)",defaultFontColor:"#666",defaultFontFamily:"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",defaultFontSize:12,defaultFontStyle:"normal",showLines:!0,elements:{},layout:{padding:{top:0,right:0,bottom:0,left:0}}}),e.exports=function(){var t=function(t,e){return this.construct(t,e),this};return t.Chart=t}},{26:26}],31:[function(t,e,i){"use strict";var B=t(46);function W(t,e){return B.where(t,function(t){return t.position===e})}function V(t,a){t.forEach(function(t,e){return t._tmpIndex_=e,t}),t.sort(function(t,e){var i=a?e:t,n=a?t:e;return i.weight===n.weight?i._tmpIndex_-n._tmpIndex_:i.weight-n.weight}),t.forEach(function(t){delete t._tmpIndex_})}e.exports={defaults:{},addBox:function(t,e){t.boxes||(t.boxes=[]),e.fullWidth=e.fullWidth||!1,e.position=e.position||"top",e.weight=e.weight||0,t.boxes.push(e)},removeBox:function(t,e){var i=t.boxes?t.boxes.indexOf(e):-1;-1!==i&&t.boxes.splice(i,1)},configure:function(t,e,i){for(var n,a=["fullWidth","position","weight"],o=a.length,r=0;r<o;++r)n=a[r],i.hasOwnProperty(n)&&(e[n]=i[n])},update:function(e,i,t){if(e){var n=e.options.layout||{},a=B.options.toPadding(n.padding),o=a.left,r=a.right,s=a.top,l=a.bottom,u=W(e.boxes,"left"),d=W(e.boxes,"right"),c=W(e.boxes,"top"),h=W(e.boxes,"bottom"),f=W(e.boxes,"chartArea");V(u,!0),V(d,!1),V(c,!0),V(h,!1);var g=i-o-r,p=t-s-l,m=p/2,v=(i-g/2)/(u.length+d.length),b=(t-m)/(c.length+h.length),x=g,y=p,k=[];B.each(u.concat(d,c,h),function(t){var e,i=t.isHorizontal();i?(e=t.update(t.fullWidth?g:x,b),y-=e.height):(e=t.update(v,y),x-=e.width),k.push({horizontal:i,minSize:e,box:t})});var M=0,w=0,C=0,S=0;B.each(c.concat(h),function(t){if(t.getPadding){var e=t.getPadding();M=Math.max(M,e.left),w=Math.max(w,e.right)}}),B.each(u.concat(d),function(t){if(t.getPadding){var e=t.getPadding();C=Math.max(C,e.top),S=Math.max(S,e.bottom)}});var _=o,D=r,P=s,I=l;B.each(u.concat(d),z),B.each(u,function(t){_+=t.width}),B.each(d,function(t){D+=t.width}),B.each(c.concat(h),z),B.each(c,function(t){P+=t.height}),B.each(h,function(t){I+=t.height}),B.each(u.concat(d),function(e){var t=B.findNextWhere(k,function(t){return t.box===e}),i={left:0,right:0,top:P,bottom:I};t&&e.update(t.minSize.width,y,i)}),_=o,D=r,P=s,I=l,B.each(u,function(t){_+=t.width}),B.each(d,function(t){D+=t.width}),B.each(c,function(t){P+=t.height}),B.each(h,function(t){I+=t.height});var A=Math.max(M-_,0);_+=A,D+=Math.max(w-D,0);var T=Math.max(C-P,0);P+=T,I+=Math.max(S-I,0);var F=t-P-I,O=i-_-D;O===x&&F===y||(B.each(u,function(t){t.height=F}),B.each(d,function(t){t.height=F}),B.each(c,function(t){t.fullWidth||(t.width=O)}),B.each(h,function(t){t.fullWidth||(t.width=O)}),y=F,x=O);var R=o+A,L=s+T;B.each(u.concat(c),N),R+=x,L+=y,B.each(d,N),B.each(h,N),e.chartArea={left:_,top:P,right:_+x,bottom:P+y},B.each(f,function(t){t.left=e.chartArea.left,t.top=e.chartArea.top,t.right=e.chartArea.right,t.bottom=e.chartArea.bottom,t.update(x,y)})}function z(e){var t=B.findNextWhere(k,function(t){return t.box===e});if(t)if(e.isHorizontal()){var i={left:Math.max(_,M),right:Math.max(D,w),top:0,bottom:0};e.update(e.fullWidth?g:x,p/2,i)}else e.update(t.minSize.width,y)}function N(t){t.isHorizontal()?(t.left=t.fullWidth?o:_,t.right=t.fullWidth?i-r:_+x,t.top=L,t.bottom=L+t.height,L=t.bottom):(t.left=R,t.right=R+t.width,t.top=P,t.bottom=P+y,R=t.right)}}}},{46:46}],32:[function(t,e,i){"use strict";var r=t(26),s=t(46);r._set("global",{plugins:{}}),e.exports={_plugins:[],_cacheId:0,register:function(t){var e=this._plugins;[].concat(t).forEach(function(t){-1===e.indexOf(t)&&e.push(t)}),this._cacheId++},unregister:function(t){var i=this._plugins;[].concat(t).forEach(function(t){var e=i.indexOf(t);-1!==e&&i.splice(e,1)}),this._cacheId++},clear:function(){this._plugins=[],this._cacheId++},count:function(){return this._plugins.length},getAll:function(){return this._plugins},notify:function(t,e,i){var n,a,o,r,s,l=this.descriptors(t),u=l.length;for(n=0;n<u;++n)if("function"==typeof(s=(o=(a=l[n]).plugin)[e])&&((r=[t].concat(i||[])).push(a.options),!1===s.apply(o,r)))return!1;return!0},descriptors:function(t){var e=t.$plugins||(t.$plugins={});if(e.id===this._cacheId)return e.descriptors;var n=[],a=[],i=t&&t.config||{},o=i.options&&i.options.plugins||{};return this._plugins.concat(i.plugins||[]).forEach(function(t){if(-1===n.indexOf(t)){var e=t.id,i=o[e];!1!==i&&(!0===i&&(i=s.clone(r.global.plugins[e])),n.push(t),a.push({plugin:t,options:i||{}}))}}),e.descriptors=a,e.id=this._cacheId,a},_invalidate:function(t){delete t.$plugins}}},{26:26,46:46}],33:[function(t,e,i){"use strict";var y=t(26),n=t(27),H=t(46),a=t(35);function k(t){var e,i,n=[];for(e=0,i=t.length;e<i;++e)n.push(t[e].label);return n}function j(t,e,i){var n=t.getPixelForTick(e);return i&&(n-=0===e?(t.getPixelForTick(1)-n)/2:(n-t.getPixelForTick(e-1))/2),n}function M(t,e,i){return H.isArray(e)?H.longestText(t,i,e):t.measureText(e).width}function w(t){var e=H.valueOrDefault,i=y.global,n=e(t.fontSize,i.defaultFontSize),a=e(t.fontStyle,i.defaultFontStyle),o=e(t.fontFamily,i.defaultFontFamily);return{size:n,style:a,family:o,font:H.fontString(n,a,o)}}function C(t){return H.options.toLineHeight(H.valueOrDefault(t.lineHeight,1.2),H.valueOrDefault(t.fontSize,y.global.defaultFontSize))}y._set("scale",{display:!0,position:"left",offset:!1,gridLines:{display:!0,color:"rgba(0, 0, 0, 0.1)",lineWidth:1,drawBorder:!0,drawOnChartArea:!0,drawTicks:!0,tickMarkLength:10,zeroLineWidth:1,zeroLineColor:"rgba(0,0,0,0.25)",zeroLineBorderDash:[],zeroLineBorderDashOffset:0,offsetGridLines:!1,borderDash:[],borderDashOffset:0},scaleLabel:{display:!1,labelString:"",lineHeight:1.2,padding:{top:4,bottom:4}},ticks:{beginAtZero:!1,minRotation:0,maxRotation:50,mirror:!1,padding:0,reverse:!1,display:!0,autoSkip:!0,autoSkipPadding:0,labelOffset:0,callback:a.formatters.values,minor:{},major:{}}}),e.exports=n.extend({getPadding:function(){return{left:this.paddingLeft||0,top:this.paddingTop||0,right:this.paddingRight||0,bottom:this.paddingBottom||0}},getTicks:function(){return this._ticks},mergeTicksOptions:function(){var t=this.options.ticks;for(var e in!1===t.minor&&(t.minor={display:!1}),!1===t.major&&(t.major={display:!1}),t)"major"!==e&&"minor"!==e&&(void 0===t.minor[e]&&(t.minor[e]=t[e]),void 0===t.major[e]&&(t.major[e]=t[e]))},beforeUpdate:function(){H.callback(this.options.beforeUpdate,[this])},update:function(t,e,i){var n,a,o,r,s,l,u=this;for(u.beforeUpdate(),u.maxWidth=t,u.maxHeight=e,u.margins=H.extend({left:0,right:0,top:0,bottom:0},i),u.longestTextCache=u.longestTextCache||{},u.beforeSetDimensions(),u.setDimensions(),u.afterSetDimensions(),u.beforeDataLimits(),u.determineDataLimits(),u.afterDataLimits(),u.beforeBuildTicks(),s=u.buildTicks()||[],u.afterBuildTicks(),u.beforeTickToLabelConversion(),o=u.convertTicksToLabels(s)||u.ticks,u.afterTickToLabelConversion(),n=0,a=(u.ticks=o).length;n<a;++n)r=o[n],(l=s[n])?l.label=r:s.push(l={label:r,major:!1});return u._ticks=s,u.beforeCalculateTickRotation(),u.calculateTickRotation(),u.afterCalculateTickRotation(),u.beforeFit(),u.fit(),u.afterFit(),u.afterUpdate(),u.minSize},afterUpdate:function(){H.callback(this.options.afterUpdate,[this])},beforeSetDimensions:function(){H.callback(this.options.beforeSetDimensions,[this])},setDimensions:function(){var t=this;t.isHorizontal()?(t.width=t.maxWidth,t.left=0,t.right=t.width):(t.height=t.maxHeight,t.top=0,t.bottom=t.height),t.paddingLeft=0,t.paddingTop=0,t.paddingRight=0,t.paddingBottom=0},afterSetDimensions:function(){H.callback(this.options.afterSetDimensions,[this])},beforeDataLimits:function(){H.callback(this.options.beforeDataLimits,[this])},determineDataLimits:H.noop,afterDataLimits:function(){H.callback(this.options.afterDataLimits,[this])},beforeBuildTicks:function(){H.callback(this.options.beforeBuildTicks,[this])},buildTicks:H.noop,afterBuildTicks:function(){H.callback(this.options.afterBuildTicks,[this])},beforeTickToLabelConversion:function(){H.callback(this.options.beforeTickToLabelConversion,[this])},convertTicksToLabels:function(){var t=this.options.ticks;this.ticks=this.ticks.map(t.userCallback||t.callback,this)},afterTickToLabelConversion:function(){H.callback(this.options.afterTickToLabelConversion,[this])},beforeCalculateTickRotation:function(){H.callback(this.options.beforeCalculateTickRotation,[this])},calculateTickRotation:function(){var t=this,e=t.ctx,i=t.options.ticks,n=k(t._ticks),a=w(i);e.font=a.font;var o=i.minRotation||0;if(n.length&&t.options.display&&t.isHorizontal())for(var r,s=H.longestText(e,a.font,n,t.longestTextCache),l=s,u=t.getPixelForTick(1)-t.getPixelForTick(0)-6;u<l&&o<i.maxRotation;){var d=H.toRadians(o);if(r=Math.cos(d),Math.sin(d)*s>t.maxHeight){o--;break}o++,l=r*s}t.labelRotation=o},afterCalculateTickRotation:function(){H.callback(this.options.afterCalculateTickRotation,[this])},beforeFit:function(){H.callback(this.options.beforeFit,[this])},fit:function(){var t=this,e=t.minSize={width:0,height:0},i=k(t._ticks),n=t.options,a=n.ticks,o=n.scaleLabel,r=n.gridLines,s=n.display,l=t.isHorizontal(),u=w(a),d=n.gridLines.tickMarkLength;if(e.width=l?t.isFullWidth()?t.maxWidth-t.margins.left-t.margins.right:t.maxWidth:s&&r.drawTicks?d:0,e.height=l?s&&r.drawTicks?d:0:t.maxHeight,o.display&&s){var c=C(o)+H.options.toPadding(o.padding).height;l?e.height+=c:e.width+=c}if(a.display&&s){var h=H.longestText(t.ctx,u.font,i,t.longestTextCache),f=H.numberOfLabelLines(i),g=.5*u.size,p=t.options.ticks.padding;if(l){t.longestLabelWidth=h;var m=H.toRadians(t.labelRotation),v=Math.cos(m),b=Math.sin(m)*h+u.size*f+g*(f-1)+g;e.height=Math.min(t.maxHeight,e.height+b+p),t.ctx.font=u.font;var x=M(t.ctx,i[0],u.font),y=M(t.ctx,i[i.length-1],u.font);0!==t.labelRotation?(t.paddingLeft="bottom"===n.position?v*x+3:v*g+3,t.paddingRight="bottom"===n.position?v*g+3:v*y+3):(t.paddingLeft=x/2+3,t.paddingRight=y/2+3)}else a.mirror?h=0:h+=p+g,e.width=Math.min(t.maxWidth,e.width+h),t.paddingTop=u.size/2,t.paddingBottom=u.size/2}t.handleMargins(),t.width=e.width,t.height=e.height},handleMargins:function(){var t=this;t.margins&&(t.paddingLeft=Math.max(t.paddingLeft-t.margins.left,0),t.paddingTop=Math.max(t.paddingTop-t.margins.top,0),t.paddingRight=Math.max(t.paddingRight-t.margins.right,0),t.paddingBottom=Math.max(t.paddingBottom-t.margins.bottom,0))},afterFit:function(){H.callback(this.options.afterFit,[this])},isHorizontal:function(){return"top"===this.options.position||"bottom"===this.options.position},isFullWidth:function(){return this.options.fullWidth},getRightValue:function(t){if(H.isNullOrUndef(t))return NaN;if("number"==typeof t&&!isFinite(t))return NaN;if(t)if(this.isHorizontal()){if(void 0!==t.x)return this.getRightValue(t.x)}else if(void 0!==t.y)return this.getRightValue(t.y);return t},getLabelForIndex:H.noop,getPixelForValue:H.noop,getValueForPixel:H.noop,getPixelForTick:function(t){var e=this,i=e.options.offset;if(e.isHorizontal()){var n=(e.width-(e.paddingLeft+e.paddingRight))/Math.max(e._ticks.length-(i?0:1),1),a=n*t+e.paddingLeft;i&&(a+=n/2);var o=e.left+Math.round(a);return o+=e.isFullWidth()?e.margins.left:0}var r=e.height-(e.paddingTop+e.paddingBottom);return e.top+t*(r/(e._ticks.length-1))},getPixelForDecimal:function(t){var e=this;if(e.isHorizontal()){var i=(e.width-(e.paddingLeft+e.paddingRight))*t+e.paddingLeft,n=e.left+Math.round(i);return n+=e.isFullWidth()?e.margins.left:0}return e.top+t*e.height},getBasePixel:function(){return this.getPixelForValue(this.getBaseValue())},getBaseValue:function(){var t=this.min,e=this.max;return this.beginAtZero?0:t<0&&e<0?e:0<t&&0<e?t:0},_autoSkip:function(t){var e,i,n,a,o=this,r=o.isHorizontal(),s=o.options.ticks.minor,l=t.length,u=H.toRadians(o.labelRotation),d=Math.cos(u),c=o.longestLabelWidth*d,h=[];for(s.maxTicksLimit&&(a=s.maxTicksLimit),r&&(e=!1,(c+s.autoSkipPadding)*l>o.width-(o.paddingLeft+o.paddingRight)&&(e=1+Math.floor((c+s.autoSkipPadding)*l/(o.width-(o.paddingLeft+o.paddingRight)))),a&&a<l&&(e=Math.max(e,Math.floor(l/a)))),i=0;i<l;i++)n=t[i],(1<e&&0<i%e||i%e==0&&l<=i+e)&&i!==l-1&&delete n.label,h.push(n);return h},draw:function(S){var _=this,D=_.options;if(D.display){var r=_.ctx,P=y.global,I=D.ticks.minor,t=D.ticks.major||I,A=D.gridLines,e=D.scaleLabel,T=0!==_.labelRotation,F=_.isHorizontal(),O=I.autoSkip?_._autoSkip(_.getTicks()):_.getTicks(),s=H.valueOrDefault(I.fontColor,P.defaultFontColor),l=w(I),u=H.valueOrDefault(t.fontColor,P.defaultFontColor),d=w(t),R=A.drawTicks?A.tickMarkLength:0,i=H.valueOrDefault(e.fontColor,P.defaultFontColor),n=w(e),a=H.options.toPadding(e.padding),L=H.toRadians(_.labelRotation),z=[],N=_.options.gridLines.lineWidth,B="right"===D.position?_.left:_.right-N-R,W="right"===D.position?_.left+R:_.right,V="bottom"===D.position?_.top+N:_.bottom-R-N,E="bottom"===D.position?_.top+N+R:_.bottom+N;if(H.each(O,function(t,e){if(!H.isNullOrUndef(t.label)){var i,n,a,o,r,s,l,u,d,c,h,f,g,p,m=t.label;o=e===_.zeroLineIndex&&D.offset===A.offsetGridLines?(i=A.zeroLineWidth,n=A.zeroLineColor,a=A.zeroLineBorderDash,A.zeroLineBorderDashOffset):(i=H.valueAtIndexOrDefault(A.lineWidth,e),n=H.valueAtIndexOrDefault(A.color,e),a=H.valueOrDefault(A.borderDash,P.borderDash),H.valueOrDefault(A.borderDashOffset,P.borderDashOffset));var v="middle",b="middle",x=I.padding;if(F){var y=R+x;p="bottom"===D.position?(b=T?"middle":"top",v=T?"right":"center",_.top+y):(b=T?"middle":"bottom",v=T?"left":"center",_.bottom-y);var k=j(_,e,A.offsetGridLines&&1<O.length);k<_.left&&(n="rgba(0,0,0,0)"),k+=H.aliasPixel(i),g=_.getPixelForTick(e)+I.labelOffset,r=l=d=h=k,s=V,u=E,c=S.top,f=S.bottom+N}else{var M,w="left"===D.position;M=I.mirror?(v=w?"left":"right",x):(v=w?"right":"left",R+x),g=w?_.right-M:_.left+M;var C=j(_,e,A.offsetGridLines&&1<O.length);C<_.top&&(n="rgba(0,0,0,0)"),C+=H.aliasPixel(i),p=_.getPixelForTick(e)+I.labelOffset,r=B,l=W,d=S.left,h=S.right+N,s=u=c=f=C}z.push({tx1:r,ty1:s,tx2:l,ty2:u,x1:d,y1:c,x2:h,y2:f,labelX:g,labelY:p,glWidth:i,glColor:n,glBorderDash:a,glBorderDashOffset:o,rotation:-1*L,label:m,major:t.major,textBaseline:b,textAlign:v})}}),H.each(z,function(t){if(A.display&&(r.save(),r.lineWidth=t.glWidth,r.strokeStyle=t.glColor,r.setLineDash&&(r.setLineDash(t.glBorderDash),r.lineDashOffset=t.glBorderDashOffset),r.beginPath(),A.drawTicks&&(r.moveTo(t.tx1,t.ty1),r.lineTo(t.tx2,t.ty2)),A.drawOnChartArea&&(r.moveTo(t.x1,t.y1),r.lineTo(t.x2,t.y2)),r.stroke(),r.restore()),I.display){r.save(),r.translate(t.labelX,t.labelY),r.rotate(t.rotation),r.font=t.major?d.font:l.font,r.fillStyle=t.major?u:s,r.textBaseline=t.textBaseline,r.textAlign=t.textAlign;var e=t.label;if(H.isArray(e))for(var i=e.length,n=1.5*l.size,a=_.isHorizontal()?0:-n*(i-1)/2,o=0;o<i;++o)r.fillText(""+e[o],0,a),a+=n;else r.fillText(e,0,0);r.restore()}}),e.display){var o,c,h=0,f=C(e)/2;if(F)o=_.left+(_.right-_.left)/2,c="bottom"===D.position?_.bottom-f-a.bottom:_.top+f+a.top;else{var g="left"===D.position;o=g?_.left+f+a.top:_.right-f-a.top,c=_.top+(_.bottom-_.top)/2,h=g?-.5*Math.PI:.5*Math.PI}r.save(),r.translate(o,c),r.rotate(h),r.textAlign="center",r.textBaseline="middle",r.fillStyle=i,r.font=n.font,r.fillText(e.labelString,0,0),r.restore()}if(A.drawBorder){r.lineWidth=H.valueAtIndexOrDefault(A.lineWidth,0),r.strokeStyle=H.valueAtIndexOrDefault(A.color,0);var p=_.left,m=_.right+N,v=_.top,b=_.bottom+N,x=H.aliasPixel(r.lineWidth);F?(v=b="top"===D.position?_.bottom:_.top,v+=x,b+=x):(p=m="left"===D.position?_.right:_.left,p+=x,m+=x),r.beginPath(),r.moveTo(p,v),r.lineTo(m,b),r.stroke()}}}})},{26:26,27:27,35:35,46:46}],34:[function(t,e,i){"use strict";var n=t(26),a=t(46),o=t(31);e.exports={constructors:{},defaults:{},registerScaleType:function(t,e,i){this.constructors[t]=e,this.defaults[t]=a.clone(i)},getScaleConstructor:function(t){return this.constructors.hasOwnProperty(t)?this.constructors[t]:void 0},getScaleDefaults:function(t){return this.defaults.hasOwnProperty(t)?a.merge({},[n.scale,this.defaults[t]]):{}},updateScaleDefaults:function(t,e){this.defaults.hasOwnProperty(t)&&(this.defaults[t]=a.extend(this.defaults[t],e))},addScalesToLayout:function(e){a.each(e.scales,function(t){t.fullWidth=t.options.fullWidth,t.position=t.options.position,t.weight=t.options.weight,o.addBox(e,t)})}}},{26:26,31:31,46:46}],35:[function(t,e,i){"use strict";var l=t(46);e.exports={formatters:{values:function(t){return l.isArray(t)?t:""+t},linear:function(t,e,i){var n=3<i.length?i[2]-i[1]:i[1]-i[0];1<Math.abs(n)&&t!==Math.floor(t)&&(n=t-Math.floor(t));var a=l.log10(Math.abs(n)),o="";if(0!==t)if(Math.max(Math.abs(i[0]),Math.abs(i[i.length-1]))<1e-4){var r=l.log10(Math.abs(t));o=t.toExponential(Math.floor(r)-Math.floor(a))}else{var s=-1*Math.floor(a);s=Math.max(Math.min(s,20),0),o=t.toFixed(s)}else o="0";return o},logarithmic:function(t,e,i){var n=t/Math.pow(10,Math.floor(l.log10(t)));return 0===t?"0":1===n||2===n||5===n||0===e||e===i.length-1?t.toExponential():""}}}},{46:46}],36:[function(t,e,i){"use strict";var n=t(26),a=t(27),R=t(46);n._set("global",{tooltips:{enabled:!0,custom:null,mode:"nearest",position:"average",intersect:!0,backgroundColor:"rgba(0,0,0,0.8)",titleFontStyle:"bold",titleSpacing:2,titleMarginBottom:6,titleFontColor:"#fff",titleAlign:"left",bodySpacing:2,bodyFontColor:"#fff",bodyAlign:"left",footerFontStyle:"bold",footerSpacing:2,footerMarginTop:6,footerFontColor:"#fff",footerAlign:"left",yPadding:6,xPadding:6,caretPadding:2,caretSize:5,cornerRadius:6,multiKeyBackground:"#fff",displayColors:!0,borderColor:"rgba(0,0,0,0)",borderWidth:0,callbacks:{beforeTitle:R.noop,title:function(t,e){var i="",n=e.labels,a=n?n.length:0;if(0<t.length){var o=t[0];o.xLabel?i=o.xLabel:0<a&&o.index<a&&(i=n[o.index])}return i},afterTitle:R.noop,beforeBody:R.noop,beforeLabel:R.noop,label:function(t,e){var i=e.datasets[t.datasetIndex].label||"";return i&&(i+=": "),i+=t.yLabel},labelColor:function(t,e){var i=e.getDatasetMeta(t.datasetIndex).data[t.index]._view;return{borderColor:i.borderColor,backgroundColor:i.backgroundColor}},labelTextColor:function(){return this._options.bodyFontColor},afterLabel:R.noop,afterBody:R.noop,beforeFooter:R.noop,footer:R.noop,afterFooter:R.noop}}});var L={average:function(t){if(!t.length)return!1;var e,i,n=0,a=0,o=0;for(e=0,i=t.length;e<i;++e){var r=t[e];if(r&&r.hasValue()){var s=r.tooltipPosition();n+=s.x,a+=s.y,++o}}return{x:Math.round(n/o),y:Math.round(a/o)}},nearest:function(t,e){var i,n,a,o=e.x,r=e.y,s=Number.POSITIVE_INFINITY;for(i=0,n=t.length;i<n;++i){var l=t[i];if(l&&l.hasValue()){var u=l.getCenterPoint(),d=R.distanceBetweenPoints(e,u);d<s&&(s=d,a=l)}}if(a){var c=a.tooltipPosition();o=c.x,r=c.y}return{x:o,y:r}}};function h(t,e){var i=R.color(t);return i.alpha(e*i.alpha()).rgbaString()}function r(t,e){return e&&(R.isArray(e)?Array.prototype.push.apply(t,e):t.push(e)),t}function s(t){return("string"==typeof t||t instanceof String)&&-1<t.indexOf("\n")?t.split("\n"):t}function z(t){var e=n.global,i=R.valueOrDefault;return{xPadding:t.xPadding,yPadding:t.yPadding,xAlign:t.xAlign,yAlign:t.yAlign,bodyFontColor:t.bodyFontColor,_bodyFontFamily:i(t.bodyFontFamily,e.defaultFontFamily),_bodyFontStyle:i(t.bodyFontStyle,e.defaultFontStyle),_bodyAlign:t.bodyAlign,bodyFontSize:i(t.bodyFontSize,e.defaultFontSize),bodySpacing:t.bodySpacing,titleFontColor:t.titleFontColor,_titleFontFamily:i(t.titleFontFamily,e.defaultFontFamily),_titleFontStyle:i(t.titleFontStyle,e.defaultFontStyle),titleFontSize:i(t.titleFontSize,e.defaultFontSize),_titleAlign:t.titleAlign,titleSpacing:t.titleSpacing,titleMarginBottom:t.titleMarginBottom,footerFontColor:t.footerFontColor,_footerFontFamily:i(t.footerFontFamily,e.defaultFontFamily),_footerFontStyle:i(t.footerFontStyle,e.defaultFontStyle),footerFontSize:i(t.footerFontSize,e.defaultFontSize),_footerAlign:t.footerAlign,footerSpacing:t.footerSpacing,footerMarginTop:t.footerMarginTop,caretSize:t.caretSize,cornerRadius:t.cornerRadius,backgroundColor:t.backgroundColor,opacity:0,legendColorBackground:t.multiKeyBackground,displayColors:t.displayColors,borderColor:t.borderColor,borderWidth:t.borderWidth}}function o(t){return r([],s(t))}(e.exports=a.extend({initialize:function(){this._model=z(this._options),this._lastActive=[]},getTitle:function(){var t=this._options.callbacks,e=t.beforeTitle.apply(this,arguments),i=t.title.apply(this,arguments),n=t.afterTitle.apply(this,arguments),a=[];return a=r(a=r(a=r(a,s(e)),s(i)),s(n))},getBeforeBody:function(){return o(this._options.callbacks.beforeBody.apply(this,arguments))},getBody:function(t,i){var n=this,a=n._options.callbacks,o=[];return R.each(t,function(t){var e={before:[],lines:[],after:[]};r(e.before,s(a.beforeLabel.call(n,t,i))),r(e.lines,a.label.call(n,t,i)),r(e.after,s(a.afterLabel.call(n,t,i))),o.push(e)}),o},getAfterBody:function(){return o(this._options.callbacks.afterBody.apply(this,arguments))},getFooter:function(){var t=this._options.callbacks,e=t.beforeFooter.apply(this,arguments),i=t.footer.apply(this,arguments),n=t.afterFooter.apply(this,arguments),a=[];return a=r(a=r(a=r(a,s(e)),s(i)),s(n))},update:function(t){var e,i,n,a,o,r,s,l,u,d,c,h,f,g,p,m,v,b,x,y,k=this,M=k._options,w=k._model,C=k._model=z(M),S=k._active,_=k._data,D={xAlign:w.xAlign,yAlign:w.yAlign},P={x:w.x,y:w.y},I={width:w.width,height:w.height},A={x:w.caretX,y:w.caretY};if(S.length){C.opacity=1;var T=[],F=[];A=L[M.position].call(k,S,k._eventPosition);var O=[];for(e=0,i=S.length;e<i;++e)O.push((m=S[e],b=v=void 0,v=m._xScale,b=m._yScale||m._scale,x=m._index,y=m._datasetIndex,{xLabel:v?v.getLabelForIndex(x,y):"",yLabel:b?b.getLabelForIndex(x,y):"",index:x,datasetIndex:y,x:m._model.x,y:m._model.y}));M.filter&&(O=O.filter(function(t){return M.filter(t,_)})),M.itemSort&&(O=O.sort(function(t,e){return M.itemSort(t,e,_)})),R.each(O,function(t){T.push(M.callbacks.labelColor.call(k,t,k._chart)),F.push(M.callbacks.labelTextColor.call(k,t,k._chart))}),C.title=k.getTitle(O,_),C.beforeBody=k.getBeforeBody(O,_),C.body=k.getBody(O,_),C.afterBody=k.getAfterBody(O,_),C.footer=k.getFooter(O,_),C.x=Math.round(A.x),C.y=Math.round(A.y),C.caretPadding=M.caretPadding,C.labelColors=T,C.labelTextColors=F,C.dataPoints=O,D=function(t,e){var i,n,a,o,r,s=t._model,l=t._chart,u=t._chart.chartArea,d="center",c="center";s.y<e.height?c="top":s.y>l.height-e.height&&(c="bottom");var h=(u.left+u.right)/2,f=(u.top+u.bottom)/2;n="center"===c?(i=function(t){return t<=h},function(t){return h<t}):(i=function(t){return t<=e.width/2},function(t){return t>=l.width-e.width/2}),a=function(t){return t+e.width+s.caretSize+s.caretPadding>l.width},o=function(t){return t-e.width-s.caretSize-s.caretPadding<0},r=function(t){return t<=f?"top":"bottom"},i(s.x)?(d="left",a(s.x)&&(d="center",c=r(s.y))):n(s.x)&&(d="right",o(s.x)&&(d="center",c=r(s.y)));var g=t._options;return{xAlign:g.xAlign?g.xAlign:d,yAlign:g.yAlign?g.yAlign:c}}(this,I=function(t,e){var i=t._chart.ctx,n=2*e.yPadding,a=0,o=e.body,r=o.reduce(function(t,e){return t+e.before.length+e.lines.length+e.after.length},0);r+=e.beforeBody.length+e.afterBody.length;var s=e.title.length,l=e.footer.length,u=e.titleFontSize,d=e.bodyFontSize,c=e.footerFontSize;n+=s*u,n+=s?(s-1)*e.titleSpacing:0,n+=s?e.titleMarginBottom:0,n+=r*d,n+=r?(r-1)*e.bodySpacing:0,n+=l?e.footerMarginTop:0,n+=l*c,n+=l?(l-1)*e.footerSpacing:0;var h=0,f=function(t){a=Math.max(a,i.measureText(t).width+h)};return i.font=R.fontString(u,e._titleFontStyle,e._titleFontFamily),R.each(e.title,f),i.font=R.fontString(d,e._bodyFontStyle,e._bodyFontFamily),R.each(e.beforeBody.concat(e.afterBody),f),h=e.displayColors?d+2:0,R.each(o,function(t){R.each(t.before,f),R.each(t.lines,f),R.each(t.after,f)}),h=0,i.font=R.fontString(c,e._footerFontStyle,e._footerFontFamily),R.each(e.footer,f),{width:a+=2*e.xPadding,height:n}}(this,C)),n=C,a=I,o=D,r=k._chart,s=n.x,l=n.y,u=n.caretSize,d=n.caretPadding,c=n.cornerRadius,h=o.xAlign,f=o.yAlign,g=u+d,p=c+d,"right"===h?s-=a.width:"center"===h&&((s-=a.width/2)+a.width>r.width&&(s=r.width-a.width),s<0&&(s=0)),"top"===f?l+=g:l-="bottom"===f?a.height+g:a.height/2,"center"===f?"left"===h?s+=g:"right"===h&&(s-=g):"left"===h?s-=p:"right"===h&&(s+=p),P={x:s,y:l}}else C.opacity=0;return C.xAlign=D.xAlign,C.yAlign=D.yAlign,C.x=P.x,C.y=P.y,C.width=I.width,C.height=I.height,C.caretX=A.x,C.caretY=A.y,k._model=C,t&&M.custom&&M.custom.call(k,C),k},drawCaret:function(t,e){var i=this._chart.ctx,n=this._view,a=this.getCaretPosition(t,e,n);i.lineTo(a.x1,a.y1),i.lineTo(a.x2,a.y2),i.lineTo(a.x3,a.y3)},getCaretPosition:function(t,e,i){var n,a,o,r,s,l,u=i.caretSize,d=i.cornerRadius,c=i.xAlign,h=i.yAlign,f=t.x,g=t.y,p=e.width,m=e.height;if("center"===h)s=g+m/2,l="left"===c?(a=(n=f)-u,o=n,r=s+u,s-u):(a=(n=f+p)+u,o=n,r=s-u,s+u);else if(o=(n="left"===c?(a=f+d+u)-u:"right"===c?(a=f+p-d-u)-u:(a=i.caretX)-u,a+u),"top"===h)s=(r=g)-u,l=r;else{s=(r=g+m)+u,l=r;var v=o;o=n,n=v}return{x1:n,x2:a,x3:o,y1:r,y2:s,y3:l}},drawTitle:function(t,e,i,n){var a=e.title;if(a.length){i.textAlign=e._titleAlign,i.textBaseline="top";var o,r,s=e.titleFontSize,l=e.titleSpacing;for(i.fillStyle=h(e.titleFontColor,n),i.font=R.fontString(s,e._titleFontStyle,e._titleFontFamily),o=0,r=a.length;o<r;++o)i.fillText(a[o],t.x,t.y),t.y+=s+l,o+1===a.length&&(t.y+=e.titleMarginBottom-l)}},drawBody:function(n,a,o,r){var s=a.bodyFontSize,e=a.bodySpacing,t=a.body;o.textAlign=a._bodyAlign,o.textBaseline="top",o.font=R.fontString(s,a._bodyFontStyle,a._bodyFontFamily);var i=0,l=function(t){o.fillText(t,n.x+i,n.y),n.y+=s+e};o.fillStyle=h(a.bodyFontColor,r),R.each(a.beforeBody,l);var u=a.displayColors;i=u?s+2:0,R.each(t,function(t,e){var i=h(a.labelTextColors[e],r);o.fillStyle=i,R.each(t.before,l),R.each(t.lines,function(t){u&&(o.fillStyle=h(a.legendColorBackground,r),o.fillRect(n.x,n.y,s,s),o.lineWidth=1,o.strokeStyle=h(a.labelColors[e].borderColor,r),o.strokeRect(n.x,n.y,s,s),o.fillStyle=h(a.labelColors[e].backgroundColor,r),o.fillRect(n.x+1,n.y+1,s-2,s-2),o.fillStyle=i),l(t)}),R.each(t.after,l)}),i=0,R.each(a.afterBody,l),n.y-=e},drawFooter:function(e,i,n,t){var a=i.footer;a.length&&(e.y+=i.footerMarginTop,n.textAlign=i._footerAlign,n.textBaseline="top",n.fillStyle=h(i.footerFontColor,t),n.font=R.fontString(i.footerFontSize,i._footerFontStyle,i._footerFontFamily),R.each(a,function(t){n.fillText(t,e.x,e.y),e.y+=i.footerFontSize+i.footerSpacing}))},drawBackground:function(t,e,i,n,a){i.fillStyle=h(e.backgroundColor,a),i.strokeStyle=h(e.borderColor,a),i.lineWidth=e.borderWidth;var o=e.xAlign,r=e.yAlign,s=t.x,l=t.y,u=n.width,d=n.height,c=e.cornerRadius;i.beginPath(),i.moveTo(s+c,l),"top"===r&&this.drawCaret(t,n),i.lineTo(s+u-c,l),i.quadraticCurveTo(s+u,l,s+u,l+c),"center"===r&&"right"===o&&this.drawCaret(t,n),i.lineTo(s+u,l+d-c),i.quadraticCurveTo(s+u,l+d,s+u-c,l+d),"bottom"===r&&this.drawCaret(t,n),i.lineTo(s+c,l+d),i.quadraticCurveTo(s,l+d,s,l+d-c),"center"===r&&"left"===o&&this.drawCaret(t,n),i.lineTo(s,l+c),i.quadraticCurveTo(s,l,s+c,l),i.closePath(),i.fill(),0<e.borderWidth&&i.stroke()},draw:function(){var t=this._chart.ctx,e=this._view;if(0!==e.opacity){var i={width:e.width,height:e.height},n={x:e.x,y:e.y},a=Math.abs(e.opacity<.001)?0:e.opacity,o=e.title.length||e.beforeBody.length||e.body.length||e.afterBody.length||e.footer.length;this._options.enabled&&o&&(this.drawBackground(n,e,t,i,a),n.x+=e.xPadding,n.y+=e.yPadding,this.drawTitle(n,e,t,a),this.drawBody(n,e,t,a),this.drawFooter(n,e,t,a))}},handleEvent:function(t){var e,i=this,n=i._options;return i._lastActive=i._lastActive||[],"mouseout"===t.type?i._active=[]:i._active=i._chart.getElementsAtEventForMode(t,n.mode,n),(e=!R.arrayEquals(i._active,i._lastActive))&&(i._lastActive=i._active,(n.enabled||n.custom)&&(i._eventPosition={x:t.x,y:t.y},i.update(!0),i.pivot())),e}})).positioners=L},{26:26,27:27,46:46}],37:[function(t,e,i){"use strict";var n=t(26),a=t(27),d=t(46);n._set("global",{elements:{arc:{backgroundColor:n.global.defaultColor,borderColor:"#fff",borderWidth:2}}}),e.exports=a.extend({inLabelRange:function(t){var e=this._view;return!!e&&Math.pow(t-e.x,2)<Math.pow(e.radius+e.hoverRadius,2)},inRange:function(t,e){var i=this._view;if(i){for(var n=d.getAngleFromPoint(i,{x:t,y:e}),a=n.angle,o=n.distance,r=i.startAngle,s=i.endAngle;s<r;)s+=2*Math.PI;for(;s<a;)a-=2*Math.PI;for(;a<r;)a+=2*Math.PI;var l=r<=a&&a<=s,u=o>=i.innerRadius&&o<=i.outerRadius;return l&&u}return!1},getCenterPoint:function(){var t=this._view,e=(t.startAngle+t.endAngle)/2,i=(t.innerRadius+t.outerRadius)/2;return{x:t.x+Math.cos(e)*i,y:t.y+Math.sin(e)*i}},getArea:function(){var t=this._view;return Math.PI*((t.endAngle-t.startAngle)/(2*Math.PI))*(Math.pow(t.outerRadius,2)-Math.pow(t.innerRadius,2))},tooltipPosition:function(){var t=this._view,e=t.startAngle+(t.endAngle-t.startAngle)/2,i=(t.outerRadius-t.innerRadius)/2+t.innerRadius;return{x:t.x+Math.cos(e)*i,y:t.y+Math.sin(e)*i}},draw:function(){var t=this._chart.ctx,e=this._view,i=e.startAngle,n=e.endAngle;t.beginPath(),t.arc(e.x,e.y,e.outerRadius,i,n),t.arc(e.x,e.y,e.innerRadius,n,i,!0),t.closePath(),t.strokeStyle=e.borderColor,t.lineWidth=e.borderWidth,t.fillStyle=e.backgroundColor,t.fill(),t.lineJoin="bevel",e.borderWidth&&t.stroke()}})},{26:26,27:27,46:46}],38:[function(t,e,i){"use strict";var n=t(26),a=t(27),d=t(46),c=n.global;n._set("global",{elements:{line:{tension:.4,backgroundColor:c.defaultColor,borderWidth:3,borderColor:c.defaultColor,borderCapStyle:"butt",borderDash:[],borderDashOffset:0,borderJoinStyle:"miter",capBezierPoints:!0,fill:!0}}}),e.exports=a.extend({draw:function(){var t,e,i,n,a=this._view,o=this._chart.ctx,r=a.spanGaps,s=this._children.slice(),l=c.elements.line,u=-1;for(this._loop&&s.length&&s.push(s[0]),o.save(),o.lineCap=a.borderCapStyle||l.borderCapStyle,o.setLineDash&&o.setLineDash(a.borderDash||l.borderDash),o.lineDashOffset=a.borderDashOffset||l.borderDashOffset,o.lineJoin=a.borderJoinStyle||l.borderJoinStyle,o.lineWidth=a.borderWidth||l.borderWidth,o.strokeStyle=a.borderColor||c.defaultColor,o.beginPath(),u=-1,t=0;t<s.length;++t)e=s[t],i=d.previousItem(s,t),n=e._view,0===t?n.skip||(o.moveTo(n.x,n.y),u=t):(i=-1===u?i:s[u],n.skip||(u!==t-1&&!r||-1===u?o.moveTo(n.x,n.y):d.canvas.lineTo(o,i._view,e._view),u=t));o.stroke(),o.restore()}})},{26:26,27:27,46:46}],39:[function(t,e,i){"use strict";var u=t(26),n=t(27),d=t(46),c=u.global.defaultColor;function a(t){var e=this._view;return!!e&&Math.abs(t-e.x)<e.radius+e.hitRadius}u._set("global",{elements:{point:{radius:3,pointStyle:"circle",backgroundColor:c,borderColor:c,borderWidth:1,hitRadius:1,hoverRadius:4,hoverBorderWidth:1}}}),e.exports=n.extend({inRange:function(t,e){var i=this._view;return!!i&&Math.pow(t-i.x,2)+Math.pow(e-i.y,2)<Math.pow(i.hitRadius+i.radius,2)},inLabelRange:a,inXRange:a,inYRange:function(t){var e=this._view;return!!e&&Math.abs(t-e.y)<e.radius+e.hitRadius},getCenterPoint:function(){var t=this._view;return{x:t.x,y:t.y}},getArea:function(){return Math.PI*Math.pow(this._view.radius,2)},tooltipPosition:function(){var t=this._view;return{x:t.x,y:t.y,padding:t.radius+t.borderWidth}},draw:function(t){var e=this._view,i=this._model,n=this._chart.ctx,a=e.pointStyle,o=e.rotation,r=e.radius,s=e.x,l=e.y;e.skip||(void 0===t||i.x>=t.left&&1.01*t.right>=i.x&&i.y>=t.top&&1.01*t.bottom>=i.y)&&(n.strokeStyle=e.borderColor||c,n.lineWidth=d.valueOrDefault(e.borderWidth,u.global.elements.point.borderWidth),n.fillStyle=e.backgroundColor||c,d.canvas.drawPoint(n,a,r,s,l,o))}})},{26:26,27:27,46:46}],40:[function(t,e,i){"use strict";var n=t(26),a=t(27);function l(t){return void 0!==t._view.width}function o(t){var e,i,n,a,o=t._view;if(l(t)){var r=o.width/2;e=o.x-r,i=o.x+r,n=Math.min(o.y,o.base),a=Math.max(o.y,o.base)}else{var s=o.height/2;e=Math.min(o.x,o.base),i=Math.max(o.x,o.base),n=o.y-s,a=o.y+s}return{left:e,top:n,right:i,bottom:a}}n._set("global",{elements:{rectangle:{backgroundColor:n.global.defaultColor,borderColor:n.global.defaultColor,borderSkipped:"bottom",borderWidth:0}}}),e.exports=a.extend({draw:function(){var t,e,i,n,a,o,r,s=this._chart.ctx,l=this._view,u=l.borderWidth;if(r=l.horizontal?(t=l.base,e=l.x,i=l.y-l.height/2,n=l.y+l.height/2,a=t<e?1:-1,o=1,l.borderSkipped||"left"):(t=l.x-l.width/2,e=l.x+l.width/2,a=1,o=(i=l.y)<(n=l.base)?1:-1,l.borderSkipped||"bottom"),u){var d=Math.min(Math.abs(t-e),Math.abs(i-n)),c=(u=d<u?d:u)/2,h=t+("left"!==r?c*a:0),f=e+("right"!==r?-c*a:0),g=i+("top"!==r?c*o:0),p=n+("bottom"!==r?-c*o:0);h!==f&&(i=g,n=p),g!==p&&(t=h,e=f)}s.beginPath(),s.fillStyle=l.backgroundColor,s.strokeStyle=l.borderColor,s.lineWidth=u;var m=[[t,n],[t,i],[e,i],[e,n]],v=["bottom","left","top","right"].indexOf(r,0);function b(t){return m[(v+t)%4]}-1===v&&(v=0);var x=b(0);s.moveTo(x[0],x[1]);for(var y=1;y<4;y++)x=b(y),s.lineTo(x[0],x[1]);s.fill(),u&&s.stroke()},height:function(){var t=this._view;return t.base-t.y},inRange:function(t,e){var i=!1;if(this._view){var n=o(this);i=t>=n.left&&t<=n.right&&e>=n.top&&e<=n.bottom}return i},inLabelRange:function(t,e){if(!this._view)return!1;var i=o(this);return l(this)?t>=i.left&&t<=i.right:e>=i.top&&e<=i.bottom},inXRange:function(t){var e=o(this);return t>=e.left&&t<=e.right},inYRange:function(t){var e=o(this);return t>=e.top&&t<=e.bottom},getCenterPoint:function(){var t,e,i=this._view;return e=l(this)?(t=i.x,(i.y+i.base)/2):(t=(i.x+i.base)/2,i.y),{x:t,y:e}},getArea:function(){var t=this._view;return t.width*Math.abs(t.y-t.base)},tooltipPosition:function(){var t=this._view;return{x:t.x,y:t.y}}})},{26:26,27:27}],41:[function(t,e,i){"use strict";e.exports={},e.exports.Arc=t(37),e.exports.Line=t(38),e.exports.Point=t(39),e.exports.Rectangle=t(40)},{37:37,38:38,39:39,40:40}],42:[function(t,e,i){"use strict";var n=t(43);i=e.exports={clear:function(t){t.ctx.clearRect(0,0,t.width,t.height)},roundedRect:function(t,e,i,n,a,o){if(o){var r=Math.min(o,a/2-1e-7,n/2-1e-7);t.moveTo(e+r,i),t.lineTo(e+n-r,i),t.arcTo(e+n,i,e+n,i+r,r),t.lineTo(e+n,i+a-r),t.arcTo(e+n,i+a,e+n-r,i+a,r),t.lineTo(e+r,i+a),t.arcTo(e,i+a,e,i+a-r,r),t.lineTo(e,i+r),t.arcTo(e,i,e+r,i,r),t.closePath(),t.moveTo(e,i)}else t.rect(e,i,n,a)},drawPoint:function(t,e,i,n,a,o){var r,s,l,u,d,c;if(o=o||0,!e||"object"!=typeof e||"[object HTMLImageElement]"!==(r=e.toString())&&"[object HTMLCanvasElement]"!==r){if(!(isNaN(i)||i<=0)){switch(t.save(),t.translate(n,a),t.rotate(o*Math.PI/180),t.beginPath(),e){default:t.arc(0,0,i,0,2*Math.PI),t.closePath();break;case"triangle":d=(s=3*i/Math.sqrt(3))*Math.sqrt(3)/2,t.moveTo(-s/2,d/3),t.lineTo(s/2,d/3),t.lineTo(0,-2*d/3),t.closePath();break;case"rect":c=1/Math.SQRT2*i,t.rect(-c,-c,2*c,2*c);break;case"rectRounded":var h=i/Math.SQRT2,f=-h,g=-h,p=Math.SQRT2*i;this.roundedRect(t,f,g,p,p,.425*i);break;case"rectRot":c=1/Math.SQRT2*i,t.moveTo(-c,0),t.lineTo(0,c),t.lineTo(c,0),t.lineTo(0,-c),t.closePath();break;case"cross":t.moveTo(0,i),t.lineTo(0,-i),t.moveTo(-i,0),t.lineTo(i,0);break;case"crossRot":l=Math.cos(Math.PI/4)*i,u=Math.sin(Math.PI/4)*i,t.moveTo(-l,-u),t.lineTo(l,u),t.moveTo(-l,u),t.lineTo(l,-u);break;case"star":t.moveTo(0,i),t.lineTo(0,-i),t.moveTo(-i,0),t.lineTo(i,0),l=Math.cos(Math.PI/4)*i,u=Math.sin(Math.PI/4)*i,t.moveTo(-l,-u),t.lineTo(l,u),t.moveTo(-l,u),t.lineTo(l,-u);break;case"line":t.moveTo(-i,0),t.lineTo(i,0);break;case"dash":t.moveTo(0,0),t.lineTo(i,0)}t.fill(),t.stroke(),t.restore()}}else t.drawImage(e,n-e.width/2,a-e.height/2,e.width,e.height)},clipArea:function(t,e){t.save(),t.beginPath(),t.rect(e.left,e.top,e.right-e.left,e.bottom-e.top),t.clip()},unclipArea:function(t){t.restore()},lineTo:function(t,e,i,n){if(i.steppedLine)return"after"===i.steppedLine&&!n||"after"!==i.steppedLine&&n?t.lineTo(e.x,i.y):t.lineTo(i.x,e.y),void t.lineTo(i.x,i.y);i.tension?t.bezierCurveTo(n?e.controlPointPreviousX:e.controlPointNextX,n?e.controlPointPreviousY:e.controlPointNextY,n?i.controlPointNextX:i.controlPointPreviousX,n?i.controlPointNextY:i.controlPointPreviousY,i.x,i.y):t.lineTo(i.x,i.y)}};n.clear=i.clear,n.drawRoundedRectangle=function(t){t.beginPath(),i.roundedRect.apply(i,arguments)}},{43:43}],43:[function(t,e,i){"use strict";var n,d={noop:function(){},uid:(n=0,function(){return n++}),isNullOrUndef:function(t){return null==t},isArray:Array.isArray?Array.isArray:function(t){return"[object Array]"===Object.prototype.toString.call(t)},isObject:function(t){return null!==t&&"[object Object]"===Object.prototype.toString.call(t)},valueOrDefault:function(t,e){return void 0===t?e:t},valueAtIndexOrDefault:function(t,e,i){return d.valueOrDefault(d.isArray(t)?t[e]:t,i)},callback:function(t,e,i){if(t&&"function"==typeof t.call)return t.apply(i,e)},each:function(t,e,i,n){var a,o,r;if(d.isArray(t))if(o=t.length,n)for(a=o-1;0<=a;a--)e.call(i,t[a],a);else for(a=0;a<o;a++)e.call(i,t[a],a);else if(d.isObject(t))for(o=(r=Object.keys(t)).length,a=0;a<o;a++)e.call(i,t[r[a]],r[a])},arrayEquals:function(t,e){var i,n,a,o;if(!t||!e||t.length!==e.length)return!1;for(i=0,n=t.length;i<n;++i)if(a=t[i],o=e[i],a instanceof Array&&o instanceof Array){if(!d.arrayEquals(a,o))return!1}else if(a!==o)return!1;return!0},clone:function(t){if(d.isArray(t))return t.map(d.clone);if(d.isObject(t)){for(var e={},i=Object.keys(t),n=i.length,a=0;a<n;++a)e[i[a]]=d.clone(t[i[a]]);return e}return t},_merger:function(t,e,i,n){var a=e[t],o=i[t];d.isObject(a)&&d.isObject(o)?d.merge(a,o,n):e[t]=d.clone(o)},_mergerIf:function(t,e,i){var n=e[t],a=i[t];d.isObject(n)&&d.isObject(a)?d.mergeIf(n,a):e.hasOwnProperty(t)||(e[t]=d.clone(a))},merge:function(t,e,i){var n,a,o,r,s,l=d.isArray(e)?e:[e],u=l.length;if(!d.isObject(t))return t;for(n=(i=i||{}).merger||d._merger,a=0;a<u;++a)if(e=l[a],d.isObject(e))for(s=0,r=(o=Object.keys(e)).length;s<r;++s)n(o[s],t,e,i);return t},mergeIf:function(t,e){return d.merge(t,e,{merger:d._mergerIf})},extend:function(i){for(var t=function(t,e){i[e]=t},e=1,n=arguments.length;e<n;++e)d.each(arguments[e],t);return i},inherits:function(t){var e=this,i=t&&t.hasOwnProperty("constructor")?t.constructor:function(){return e.apply(this,arguments)},n=function(){this.constructor=i};return n.prototype=e.prototype,i.prototype=new n,i.extend=d.inherits,t&&d.extend(i.prototype,t),i.__super__=e.prototype,i}};(e.exports=d).callCallback=d.callback,d.indexOf=function(t,e,i){return Array.prototype.indexOf.call(t,e,i)},d.getValueOrDefault=d.valueOrDefault,d.getValueAtIndexOrDefault=d.valueAtIndexOrDefault},{}],44:[function(t,e,i){"use strict";var n=t(43),a={linear:function(t){return t},easeInQuad:function(t){return t*t},easeOutQuad:function(t){return-t*(t-2)},easeInOutQuad:function(t){return(t/=.5)<1?.5*t*t:-.5*(--t*(t-2)-1)},easeInCubic:function(t){return t*t*t},easeOutCubic:function(t){return(t-=1)*t*t+1},easeInOutCubic:function(t){return(t/=.5)<1?.5*t*t*t:.5*((t-=2)*t*t+2)},easeInQuart:function(t){return t*t*t*t},easeOutQuart:function(t){return-((t-=1)*t*t*t-1)},easeInOutQuart:function(t){return(t/=.5)<1?.5*t*t*t*t:-.5*((t-=2)*t*t*t-2)},easeInQuint:function(t){return t*t*t*t*t},easeOutQuint:function(t){return(t-=1)*t*t*t*t+1},easeInOutQuint:function(t){return(t/=.5)<1?.5*t*t*t*t*t:.5*((t-=2)*t*t*t*t+2)},easeInSine:function(t){return 1-Math.cos(t*(Math.PI/2))},easeOutSine:function(t){return Math.sin(t*(Math.PI/2))},easeInOutSine:function(t){return-.5*(Math.cos(Math.PI*t)-1)},easeInExpo:function(t){return 0===t?0:Math.pow(2,10*(t-1))},easeOutExpo:function(t){return 1===t?1:1-Math.pow(2,-10*t)},easeInOutExpo:function(t){return 0===t?0:1===t?1:(t/=.5)<1?.5*Math.pow(2,10*(t-1)):.5*(2-Math.pow(2,-10*--t))},easeInCirc:function(t){return 1<=t?t:-(Math.sqrt(1-t*t)-1)},easeOutCirc:function(t){return Math.sqrt(1-(t-=1)*t)},easeInOutCirc:function(t){return(t/=.5)<1?-.5*(Math.sqrt(1-t*t)-1):.5*(Math.sqrt(1-(t-=2)*t)+1)},easeInElastic:function(t){var e=1.70158,i=0,n=1;return 0===t?0:1===t?1:(i||(i=.3),e=n<1?(n=1,i/4):i/(2*Math.PI)*Math.asin(1/n),-n*Math.pow(2,10*(t-=1))*Math.sin((t-e)*(2*Math.PI)/i))},easeOutElastic:function(t){var e=1.70158,i=0,n=1;return 0===t?0:1===t?1:(i||(i=.3),e=n<1?(n=1,i/4):i/(2*Math.PI)*Math.asin(1/n),n*Math.pow(2,-10*t)*Math.sin((t-e)*(2*Math.PI)/i)+1)},easeInOutElastic:function(t){var e=1.70158,i=0,n=1;return 0===t?0:2==(t/=.5)?1:(i||(i=.45),e=n<1?(n=1,i/4):i/(2*Math.PI)*Math.asin(1/n),t<1?n*Math.pow(2,10*(t-=1))*Math.sin((t-e)*(2*Math.PI)/i)*-.5:n*Math.pow(2,-10*(t-=1))*Math.sin((t-e)*(2*Math.PI)/i)*.5+1)},easeInBack:function(t){return t*t*(2.70158*t-1.70158)},easeOutBack:function(t){return(t-=1)*t*(2.70158*t+1.70158)+1},easeInOutBack:function(t){var e=1.70158;return(t/=.5)<1?t*t*((1+(e*=1.525))*t-e)*.5:.5*((t-=2)*t*((1+(e*=1.525))*t+e)+2)},easeInBounce:function(t){return 1-a.easeOutBounce(1-t)},easeOutBounce:function(t){return t<1/2.75?7.5625*t*t:t<2/2.75?7.5625*(t-=1.5/2.75)*t+.75:t<2.5/2.75?7.5625*(t-=2.25/2.75)*t+.9375:7.5625*(t-=2.625/2.75)*t+.984375},easeInOutBounce:function(t){return t<.5?.5*a.easeInBounce(2*t):.5*a.easeOutBounce(2*t-1)+.5}};e.exports={effects:a},n.easingEffects=a},{43:43}],45:[function(t,e,i){"use strict";var r=t(43);e.exports={toLineHeight:function(t,e){var i=(""+t).match(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);if(!i||"normal"===i[1])return 1.2*e;switch(t=+i[2],i[3]){case"px":return t;case"%":t/=100}return e*t},toPadding:function(t){var e,i,n,a;return r.isObject(t)?(e=+t.top||0,i=+t.right||0,n=+t.bottom||0,a=+t.left||0):e=i=n=a=+t||0,{top:e,right:i,bottom:n,left:a,height:e+n,width:a+i}},resolve:function(t,e,i){var n,a,o;for(n=0,a=t.length;n<a;++n)if(void 0!==(o=t[n])&&(void 0!==e&&"function"==typeof o&&(o=o(e)),void 0!==i&&r.isArray(o)&&(o=o[i]),void 0!==o))return o}}},{43:43}],46:[function(t,e,i){"use strict";e.exports=t(43),e.exports.easing=t(44),e.exports.canvas=t(42),e.exports.options=t(45)},{42:42,43:43,44:44,45:45}],47:[function(t,e,i){e.exports={acquireContext:function(t){return t&&t.canvas&&(t=t.canvas),t&&t.getContext("2d")||null}}},{}],48:[function(t,e,i){"use strict";var f=t(46),g="$chartjs",p="chartjs-",m=p+"render-monitor",v=p+"render-animation",b=["animationstart","webkitAnimationStart"],s={touchstart:"mousedown",touchmove:"mousemove",touchend:"mouseup",pointerenter:"mouseenter",pointerdown:"mousedown",pointermove:"mousemove",pointerup:"mouseup",pointerleave:"mouseout",pointerout:"mouseout"};function l(t,e){var i=f.getStyle(t,e),n=i&&i.match(/^(\d+)(\.\d+)?px$/);return n?Number(n[1]):void 0}var n=!!function(){var t=!1;try{var e=Object.defineProperty({},"passive",{get:function(){t=!0}});window.addEventListener("e",null,e)}catch(t){}return t}()&&{passive:!0};function x(t,e,i){t.addEventListener(e,i,n)}function r(t,e,i){t.removeEventListener(e,i,n)}function y(t,e,i,n,a){return{type:t,chart:e,native:a||null,x:void 0!==i?i:null,y:void 0!==n?n:null}}function a(e,t,i){var n,a,o,r,s,l,u,d,c=e[g]||(e[g]={}),h=c.resizer=function(t){var e=document.createElement("div"),i=p+"size-monitor",n="position:absolute;left:0;top:0;right:0;bottom:0;overflow:hidden;pointer-events:none;visibility:hidden;z-index:-1;";e.style.cssText=n,e.className=i,e.innerHTML='<div class="'+i+'-expand" style="'+n+'"><div style="position:absolute;width:1000000px;height:1000000px;left:0;top:0"></div></div><div class="'+i+'-shrink" style="'+n+'"><div style="position:absolute;width:200%;height:200%;left:0; top:0"></div></div>';var a=e.childNodes[0],o=e.childNodes[1];e._reset=function(){a.scrollLeft=1e6,a.scrollTop=1e6,o.scrollLeft=1e6,o.scrollTop=1e6};var r=function(){e._reset(),t()};return x(a,"scroll",r.bind(a,"expand")),x(o,"scroll",r.bind(o,"shrink")),e}((o=!(n=function(){if(c.resizer)return t(y("resize",i))}),r=[],function(){r=Array.prototype.slice.call(arguments),a=a||this,o||(o=!0,f.requestAnimFrame.call(window,function(){o=!1,n.apply(a,r)}))}));l=function(){if(c.resizer){var t=e.parentNode;t&&t!==h.parentNode&&t.insertBefore(h,t.firstChild),h._reset()}},u=(s=e)[g]||(s[g]={}),d=u.renderProxy=function(t){t.animationName===v&&l()},f.each(b,function(t){x(s,t,d)}),u.reflow=!!s.offsetParent,s.classList.add(m)}function o(t){var e,i,n,a=t[g]||{},o=a.resizer;delete a.resizer,i=(e=t)[g]||{},(n=i.renderProxy)&&(f.each(b,function(t){r(e,t,n)}),delete i.renderProxy),e.classList.remove(m),o&&o.parentNode&&o.parentNode.removeChild(o)}e.exports={_enabled:"undefined"!=typeof window&&"undefined"!=typeof document,initialize:function(){var t,e,i,n="from{opacity:0.99}to{opacity:1}";e="@-webkit-keyframes "+v+"{"+n+"}@keyframes "+v+"{"+n+"}."+m+"{-webkit-animation:"+v+" 0.001s;animation:"+v+" 0.001s;}",i=(t=this)._style||document.createElement("style"),t._style||(e="/* Chart.js */\n"+e,(t._style=i).setAttribute("type","text/css"),document.getElementsByTagName("head")[0].appendChild(i)),i.appendChild(document.createTextNode(e))},acquireContext:function(t,e){"string"==typeof t?t=document.getElementById(t):t.length&&(t=t[0]),t&&t.canvas&&(t=t.canvas);var i=t&&t.getContext&&t.getContext("2d");return i&&i.canvas===t?(function(t,e){var i=t.style,n=t.getAttribute("height"),a=t.getAttribute("width");if(t[g]={initial:{height:n,width:a,style:{display:i.display,height:i.height,width:i.width}}},i.display=i.display||"block",null===a||""===a){var o=l(t,"width");void 0!==o&&(t.width=o)}if(null===n||""===n)if(""===t.style.height)t.height=t.width/(e.options.aspectRatio||2);else{var r=l(t,"height");void 0!==o&&(t.height=r)}}(t,e),i):null},releaseContext:function(t){var i=t.canvas;if(i[g]){var n=i[g].initial;["height","width"].forEach(function(t){var e=n[t];f.isNullOrUndef(e)?i.removeAttribute(t):i.setAttribute(t,e)}),f.each(n.style||{},function(t,e){i.style[e]=t}),i.width=i.width,delete i[g]}},addEventListener:function(o,t,r){var e=o.canvas;if("resize"!==t){var i=r[g]||(r[g]={});x(e,t,(i.proxies||(i.proxies={}))[o.id+"_"+t]=function(t){var e,i,n,a;r((i=o,n=s[(e=t).type]||e.type,a=f.getRelativePosition(e,i),y(n,i,a.x,a.y,e)))})}else a(e,r,o)},removeEventListener:function(t,e,i){var n=t.canvas;if("resize"!==e){var a=((i[g]||{}).proxies||{})[t.id+"_"+e];a&&r(n,e,a)}else o(n)}},f.addEvent=x,f.removeEvent=r},{46:46}],49:[function(t,e,i){"use strict";var n=t(46),a=t(47),o=t(48),r=o._enabled?o:a;e.exports=n.extend({initialize:function(){},acquireContext:function(){},releaseContext:function(){},addEventListener:function(){},removeEventListener:function(){}},r)},{46:46,47:47,48:48}],50:[function(t,e,i){"use strict";e.exports={},e.exports.filler=t(51),e.exports.legend=t(52),e.exports.title=t(53)},{51:51,52:52,53:53}],51:[function(t,e,i){"use strict";var u=t(26),h=t(41),d=t(46);u._set("global",{plugins:{filler:{propagate:!0}}});var f={dataset:function(t){var e=t.fill,i=t.chart,n=i.getDatasetMeta(e),a=n&&i.isDatasetVisible(e)&&n.dataset._children||[],o=a.length||0;return o?function(t,e){return e<o&&a[e]._view||null}:null},boundary:function(t){var e=t.boundary,i=e?e.x:null,n=e?e.y:null;return function(t){return{x:null===i?t.x:i,y:null===n?t.y:n}}}};function g(t,e,i){var n,a=t._model||{},o=a.fill;if(void 0===o&&(o=!!a.backgroundColor),!1===o||null===o)return!1;if(!0===o)return"origin";if(n=parseFloat(o,10),isFinite(n)&&Math.floor(n)===n)return"-"!==o[0]&&"+"!==o[0]||(n=e+n),!(n===e||n<0||i<=n)&&n;switch(o){case"bottom":return"start";case"top":return"end";case"zero":return"origin";case"origin":case"start":case"end":return o;default:return!1}}function p(t){var e,i=t.el._model||{},n=t.el._scale||{},a=t.fill,o=null;if(isFinite(a))return null;if("start"===a?o=void 0===i.scaleBottom?n.bottom:i.scaleBottom:"end"===a?o=void 0===i.scaleTop?n.top:i.scaleTop:void 0!==i.scaleZero?o=i.scaleZero:n.getBasePosition?o=n.getBasePosition():n.getBasePixel&&(o=n.getBasePixel()),null!=o){if(void 0!==o.x&&void 0!==o.y)return o;if("number"==typeof o&&isFinite(o))return{x:(e=n.isHorizontal())?o:null,y:e?null:o}}return null}function m(t,e,i){var n,a=t[e].fill,o=[e];if(!i)return a;for(;!1!==a&&-1===o.indexOf(a);){if(!isFinite(a))return a;if(!(n=t[a]))return!1;if(n.visible)return a;o.push(a),a=n.fill}return!1}function x(t){return t&&!t.skip}function y(t,e,i,n,a){var o;if(n&&a){for(t.moveTo(e[0].x,e[0].y),o=1;o<n;++o)d.canvas.lineTo(t,e[o-1],e[o]);for(t.lineTo(i[a-1].x,i[a-1].y),o=a-1;0<o;--o)d.canvas.lineTo(t,i[o],i[o-1],!0)}}e.exports={id:"filler",afterDatasetsUpdate:function(t,e){var i,n,a,o,r,s,l,u=(t.data.datasets||[]).length,d=e.propagate,c=[];for(n=0;n<u;++n)o=null,(a=(i=t.getDatasetMeta(n)).dataset)&&a._model&&a instanceof h.Line&&(o={visible:t.isDatasetVisible(n),fill:g(a,n,u),chart:t,el:a}),i.$filler=o,c.push(o);for(n=0;n<u;++n)(o=c[n])&&(o.fill=m(c,n,d),o.boundary=p(o),o.mapper=(l=void 0,s=(r=o).fill,!(l="dataset")===s?null:(isFinite(s)||(l="boundary"),f[l](r))))},beforeDatasetDraw:function(t,e){var i=e.meta.$filler;if(i){var n=t.ctx,a=i.el,o=a._view,r=a._children||[],s=i.mapper,l=o.backgroundColor||u.global.defaultColor;s&&l&&r.length&&(d.canvas.clipArea(n,t.chartArea),function(t,e,i,n,a,o){var r,s,l,u,d,c,h,f=e.length,g=n.spanGaps,p=[],m=[],v=0,b=0;for(t.beginPath(),r=0,s=f+!!o;r<s;++r)d=i(u=e[l=r%f]._view,l,n),c=x(u),h=x(d),c&&h?(v=p.push(u),b=m.push(d)):v&&b&&(g?(c&&p.push(u),h&&m.push(d)):(y(t,p,m,v,b),v=b=0,p=[],m=[]));y(t,p,m,v,b),t.closePath(),t.fillStyle=a,t.fill()}(n,r,s,o,l,a._loop),d.canvas.unclipArea(n))}}}},{26:26,41:41,46:46}],52:[function(t,e,i){"use strict";var _=t(26),n=t(27),D=t(46),a=t(31),o=D.noop;function P(t,e){return t.usePointStyle?e*Math.SQRT2:t.boxWidth}_._set("global",{legend:{display:!0,position:"top",fullWidth:!0,reverse:!1,weight:1e3,onClick:function(t,e){var i=e.datasetIndex,n=this.chart,a=n.getDatasetMeta(i);a.hidden=null===a.hidden?!n.data.datasets[i].hidden:null,n.update()},onHover:null,labels:{boxWidth:40,padding:10,generateLabels:function(i){var t=i.data;return D.isArray(t.datasets)?t.datasets.map(function(t,e){return{text:t.label,fillStyle:D.isArray(t.backgroundColor)?t.backgroundColor[0]:t.backgroundColor,hidden:!i.isDatasetVisible(e),lineCap:t.borderCapStyle,lineDash:t.borderDash,lineDashOffset:t.borderDashOffset,lineJoin:t.borderJoinStyle,lineWidth:t.borderWidth,strokeStyle:t.borderColor,pointStyle:t.pointStyle,datasetIndex:e}},this):[]}}},legendCallback:function(t){var e=[];e.push('<ul class="'+t.id+'-legend">');for(var i=0;i<t.data.datasets.length;i++)e.push('<li><span style="background-color:'+t.data.datasets[i].backgroundColor+'"></span>'),t.data.datasets[i].label&&e.push(t.data.datasets[i].label),e.push("</li>");return e.push("</ul>"),e.join("")}});var r=n.extend({initialize:function(t){D.extend(this,t),this.legendHitBoxes=[],this.doughnutMode=!1},beforeUpdate:o,update:function(t,e,i){var n=this;return n.beforeUpdate(),n.maxWidth=t,n.maxHeight=e,n.margins=i,n.beforeSetDimensions(),n.setDimensions(),n.afterSetDimensions(),n.beforeBuildLabels(),n.buildLabels(),n.afterBuildLabels(),n.beforeFit(),n.fit(),n.afterFit(),n.afterUpdate(),n.minSize},afterUpdate:o,beforeSetDimensions:o,setDimensions:function(){var t=this;t.isHorizontal()?(t.width=t.maxWidth,t.left=0,t.right=t.width):(t.height=t.maxHeight,t.top=0,t.bottom=t.height),t.paddingLeft=0,t.paddingTop=0,t.paddingRight=0,t.paddingBottom=0,t.minSize={width:0,height:0}},afterSetDimensions:o,beforeBuildLabels:o,buildLabels:function(){var e=this,i=e.options.labels||{},t=D.callback(i.generateLabels,[e.chart],e)||[];i.filter&&(t=t.filter(function(t){return i.filter(t,e.chart.data)})),e.options.reverse&&t.reverse(),e.legendItems=t},afterBuildLabels:o,beforeFit:o,fit:function(){var n=this,t=n.options,a=t.labels,e=t.display,o=n.ctx,i=_.global,r=D.valueOrDefault,s=r(a.fontSize,i.defaultFontSize),l=r(a.fontStyle,i.defaultFontStyle),u=r(a.fontFamily,i.defaultFontFamily),d=D.fontString(s,l,u),c=n.legendHitBoxes=[],h=n.minSize,f=n.isHorizontal();if(h.height=f?(h.width=n.maxWidth,e?10:0):(h.width=e?10:0,n.maxHeight),e)if(o.font=d,f){var g=n.lineWidths=[0],p=n.legendItems.length?s+a.padding:0;o.textAlign="left",o.textBaseline="top",D.each(n.legendItems,function(t,e){var i=P(a,s)+s/2+o.measureText(t.text).width;g[g.length-1]+i+a.padding>=n.width&&(p+=s+a.padding,g[g.length]=n.left),c[e]={left:0,top:0,width:i,height:s},g[g.length-1]+=i+a.padding}),h.height+=p}else{var m=a.padding,v=n.columnWidths=[],b=a.padding,x=0,y=0,k=s+m;D.each(n.legendItems,function(t,e){var i=P(a,s)+s/2+o.measureText(t.text).width;y+k>h.height&&(b+=x+a.padding,v.push(x),y=x=0),x=Math.max(x,i),y+=k,c[e]={left:0,top:0,width:i,height:s}}),b+=x,v.push(x),h.width+=b}n.width=h.width,n.height=h.height},afterFit:o,isHorizontal:function(){return"top"===this.options.position||"bottom"===this.options.position},draw:function(){var c=this,h=c.options,f=h.labels,g=_.global,p=g.elements.line,m=c.width,v=c.lineWidths;if(h.display){var b,x=c.ctx,y=D.valueOrDefault,t=y(f.fontColor,g.defaultFontColor),k=y(f.fontSize,g.defaultFontSize),e=y(f.fontStyle,g.defaultFontStyle),i=y(f.fontFamily,g.defaultFontFamily),n=D.fontString(k,e,i);x.textAlign="left",x.textBaseline="middle",x.lineWidth=.5,x.strokeStyle=t,x.fillStyle=t,x.font=n;var M=P(f,k),w=c.legendHitBoxes,C=c.isHorizontal();b=C?{x:c.left+(m-v[0])/2,y:c.top+f.padding,line:0}:{x:c.left+f.padding,y:c.top+f.padding,line:0};var S=k+f.padding;D.each(c.legendItems,function(t,e){var i,n,a,o,r,s=x.measureText(t.text).width,l=M+k/2+s,u=b.x,d=b.y;C?m<=u+l&&(d=b.y+=S,b.line++,u=b.x=c.left+(m-v[b.line])/2):d+S>c.bottom&&(u=b.x=u+c.columnWidths[b.line]+f.padding,d=b.y=c.top+f.padding,b.line++),function(t,e,i){if(!(isNaN(M)||M<=0)){x.save(),x.fillStyle=y(i.fillStyle,g.defaultColor),x.lineCap=y(i.lineCap,p.borderCapStyle),x.lineDashOffset=y(i.lineDashOffset,p.borderDashOffset),x.lineJoin=y(i.lineJoin,p.borderJoinStyle),x.lineWidth=y(i.lineWidth,p.borderWidth),x.strokeStyle=y(i.strokeStyle,g.defaultColor);var n=0===y(i.lineWidth,p.borderWidth);if(x.setLineDash&&x.setLineDash(y(i.lineDash,p.borderDash)),h.labels&&h.labels.usePointStyle){var a=k*Math.SQRT2/2,o=a/Math.SQRT2,r=t+o,s=e+o;D.canvas.drawPoint(x,i.pointStyle,a,r,s)}else n||x.strokeRect(t,e,M,k),x.fillRect(t,e,M,k);x.restore()}}(u,d,t),w[e].left=u,w[e].top=d,i=t,n=s,o=M+(a=k/2)+u,r=d+a,x.fillText(i.text,o,r),i.hidden&&(x.beginPath(),x.lineWidth=2,x.moveTo(o,r),x.lineTo(o+n,r),x.stroke()),C?b.x+=l+f.padding:b.y+=S})}},handleEvent:function(t){var e=this,i=e.options,n="mouseup"===t.type?"click":t.type,a=!1;if("mousemove"===n){if(!i.onHover)return}else{if("click"!==n)return;if(!i.onClick)return}var o=t.x,r=t.y;if(o>=e.left&&o<=e.right&&r>=e.top&&r<=e.bottom)for(var s=e.legendHitBoxes,l=0;l<s.length;++l){var u=s[l];if(o>=u.left&&o<=u.left+u.width&&r>=u.top&&r<=u.top+u.height){if("click"===n){i.onClick.call(e,t.native,e.legendItems[l]),a=!0;break}if("mousemove"===n){i.onHover.call(e,t.native,e.legendItems[l]),a=!0;break}}}return a}});function s(t,e){var i=new r({ctx:t.ctx,options:e,chart:t});a.configure(t,i,e),a.addBox(t,i),t.legend=i}e.exports={id:"legend",_element:r,beforeInit:function(t){var e=t.options.legend;e&&s(t,e)},beforeUpdate:function(t){var e=t.options.legend,i=t.legend;e?(D.mergeIf(e,_.global.legend),i?(a.configure(t,i,e),i.options=e):s(t,e)):i&&(a.removeBox(t,i),delete t.legend)},afterEvent:function(t,e){var i=t.legend;i&&i.handleEvent(e)}}},{26:26,27:27,31:31,46:46}],53:[function(t,e,i){"use strict";var M=t(26),n=t(27),w=t(46),a=t(31),o=w.noop;M._set("global",{title:{display:!1,fontStyle:"bold",fullWidth:!0,lineHeight:1.2,padding:10,position:"top",text:"",weight:2e3}});var r=n.extend({initialize:function(t){w.extend(this,t),this.legendHitBoxes=[]},beforeUpdate:o,update:function(t,e,i){var n=this;return n.beforeUpdate(),n.maxWidth=t,n.maxHeight=e,n.margins=i,n.beforeSetDimensions(),n.setDimensions(),n.afterSetDimensions(),n.beforeBuildLabels(),n.buildLabels(),n.afterBuildLabels(),n.beforeFit(),n.fit(),n.afterFit(),n.afterUpdate(),n.minSize},afterUpdate:o,beforeSetDimensions:o,setDimensions:function(){var t=this;t.isHorizontal()?(t.width=t.maxWidth,t.left=0,t.right=t.width):(t.height=t.maxHeight,t.top=0,t.bottom=t.height),t.paddingLeft=0,t.paddingTop=0,t.paddingRight=0,t.paddingBottom=0,t.minSize={width:0,height:0}},afterSetDimensions:o,beforeBuildLabels:o,buildLabels:o,afterBuildLabels:o,beforeFit:o,fit:function(){var t=this,e=w.valueOrDefault,i=t.options,n=i.display,a=e(i.fontSize,M.global.defaultFontSize),o=t.minSize,r=w.isArray(i.text)?i.text.length:1,s=w.options.toLineHeight(i.lineHeight,a),l=n?r*s+2*i.padding:0;t.isHorizontal()?(o.width=t.maxWidth,o.height=l):(o.width=l,o.height=t.maxHeight),t.width=o.width,t.height=o.height},afterFit:o,isHorizontal:function(){var t=this.options.position;return"top"===t||"bottom"===t},draw:function(){var t=this,e=t.ctx,i=w.valueOrDefault,n=t.options,a=M.global;if(n.display){var o,r,s,l=i(n.fontSize,a.defaultFontSize),u=i(n.fontStyle,a.defaultFontStyle),d=i(n.fontFamily,a.defaultFontFamily),c=w.fontString(l,u,d),h=w.options.toLineHeight(n.lineHeight,l),f=h/2+n.padding,g=0,p=t.top,m=t.left,v=t.bottom,b=t.right;e.fillStyle=i(n.fontColor,a.defaultFontColor),e.font=c,t.isHorizontal()?(r=m+(b-m)/2,s=p+f,o=b-m):(r="left"===n.position?m+f:b-f,s=p+(v-p)/2,o=v-p,g=Math.PI*("left"===n.position?-.5:.5)),e.save(),e.translate(r,s),e.rotate(g),e.textAlign="center",e.textBaseline="middle";var x=n.text;if(w.isArray(x))for(var y=0,k=0;k<x.length;++k)e.fillText(x[k],0,y,o),y+=h;else e.fillText(x,0,0,o);e.restore()}}});function s(t,e){var i=new r({ctx:t.ctx,options:e,chart:t});a.configure(t,i,e),a.addBox(t,i),t.titleBlock=i}e.exports={id:"title",_element:r,beforeInit:function(t){var e=t.options.title;e&&s(t,e)},beforeUpdate:function(t){var e=t.options.title,i=t.titleBlock;e?(w.mergeIf(e,M.global.title),i?(a.configure(t,i,e),i.options=e):s(t,e)):i&&(a.removeBox(t,i),delete t.titleBlock)}}},{26:26,27:27,31:31,46:46}],54:[function(t,e,i){"use strict";var n=t(33),a=t(34);e.exports=function(){var t=n.extend({getLabels:function(){var t=this.chart.data;return this.options.labels||(this.isHorizontal()?t.xLabels:t.yLabels)||t.labels},determineDataLimits:function(){var t,e=this,i=e.getLabels();e.minIndex=0,e.maxIndex=i.length-1,void 0!==e.options.ticks.min&&(t=i.indexOf(e.options.ticks.min),e.minIndex=-1!==t?t:e.minIndex),void 0!==e.options.ticks.max&&(t=i.indexOf(e.options.ticks.max),e.maxIndex=-1!==t?t:e.maxIndex),e.min=i[e.minIndex],e.max=i[e.maxIndex]},buildTicks:function(){var t=this,e=t.getLabels();t.ticks=0===t.minIndex&&t.maxIndex===e.length-1?e:e.slice(t.minIndex,t.maxIndex+1)},getLabelForIndex:function(t,e){var i=this,n=i.chart.data,a=i.isHorizontal();return n.yLabels&&!a?i.getRightValue(n.datasets[e].data[t]):i.ticks[t-i.minIndex]},getPixelForValue:function(t,e){var i,n=this,a=n.options.offset,o=Math.max(n.maxIndex+1-n.minIndex-(a?0:1),1);if(null!=t&&(i=n.isHorizontal()?t.x:t.y),void 0!==i||void 0!==t&&isNaN(e)){t=i||t;var r=n.getLabels().indexOf(t);e=-1!==r?r:e}if(n.isHorizontal()){var s=n.width/o,l=s*(e-n.minIndex);return a&&(l+=s/2),n.left+Math.round(l)}var u=n.height/o,d=u*(e-n.minIndex);return a&&(d+=u/2),n.top+Math.round(d)},getPixelForTick:function(t){return this.getPixelForValue(this.ticks[t],t+this.minIndex,null)},getValueForPixel:function(t){var e=this,i=e.options.offset,n=Math.max(e._ticks.length-(i?0:1),1),a=e.isHorizontal(),o=(a?e.width:e.height)/n;return t-=a?e.left:e.top,i&&(t-=o/2),(t<=0?0:Math.round(t/o))+e.minIndex},getBasePixel:function(){return this.bottom}});a.registerScaleType("category",t,{position:"bottom"})}},{33:33,34:34}],55:[function(t,e,i){"use strict";var n=t(26),c=t(46),a=t(34),o=t(35);e.exports=function(t){var e={position:"left",ticks:{callback:o.formatters.linear}},i=t.LinearScaleBase.extend({determineDataLimits:function(){var r=this,s=r.options,l=r.chart,t=l.data.datasets,e=r.isHorizontal();function u(t){return e?t.xAxisID===r.id:t.yAxisID===r.id}r.min=null,r.max=null;var n=s.stacked;if(void 0===n&&c.each(t,function(t,e){if(!n){var i=l.getDatasetMeta(e);l.isDatasetVisible(e)&&u(i)&&void 0!==i.stack&&(n=!0)}}),s.stacked||n){var d={};c.each(t,function(t,e){var n=l.getDatasetMeta(e),i=[n.type,void 0===s.stacked&&void 0===n.stack?e:"",n.stack].join(".");void 0===d[i]&&(d[i]={positiveValues:[],negativeValues:[]});var a=d[i].positiveValues,o=d[i].negativeValues;l.isDatasetVisible(e)&&u(n)&&c.each(t.data,function(t,e){var i=+r.getRightValue(t);isNaN(i)||n.data[e].hidden||(a[e]=a[e]||0,o[e]=o[e]||0,s.relativePoints?a[e]=100:i<0?o[e]+=i:a[e]+=i)})}),c.each(d,function(t){var e=t.positiveValues.concat(t.negativeValues),i=c.min(e),n=c.max(e);r.min=null===r.min?i:Math.min(r.min,i),r.max=null===r.max?n:Math.max(r.max,n)})}else c.each(t,function(t,e){var n=l.getDatasetMeta(e);l.isDatasetVisible(e)&&u(n)&&c.each(t.data,function(t,e){var i=+r.getRightValue(t);isNaN(i)||n.data[e].hidden||(null===r.min?r.min=i:i<r.min&&(r.min=i),null===r.max?r.max=i:i>r.max&&(r.max=i))})});r.min=isFinite(r.min)&&!isNaN(r.min)?r.min:0,r.max=isFinite(r.max)&&!isNaN(r.max)?r.max:1,this.handleTickRangeOptions()},getTickLimit:function(){var t,e=this.options.ticks;if(this.isHorizontal())t=Math.min(e.maxTicksLimit?e.maxTicksLimit:11,Math.ceil(this.width/50));else{var i=c.valueOrDefault(e.fontSize,n.global.defaultFontSize);t=Math.min(e.maxTicksLimit?e.maxTicksLimit:11,Math.ceil(this.height/(2*i)))}return t},handleDirectionalChanges:function(){this.isHorizontal()||this.ticks.reverse()},getLabelForIndex:function(t,e){return+this.getRightValue(this.chart.data.datasets[e].data[t])},getPixelForValue:function(t){var e=this,i=e.start,n=+e.getRightValue(t),a=e.end-i;return e.isHorizontal()?e.left+e.width/a*(n-i):e.bottom-e.height/a*(n-i)},getValueForPixel:function(t){var e=this,i=e.isHorizontal(),n=i?e.width:e.height,a=(i?t-e.left:e.bottom-t)/n;return e.start+(e.end-e.start)*a},getPixelForTick:function(t){return this.getPixelForValue(this.ticksAsNumbers[t])}});a.registerScaleType("linear",i,e)}},{26:26,34:34,35:35,46:46}],56:[function(t,e,i){"use strict";var c=t(46),n=t(33);e.exports=function(t){var e=c.noop;t.LinearScaleBase=n.extend({getRightValue:function(t){return"string"==typeof t?+t:n.prototype.getRightValue.call(this,t)},handleTickRangeOptions:function(){var t=this,e=t.options.ticks;if(e.beginAtZero){var i=c.sign(t.min),n=c.sign(t.max);i<0&&n<0?t.max=0:0<i&&0<n&&(t.min=0)}var a=void 0!==e.min||void 0!==e.suggestedMin,o=void 0!==e.max||void 0!==e.suggestedMax;void 0!==e.min?t.min=e.min:void 0!==e.suggestedMin&&(null===t.min?t.min=e.suggestedMin:t.min=Math.min(t.min,e.suggestedMin)),void 0!==e.max?t.max=e.max:void 0!==e.suggestedMax&&(null===t.max?t.max=e.suggestedMax:t.max=Math.max(t.max,e.suggestedMax)),a!==o&&t.min>=t.max&&(a?t.max=t.min+1:t.min=t.max-1),t.min===t.max&&(t.max++,e.beginAtZero||t.min--)},getTickLimit:e,handleDirectionalChanges:e,buildTicks:function(){var t=this,e=t.options.ticks,i=t.getTickLimit(),n={maxTicks:i=Math.max(2,i),min:e.min,max:e.max,precision:e.precision,stepSize:c.valueOrDefault(e.fixedStepSize,e.stepSize)},a=t.ticks=function(t,e){var i,n,a,o=[];if(t.stepSize&&0<t.stepSize)a=t.stepSize;else{var r=c.niceNum(e.max-e.min,!1);a=c.niceNum(r/(t.maxTicks-1),!0),void 0!==(n=t.precision)&&(i=Math.pow(10,n),a=Math.ceil(a*i)/i)}var s=Math.floor(e.min/a)*a,l=Math.ceil(e.max/a)*a;c.isNullOrUndef(t.min)||c.isNullOrUndef(t.max)||!t.stepSize||c.almostWhole((t.max-t.min)/t.stepSize,a/1e3)&&(s=t.min,l=t.max);var u=(l-s)/a;u=c.almostEquals(u,Math.round(u),a/1e3)?Math.round(u):Math.ceil(u),a<(n=1)&&(n=Math.pow(10,1-Math.floor(c.log10(a))),s=Math.round(s*n)/n,l=Math.round(l*n)/n),o.push(void 0!==t.min?t.min:s);for(var d=1;d<u;++d)o.push(Math.round((s+d*a)*n)/n);return o.push(void 0!==t.max?t.max:l),o}(n,t);t.handleDirectionalChanges(),t.max=c.max(a),t.min=c.min(a),e.reverse?(a.reverse(),t.start=t.max,t.end=t.min):(t.start=t.min,t.end=t.max)},convertTicksToLabels:function(){var t=this;t.ticksAsNumbers=t.ticks.slice(),t.zeroLineIndex=t.ticks.indexOf(0),n.prototype.convertTicksToLabels.call(t)}})}},{33:33,46:46}],57:[function(t,e,i){"use strict";var h=t(46),n=t(33),a=t(34),o=t(35);e.exports=function(c){var t={position:"left",ticks:{callback:o.formatters.logarithmic}},e=n.extend({determineDataLimits:function(){var r=this,i=r.options,s=r.chart,t=s.data.datasets,e=r.isHorizontal();function l(t){return e?t.xAxisID===r.id:t.yAxisID===r.id}r.min=null,r.max=null,r.minNotZero=null;var n=i.stacked;if(void 0===n&&h.each(t,function(t,e){if(!n){var i=s.getDatasetMeta(e);s.isDatasetVisible(e)&&l(i)&&void 0!==i.stack&&(n=!0)}}),i.stacked||n){var u={};h.each(t,function(t,e){var a=s.getDatasetMeta(e),o=[a.type,void 0===i.stacked&&void 0===a.stack?e:"",a.stack].join(".");s.isDatasetVisible(e)&&l(a)&&(void 0===u[o]&&(u[o]=[]),h.each(t.data,function(t,e){var i=u[o],n=+r.getRightValue(t);isNaN(n)||a.data[e].hidden||n<0||(i[e]=i[e]||0,i[e]+=n)}))}),h.each(u,function(t){if(0<t.length){var e=h.min(t),i=h.max(t);r.min=null===r.min?e:Math.min(r.min,e),r.max=null===r.max?i:Math.max(r.max,i)}})}else h.each(t,function(t,e){var n=s.getDatasetMeta(e);s.isDatasetVisible(e)&&l(n)&&h.each(t.data,function(t,e){var i=+r.getRightValue(t);isNaN(i)||n.data[e].hidden||i<0||(null===r.min?r.min=i:i<r.min&&(r.min=i),null===r.max?r.max=i:i>r.max&&(r.max=i),0!==i&&(null===r.minNotZero||i<r.minNotZero)&&(r.minNotZero=i))})});this.handleTickRangeOptions()},handleTickRangeOptions:function(){var t=this,e=t.options.ticks,i=h.valueOrDefault;t.min=i(e.min,t.min),t.max=i(e.max,t.max),t.min===t.max&&(0!==t.min&&null!==t.min?(t.min=Math.pow(10,Math.floor(h.log10(t.min))-1),t.max=Math.pow(10,Math.floor(h.log10(t.max))+1)):(t.min=1,t.max=10)),null===t.min&&(t.min=Math.pow(10,Math.floor(h.log10(t.max))-1)),null===t.max&&(t.max=0!==t.min?Math.pow(10,Math.floor(h.log10(t.min))+1):10),null===t.minNotZero&&(0<t.min?t.minNotZero=t.min:t.max<1?t.minNotZero=Math.pow(10,Math.floor(h.log10(t.max))):t.minNotZero=1)},buildTicks:function(){var t=this,e=t.options.ticks,i=!t.isHorizontal(),n={min:e.min,max:e.max},a=t.ticks=function(t,e){var i,n,a=[],o=h.valueOrDefault,r=o(t.min,Math.pow(10,Math.floor(h.log10(e.min)))),s=Math.floor(h.log10(e.max)),l=Math.ceil(e.max/Math.pow(10,s));0===r?(i=Math.floor(h.log10(e.minNotZero)),n=Math.floor(e.minNotZero/Math.pow(10,i)),a.push(r),r=n*Math.pow(10,i)):(i=Math.floor(h.log10(r)),n=Math.floor(r/Math.pow(10,i)));for(var u=i<0?Math.pow(10,Math.abs(i)):1;a.push(r),10==++n&&(n=1,u=0<=++i?1:u),r=Math.round(n*Math.pow(10,i)*u)/u,i<s||i===s&&n<l;);var d=o(t.max,r);return a.push(d),a}(n,t);t.max=h.max(a),t.min=h.min(a),e.reverse?(i=!i,t.start=t.max,t.end=t.min):(t.start=t.min,t.end=t.max),i&&a.reverse()},convertTicksToLabels:function(){this.tickValues=this.ticks.slice(),n.prototype.convertTicksToLabels.call(this)},getLabelForIndex:function(t,e){return+this.getRightValue(this.chart.data.datasets[e].data[t])},getPixelForTick:function(t){return this.getPixelForValue(this.tickValues[t])},_getFirstTickValue:function(t){var e=Math.floor(h.log10(t));return Math.floor(t/Math.pow(10,e))*Math.pow(10,e)},getPixelForValue:function(t){var e,i,n,a,o,r=this,s=r.options.ticks.reverse,l=h.log10,u=r._getFirstTickValue(r.minNotZero),d=0;return t=+r.getRightValue(t),o=s?(n=r.end,a=r.start,-1):(n=r.start,a=r.end,1),i=r.isHorizontal()?(e=r.width,s?r.right:r.left):(e=r.height,o*=-1,s?r.top:r.bottom),t!==n&&(0===n&&(e-=d=h.getValueOrDefault(r.options.ticks.fontSize,c.defaults.global.defaultFontSize),n=u),0!==t&&(d+=e/(l(a)-l(n))*(l(t)-l(n))),i+=o*d),i},getValueForPixel:function(t){var e,i,n,a,o=this,r=o.options.ticks.reverse,s=h.log10,l=o._getFirstTickValue(o.minNotZero);if(n=r?(i=o.end,o.start):(i=o.start,o.end),(a=o.isHorizontal()?(e=o.width,r?o.right-t:t-o.left):(e=o.height,r?t-o.top:o.bottom-t))!==i){if(0===i){var u=h.getValueOrDefault(o.options.ticks.fontSize,c.defaults.global.defaultFontSize);a-=u,e-=u,i=l}a*=s(n)-s(i),a/=e,a=Math.pow(10,s(i)+a)}return a}});a.registerScaleType("logarithmic",e,t)}},{33:33,34:34,35:35,46:46}],58:[function(t,e,i){"use strict";var n=t(26),k=t(46),a=t(34),o=t(35);e.exports=function(e){var v=n.global,t={display:!0,animate:!0,position:"chartArea",angleLines:{display:!0,color:"rgba(0, 0, 0, 0.1)",lineWidth:1},gridLines:{circular:!1},ticks:{showLabelBackdrop:!0,backdropColor:"rgba(255,255,255,0.75)",backdropPaddingY:2,backdropPaddingX:2,callback:o.formatters.linear},pointLabels:{display:!0,fontSize:10,callback:function(t){return t}}};function b(t){var e=t.options;return e.angleLines.display||e.pointLabels.display?t.chart.data.labels.length:0}function x(t){var e=t.options.pointLabels,i=k.valueOrDefault(e.fontSize,v.defaultFontSize),n=k.valueOrDefault(e.fontStyle,v.defaultFontStyle),a=k.valueOrDefault(e.fontFamily,v.defaultFontFamily);return{size:i,style:n,family:a,font:k.fontString(i,n,a)}}function m(t,e,i,n,a){return t===n||t===a?{start:e-i/2,end:e+i/2}:t<n||a<t?{start:e-i-5,end:e}:{start:e,end:e+i+5}}function y(t,e,i,n){if(k.isArray(e))for(var a=i.y,o=1.5*n,r=0;r<e.length;++r)t.fillText(e[r],i.x,a),a+=o;else t.fillText(e,i.x,i.y)}function s(t){return k.isNumber(t)?t:0}var i=e.LinearScaleBase.extend({setDimensions:function(){var t=this,e=t.options,i=e.ticks;t.width=t.maxWidth,t.height=t.maxHeight,t.xCenter=Math.round(t.width/2),t.yCenter=Math.round(t.height/2);var n=k.min([t.height,t.width]),a=k.valueOrDefault(i.fontSize,v.defaultFontSize);t.drawingArea=e.display?n/2-(a/2+i.backdropPaddingY):n/2},determineDataLimits:function(){var a=this,i=a.chart,o=Number.POSITIVE_INFINITY,r=Number.NEGATIVE_INFINITY;k.each(i.data.datasets,function(t,e){if(i.isDatasetVisible(e)){var n=i.getDatasetMeta(e);k.each(t.data,function(t,e){var i=+a.getRightValue(t);isNaN(i)||n.data[e].hidden||(o=Math.min(i,o),r=Math.max(i,r))})}}),a.min=o===Number.POSITIVE_INFINITY?0:o,a.max=r===Number.NEGATIVE_INFINITY?0:r,a.handleTickRangeOptions()},getTickLimit:function(){var t=this.options.ticks,e=k.valueOrDefault(t.fontSize,v.defaultFontSize);return Math.min(t.maxTicksLimit?t.maxTicksLimit:11,Math.ceil(this.drawingArea/(1.5*e)))},convertTicksToLabels:function(){var t=this;e.LinearScaleBase.prototype.convertTicksToLabels.call(t),t.pointLabels=t.chart.data.labels.map(t.options.pointLabels.callback,t)},getLabelForIndex:function(t,e){return+this.getRightValue(this.chart.data.datasets[e].data[t])},fit:function(){var t,e;this.options.pointLabels.display?function(t){var e,i,n,a=x(t),o=Math.min(t.height/2,t.width/2),r={r:t.width,l:0,t:t.height,b:0},s={};t.ctx.font=a.font,t._pointLabelSizes=[];var l,u,d,c=b(t);for(e=0;e<c;e++){n=t.getPointPosition(e,o),l=t.ctx,u=a.size,d=t.pointLabels[e]||"",i=k.isArray(d)?{w:k.longestText(l,l.font,d),h:d.length*u+1.5*(d.length-1)*u}:{w:l.measureText(d).width,h:u},t._pointLabelSizes[e]=i;var h=t.getIndexAngle(e),f=k.toDegrees(h)%360,g=m(f,n.x,i.w,0,180),p=m(f,n.y,i.h,90,270);g.start<r.l&&(r.l=g.start,s.l=h),g.end>r.r&&(r.r=g.end,s.r=h),p.start<r.t&&(r.t=p.start,s.t=h),p.end>r.b&&(r.b=p.end,s.b=h)}t.setReductions(o,r,s)}(this):(t=this,e=Math.min(t.height/2,t.width/2),t.drawingArea=Math.round(e),t.setCenterPoint(0,0,0,0))},setReductions:function(t,e,i){var n=e.l/Math.sin(i.l),a=Math.max(e.r-this.width,0)/Math.sin(i.r),o=-e.t/Math.cos(i.t),r=-Math.max(e.b-this.height,0)/Math.cos(i.b);n=s(n),a=s(a),o=s(o),r=s(r),this.drawingArea=Math.min(Math.round(t-(n+a)/2),Math.round(t-(o+r)/2)),this.setCenterPoint(n,a,o,r)},setCenterPoint:function(t,e,i,n){var a=this,o=a.width-e-a.drawingArea,r=t+a.drawingArea,s=i+a.drawingArea,l=a.height-n-a.drawingArea;a.xCenter=Math.round((r+o)/2+a.left),a.yCenter=Math.round((s+l)/2+a.top)},getIndexAngle:function(t){return t*(2*Math.PI/b(this))+(this.chart.options&&this.chart.options.startAngle?this.chart.options.startAngle:0)*Math.PI*2/360},getDistanceFromCenterForValue:function(t){var e=this;if(null===t)return 0;var i=e.drawingArea/(e.max-e.min);return e.options.ticks.reverse?(e.max-t)*i:(t-e.min)*i},getPointPosition:function(t,e){var i=this.getIndexAngle(t)-Math.PI/2;return{x:Math.round(Math.cos(i)*e)+this.xCenter,y:Math.round(Math.sin(i)*e)+this.yCenter}},getPointPositionForValue:function(t,e){return this.getPointPosition(t,this.getDistanceFromCenterForValue(e))},getBasePosition:function(){var t=this.min,e=this.max;return this.getPointPositionForValue(0,this.beginAtZero?0:t<0&&e<0?e:0<t&&0<e?t:0)},draw:function(){var o=this,t=o.options,r=t.gridLines,s=t.ticks,l=k.valueOrDefault;if(t.display){var u=o.ctx,d=this.getIndexAngle(0),c=l(s.fontSize,v.defaultFontSize),e=l(s.fontStyle,v.defaultFontStyle),i=l(s.fontFamily,v.defaultFontFamily),h=k.fontString(c,e,i);k.each(o.ticks,function(t,e){if(0<e||s.reverse){var i=o.getDistanceFromCenterForValue(o.ticksAsNumbers[e]);if(r.display&&0!==e&&function(t,e,i,n){var a=t.ctx;if(a.strokeStyle=k.valueAtIndexOrDefault(e.color,n-1),a.lineWidth=k.valueAtIndexOrDefault(e.lineWidth,n-1),t.options.gridLines.circular)a.beginPath(),a.arc(t.xCenter,t.yCenter,i,0,2*Math.PI),a.closePath(),a.stroke();else{var o=b(t);if(0===o)return;a.beginPath();var r=t.getPointPosition(0,i);a.moveTo(r.x,r.y);for(var s=1;s<o;s++)r=t.getPointPosition(s,i),a.lineTo(r.x,r.y);a.closePath(),a.stroke()}}(o,r,i,e),s.display){var n=l(s.fontColor,v.defaultFontColor);if(u.font=h,u.save(),u.translate(o.xCenter,o.yCenter),u.rotate(d),s.showLabelBackdrop){var a=u.measureText(t).width;u.fillStyle=s.backdropColor,u.fillRect(-a/2-s.backdropPaddingX,-i-c/2-s.backdropPaddingY,a+2*s.backdropPaddingX,c+2*s.backdropPaddingY)}u.textAlign="center",u.textBaseline="middle",u.fillStyle=n,u.fillText(t,0,-i),u.restore()}}}),(t.angleLines.display||t.pointLabels.display)&&function(t){var e=t.ctx,i=t.options,n=i.angleLines,a=i.pointLabels;e.lineWidth=n.lineWidth,e.strokeStyle=n.color;var o,r,s,l,u=t.getDistanceFromCenterForValue(i.ticks.reverse?t.min:t.max),d=x(t);e.textBaseline="top";for(var c=b(t)-1;0<=c;c--){if(n.display){var h=t.getPointPosition(c,u);e.beginPath(),e.moveTo(t.xCenter,t.yCenter),e.lineTo(h.x,h.y),e.stroke(),e.closePath()}if(a.display){var f=t.getPointPosition(c,u+5),g=k.valueAtIndexOrDefault(a.fontColor,c,v.defaultFontColor);e.font=d.font,e.fillStyle=g;var p=t.getIndexAngle(c),m=k.toDegrees(p);e.textAlign=0===(l=m)||180===l?"center":l<180?"left":"right",o=m,r=t._pointLabelSizes[c],s=f,90===o||270===o?s.y-=r.h/2:(270<o||o<90)&&(s.y-=r.h),y(e,t.pointLabels[c]||"",f,d.size)}}}(o)}}});a.registerScaleType("radialLinear",i,t)}},{26:26,34:34,35:35,46:46}],59:[function(t,e,i){"use strict";var x=t(1);x="function"==typeof x?x:window.moment;var r=t(26),m=t(46),n=t(33),a=t(34),p=Number.MIN_SAFE_INTEGER||-9007199254740991,v=Number.MAX_SAFE_INTEGER||9007199254740991,y={millisecond:{common:!0,size:1,steps:[1,2,5,10,20,50,100,250,500]},second:{common:!0,size:1e3,steps:[1,2,5,10,15,30]},minute:{common:!0,size:6e4,steps:[1,2,5,10,15,30]},hour:{common:!0,size:36e5,steps:[1,2,3,6,12]},day:{common:!0,size:864e5,steps:[1,2,5]},week:{common:!1,size:6048e5,steps:[1,2,3,4]},month:{common:!0,size:2628e6,steps:[1,2,3]},quarter:{common:!1,size:7884e6,steps:[1,2,3,4]},year:{common:!0,size:3154e7}},k=Object.keys(y);function b(t,e){return t-e}function M(t){var e,i,n,a={},o=[];for(e=0,i=t.length;e<i;++e)a[n=t[e]]||(a[n]=!0,o.push(n));return o}function w(t,e,i,n){var a=function(t,e,i){for(var n,a,o,r=0,s=t.length-1;0<=r&&r<=s;){if(a=t[(n=r+s>>1)-1]||null,o=t[n],!a)return{lo:null,hi:o};if(o[e]<i)r=n+1;else{if(!(a[e]>i))return{lo:a,hi:o};s=n-1}}return{lo:o,hi:null}}(t,e,i),o=a.lo?a.hi?a.lo:t[t.length-2]:t[0],r=a.lo?a.hi?a.hi:t[t.length-1]:t[1],s=r[e]-o[e],l=s?(i-o[e])/s:0,u=(r[n]-o[n])*l;return o[n]+u}function C(t,e){var i=e.parser,n=e.parser||e.format;return"function"==typeof i?i(t):"string"==typeof t&&"string"==typeof n?x(t,n):(t instanceof x||(t=x(t)),t.isValid()?t:"function"==typeof n?n(t):t)}function S(t,e){if(m.isNullOrUndef(t))return null;var i=e.options.time,n=C(e.getRightValue(t),i);return n.isValid()?(i.round&&n.startOf(i.round),n.valueOf()):null}function _(t){for(var e=k.indexOf(t)+1,i=k.length;e<i;++e)if(y[k[e]].common)return k[e]}function D(t,e,i,n){var a,o=n.time,r=o.unit||function(t,e,i,n){var a,o,r,s=k.length;for(a=k.indexOf(t);a<s-1;++a)if(r=(o=y[k[a]]).steps?o.steps[o.steps.length-1]:v,o.common&&Math.ceil((i-e)/(r*o.size))<=n)return k[a];return k[s-1]}(o.minUnit,t,e,i),s=_(r),l=m.valueOrDefault(o.stepSize,o.unitStepSize),u="week"===r&&o.isoWeekday,d=n.ticks.major.enabled,c=y[r],h=x(t),f=x(e),g=[];for(l||(l=function(t,e,i,n){var a,o,r,s=e-t,l=y[i],u=l.size,d=l.steps;if(!d)return Math.ceil(s/(n*u));for(a=0,o=d.length;a<o&&(r=d[a],!(Math.ceil(s/(u*r))<=n));++a);return r}(t,e,r,i)),u&&(h=h.isoWeekday(u),f=f.isoWeekday(u)),h=h.startOf(u?"day":r),(f=f.startOf(u?"day":r))<e&&f.add(1,r),a=x(h),d&&s&&!u&&!o.round&&(a.startOf(s),a.add(~~((h-a)/(c.size*l))*l,r));a<f;a.add(l,r))g.push(+a);return g.push(+a),g}e.exports=function(){var t=n.extend({initialize:function(){if(!x)throw new Error("Chart.js - Moment.js could not be found! You must include it before Chart.js to use the time scale. Download at https://momentjs.com");this.mergeTicksOptions(),n.prototype.initialize.call(this)},update:function(){var t=this.options;return t.time&&t.time.format&&console.warn("options.time.format is deprecated and replaced by options.time.parser."),n.prototype.update.apply(this,arguments)},getRightValue:function(t){return t&&void 0!==t.t&&(t=t.t),n.prototype.getRightValue.call(this,t)},determineDataLimits:function(){var t,e,i,n,a,o,r=this,s=r.chart,l=r.options.time,u=l.unit||"day",d=v,c=p,h=[],f=[],g=[];for(t=0,i=s.data.labels.length;t<i;++t)g.push(S(s.data.labels[t],r));for(t=0,i=(s.data.datasets||[]).length;t<i;++t)if(s.isDatasetVisible(t))if(a=s.data.datasets[t].data,m.isObject(a[0]))for(f[t]=[],e=0,n=a.length;e<n;++e)o=S(a[e],r),h.push(o),f[t][e]=o;else h.push.apply(h,g),f[t]=g.slice(0);else f[t]=[];g.length&&(g=M(g).sort(b),d=Math.min(d,g[0]),c=Math.max(c,g[g.length-1])),h.length&&(h=M(h).sort(b),d=Math.min(d,h[0]),c=Math.max(c,h[h.length-1])),d=S(l.min,r)||d,c=S(l.max,r)||c,d=d===v?+x().startOf(u):d,c=c===p?+x().endOf(u)+1:c,r.min=Math.min(d,c),r.max=Math.max(d+1,c),r._horizontal=r.isHorizontal(),r._table=[],r._timestamps={data:h,datasets:f,labels:g}},buildTicks:function(){var t,e,i,n,a,o,r,s,l,u,d,c,h=this,f=h.min,g=h.max,p=h.options,m=p.time,v=[],b=[];switch(p.ticks.source){case"data":v=h._timestamps.data;break;case"labels":v=h._timestamps.labels;break;case"auto":default:v=D(f,g,h.getLabelCapacity(f),p)}for("ticks"===p.bounds&&v.length&&(f=v[0],g=v[v.length-1]),f=S(m.min,h)||f,g=S(m.max,h)||g,t=0,e=v.length;t<e;++t)f<=(i=v[t])&&i<=g&&b.push(i);return h.min=f,h.max=g,h._unit=m.unit||function(t,e,i,n){var a,o,r=x.duration(x(n).diff(x(i)));for(a=k.length-1;a>=k.indexOf(e);a--)if(o=k[a],y[o].common&&r.as(o)>=t.length)return o;return k[e?k.indexOf(e):0]}(b,m.minUnit,h.min,h.max),h._majorUnit=_(h._unit),h._table=function(t,e,i,n){if("linear"===n||!t.length)return[{time:e,pos:0},{time:i,pos:1}];var a,o,r,s,l,u=[],d=[e];for(a=0,o=t.length;a<o;++a)e<(s=t[a])&&s<i&&d.push(s);for(d.push(i),a=0,o=d.length;a<o;++a)l=d[a+1],r=d[a-1],s=d[a],void 0!==r&&void 0!==l&&Math.round((l+r)/2)===s||u.push({time:s,pos:a/(o-1)});return u}(h._timestamps.data,f,g,p.distribution),h._offsets=(n=h._table,a=b,o=f,r=g,c=d=0,(s=p).offset&&a.length&&(s.time.min||(l=1<a.length?a[1]:r,u=a[0],d=(w(n,"time",l,"pos")-w(n,"time",u,"pos"))/2),s.time.max||(l=a[a.length-1],u=1<a.length?a[a.length-2]:o,c=(w(n,"time",l,"pos")-w(n,"time",u,"pos"))/2)),{left:d,right:c}),h._labelFormat=function(t,e){var i,n,a,o=t.length;for(i=0;i<o;i++){if(0!==(n=C(t[i],e)).millisecond())return"MMM D, YYYY h:mm:ss.SSS a";0===n.second()&&0===n.minute()&&0===n.hour()||(a=!0)}return a?"MMM D, YYYY h:mm:ss a":"MMM D, YYYY"}(h._timestamps.data,m),function(t,e){var i,n,a,o,r=[];for(i=0,n=t.length;i<n;++i)a=t[i],o=!!e&&a===+x(a).startOf(e),r.push({value:a,major:o});return r}(b,h._majorUnit)},getLabelForIndex:function(t,e){var i=this.chart.data,n=this.options.time,a=i.labels&&t<i.labels.length?i.labels[t]:"",o=i.datasets[e].data[t];return m.isObject(o)&&(a=this.getRightValue(o)),n.tooltipFormat?C(a,n).format(n.tooltipFormat):"string"==typeof a?a:C(a,n).format(this._labelFormat)},tickFormatFunction:function(t,e,i,n){var a=this.options,o=t.valueOf(),r=a.time.displayFormats,s=r[this._unit],l=this._majorUnit,u=r[l],d=t.clone().startOf(l).valueOf(),c=a.ticks.major,h=c.enabled&&l&&u&&o===d,f=t.format(n||(h?u:s)),g=h?c:a.ticks.minor,p=m.valueOrDefault(g.callback,g.userCallback);return p?p(f,e,i):f},convertTicksToLabels:function(t){var e,i,n=[];for(e=0,i=t.length;e<i;++e)n.push(this.tickFormatFunction(x(t[e].value),e,t));return n},getPixelForOffset:function(t){var e=this,i=e._horizontal?e.width:e.height,n=e._horizontal?e.left:e.top,a=w(e._table,"time",t,"pos");return n+i*(e._offsets.left+a)/(e._offsets.left+1+e._offsets.right)},getPixelForValue:function(t,e,i){var n=null;if(void 0!==e&&void 0!==i&&(n=this._timestamps.datasets[i][e]),null===n&&(n=S(t,this)),null!==n)return this.getPixelForOffset(n)},getPixelForTick:function(t){var e=this.getTicks();return 0<=t&&t<e.length?this.getPixelForOffset(e[t].value):null},getValueForPixel:function(t){var e=this,i=e._horizontal?e.width:e.height,n=e._horizontal?e.left:e.top,a=(i?(t-n)/i:0)*(e._offsets.left+1+e._offsets.left)-e._offsets.right,o=w(e._table,"pos",a,"time");return x(o)},getLabelWidth:function(t){var e=this.options.ticks,i=this.ctx.measureText(t).width,n=m.toRadians(e.maxRotation),a=Math.cos(n),o=Math.sin(n);return i*a+m.valueOrDefault(e.fontSize,r.global.defaultFontSize)*o},getLabelCapacity:function(t){var e=this.options.time.displayFormats.millisecond,i=this.tickFormatFunction(x(t),0,[],e),n=this.getLabelWidth(i),a=this.isHorizontal()?this.width:this.height,o=Math.floor(a/n);return 0<o?o:1}});a.registerScaleType("time",t,{position:"bottom",distribution:"linear",bounds:"data",time:{parser:!1,format:!1,unit:!1,round:!1,displayFormat:!1,isoWeekday:!1,minUnit:"millisecond",displayFormats:{millisecond:"h:mm:ss.SSS a",second:"h:mm:ss a",minute:"h:mm a",hour:"hA",day:"MMM D",week:"ll",month:"MMM YYYY",quarter:"[Q]Q - YYYY",year:"YYYY"}},ticks:{autoSkip:!1,source:"auto",major:{enabled:!1}}})}},{1:1,26:26,33:33,34:34,46:46}]},{},[7])(7)});</script>
<script>
  var ChartBehaviors = ChartBehaviors || {};
  /** @polymerBehavior */
  ChartBehaviors.ChartPropertyBehavior = Polymer.dedupingMixin(function(superClass) {
    return class extends superClass {
      static get properties() {
        return {
          type: {
            type: String,
            readOnly: true,
            value: 'bar',
          },

          chart: {
            notify: true
          },

          data: {
            type: Object,
            value: function () {
              return {};
            }
          },

          options: {
            type: Object,
            value: function () {
              return {};
            }
          },

          colors: {
            type: Array,
            value: function () {
              return [
                '#3366cc', '#ff9900', '#dc3912', '#109618', '#990099', '#0099c6', '#dd4477', '#66aa00', '#b82e2e',
                '#316395', '#994499', '#22aa99', '#aaaa11', '#6633cc', '#e67300', '#8b0707', '#651067', '#329262',
                '#5574a6', '#3b3eac', '#b77322', '#16d620', '#b91383', '#f4359e', '#9c5935', '#a9c413', '#2a778d',
                '#668d1c', '#bea413', '#0c5922', '#743411'
              ];
            }
          },

          labels: {
            type: Array,
            value: function () {
              return [];
            }
          },

          values: {
            type: Array,
            value: function () {
              return [];
            }
          },

          series: {
            type: Array,
            value: function() {
              return [];
            }
          }
        };
      }

      static get observers() {
        return [
          '_configurationChanged(data.*, options.*)',
          '_updateData(colors, labels, values, series)'
        ];
      }

      _configurationChanged(dataRecord, optionsRecord) {
        if (dataRecord.base.labels && dataRecord.base.datasets) {
          this.hasData = true;
        } else {
          this.hasData = false;
        }

        if (this.hasData && this.isAttached) {
          this._queue();
        }
      }

    }
  });

</script>
<script>
  var ChartBehaviors = ChartBehaviors || {};
  /** @polymerBehavior */
  ChartBehaviors.ContextBehavior = Polymer.dedupingMixin(function(superClass) {
    return class extends superClass {
      _measure(cb) {
        function measure() {
          if (this.offsetHeight) {
            cb(true);
          } else {
            cb(false);
          }
        }
        requestAnimationFrame(measure.bind(this));
      }

      _queue() {
        if (this.hasData) {
          this._measure(hasHeight => {
            if (hasHeight) {
              this.updateChart();
            }
          });
        }
      }

      updateChart() {

        this.async(function () {

          if (this.chart) {

            this.chart.stop();
            this.mixin(this.chart.data, this.data);
            this.chart.update();

          } else {

            this.async(function () {
              if (this.hasData) {
                this.chart = new Chart(this.ctx, {
                  type: this.type,
                  data: this.data,
                  options: this.options
                });
              }
            }, null, 0);

          }

        }, null, 0);

      }

      connectedCallback() {
        super.connectedCallback();
        this.ctx = this.$.canvas.getContext('2d');
        this._queue();
      }
    }
  });

</script>
<script>
  var ChartBehaviors = ChartBehaviors || {};
  /** @polymerBehavior */
  ChartBehaviors.ResizeBehavior = Polymer.dedupingMixin(function(superClass) {
    return class extends superClass {

      connectedCallback() {
        super.connectedCallback();
        this._boundOnIronResize = this._onIronResize.bind(this);
        this.addEventListener('iron-resize', this._boundOnIronResize);
      }

      disconnectedCallback() {
        super.disconnectedCallback();
        this.removeEventListener('iron-resize', this._boundOnIronResize);
      }

      // If an iron-resizer changes our size and notifies us
      // check to see if we have a height and if so, recreate
      // the chart
      _onIronResize() {
        this._queue();
      }

      // This is a public method the user can call if they've
      // changed our dimensions with CSS.
      resize() {
        if (this.chart) {
          this.chart.resize();
          this.chart.render(true);
        }
      }
    }
  });

</script>
<dom-module id="chart-styles" assetpath="bower_components/chart-elements/">

  <template>

    <style>
      :host {
        display: inline-block;
        position: relative;
      }

      :host > div {
        height: 100%;
      }

      #canvas {
        width: 100%;
        height: 100%;
      }
    </style>

  </template>

</dom-module>
<dom-module id="chart-bar" assetpath="bower_components/chart-elements/">

  <template>

    <style include="chart-styles"></style>

    <div>
      <canvas id="canvas"></canvas>
    </div>

  </template>

  <script>
    class ChartBar extends ChartBehaviors.ResizeBehavior(ChartBehaviors.ContextBehavior(ChartBehaviors.ChartPropertyBehavior(Polymer.mixinBehaviors([Polymer.IronResizableBehavior], Polymer.Element)))) {
      static get is() { return 'chart-bar'; }

      ready() {
        super.ready();
        this._setType('bar');
      }

      _updateData() {
        this.data = {
          labels: this.labels,
          datasets: this.values.map((val, i) => ({
            data: this.values[i],
            label: this.series[i],
            fill: true,
            backgroundColor: this.colors[i],
            borderColor: this.colors[i],
            borderWidth: 1
          }))
        };
      }

    };

    window.customElements.define(ChartBar.is, ChartBar);
  </script>

</dom-module>
<dom-module id="chart-line" assetpath="bower_components/chart-elements/">

  <template>

    <style include="chart-styles"></style>

    <div>
      <canvas id="canvas"></canvas>
    </div>

  </template>

  <script>
    class ChartLine extends ChartBehaviors.ResizeBehavior(ChartBehaviors.ContextBehavior(ChartBehaviors.ChartPropertyBehavior(Polymer.mixinBehaviors([Polymer.IronResizableBehavior], Polymer.Element)))) {

      static get is() { return 'chart-line'; }

      ready() {
        super.ready();
        this._setType('line');
      }

      _updateData() {
        this.data = {
          labels: this.labels,
          datasets: this.values.map((val, i) => ({
            data: this.values[i],
            label: this.series[i],
            fill: false,
            lineTension: 0,
            fillColor: this.colors[i],
            strokeColor: this.colors[i],
            pointColor: this.colors[i],
            borderWidth: 2,
            pointHitRadius: 20,
            pointRadius: 4,
            pointHoverRadius: 4,
            pointBorderWidth: 1,
            pointHoverBorderWidth: 1,
            pointBorderColor: '#fff',
            pointStrokeColor: this.colors[i],
            pointBackgroundColor: this.colors[i],
            borderColor: this.colors[i]
          }))
        };
      }

    };

    window.customElements.define(ChartLine.is, ChartLine);
  </script>
</dom-module>
<dom-module id="chart-pie" assetpath="bower_components/chart-elements/">

  <template>

    <style include="chart-styles"></style>

    <div>
      <canvas id="canvas"></canvas>
    </div>

  </template>

  <script>
    class ChartPie extends ChartBehaviors.ResizeBehavior(ChartBehaviors.ContextBehavior(ChartBehaviors.ChartPropertyBehavior(Polymer.mixinBehaviors([Polymer.IronResizableBehavior], Polymer.Element)))) {

      static get is() { return 'chart-pie'; }

      ready() {
        super.ready();
        this.options = {
          legend: {
            display: true,
            position: 'bottom',
            labels: {
              boxWidth: 12
            }
          },
          animation: false
        };
        this._setType('pie');
      }

      _updateData() {
        this.data = {
          labels: this.labels,
          datasets: [{
            data: (this.values && this.values.length && Array.isArray(this.values[0])) ? this.values[0] : this.values,
            backgroundColor: this.colors,
            hoverBackgroundColor: this.colors
          }]
        };
      }

    };

    window.customElements.define(ChartPie.is, ChartPie);
  </script>

</dom-module>
<dom-module id="nuxeo-document-layout" assetpath="document/">
  <template>
    <nuxeo-layout id="layout" href="[[_href]]" model="[[_model]]" error="[[i18n('documentView.layoutNotFound', document.type)]]" on-element-changed="_elementChanged">
    </nuxeo-layout>
  </template>
  <script>
    Polymer({
      is: 'nuxeo-document-layout',
      behaviors: [Nuxeo.I18nBehavior],
      properties: {
        document: {
          type: Object,
          notify: true
        },
        layout: {
          type: String,
          value: 'view'
        },
        _model: {
          type: Object,
          notify: true,
          value: {}
        },
        _href: {
          type: String,
          notify: true
        }
      },

      observers: ['_loadLayout(document, layout)'],

      get element() {
        return this.$.layout.element;
      },

      validate: function() {
        return this.$.layout.validate();
      },

      _loadLayout: function(document, layout) {
        if (document) {
          if (!this.previousDocument || (document.type === this.previousDocument.type)) {
            this._model = {document: document};
          }
          if (!this.previousDocument || (document.uid !== this.previousDocument.uid)) {
            this._href = null; // force layout restamp
          }
          var doctype = document.type.toLowerCase();
          var name = ['nuxeo', doctype, layout, 'layout'].join('-');
          this._href = this.resolveUrl(doctype + '/' + name + '.html');
        } else if (document === undefined) {
          // XXX undefined is used to notify a cancel to inner elements
          this._model = {document: document};
        }
        this.previousDocument = document;
      },

      _elementChanged: function() {
        this._model = {document: this.document};
        // forward document path change events
        this.element.addEventListener('document-changed', function(e) {
          this.notifyPath(e.detail.path, e.detail.value);
        }.bind(this));
        Polymer.RenderStatus.afterNextRender(this, function() {
          // fire the `document-layout-changed` event only after flush
          this.fire('document-layout-changed', {
            element: this.element,
            layout: this.layout
          });
        }.bind(this));
      }

    });
  </script>
</dom-module>
<dom-module id="nuxeo-document-form-layout" assetpath="document/">
  <template>
    <style include="nuxeo-styles">
      .actions {
        @apply --buttons-bar;
        @apply --layout-horizontal;
        @apply --layout-flex;
        @apply --layout-justified;
      }

      .scrollable {
        padding: 0 24px;
        max-height: 60vh;
        @apply --layout-scroll;
      }
    </style>

    <nuxeo-document id="doc" doc-id="[[document.uid]]" response="{{document}}" headers="[[headers]]" sync-indexing=""></nuxeo-document>

    <iron-form id="form">
      <form>
        <div class="scrollable">
          <nuxeo-document-layout id="layout" document="{{document}}" layout="[[layout]]"></nuxeo-document-layout>
        </div>
        <div class="actions">
          <paper-button on-tap="cancel" noink="">[[i18n('command.cancel')]]</paper-button>
          <paper-button id="save" on-tap="save" noink="" class="primary">[[i18n('command.save')]]</paper-button>
        </div>
      </form>
    </iron-form>

  </template>
  <script>
    Polymer({
      is: 'nuxeo-document-form-layout',
      behaviors: [Polymer.IronResizableBehavior, Nuxeo.I18nBehavior],
      properties: {
        document: {
          type: Object,
          notify: true
        },

        layout: {
          type: String,
          value: 'edit'
        },

        headers: {
          type: Object
        }
      },

      observers: [
        '_documentChanged(document.*)'
      ],

      _validate: function() {
        // run our custom validation function first to allow setting custom native validity
        var result = this.$.layout.validate() && this._doNativeValidation(this.$.form) && this.$.form.validate();
        if (result) {
          return result;
        } else {
          var layout = this.$.layout.$.layout;
          var nodes = layout._getValidatableElements(layout.element.root);
          var invalidField = nodes.find(function(node) {
            return node.invalid;
          });
          invalidField.scrollIntoView();
          invalidField.focus();
        }
      },

      _doSave: function() {
        if (!this.document.uid) { // create
          this.$.doc.data = this.document;
          return this.$.doc.post()
        } else { // edit
          this.$.doc.data = {
            'entity-type': 'document',
            uid: this.document.uid,
            properties: this._dirtyProperties
          };
          return this.$.doc.put();
        }
      },

      save: function() {
        if (!this._validate()) {
          return;
        }
        this._doSave().then(this._refresh.bind(this), function(err) {
          this.fire('notify', {message: this.i18n('document.saveError')});
          console.error(err);
        }.bind(this));
      },

      cancel: function() {
        this._refresh();
        this.document = undefined;
      },

      _refresh: function() {
        this.fire('document-updated');
      },

      _documentChanged: function(e) {
        if (e.path === 'document') {
          this._dirtyProperties = {};
        } else {
          // copy dirty properties (cannot patch complex or list properties)
          var match = e.path.match(/^document\.properties\.([^\.]*)/);
          if (match) {
            var prop = match[1];
            this._dirtyProperties[prop] = this.document.properties[prop];
          }
        }
      },

      // trigger native browser invalid-form UI
      _doNativeValidation: function(/*form*/) {
        /*var fakeSubmit = document.createElement('input');
        fakeSubmit.setAttribute('type', 'submit');
        fakeSubmit.style.display = 'none';
        form._form.appendChild(fakeSubmit);
        fakeSubmit.click();
        form._form.removeChild(fakeSubmit);
        return form._form.checkValidity();*/
        return true;
      }
    });
  </script>
</dom-module>
<dom-module id="nuxeo-document-creation-stats" assetpath="nuxeo-document-creation-stats/">

  <template>
    <style>
      :host {
        display: none;
      }
    </style>

    <nuxeo-connection id="nxcon"></nuxeo-connection>
    <iron-localstorage id="storage" name="[[name]]" value="{{creationStats}}" on-iron-localstorage-load-empty="initialize" auto-save-disabled="">
    </iron-localstorage>

  </template>

  <script>
    Polymer({
      is: 'nuxeo-document-creation-stats',

      properties: {
        name: String,
        recencySize: {
          type: Number,
          value: 5
        },
        creationStats: {
          type: Object,
          notify: true
        }
      },

      ready: function() {
        this.$.nxcon.connect().then(function(res) {
          this.name =  res.id + '-document-creation-stats';
        }.bind(this));
      },

      initialize: function() {
        this.creationStats = {
          recency: [],
          frequency: {},
          total: 0
        };
      },

      storeType: function(type) {
        this.$.storage.reload();

        if (this.creationStats.recency.length === this.recencySize) {
          this.splice('creationStats.recency', 0, 1);
        }
        if (!(type in this.creationStats.frequency)) {
          this.set('creationStats.frequency.' + type, 0);
        }

        this.push('creationStats.recency', type);
        this.set('creationStats.frequency.' + type, this.creationStats.frequency[type] + 1);
        this.set('creationStats.total', this.creationStats.total + 1);
        this.$.storage.save();
      },

      lastType: function(n) {
        this.$.storage.reload();
        if (this.creationStats.recency.length === 0) {
          return [];
        }
        return this.creationStats.recency.slice(Math.max(this.creationStats.recency.length - (n ? n : 1), 0));
      },

      mostCommonType: function(n) {
        this.$.storage.reload();
        var sorted = Object.keys(this.creationStats.frequency).sort(function(a, b) {
          return this.creationStats.frequency[a] < this.creationStats.frequency[b];
        }.bind(this)).filter(function(elem, index, self) {
          return index === self.indexOf(elem);
        });
        return sorted.slice(0, Math.min((n ? n : 1), sorted.length));
      }
    });
  </script>

</dom-module>
<dom-module id="nuxeo-document-create" assetpath="document/">

  <template>
    <style include="iron-flex iron-flex-alignment nuxeo-styles">
      :host {
        display: block;
        @apply --layout-flex;
        @apply --layout-horizontal;
        --paper-dialog-scrollable: {
          padding: 0;
          overflow-x: hidden;
        };
      }

      paper-dialog-scrollable {
        display: block;
        @apply --layout-flex;
      }

      .typeSelection {
        margin: 1rem 0;
        @apply --layout-wrap;
        @apply --layout-flex;
        @apply --layout-horizontal;
      }

      .typeSelection paper-button {
        min-width: 128px;
        max-width: 128px;
        height: 128px;
        margin: 4px;
        border: none;
        text-align: center;
        box-shadow: none;
        background-color: var(--nuxeo-dialog-buttons-bar);
      }

      .typeSelection paper-button:hover {
        color: var(--nuxeo-link-hover-color);
        filter: brightness(102%);
        -webkit-filter: brightness(102%);
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.3), 0 -3px 0 var(--nuxeo-link-hover-color) inset;
      }

      .typeSelection iron-icon {
        width: var(--nuxeo-document-creation-form-icon-width, 42px);
        height: var(--nuxeo-document-creation-form-icon-height, 42px);
        filter: brightness(1.5);
        -webkit-filter: brightness(1.5);
      }

      .container {
        margin: 0 2rem;
        padding: 0 1rem 0 0;
        display: inline-block;
        @apply --layout-flex;
        @apply --layout-vertical;
      }

      #form {
        @apply --layout-flex;
        @apply --layout-horizontal;
      }

      #document-create {
        margin-bottom: 2.5em;
      }

      .heading {
        text-transform: uppercase;
        font-size: 1.1rem;
        padding: 1.7rem 2.5rem;
      }

      .heading iron-icon {
        width: 1.2rem;
        height: 1.2rem;
        margin-right: 8px;
      }

      .typeSelection div {
        margin-top: 1em;
        word-break: break-word;
      }

      .buttons {
        @apply --buttons-bar;
      }

      .error {
        border-left: 4px solid var(--nuxeo-warn-text);
        color: var(--nuxeo-text-default);
        padding-left: 8px;
      }

      .suggester {
        background-color: var(--nuxeo-dialog-buttons-bar);
        padding: 8px 16px;
        margin: 1rem 0;
        z-index: 100;
      }

      .importing-label {
        margin-right: 8px;
      }

      .vertical {
        @apply --layout-flex;
        @apply --layout-vertical;
      }

      iron-pages {
        @apply --layout-flex;
        @apply --layout-horizontal;
      }
    </style>

    <nuxeo-document id="docRequest" doc-path="[[targetPath]]" data="[[document]]" sync-indexing="" enrichers="permissions, subtypes" response="{{createResponse}}"></nuxeo-document>

    <iron-pages selected="[[stage]]" attr-for-selected="name">

      <div name="choose" class="vertical">
        <div class="container">
          <div class="suggester">
            <nuxeo-path-suggestion id="pathSuggesterChoose" value="{{targetPath}}" label="[[i18n('documentCreationForm.location')]]" parent="{{suggesterParent}}" children="{{suggesterChildren}}" disabled="" always-float-label=""></nuxeo-path-suggestion>
            <span class$="horizontal layout [[_formatErrorMessage(errorMessage)]]">[[errorMessage]]</span>
          </div>
          <paper-dialog-scrollable>
            <div name="typeSelection" class="typeSelection">
              <template is="dom-repeat" items="[[subtypes]]" as="type">
                <paper-button noink="" name$="[[type.type]]" class="docTypeButton vertical layout" on-tap="_selectType" data-args$="[[type]]">
                  <iron-icon src="[[_getTypeIcon(type)]]"></iron-icon>
                  <div>[[_getTypeLabel(type)]]</div>
                </paper-button>
              </template>
            </div>
          </paper-dialog-scrollable>
        </div>
        <div class="buttons horizontal end-justified layout">
          <div class="flex start-justified">
            <paper-button noink="" dialog-dismiss="" on-tap="_cancel">[[i18n('command.cancel')]]</paper-button>
          </div>
        </div>
      </div>

      <div name="edit" class="vertical layout flex">
        <div class="horizontal layout heading center">
          <iron-icon src="[[_getTypeIcon(selectedDocType)]]"></iron-icon>
          <span>[[_newDocumentLabel(selectedDocType)]]</span>
        </div>
        <div id="editor" class="container">
          <div class="suggester">
            <nuxeo-path-suggestion id="pathSuggesterEdit" value="{{targetPath}}" label="[[i18n('documentCreationForm.location')]]" parent="{{suggesterParent}}" children="{{suggesterChildren}}" disabled="" always-float-label=""></nuxeo-path-suggestion>
            <span class$="horizontal layout [[_formatErrorMessage(errorMessage)]]">[[errorMessage]]</span>
          </div>
          <paper-dialog-scrollable id="editScrollable">
            <iron-form id="form">
              <form class="form vertical layout flex">
                <iron-a11y-keys keys="enter" on-keys-pressed="_submitKeyHandler"></iron-a11y-keys>
                <nuxeo-document-layout id="document-create" layout="create" document="[[document]]"></nuxeo-document-layout>
              </form>
            </iron-form>
          </paper-dialog-scrollable>
        </div>
        <div class="buttons horizontal end-justified layout">
          <div class="flex start-justified">
            <paper-button noink="" dialog-dismiss="" on-tap="_cancel" disabled$="[[creating]]">[[i18n('command.cancel')]]</paper-button>
          </div>
          <paper-button noink="" on-tap="_back" disabled$="[[creating]]">[[i18n('command.back')]]</paper-button>
          <paper-button id="create" noink="" class="primary" on-tap="_create" disabled$="[[!_canCreate(canCreate,creating)]]">
            <template is="dom-if" if="[[!creating]]">
              [[i18n('command.create')]]
            </template>
            <template is="dom-if" if="[[creating]]">
              <span class="importing-label">[[i18n('documentImport.creating')]]</span>
              <paper-spinner-lite active=""></paper-spinner-lite>
            </template>
          </paper-button>
        </div>
      </div>

    </iron-pages>

    <nuxeo-document-creation-stats id="creationStats"></nuxeo-document-creation-stats>

  </template>

  <script>
    Polymer({
      is: 'nuxeo-document-create',
      behaviors: [Polymer.IronResizableBehavior, Nuxeo.DocumentCreationBehavior],
      properties: {

        stage: {
          type: String,
          value: 'choose'
        },

        visible: {
          type: Boolean
        },

        creating: {
          type: Boolean,
          value: false
        }

      },

      observers: [
        '_visibleOnStage(visible,stage)'
      ],

      ready: function() {
        this.addEventListener('element-changed', this._layoutUpdated.bind(this), true);
      },

      init: function(typeId) {
        if (typeId) {
          var typeObj = this.subtypes.find(function(type) {
            return type.id === typeId;
          });
          if (typeObj) {
            this.selectedDocType = typeObj;
          }
        }
      },

      /**
       * Retrieves and creates the layout for the current document type
       */
      _updateDocument: function() {

        if (!this._isValidType(this.selectedDocType) || !this.parent) {
          this.document = null;
          return;
        }

        this.newDocument(this.selectedDocType.type, this._getDocumentProperties()).then(function(document) {
          document.parentRef = this.parent.uid;
          this.document = document;
          this.stage = 'edit';
          this.$.editScrollable.scrollTarget.scrollTop = 0;
        }.bind(this));
      },

      _selectType: function(e) {
        this.selectedDocType = e.model.type;
        this.fire('nx-creation-wizard-hide-tabs');
      },

      _validate: function() {
        var layout = this.$['document-create'];
        var result = layout.validate() && this._doNativeValidation(this.$.form) &&
          this.$.form.validate() && this._isValidType(this.selectedDocType);
        if (result) {
          return result;
        } else {
          var innerLayout = layout.$.layout;
          var nodes = innerLayout._getValidatableElements(innerLayout.element.root);
          var invalidField = nodes.find(function(node) {
            return node.invalid;
          });
          invalidField.scrollIntoView();
          invalidField.focus();
        }
      },

      _create: function() {
        if (!this._validate() || !this.canCreate) {
          return;
        }
        this.document.name = this.document.name || this._sanitizeName(this.document.properties['dc:title']);
        this.set('creating', true);
        this.$.docRequest.post().then(function(response) {
          this.$.creationStats.storeType(this.selectedDocType.id);
          this._clear();
          this.navigateTo('browse', response.path);
          this._notify(response);
          this.set('creating', false);
        }.bind(this)).catch(function(err) {
          this.set('creating', false);
          this.fire('notify', {message: this.i18n('documentCreationForm.createError')});
          console.error(err);
        }.bind(this));
      },

      _back: function() {
        this._clear();
        this.fire('nx-creation-wizard-show-tabs');
      },

      _cancel: function() {
        this._clear();
        this.document = undefined;
        this.fire('nx-creation-wizard-show-tabs');
      },

      _newDocumentLabel: function() {
        return this.i18n('documentCreationForm.newDoc.heading', this._getTypeLabel(this.selectedDocType));
      },

      _clear: function() {
        this.stage = 'choose';
        this.selectedDocType = {};
      },

      _visibleOnStage: function() {
        this.$.pathSuggesterChoose.disabled = !this.visible || this.stage !== 'choose';
        this.$.pathSuggesterEdit.disabled = !this.visible || this.stage !== 'edit';
      },

      _layoutUpdated: function(e) {
        this.async(function() {
          var input = e.detail.value.querySelector('[autofocus]');
          if (input) {
            input.focus();
          }
        });
      },

      _submitKeyHandler: function(e) {
        if (e.detail.keyboardEvent.target.tagName === 'INPUT') {
          this._create();
        }
      },

      _canCreate: function() {
        return this.canCreate && !this.creating;
      },

      // trigger native browser invalid-form UI
      _doNativeValidation: function(/*form*/) {
        var fakeSubmit = document.createElement('input');
        fakeSubmit.setAttribute('type', 'submit');
        fakeSubmit.style.display = 'none';
        // TODO: this breaks fields bound to multivalued nuxeo-directory-suggestion
        /* form._form.appendChild(fakeSubmit);
        fakeSubmit.click();
        form._form.removeChild(fakeSubmit);
        return form._form.checkValidity(); */
        return true;
      }

    });
  </script>
</dom-module>
<dom-module id="nuxeo-document-import" assetpath="document/">

  <template>
    <style include="iron-flex iron-flex-alignment iron-flex-factors nuxeo-styles">
      :host {
        display: block;
        @apply --layout-flex;
        @apply --layout-horizontal;
        --paper-dialog-scrollable: {
          padding: 0;
          overflow-x: hidden;
        };
      }

      paper-spinner-lite {
        --paper-spinner-color: var(--default-primary-color);
      }

      paper-dialog-scrollable {
        display: block;
        @apply --layout-flex;
      }

      paper-dialog-scrollable:after {
        height: 0;
      }

      .suggester {
        background-color: var(--nuxeo-dialog-buttons-bar);
        padding: 8px 16px;
        margin: 1rem 32px;
      }

      .file-to-import {
        min-height: 3em;
        margin: 0 .3em .8em;
        width: calc(50% - 3em);
        padding: .8em 1em;
        background-color:var(--nuxeo-box);
        border: 1px solid var(--divider-color);
        position: relative;
      }

      paper-progress {
        width: 100%;
      }

      div[name='customize'] #blobEditor span {
        width: 200px;
      }

      #dropzone {
        padding: 1em;
        position: relative;
        border: 2px dashed var(--divider-color);
        border-radius: 4px;
        background-color: rgba(0,0,0,0.05);
        min-height: 100px;
        margin: 1em 2em 5em;
      }

      #form {
        padding: 0 32px;
      }

      #document-import {
        margin-bottom: 2.5em;
      }

      #blobEditor {
        @apply --layout-flex-3;
      }

      #blobList {
        height: 100px;
      }

      #blobList .file-overview:first-of-type {
        margin-top: 32px;
      }

      #blobList .error {
        margin: 8px;
      }

      #sidePanel {
        @apply --layout-flex;
        background: var(--nuxeo-page-background);
        min-width: 200px;
      }

      .blobCheck {
        display: block;
        width: 16px;
        height: 16px;
      }

      .blobCheck.checked {
        color: var(--nuxeo-validated);
      }

      .blobCheck.unchecked {
        opacity: .3;
      }

      .blobCheck.hidden {
        visibility: hidden;
      }

      .file-overview {
        border: 1px solid var(--divider-color);
        border-radius: 1px;
        background-color: var(--nuxeo-box);
        padding: 16px 14px 16px 14px;
        margin: 8px;
        font-weight: bold;
        text-transform: none;
        color: var(--secondary-text-color);
      }

      .file-overview:hover {
        @apply --nuxeo-block-hover;
      }

      .file-overview.selected {
        @apply --nuxeo-block-selected;
      }

      .file-overview iron-icon {
        margin-top: 0.1em;
      }

      .name {
        font-weight: bold;
        word-break: break-all;
      }

      .size {
        font-size: .8rem;
        opacity: .3;
        padding: .1em .5em;
        white-space: nowrap;
      }

      .wrap.baseline {
        align-items: baseline;
      }

      .complete {
        background-color: var(--nuxeo-validated);
        border-radius: 2em;
        width: 1.5em;
        position: absolute;
        right: 1.5em;
        top: .8em;
        text-align: center;
      }

      .complete iron-icon  {
        width: 1.2em;
        height: 1.3em;
      }

      .provider {
        color: var(--nuxeo-primary-color);
      }

      .dropzone-label {
        cursor: pointer;
        margin: 16px 0 48px 0;
      }

      .dropzone-heading {
        font-weight: bold;
        margin: 4px 8px;
        padding: 4px 8px;
        width: 100%;
      }

      .disclaimer {
        display: block;
        font-weight: normal;
        font-size: .75rem;
        opacity: .3;
      }

      .clear {
        width: 3em;
        text-align: right;
      }

      .clear paper-icon-button {
        padding: 0 0 1em .5em;
      }

      .file-to-import:last-of-type {
        margin-bottom: 3em;
      }

      .disclaimer.checked,
      .disclaimer.hidden {
        visibility: hidden;
      }

      .add-more {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        text-align: center;
        background-color: var(--nuxeo-box);
        padding: .5em;
      }

      .buttons {
        @apply --buttons-bar;
      }

      .add-more .importActions {
        margin-left: 8px;
      }

      .importActions > * {
        margin-left: 8px;
      }

      @media (max-width: 1024px) {
        .file-to-import {
          width: calc(100% - 2em);
        }
      }

      .error {
        border-left: 4px solid var(--nuxeo-warn-text);
        color: var(--primary-text-color);
        padding-left: 8px;
      }

      .importing-label {
        margin-right: 8px;
      }

      iron-pages,
      div[name="upload"] ,
      div[name="customize"] {
        /*Firefox fix (NXP-22349)*/
        min-height: 100%;
      }
      div[name="upload"] {
        outline: none;
      }

    </style>

    <nuxeo-connection id="nx"></nuxeo-connection>
    <nuxeo-resource id="blobRemover"></nuxeo-resource>
    <nuxeo-operation id="fileManagerImport" op="FileManager.Import" sync-indexing=""></nuxeo-operation>
    <nuxeo-document id="docRequest" doc-path="[[targetPath]]" data="[[document]]" sync-indexing="" headers="{&quot;X-Batch-No-Drop&quot;: &quot;true&quot;}" response="{{createResponse}}"></nuxeo-document>
    <nuxeo-document id="parentFetcher" doc-path="[[targetPath]]"></nuxeo-document>

    <iron-a11y-keys keys="enter" on-keys-pressed="_submitKeyHandler"></iron-a11y-keys>

    <iron-pages selected="[[stage]]" attr-for-selected="name" class="vertical layout flex">

      <div name="upload" class="upload vertical layout flex" tabindex="0">

        <div class="suggester">
          <nuxeo-path-suggestion id="pathSuggesterUpload" label="[[i18n('documentImportForm.location')]]" value="{{targetPath}}" parent="{{suggesterParent}}" children="{{suggesterChildren}}" disabled="" always-float-label=""></nuxeo-path-suggestion>
          <span class$="horizontal layout [[_formatErrorMessage(errorMessage)]]">[[errorMessage]]</span>
        </div>

        <div id="dropzone" class="vertical layout flex">
          <input hidden="" id="uploadFiles" type="file" on-change="_filesChanged" multiple="">
          <template is="dom-if" if="[[!hasFiles]]">
            <div class="vertical layout center center-justified flex">
              <div class="dropzone-label horizontal layout center center-justified">
                <a href="javascript:undefined" on-tap="_showUploadDialog">
                  [[i18n('documentImportForm.clickOrDrop')]]</a>
              </div>
              <span hidden$="[[!_hasVisibleContributions]]">[[i18n('documentImportForm.linkFilesFrom')]]</span>
              <div class="importActions horizontal layout wrap">
                <nuxeo-slot slot="FILE_UPLOAD_ACTIONS" empty="{{!hasContributions}}"></nuxeo-slot>
              </div>
            </div>
          </template>
          <template is="dom-if" if="[[hasFiles]]" restamp="">
            <paper-dialog-scrollable>
              <div class="vertical layout flex">
                <div class="horizontal layout wrap baseline">
                  <span class="dropzone-heading" hidden$="[[!_showDropzoneFileHeadings(hasLocalFiles,hasRemoteFiles)]]">
                    [[i18n('documentImportForm.localFiles')]]
                  </span>
                  <template is="dom-repeat" items="[[localFiles]]" as="file">
                    <div class="file-to-import horizontal layout">
                      <div class="vertical layout flex">
                        <div class="horizontal layout">
                          <div class="name">
                            [[file.name]]
                          </div>
                          <span class="size">
                            [[formatSize(file.size)]]
                          </span>
                        </div>
                        <template is="dom-if" if="[[file.providerName]]">
                          <div class="provider">
                            [[file.providerName]]
                          </div>
                        </template>
                        <template is="dom-if" if="[[!file.complete]]">
                          <paper-progress indeterminate="[[!hasProgress()]]" value="[[file.progress]]"></paper-progress>
                        </template>
                      </div>
                      <div class="clear" hidden$="[[!file.complete]]">
                        <paper-icon-button icon="nuxeo:remove" on-tap="_removeBlob"></paper-icon-button>
                        <nuxeo-tooltip>[[i18n('command.remove')]]</nuxeo-tooltip>
                      </div>
                    </div>
                  </template>
                  <span class="dropzone-heading" hidden$="[[!_showDropzoneFileHeadings(hasLocalFiles,hasRemoteFiles)]]">
                    [[i18n('documentImportForm.remoteFiles')]]
                  </span>
                  <template is="dom-repeat" items="[[remoteFiles]]" as="file">
                    <div class="file-to-import horizontal layout">
                      <div class="vertical layout flex">
                        <div class="horizontal layout center">
                          <div class="name">
                            [[file.name]]
                          </div>
                          <span class="size">
                            [[formatSize(file.size)]]
                          </span>
                        </div>
                        <div class="provider">
                          [[file.providerName]]
                        </div>
                      </div>
                      <div class="horizontal layout center">
                        <paper-icon-button icon="nuxeo:remove" on-tap="_removeBlob"></paper-icon-button>
                        <nuxeo-tooltip>[[i18n('command.remove')]]</nuxeo-tooltip>
                      </div>
                    </div>
                  </template>
                </div>
              </div>
            </paper-dialog-scrollable>
            <div class="horizontal layout center end-justified" hidden$="!hasFiles">
              <div class="add-more horizontal layout center">
                <a href="javascript:undefined" on-tap="_showUploadDialog">Add more files</a>
                <span hidden$="[[!_hasVisibleContributions]]">&nbsp;[[i18n('documentImportForm.linkFilesFrom')]]&nbsp;</span>
                <div class="importActions horizontal layout wrap">
                  <nuxeo-slot slot="FILE_UPLOAD_ACTIONS" empty="{{!hasContributions}}"></nuxeo-slot>
                </div>
              </div>
            </div>
          </template>
        </div>
        <div class="buttons horizontal end-justified layout">
          <div class="flex start-justified">
            <paper-button noink="" dialog-dismiss="" on-tap="_cancel" hidden$="[[_creating]]">[[i18n('command.cancel')]]</paper-button>
          </div>
          <paper-button noink="" id="edit" class="primary" on-tap="_toggleCustomize" hidden$="[[!_canAddProperties(_creating,hasFiles,canCreate)]]">
                        [[i18n('documentImportForm.addProperties')]]
                      </paper-button>
          <paper-button noink="" id="create" class="primary" on-tap="_import" disabled$="[[!_canImport(_creating, hasLocalFilesUploaded,hasRemoteFiles,canCreate)]]">
                        <template is="dom-if" if="[[!_isUploadingOrImporting(_creating, hasLocalFiles, hasLocalFilesUploaded)]]">
                          [[i18n('command.create')]]
                        </template>
                        <template is="dom-if" if="[[_isUploadingOrImporting(_creating, hasLocalFiles, hasLocalFilesUploaded)]]">
                          <span class="importing-label" hidden$="[[_creating]]">[[i18n('documentImport.uploading')]]</span>
                          <span class="importing-label" hidden$="[[!_creating]]">[[i18n('documentImport.importing')]]</span>
                          <paper-spinner-lite active=""></paper-spinner-lite>
                        </template>
                      </paper-button>
        </div>
      </div>

      <div name="customize" class="vertical layout flex">
        <div class="horizontal layout flex">
          <paper-dialog-scrollable id="blobEditor">
            <div class="suggester">
              <nuxeo-path-suggestion id="pathSuggesterCustomize" label="[[i18n('documentImportForm.location')]]" value="{{targetPath}}" parent="{{suggesterParent}}" children="{{suggesterChildren}}" disabled="" always-float-label=""></nuxeo-path-suggestion>
              <span class$="horizontal layout [[_formatErrorMessage(errorMessage)]]">[[errorMessage]]</span>
            </div>
            <iron-form id="form">
              <form class="form vertical layout flex">
                <div class="horizontal layout center">
                  <div class="flex">
                    <nuxeo-select id="docTypeDropdown" selected="{{selectedDocType}}" attr-for-selected="key" label="[[i18n('documentImportForm.type.label')]]" placeholder="[[i18n('documentImportForm.type.placeholder')]]" error-message="[[i18n('documentImportForm.type.error')]]" required="">
                      <template is="dom-repeat" items="[[_importDocTypes]]" as="type">
                        <paper-item key="[[type]]">[[_getTypeLabel(type)]]</paper-item>
                      </template>
                    </nuxeo-select>
                  </div>
                </div>
                <template is="dom-if" if="[[document]]" restamp="">
                  <nuxeo-document-layout id="document-import" layout="import" document="[[document]]"></nuxeo-document-layout>
                </template>
              </form>
            </iron-form>
          </paper-dialog-scrollable>
          <paper-dialog-scrollable id="sidePanel">
            <div id="blobList" class="flex">
              <template is="dom-repeat" items="[[localFiles]]" as="file">
                <paper-button noink="" class$="file-overview horizontal layout [[_selectedLocalDocStyle(index,docIdx)]]" on-tap="_tapLocalDoc">
                  <div class="horizontal layout flex">
                    <div class="vertical layout flex">
                      <span class="name flex" hidden$="[[file.title]]">[[file.name]]</span>
                      <span class="name flex" hidden$="[[!file.title]]">[[file.title]]</span>
                      <span class$="disclaimer [[_styleFileCheck(file.*)]]">
                        [[i18n('documentImportForm.unchecked.disclaimer')]]
                      </span>
                      <template is="dom-if" if="[[!file.complete]]">
                        <paper-progress indeterminate=""></paper-progress>
                      </template>
                    </div>
                    <iron-icon icon="icons:check-circle" class$="blobCheck [[_styleFileCheck(file.*)]]" on-tap="_checkTappedLocal"></iron-icon>
                  </div>
                </paper-button>
              </template>
              <template is="dom-repeat" items="[[remoteFiles]]" as="file">
                <paper-button noink="" class$="file-overview horizontal layout [[_selectedLocalDocStyle(index,docIdx)]]" on-tap="_tapLocalDoc">
                  <div class="horizontal layout flex">
                    <div class="vertical layout flex">
                      <span class="name flex" hidden$="[[file.title]]">[[file.name]]</span>
                      <span class="name flex" hidden$="[[!file.title]]">[[file.title]]</span>
                      <span class$="disclaimer [[_styleFileCheck(file.*)]]">
                        [[i18n('documentImportForm.unchecked.disclaimer')]]
                      </span>
                    </div>
                    <iron-icon icon="icons:check-circle" class$="blobCheck [[_styleFileCheck(file.*)]]" on-tap="_checkTappedRemote"></iron-icon>
                  </div>
                </paper-button>
              </template>
              <span class="horizontal layout error" hidden$="[[!_importWithPropertiesError]]">[[_importWithPropertiesError]]</span>
            </div>
          </paper-dialog-scrollable>
        </div>
        <div class="buttons horizontal end-justified layout">
          <div class="flex start-justified">
            <paper-button noink="" dialog-dismiss="" on-tap="_cancel" hidden$="[[_creating]]">[[i18n('command.cancel')]]</paper-button>
          </div>

          <paper-button noink="" on-tap="_previousFile" hidden$="[[!_hasPreviousFile(_creating,canCreate,customizing,docIdx)]]">
                        &nbsp;[[i18n('documentImportForm.previousDocument')]]
                      </paper-button>
          <paper-button noink="" class="primary" on-tap="_nextFile" hidden$="[[!_hasNextFile(_creating,canCreate,customizing,docIdx)]]">
                        [[i18n('documentImportForm.nextDocument')]]&nbsp;
                      </paper-button>

          <paper-button noink="" class="primary" on-tap="_applyToAll" hidden$="[[!_canApplyToAll(_creating,canCreate,customizing,docIdx)]]">
                        [[i18n('documentImportForm.applyToAll')]]
                      </paper-button>

          <paper-button noink="" class="primary" on-tap="_importWithProperties" disabled$="[[!_canImportWithMetadata(_creating,canCreate,hasLocalFilesUploaded,hasRemoteFiles,localFiles.*,remoteFiles.*)]]">
                        <template is="dom-if" if="[[_canImport(_creating, hasLocalFilesUploaded,hasRemoteFiles,canCreate)]]">
                          [[i18n('command.create')]]
                        </template>
                        <template is="dom-if" if="[[!_canImport(_creating, hasLocalFilesUploaded,hasRemoteFiles,canCreate)]]">
                          <span class="importing-label" hidden$="[[_creating]]">[[i18n('documentImport.uploading')]]</span>
                          <span class="importing-label" hidden$="[[!_creating]]">[[i18n('documentImport.importing')]]</span>
                          <paper-spinner-lite active=""></paper-spinner-lite>
                        </template>
                      </paper-button>
        </div>
      </div>
    </iron-pages>

    <nuxeo-document-creation-stats id="creationStats"></nuxeo-document-creation-stats>

  </template>

  <script>
    Polymer({
      is: 'nuxeo-document-import',
      behaviors: [Polymer.IronResizableBehavior, Nuxeo.UploaderBehavior, Nuxeo.DocumentCreationBehavior],
      properties: {

        batchAppend: {
          value: true
        },

        stage: {
          type: String,
          value: 'upload'
        },

        docIdx: {
          type: Number,
          value: -1
        },

        localFiles: {
          type: Array,
          value: []
        },

        remoteFiles: {
          type: Array,
          value: []
        },

        selectedDocType: {
          type: String,
          observer: '_selectedDocTypeChanged'
        },

        documentBlobProperties: {
          type: Object,
          value: {
            default: 'file:content',
            note: 'note:note'
          }
        },

        hasLocalFiles: {
          type: Boolean,
          value: false,
          notify: true
        },

        hasRemoteFiles: {
          type: Boolean,
          value: false,
          notify: true
        },

        hasFiles: {
          type: Boolean,
          value: false,
          computed: '_computeHasFiles(hasLocalFiles,hasRemoteFiles)'
        },

        visible: {
          type: Boolean
        },

        _doNotCreate: {
          type: Boolean,
          value: false
        },

        _docProperties: {
          type: Object,
          value: {}
        },

        _hasVisibleContributions: {
          type: Boolean
        },

        _importDocTypes: {
          type: Array,
          computed: '_computeImportDocTypes(subtypes)'
        },

        _creating: {
          type: Boolean,
          value: false
        },

        _importWithPropertiesError: String

      },
      listeners: {
        'batchFinished': '_batchReady',
        'nx-blob-picked': '_blobPicked',
        'nx-document-creation-parent-validated': '_parentValidated'
      },
      observers: [
        '_observeFiles(files.*)',
        '_observeRemoteFiles(remoteFiles.splices)',
        '_visibleOnStage(visible,stage)'
      ],

      ready: function() {
        this.connection = this.$.nx;
        this.setupDropZone(this.$.dropzone);
        this._clear();
        this.addEventListener('element-changed', this._layoutUpdated.bind(this), true);
      },

      init: function(files) {
        if (files) {
          this.uploadFiles(files);
        }
        this.set('_hasVisibleContributions',
                  this.hasContributions && !!this.$$('.importActions > *:not([hidden]):not(nuxeo-slot)'));
      },

      _observeFiles: function(changeRecord) {
        if (changeRecord) {
          if (changeRecord.path === 'files.splices' && changeRecord.value && changeRecord.value.indexSplices) {
            changeRecord.value.indexSplices.forEach(function(s) {
              for (var i = 0; i < s.addedCount; i++) {
                var index = s.index + i;
                this.push('localFiles', this.files[index]);
              }
            }, this);
            this.hasLocalFiles = this.localFiles && this.localFiles.length > 0;
            this.hasLocalFilesUploaded = false;
          } else {
            var match = changeRecord.path.match(/(files\.\d+)\.(\w+)/);
            if (match) {
              // this is needed because the client doesn't account for removed blobs
              var localFilesIdx = this.localFiles.indexOf(this.get(match[1]));
              // hack: refresh on the dom repeat
              this.notifyPath(['localFiles', localFilesIdx, match[2]].join('.'));
              if (match[2] === 'complete') {
                this.hasLocalFilesUploaded = this.hasLocalFiles && this.localFiles.every(function(file) {
                  return !file || file.complete;
                });
              }
            }
          }
        }
      },

      _observeRemoteFiles: function() {
        this.hasRemoteFiles = this.remoteFiles && this.remoteFiles.length > 0;
      },

      _showDropzoneFileHeadings: function() {
        return this.hasLocalFiles && this.hasRemoteFiles;
      },

      _canImport: function() {
        return (this.hasLocalFiles ? this.hasLocalFilesUploaded : this.hasRemoteFiles)
          && this.canCreate && !this._creating;
      },

      _isUploadingOrImporting: function() {
        return this._creating || (this.hasLocalFiles ? !this.hasLocalFilesUploaded : false);
      },

      _canImportWithMetadata: function() {
        return this._getAllFiles().every(function(file) {
          return 'checked' in file
        }) && this._canImport();
      },

      _canAddProperties: function() {
        return this.hasFiles && this.canCreate && !this._creating;
      },

      _showUploadDialog: function() {
        this.$.uploadFiles.click();
      },

      _filesChanged: function(e) {
        this.uploadFiles(e.target.files);
      },

      _selectedDocTypeChanged: function() {
        this._validate();
      },

      _toggleCustomize: function() {
        if (this.stage === 'upload') {
          this.stage = 'customize';
          this.customizing = true;
          this.set('selectedDocType', '');
          this.fire('nx-creation-wizard-hide-tabs');
          this._selectDoc(0);
        } else {
          this.stage = 'upload';
          this.customizing = false;
          this.fire('nx-creation-wizard-show-tabs');
        }
      },

      _computeHasFiles: function() {
        return this.hasLocalFiles || this.hasRemoteFiles;
      },

      _getAllFiles: function() {
        if (this.localFiles && this.remoteFiles) {
          return this.localFiles.concat(this.remoteFiles);
        } else {
          return this.localFiles ? this.localFiles : this.remoteFiles;
        }
      },

      _getTotalFileCount: function() {
        return (this.localFiles ? this.localFiles.length : 0) + (this.remoteFiles ? this.remoteFiles.length : 0);
      },

      _getCurrentFile: function() {
        var arr = this._getAllFiles();
        return arr[this.docIdx];
      },

      _isValidFileIndex: function(index) {
        var length = this._getTotalFileCount();
        return length > 0 && index >= 0 && index < length;
      },

      _getFile: function(index) {
        if (this._isValidFileIndex(index)) {
          return this._getAllFiles()[index];
        }
      },

      _setFileProp: function(index, prop, value) {
        if (this._isValidFileIndex(index)) {
          var pos = index;
          var arr = 'localFiles';
          if (pos >= this.localFiles.length) {
            arr = 'remoteFiles';
            pos = pos - this.localFiles.length;
          }
          this._setFilePropEx(arr, pos, prop, value);
        }
      },

      _setFilePropEx: function(arrName, index, prop, value) {
        this.set([arrName, index,prop].join('.'), value);
      },

      _getCurrentFileTitle: function() {
        var currentFile = this._getCurrentFile();
        return currentFile ? currentFile.name : '';
      },

      _getRemainingDocs: function() {
        var count = this._getTotalFileCount();
        return count > 1 ? this.i18n('documentImportForm.addProperties.otherDocuments', count - 1 - this.docIdx) : '';
      },

      _copyFileData: function(originIdx, destIdx) {
        var originFile = this._getFile(originIdx);
        var destFile = this._getFile(destIdx);
        var docData = originFile.docData;
        var copiedDocData = {};

        if (docData && Object.keys(docData).length > 0) {
          copiedDocData = JSON.parse(JSON.stringify(docData));
        }
        copiedDocData.document.properties['dc:title'] = destFile.name;
        this._setFileProp(destIdx, 'docData', copiedDocData);
        this._setFileProp(destIdx, 'checked', true);
      },

      _storeFile: function(index) {
        if (this._isValidFileIndex(index)) {
          var pos = index;
          var propName = 'localFiles';
          if (pos >= this.localFiles.length) {
            propName = 'remoteFiles';
            pos = pos - this.localFiles.length;
          }
          this.set([propName, pos, 'docData'].join('.'), {
            parent: this.targetPath,
            document: JSON.parse(JSON.stringify(this.document)),
            type: this.selectedDocType,
          });
          this.set([propName, pos, 'sanitizedName'].join('.'),
                    this._sanitizeName(this.document.properties['dc:title']));
          this.set([propName, pos, 'title'].join('.'), this.document.properties['dc:title']);
        }
      },

      _loadFile: function(docData, title) {
        var properties = {};
        if (docData && Object.keys(docData).length > 0) {
          this.targetPath = docData.parent;
          this.selectedDocType = this._importDocTypes.find(function(type) {
            return type.id === docData.type.id;
          });
          properties = JSON.parse(JSON.stringify(docData.document)).properties;
        }
        if (title) {
          properties['dc:title'] = title;
        }
        this._docProperties = properties;
        this._updateDocument();
      },

      _nextFile: function() {
        if (this._hasNextFile()) {
          this._selectDoc(this.docIdx + 1);
        }
      },

      _previousFile: function() {
        if (this._hasPreviousFile()) {
          this._selectDoc(this.docIdx - 1);
        }
      },

      _hasNextFile: function() {
        var length = this._getTotalFileCount();
        return length > 1 && this.docIdx < length - 1 && this.canCreate && !this._creating;
      },

      _hasPreviousFile: function() {
        var length = this._getTotalFileCount();
        return length > 1 && this.docIdx > 0  && this.canCreate && !this._creating;
      },

      _selectDoc: function(index) {
        if (!this._isValidFileIndex(index)) {
          throw 'invalid file index: ' + index;
        } else if (this.docIdx !== index && (this.docIdx < 0 || this._validate())) {
          if (this.docIdx > -1) {
            this._storeFile(this.docIdx);
          }
          var previousFile = this._getCurrentFile();
          this.docIdx = index;
          var currentFile = this._getCurrentFile();
          if (currentFile.checked) {
            // load the file's own data
            this._loadFile(currentFile.docData);
          } else if (previousFile) {
            // load the previous file's data
            this._loadFile(previousFile.docData, currentFile.name);
          } else {
            this._loadFile({}, currentFile.name);
          }
          if (!('checked' in currentFile)) {
            this._setFileProp(index, 'checked', true);
          }
        }
      },

      _validate: function() {
        // run our custom validation function first to allow setting custom native validity
        var layout = this.$$('#document-import');

        // run our custom validation function first to allow setting custom native validity
        var result = (!layout || layout.validate()) && this._doNativeValidation(this.$.form) && this.$.form.validate();

        if (result || !layout) {
          return result;
        } else {
          var innerLayout = layout.$.layout;
          var nodes = innerLayout._getValidatableElements(innerLayout.element.root);
          var invalidField = nodes.find(function(node) {
            return node.invalid;
          });
          if (invalidField) {
            invalidField.scrollIntoView();
            invalidField.focus();
          }
        }
      },

      _tapLocalDoc: function(e) {
        if (this.canCreate) {
          this._selectDoc(e.model.index);
        }
      },

      _tapRemoteDoc: function(e) {
        if (this.canCreate) {
          this._selectDoc(e.model.index + this.localFiles.length);
        }
      },

      _selectedLocalDocStyle: function(index) {
        return index === this.docIdx ? 'selected' : '';
      },

      _selectedRemoteDocStyle: function(index) {
        return (index + this.localFiles.length) === this.docIdx ? 'selected' : '';
      },

      _cancel: function() {
        if (this.batchId) {
          this.cancelBatch();
        }
        this._clear();
        this.stage = 'upload';
        this.fire('nx-creation-wizard-show-tabs');
      },

      _clear: function() {
        this.stage = 'upload';
        this.files = [];
        this.localFiles = [];
        this.remoteFiles = [];
        this.hasLocalFilesUploaded = false;
        this.hasLocalFiles = false;
        this.hasRemoteFiles = false;
        this.properties = [];
        this.customizing = false;
        this.docIdx = -1;
        this._doNotCreate = false;
        this._docProperties = {};
        this._creating = false;
        this._importWithPropertiesError = '';
        this.$.uploadFiles.value = '';
      },

      _importWithProperties: function() {
        if (this._validate()) {
          this._creating = true;
          this._storeFile(this.docIdx);
          this._processFilesWithMetadata();
        }
      },

      _import: function() {
        this._creating = true;
        var params = {
          context: {
            currentDocument: this.targetPath
          }
        };
        var doLocal = this.batchId && this.localFiles && this.localFiles.length > 0;
        var doRemote = this.remoteFiles && this.remoteFiles.length > 0;
        if (doLocal && doRemote) {
          this._smartImportLocalFiles(params)
              .then(function(response1) {
                this._smartImportRemoteFiles(params).then(function(response2) {
                  this._handleSuccess(this._mergeResponses(response1, response2));
                }.bind(this), this._handleError.bind(this));
              }.bind(this), this._handleError.bind(this));
        } else if (doLocal) {
          this._smartImportLocalFiles(params)
              .then(this._handleSuccess.bind(this), this._handleError.bind(this));
        } else {
          this._smartImportRemoteFiles(params)
              .then(this._handleSuccess.bind(this), this._handleError.bind(this));
        }
      },

      _handleSuccess: function(response, close) {
        if (close === undefined) {
          close = true;
        }
        this._notify(response, close);
        // store creation data
        if (response.entries && Array.isArray(response.entries)) {
          response.entries.forEach(function(f) {
            // XXX remove this to lower as soon as we get type information from the server
            this.$.creationStats.storeType(f.type.toLowerCase());
          }.bind(this));
        } else if (response.type) {
          this.$.creationStats.storeType(response.type);
        }
        if (close) {
          this.cancelBatch();
          this._clear();
          if (!response.entries || response.entries.length === 1) {
            this.navigateTo('browse', (response.entries ? response.entries[0] : response).path);
          } else {
            this.fire('document-updated');
            this.navigateTo('browse', this.targetPath);
          }
        }
      },

      _handleError: function(error) {
        this.set('_creating', false);
        this.set('errorMessage', this.i18n('documentImport.error.importFailed'));
        this.fire('notify', {message: this.i18n('label.error').toUpperCase() + ': ' + error.message});
      },

      _mergeResponses: function() {
        var response = {'entity-type': 'Documents', 'entries': []};
        for (var i = 0; i < arguments.length; i++) {
          var current = arguments[i];
          if (current && current.entries) {
            response.entries.concat(current.entries);
          } else {
            response.entries.push(current);
          }
        }
        return response;
      },

      _smartImportLocalFiles: function(params) {
        return this.batchExecute('FileManager.Import', params, {'nx_es_sync': 'true', 'X-Batch-No-Drop': 'true'});
      },

      _smartImportRemoteFiles: function(params) {
        this.$.fileManagerImport.input = 'blobs:' + this.remoteFiles.map(function(file) {
          return file.key;
        }).join();
        this.$.fileManagerImport.params = params;
        this.$.fileManagerImport.params.noMimeTypeCheck = true;
        return this.$.fileManagerImport.execute();
      },

      _processFilesWithMetadata: function() {
        this._importWithPropertiesError = '';
        var length = this._getTotalFileCount();
        var self = this;
        var promises = [];
        var localIndexes = [];
        var remoteIndexes = [];
        for (var i = 0; i < length; i++) {
          var arr = self.localFiles, index = i;
          if (i >= self.localFiles.length) {
            arr = self.remoteFiles;
            index = i - self.localFiles.length;
          }
          promises.push(
            (function(indexesToRemove, index){
              return ((arr[index].docData && arr[index].checked) ?
                        self._processFileWithMetadata(arr[index]) :
                        Promise.resolve({'entity-type': 'Documents', 'entries': []})).then(function(result) {
                          indexesToRemove.push(index);
                          return result;
                        }.bind(this)).catch(function(error) {
                          return error;
                        }.bind(this))
            }.bind(this))(i >= self.localFiles.length ? remoteIndexes : localIndexes, index));
        }
        Promise.all(promises).then(function(results) {
          var errorFree = results.filter(function(result) {
            return !(result instanceof Error);
          });
          this._handleSuccess(this._mergeResponses.apply(null, errorFree), !(errorFree.length < results.length));
          if (errorFree.length < results.length) {
            this.set('_creating', false);
            this.set('_importWithPropertiesError', 'These documents could not be created.');
            localIndexes.sort().reverse().forEach(function(index) {
              this.splice('localFiles', index, 1);
            }.bind(this));
            remoteIndexes.sort().reverse().forEach(function(index) {
              this.splice('remoteFiles', index, 1);
            }.bind(this));
            this._selectDoc(0);
          }

        }.bind(this));
      },

      _processFileWithMetadata: function(file) {
        this.document = file.docData.document;
        this.targetPath = file.docData.parent;
        this.document.name = file.sanitizedName || file.name;
        var blobProperty = this.documentBlobProperties[file.docData.type.id] ||
                           this.documentBlobProperties['default'];
        // XXX if fileData.type == Note, then the file's contents should be passed instead
        this.document.properties[blobProperty] = file.providerId ? {
          'providerId': file.providerId,
          'user': file.user,
          'fileId': file.fileId
        } : {
          'upload-batch': this.batchId,
          'upload-fileId': String(file.index)
        };
        return this.$.docRequest.post();
      },

      _removeBlob: function(e) {
        if (e.model.file.providerId) {
          this.splice('remoteFiles', e.model.index, 1);
        } else {
          this.$.blobRemover.path = 'upload/' + this.batchId + '/' + e.model.file.index;
          this.$.blobRemover.remove().then(function() {
            this.splice('localFiles', e.model.index, 1);
            this.hasLocalFiles = this.localFiles && this.localFiles.length > 0;
            this.$.uploadFiles.value = '';
          }.bind(this), this._handleError.bind(this));
        }
      },

      _batchReady: function(data) {
        data.stopPropagation();
        this.properties = [];
        for (var i = 0; i < this.localFiles.length; i++) {
          this.properties.push({});
        }
        var div = this.$$('div[name="upload"]');
        if (div) {
          div.focus();
        }
      },

      _blobPicked: function(e) {
        this.hasRemoteFiles = true;
        this.notifyPath('remoteFiles', this.remoteFiles.concat(e.detail.blobs));
      },

      _getDocumentProperties: function() {
        return this._docProperties;
      },

      _styleFileCheck: function(e) {
        return (e.base && ('checked' in e.base)) ? (e.base.checked ? 'checked' : 'unchecked') : 'hidden';
      },

      _checkTappedLocal: function(e) {
        e.stopPropagation();
        this._setFilePropEx('localFiles', e.model.index, 'checked', !e.model.file.checked);
      },

      _checkTappedRemote: function(e) {
        e.stopPropagation();
        this._setFilePropEx('remoteFiles', e.model.index, 'checked', !e.model.file.checked);
      },

      _canApplyToAll: function() {
        return this.customizing && this.docIdx === 0 && this._getTotalFileCount() > 1 &&
          this.canCreate && !this._creating;
      },

      _applyToAll: function() {
        var lastIdx = this._getTotalFileCount() - 1;
        if (this._isValidFileIndex(this.docIdx) && this._isValidFileIndex(lastIdx) && this._validate()) {
          this._storeFile(0);
          for (var i = 1; i <= lastIdx; i++) {
            this._copyFileData(0, i);
          }
          this._selectDoc(lastIdx);
        }
      },

      _filterImportDocTypes: function(type) {
        return window.nuxeo.importBlacklist.indexOf(type.type) === -1;
      },

      _computeImportDocTypes: function() {
        if (this.subtypes) {
          return this.subtypes.filter(this._filterImportDocTypes);
        }
      },

      _parentValidated: function() {
        if (this.canCreate && this._importDocTypes && this._importDocTypes.length === 0) {
          this.set('canCreate', false);
          this.set('errorMessage', this.i18n('documentImport.error.cannotImport'));
        }
      },

      _visibleOnStage: function() {
        this.$.pathSuggesterUpload.disabled = !this.visible || this.stage !== 'upload';
        this.$.pathSuggesterCustomize.disabled = !this.visible || this.stage !== 'customize';
      },

      /**
       * Retrieves and creates the layout for the current document type
       */
      _updateDocument: function() {

        if (!this._isValidType(this.selectedDocType) || !this.parent) {
          this.document = null;
          // prevent error message from being displayed the first time
          this.$.docTypeDropdown.invalid = false;
          return;
        }

        this.newDocument(this.selectedDocType.type, this._getDocumentProperties()).then(function(document) {
          document.parentRef = this.parent.uid;
          this.document = document;
        }.bind(this));
      },

      _layoutUpdated: function(e) {
        this.async(function() {
          var input = e.detail.value.querySelector('[autofocus]');
          if (input) {
            input.focus();
          }
        });
      },

      _submitKeyHandler: function(e) {
        if (this.stage === 'upload' && this._canImport()) {
          this._import();
        }
        if (this.stage === 'customize' && e.detail.keyboardEvent.target.tagName === 'INPUT') {
          if (this._hasNextFile()) {
            this._nextFile();
          } else if (this._canImportWithMetadata()) {
            this._importWithProperties();
          }
        }
      },

      // trigger native browser invalid-form UI
      _doNativeValidation: function(/*form*/) {
        /*var fakeSubmit = document.createElement('input');
        fakeSubmit.setAttribute('type', 'submit');
        fakeSubmit.style.display = 'none';
        form._form.appendChild(fakeSubmit);
        fakeSubmit.click();
        form._form.removeChild(fakeSubmit);
        return form._form.checkValidity();*/
        return true;
      }
    });
  </script>
</dom-module>
<dom-module id="nuxeo-delete-document-button" assetpath="bower_components/nuxeo-ui-elements/actions/">

  <template>
    <style include="nuxeo-action-button-styles"></style>

    <nuxeo-operation id="deleteOp" op="Document.Delete" input="[[document.uid]]" sync-indexing=""></nuxeo-operation>

    <nuxeo-operation id="trashOp" op="Document.Trash" input="[[document.uid]]" sync-indexing=""></nuxeo-operation>

    <dom-if if="[[_isAvailable(document)]]">
      <template>
        <div class="action" on-click="_delete">
          <paper-icon-button icon="[[icon]]" noink="" id="deleteButton"></paper-icon-button>
          <span class="label" hidden$="[[!showLabel]]">[[_label]]</span>
        </div>
        <nuxeo-tooltip>[[_label]]</nuxeo-tooltip>
      </template>
    </dom-if>

  </template>

  <script>
    {
      /**
       * A button element for moving document to trash (if available server side) or permanently delete if hard set to true.
       *
       * Example:
       *
       *     <nuxeo-delete-document-button document="[[document]]"></nuxeo-delete-document-button>
       *
       *     <nuxeo-delete-document-button document="[[document]]" hard></nuxeo-delete-document-button>
       *
       * @appliesMixin Nuxeo.I18nBehavior
       * @appliesMixin Nuxeo.FiltersBehavior
       * @memberof Nuxeo
       * @demo demo/nuxeo-delete-document-button/index.html
       */
      class DeleteDocumentButton
        extends Polymer.mixinBehaviors([Nuxeo.I18nBehavior, Nuxeo.FiltersBehavior], Nuxeo.Element) {

        static get is() {
          return 'nuxeo-delete-document-button';
        }

        static get properties() {
          return {
            /**
             * Input document.
             */
            document: Object,

            /**
             * Icon to use (iconset_name:icon_name).
             */
            icon: {
              type: String,
              value: 'nuxeo:delete',
              computed: '_computeIcon(hard)',
            },

            /**
             * Permanently delete the document.
             */
            hard: {
              type: Boolean,
              value: false,
            },

            /**
             * `true` if the action should display the label, `false` otherwise.
             */
            showLabel: {
              type: Boolean,
              value: false,
            },

            _label: {
              type: String,
              computed: '_computeLabel(hard, i18n)',
            },
          };
        }

        _isAvailable(doc) {
          return doc && !this.isVersion(doc) && this.hasPermission(doc, 'Write') && (!this.isTrashed(doc) || this.hard);
        }

        _computeIcon(hard) {
          return hard ? 'nuxeo:delete-permanently' : 'nuxeo:delete';
        }

        _computeLabel(hard) {
          return this.i18n(hard ? 'deleteButton.tooltip.permanently' : 'deleteButton.tooltip');
        }

        _delete() {
          if (!confirm(this.i18n('deleteButton.confirm'))) {
            return;
          }
          const op = this.hard ? this.$.deleteOp : this.$.trashOp;
          op.execute().then(() => {
            this.dispatchEvent(new CustomEvent('document-deleted', {
              composed: true,
              bubbles: true,
              detail: { doc: this.document },
            }));
          }).catch((error) => {
            this.dispatchEvent(new CustomEvent('document-deleted', {
              composed: true,
              bubbles: true,
              detail: { doc: this.document, error },
            }));
          });
        }

      }

      customElements.define(DeleteDocumentButton.is, DeleteDocumentButton);
      Nuxeo.DeleteDocumentButton = DeleteDocumentButton;
    }
  </script>

</dom-module>
<dom-module id="nuxeo-untrash-document-button" assetpath="bower_components/nuxeo-ui-elements/actions/">

  <template>
    <style include="nuxeo-action-button-styles"></style>

    <nuxeo-operation id="operation" op="Document.Untrash" input="[[document.uid]]" sync-indexing="">
    </nuxeo-operation>

    <dom-if if="[[_isAvailable(document)]]">
      <template>
        <div class="action" on-click="_untrash">
          <paper-icon-button icon="[[icon]]" noink="" id="untrashButton"></paper-icon-button>
          <span class="label" hidden$="[[!showLabel]]">[[_label]]</span>
        </div>
        <nuxeo-tooltip>[[_label]]</nuxeo-tooltip>
      </template>
    </dom-if>

  </template>

  <script>
    {
      /**
       * A button element to untrash a trashed document.
       *
       * Example:
       *
       *     <nuxeo-untrash-document-button document="[[document]]"></nuxeo-untrash-document-button>
       *
       * @appliesMixin Nuxeo.I18nBehavior
       * @appliesMixin Nuxeo.FiltersBehavior
       * @memberof Nuxeo
       * @demo demo/nuxeo-untrash-document-button/index.html
       */
      class UntrashDocumentButton
        extends Polymer.mixinBehaviors([Nuxeo.I18nBehavior, Nuxeo.FiltersBehavior], Nuxeo.Element) {

        static get is() {
          return 'nuxeo-untrash-document-button';
        }

        static get properties() {
          return {
            /**
             * Input document.
             */
            document: Object,

            /**
             * Icon to use (iconset_name:icon_name).
             */
            icon: {
              type: String,
              value: 'nuxeo:restore-deleted',
            },

            /**
             * `true` if the action should display the label, `false` otherwise.
             */
            showLabel: {
              type: Boolean,
              value: false,
            },

            _label: {
              type: String,
              computed: '_computeLabel(i18n)',
            },
          };
        }

        _isAvailable(doc) {
          return doc && this.isTrashed(doc) && this.hasPermission(doc, 'Write');
        }

        _computeLabel() {
          return this.i18n('untrashButton.tooltip');
        }

        _untrash() {
          this.$.operation.execute().then((res) => {
            this.dispatchEvent(new CustomEvent('document-untrashed', {
              composed: true,
              bubbles: true,
              detail: { doc: res },
            }));
          }).catch((error) => {
            this.dispatchEvent(new CustomEvent('document-untrashed', {
              composed: true,
              bubbles: true,
              detail: { error },
            }));
          });
        }

      }

      customElements.define(UntrashDocumentButton.is, UntrashDocumentButton);
      Nuxeo.UntrashDocumentButton = UntrashDocumentButton;
    }
  </script>

</dom-module>
<dom-module id="nuxeo-confirm-button" assetpath="nuxeo-confirm-button/">

  <template>
    <style include="nuxeo-styles">
      :host {
        display: block;
      }

      .title {
        margin: 16px;
        text-align: center;
      }

      .dialog {
        margin: 0;
        padding: 0;
        border-radius: 4px;
      }

      .actions {
        @apply --layout-horizontal;
        @apply --layout-justified;
        margin: 8px;
        padding: 0;
        text-align: right;
      }
    </style>

    <paper-button noink="" id="button" class="primary" on-tap="_toggleDialog">
      <slot></slot>
    </paper-button>

    <nuxeo-dialog id="dialog" class="dialog" no-overlap="" horizontal-align="auto" vertical-align="auto" on-iron-overlay-closed="_dismiss">
      <div class="title">[[dialogTitle]]</div>
      <div class="actions">
        <paper-button noink="" dialog-dismiss="">[[dialogDismiss]]</paper-button>
        <paper-button noink="" dialog-confirm="" class="primary" on-tap="_confirm">[[dialogConfirm]]</paper-button>
      </div>
    </nuxeo-dialog>

  </template>

  <script>
    Polymer({
      is: 'nuxeo-confirm-button',
      properties: {
        dialogTitle: {
          type: String,
          value: 'Are you sure?'
        },
        dialogConfirm: {
          type: String,
          value: 'Yes'
        },
        dialogDismiss: {
          type: String,
          value: 'No'
        },
        _model: {
          type: Object
        }
      },

      ready: function() {
        this.$.dialog.positionTarget = this.$.button;
      },

      _toggleDialog: function(e) {
        this._model = e.model;
        this.$.dialog.toggle();
      },

      _confirm: function() {
        this.fire('confirm', {model: this._model});
      },

      _dismiss: function() {
        this.fire('dismiss', {model: this._model});
      }

    });
  </script>

</dom-module>
<dom-module id="nuxeo-unpublish-button" assetpath="nuxeo-publication/">
  <template>
    <style>
      :host {
        display: inline-block;
      }

      nuxeo-confirm-button {
        display: inline-block;
      }

      nuxeo-confirm-button .label {
        font-weight: 500;
      }

    </style>

    <nuxeo-operation id="unpublishOp" op="Document.Delete" input="[[document]]" sync-indexing="">
    </nuxeo-operation>

    <template is="dom-if" if="[[_isAvailable(document)]]">
      <nuxeo-confirm-button dialog-title="[[i18n('publication.unpublish.confirm')]]" dialog-dismiss="[[i18n('label.no')]]" dialog-confirm="[[i18n('label.yes')]]" on-confirm="_unpublish">
        <span class="label">[[i18n('publication.unpublish')]]</span>
      </nuxeo-confirm-button>
    </template>

  </template>

  <script>
    Polymer({
      is: 'nuxeo-unpublish-button',
      behaviors: [Nuxeo.I18nBehavior, Nuxeo.RoutingBehavior, Nuxeo.FiltersBehavior],
      properties: {
        document: Object
      },

      _isAvailable: function() {
        return this.document && this.document.isProxy && this.hasPermission(this.document, 'Write');
      },

      _unpublish: function() {
        this.$.unpublishOp.execute().then(function() {
          this.fire('notify', {'message': this.i18n('publication.unpublish.success')});
          this.fire('nx-unpublish-success');
        }.bind(this)).catch(function() {
          this.fire('notify', {'message': this.i18n('publication.unpublish.error')});
        }.bind(this));
      }

    });
  </script>

</dom-module>
<dom-module id="nuxeo-publication-info-bar" assetpath="nuxeo-publication/">
  <template>
    <style include="nuxeo-styles iron-flex">
      :host {
        @apply --layout-horizontal;
        @apply --layout-center;
        @apply --layout-justified;
        padding: 8px;
        margin-bottom: 16px;
        box-shadow: 0 3px 5px rgba(0, 0, 0, 0.04);
        background-color: var(--nuxeo-box);
      }

      iron-icon {
        margin: 0 .5em;
        width: 1.5em;
      }
    </style>

    <nuxeo-document id="srcDoc" loading="{{loadingSrc}}">
    </nuxeo-document>

    <div class="layout horizontal" hidden$="[[loadingSrc]]">
      <iron-icon icon="icons:info"></iron-icon>
      <div>
        <a href$="[[_srcUrl(_src)]]" disabled$="[[_srcDeleted]]">
          [[_infoLabel(_srcDeleted)]]
        </a>
      </div>
    </div>
    <nuxeo-unpublish-button document="[[document]]"></nuxeo-unpublish-button>

  </template>

  <script>
    Polymer({
      is: 'nuxeo-publication-info-bar',
      behaviors: [Nuxeo.I18nBehavior, Nuxeo.FiltersBehavior, Nuxeo.RoutingBehavior],
      properties: {
        /**
         * Input document.
         */
        document: {
          type: Object,
          observer: '_updateSrc'
        },
        _redirectDoc: Object,
        _src: Object,
        _srcDeleted: Boolean
      },

      listeners: {
        'nx-unpublish-success': '_redirect'
      },

      _updateSrc: function() {
        this._src = null;
        this._srcDeleted = false;
        if (this.document && this.document.isProxy) {
          this.$.srcDoc.docId = this.document.properties['rend:sourceId'] || this.document.versionableId;
          this.$.srcDoc.get().then(function(src) {
            this._src = src;
            this._redirectDoc =
              (this.document.contextParameters && this.document.contextParameters.firstAccessibleAncestor) || src;
          }.bind(this)).catch(function(err) {
            if (err.status === 404) {
              this._srcDeleted = true;
              return;
            }
            throw err;
          }.bind(this));
        }
      },

      _redirect: function() {
        this.fire('navigate', {'doc': this._redirectDoc});
      },

      _infoLabel: function() {
        return this._srcDeleted ? this.i18n('publication.info.deleted'): this.i18n('publication.info', this.document.title);
      },

      _srcUrl: function() {
        return this._src ? this.urlFor('browse', this._src.path): null;
      }

    });
  </script>

</dom-module>
<dom-module id="nuxeo-restore-version-button" assetpath="nuxeo-restore-version-button/">
  <template>
    <style>
      :host {
        display: inline-block;
      }

      nuxeo-confirm-button {
        display: inline-block;
      }

      nuxeo-confirm-button .version {
        font-weight: 500;
        padding-left: 8px;
      }

    </style>

    <nuxeo-operation id="opGetLatest" op="Proxy.GetSourceDocument" input="[[document.uid]]" response="{{latest}}">
    </nuxeo-operation>

    <nuxeo-operation id="opRestoreVersion" op="Document.RestoreVersion" input="[[document.uid]]">
    </nuxeo-operation>

    <template is="dom-if" if="[[_isAvailable(latest)]]">
      <nuxeo-confirm-button dialog-title="[[i18n('versions.confirm.title')]]" dialog-dismiss="[[i18n('label.no')]]" dialog-confirm="[[i18n('label.yes')]]" on-confirm="_restore">
        [[i18n('versions.restore')]]
        <span class="version">[[document.properties.uid:major_version]].[[document.properties.uid:minor_version]]
        </span>
      </nuxeo-confirm-button>
    </template>

  </template>

  <script>
    Polymer({
      is: 'nuxeo-restore-version-button',
      behaviors: [Nuxeo.I18nBehavior, Nuxeo.RoutingBehavior],
      properties: {
        document: Object,
        latest: Object
      },
      observers: [
        '_update(document)'
      ],

      _update: function() {
        if (this.document.isVersion) {
          this.$.opGetLatest.execute();
        } else {
          this.latest = null;
        }
      },

      _isAvailable: function() {
        if (this.document && this.latest) {
          var v1 = this.document.properties['uid:major_version'] + '.' +
            this.document.properties['uid:minor_version'];
          var v2 = this.latest.properties['uid:major_version'] + '.' +
            this.latest.properties['uid:minor_version'];
          return v1 === v2 ? this.latest.isCheckedOut : true;
        }
        return false;
      },

      _restore: function() {
        if (this.document) {
          this.$.opRestoreVersion.input = this.document.uid;
          this.$.opRestoreVersion.params = {checkout: true};
          this.$.opRestoreVersion.execute().then(function() {
            this.fire('document-updated');
            this.navigateTo('browse', this.document.path);
          }.bind(this));
        }
      }

    });
  </script>

</dom-module>
<script>/**
 * jsBezier-0.7
 *
 * Copyright (c) 2010 - 2015 jsPlumb (hello@jsplumbtoolkit.com)
 *
 * licensed under the MIT license.
 *
 * a set of Bezier curve functions that deal with Beziers, used by jsPlumb, and perhaps useful for other people.  These functions work with Bezier
 * curves of arbitrary degree.
 *
 * - functions are all in the 'jsBezier' namespace.
 *
 * - all input points should be in the format {x:.., y:..}. all output points are in this format too.
 *
 * - all input curves should be in the format [ {x:.., y:..}, {x:.., y:..}, {x:.., y:..}, {x:.., y:..} ]
 *
 * - 'location' as used as an input here refers to a decimal in the range 0-1 inclusive, which indicates a point some proportion along the length
 * of the curve.  location as output has the same format and meaning.
 *
 *
 * Function List:
 * --------------
 *
 * distanceFromCurve(point, curve)
 *
 * 	Calculates the distance that the given point lies from the given Bezier.  Note that it is computed relative to the center of the Bezier,
 * so if you have stroked the curve with a wide pen you may wish to take that into account!  The distance returned is relative to the values
 * of the curve and the point - it will most likely be pixels.
 *
 * gradientAtPoint(curve, location)
 *
 * 	Calculates the gradient to the curve at the given location, as a decimal between 0 and 1 inclusive.
 *
 * gradientAtPointAlongCurveFrom (curve, location)
 *
 *	Calculates the gradient at the point on the given curve that is 'distance' units from location.
 *
 * nearestPointOnCurve(point, curve)
 *
 *	Calculates the nearest point to the given point on the given curve.  The return value of this is a JS object literal, containing both the
 *point's coordinates and also the 'location' of the point (see above), for example:  { point:{x:551,y:150}, location:0.263365 }.
 *
 * pointOnCurve(curve, location)
 *
 * 	Calculates the coordinates of the point on the given Bezier curve at the given location.
 *
 * pointAlongCurveFrom(curve, location, distance)
 *
 * 	Calculates the coordinates of the point on the given curve that is 'distance' units from location.  'distance' should be in the same coordinate
 * space as that used to construct the Bezier curve.  For an HTML Canvas usage, for example, distance would be a measure of pixels.
 *
 * locationAlongCurveFrom(curve, location, distance)
 *
 * 	Calculates the location on the given curve that is 'distance' units from location.  'distance' should be in the same coordinate
 * space as that used to construct the Bezier curve.  For an HTML Canvas usage, for example, distance would be a measure of pixels.
 *
 * perpendicularToCurveAt(curve, location, length, distance)
 *
 * 	Calculates the perpendicular to the given curve at the given location.  length is the length of the line you wish for (it will be centered
 * on the point at 'location'). distance is optional, and allows you to specify a point along the path from the given location as the center of
 * the perpendicular returned.  The return value of this is an array of two points: [ {x:...,y:...}, {x:...,y:...} ].
 *
 *
 */

(function() {

    var root = this;

    if(typeof Math.sgn == "undefined") {
        Math.sgn = function(x) { return x == 0 ? 0 : x > 0 ? 1 :-1; };
    }

    var Vectors = {
            subtract 	: 	function(v1, v2) { return {x:v1.x - v2.x, y:v1.y - v2.y }; },
            dotProduct	: 	function(v1, v2) { return (v1.x * v2.x)  + (v1.y * v2.y); },
            square		:	function(v) { return Math.sqrt((v.x * v.x) + (v.y * v.y)); },
            scale		:	function(v, s) { return {x:v.x * s, y:v.y * s }; }
        },

        maxRecursion = 64,
        flatnessTolerance = Math.pow(2.0,-maxRecursion-1);

    /**
     * Calculates the distance that the point lies from the curve.
     *
     * @param point a point in the form {x:567, y:3342}
     * @param curve a Bezier curve in the form [{x:..., y:...}, {x:..., y:...}, {x:..., y:...}, {x:..., y:...}].  note that this is currently
     * hardcoded to assume cubiz beziers, but would be better off supporting any degree.
     * @return a JS object literal containing location and distance, for example: {location:0.35, distance:10}.  Location is analogous to the location
     * argument you pass to the pointOnPath function: it is a ratio of distance travelled along the curve.  Distance is the distance in pixels from
     * the point to the curve.
     */
    var _distanceFromCurve = function(point, curve) {
        var candidates = [],
            w = _convertToBezier(point, curve),
            degree = curve.length - 1, higherDegree = (2 * degree) - 1,
            numSolutions = _findRoots(w, higherDegree, candidates, 0),
            v = Vectors.subtract(point, curve[0]), dist = Vectors.square(v), t = 0.0;

        for (var i = 0; i < numSolutions; i++) {
            v = Vectors.subtract(point, _bezier(curve, degree, candidates[i], null, null));
            var newDist = Vectors.square(v);
            if (newDist < dist) {
                dist = newDist;
                t = candidates[i];
            }
        }
        v = Vectors.subtract(point, curve[degree]);
        newDist = Vectors.square(v);
        if (newDist < dist) {
            dist = newDist;
            t = 1.0;
        }
        return {location:t, distance:dist};
    };
    /**
     * finds the nearest point on the curve to the given point.
     */
    var _nearestPointOnCurve = function(point, curve) {
        var td = _distanceFromCurve(point, curve);
        return {point:_bezier(curve, curve.length - 1, td.location, null, null), location:td.location};
    };
    var _convertToBezier = function(point, curve) {
        var degree = curve.length - 1, higherDegree = (2 * degree) - 1,
            c = [], d = [], cdTable = [], w = [],
            z = [ [1.0, 0.6, 0.3, 0.1], [0.4, 0.6, 0.6, 0.4], [0.1, 0.3, 0.6, 1.0] ];

        for (var i = 0; i <= degree; i++) c[i] = Vectors.subtract(curve[i], point);
        for (var i = 0; i <= degree - 1; i++) {
            d[i] = Vectors.subtract(curve[i+1], curve[i]);
            d[i] = Vectors.scale(d[i], 3.0);
        }
        for (var row = 0; row <= degree - 1; row++) {
            for (var column = 0; column <= degree; column++) {
                if (!cdTable[row]) cdTable[row] = [];
                cdTable[row][column] = Vectors.dotProduct(d[row], c[column]);
            }
        }
        for (i = 0; i <= higherDegree; i++) {
            if (!w[i]) w[i] = [];
            w[i].y = 0.0;
            w[i].x = parseFloat(i) / higherDegree;
        }
        var n = degree, m = degree-1;
        for (var k = 0; k <= n + m; k++) {
            var lb = Math.max(0, k - m),
                ub = Math.min(k, n);
            for (i = lb; i <= ub; i++) {
                j = k - i;
                w[i+j].y += cdTable[j][i] * z[j][i];
            }
        }
        return w;
    };
    /**
     * counts how many roots there are.
     */
    var _findRoots = function(w, degree, t, depth) {
        var left = [], right = [],
            left_count, right_count,
            left_t = [], right_t = [];

        switch (_getCrossingCount(w, degree)) {
            case 0 : {
                return 0;
            }
            case 1 : {
                if (depth >= maxRecursion) {
                    t[0] = (w[0].x + w[degree].x) / 2.0;
                    return 1;
                }
                if (_isFlatEnough(w, degree)) {
                    t[0] = _computeXIntercept(w, degree);
                    return 1;
                }
                break;
            }
        }
        _bezier(w, degree, 0.5, left, right);
        left_count  = _findRoots(left,  degree, left_t, depth+1);
        right_count = _findRoots(right, degree, right_t, depth+1);
        for (var i = 0; i < left_count; i++) t[i] = left_t[i];
        for (var i = 0; i < right_count; i++) t[i+left_count] = right_t[i];
        return (left_count+right_count);
    };
    var _getCrossingCount = function(curve, degree) {
        var n_crossings = 0, sign, old_sign;
        sign = old_sign = Math.sgn(curve[0].y);
        for (var i = 1; i <= degree; i++) {
            sign = Math.sgn(curve[i].y);
            if (sign != old_sign) n_crossings++;
            old_sign = sign;
        }
        return n_crossings;
    };
    var _isFlatEnough = function(curve, degree) {
        var  error,
            intercept_1, intercept_2, left_intercept, right_intercept,
            a, b, c, det, dInv, a1, b1, c1, a2, b2, c2;
        a = curve[0].y - curve[degree].y;
        b = curve[degree].x - curve[0].x;
        c = curve[0].x * curve[degree].y - curve[degree].x * curve[0].y;

        var max_distance_above = max_distance_below = 0.0;

        for (var i = 1; i < degree; i++) {
            var value = a * curve[i].x + b * curve[i].y + c;
            if (value > max_distance_above)
                max_distance_above = value;
            else if (value < max_distance_below)
                max_distance_below = value;
        }

        a1 = 0.0; b1 = 1.0; c1 = 0.0; a2 = a; b2 = b;
        c2 = c - max_distance_above;
        det = a1 * b2 - a2 * b1;
        dInv = 1.0/det;
        intercept_1 = (b1 * c2 - b2 * c1) * dInv;
        a2 = a; b2 = b; c2 = c - max_distance_below;
        det = a1 * b2 - a2 * b1;
        dInv = 1.0/det;
        intercept_2 = (b1 * c2 - b2 * c1) * dInv;
        left_intercept = Math.min(intercept_1, intercept_2);
        right_intercept = Math.max(intercept_1, intercept_2);
        error = right_intercept - left_intercept;
        return (error < flatnessTolerance)? 1 : 0;
    };
    var _computeXIntercept = function(curve, degree) {
        var XLK = 1.0, YLK = 0.0,
            XNM = curve[degree].x - curve[0].x, YNM = curve[degree].y - curve[0].y,
            XMK = curve[0].x - 0.0, YMK = curve[0].y - 0.0,
            det = XNM*YLK - YNM*XLK, detInv = 1.0/det,
            S = (XNM*YMK - YNM*XMK) * detInv;
        return 0.0 + XLK * S;
    };
    var _bezier = function(curve, degree, t, left, right) {
        var temp = [[]];
        for (var j =0; j <= degree; j++) temp[0][j] = curve[j];
        for (var i = 1; i <= degree; i++) {
            for (var j =0 ; j <= degree - i; j++) {
                if (!temp[i]) temp[i] = [];
                if (!temp[i][j]) temp[i][j] = {};
                temp[i][j].x = (1.0 - t) * temp[i-1][j].x + t * temp[i-1][j+1].x;
                temp[i][j].y = (1.0 - t) * temp[i-1][j].y + t * temp[i-1][j+1].y;
            }
        }
        if (left != null)
            for (j = 0; j <= degree; j++) left[j]  = temp[j][0];
        if (right != null)
            for (j = 0; j <= degree; j++) right[j] = temp[degree-j][j];

        return (temp[degree][0]);
    };

    var _curveFunctionCache = {};
    var _getCurveFunctions = function(order) {
        var fns = _curveFunctionCache[order];
        if (!fns) {
            fns = [];
            var f_term = function() { return function(t) { return Math.pow(t, order); }; },
                l_term = function() { return function(t) { return Math.pow((1-t), order); }; },
                c_term = function(c) { return function(t) { return c; }; },
                t_term = function() { return function(t) { return t; }; },
                one_minus_t_term = function() { return function(t) { return 1-t; }; },
                _termFunc = function(terms) {
                    return function(t) {
                        var p = 1;
                        for (var i = 0; i < terms.length; i++) p = p * terms[i](t);
                        return p;
                    };
                };

            fns.push(new f_term());  // first is t to the power of the curve order
            for (var i = 1; i < order; i++) {
                var terms = [new c_term(order)];
                for (var j = 0 ; j < (order - i); j++) terms.push(new t_term());
                for (var j = 0 ; j < i; j++) terms.push(new one_minus_t_term());
                fns.push(new _termFunc(terms));
            }
            fns.push(new l_term());  // last is (1-t) to the power of the curve order

            _curveFunctionCache[order] = fns;
        }

        return fns;
    };


    /**
     * calculates a point on the curve, for a Bezier of arbitrary order.
     * @param curve an array of control points, eg [{x:10,y:20}, {x:50,y:50}, {x:100,y:100}, {x:120,y:100}].  For a cubic bezier this should have four points.
     * @param location a decimal indicating the distance along the curve the point should be located at.  this is the distance along the curve as it travels, taking the way it bends into account.  should be a number from 0 to 1, inclusive.
     */
    var _pointOnPath = function(curve, location) {
        var cc = _getCurveFunctions(curve.length - 1),
            _x = 0, _y = 0;
        for (var i = 0; i < curve.length ; i++) {
            _x = _x + (curve[i].x * cc[i](location));
            _y = _y + (curve[i].y * cc[i](location));
        }

        return {x:_x, y:_y};
    };

    var _dist = function(p1,p2) {
        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
    };

    var _isPoint = function(curve) {
        return curve[0].x == curve[1].x && curve[0].y == curve[1].y;
    };

    /**
     * finds the point that is 'distance' along the path from 'location'.  this method returns both the x,y location of the point and also
     * its 'location' (proportion of travel along the path); the method below - _pointAlongPathFrom - calls this method and just returns the
     * point.
     */
    var _pointAlongPath = function(curve, location, distance) {

        if (_isPoint(curve)) {
            return {
                point:curve[0],
                location:location
            };
        }

        var prev = _pointOnPath(curve, location),
            tally = 0,
            curLoc = location,
            direction = distance > 0 ? 1 : -1,
            cur = null;

        while (tally < Math.abs(distance)) {
            curLoc += (0.005 * direction);
            cur = _pointOnPath(curve, curLoc);
            tally += _dist(cur, prev);
            prev = cur;
        }
        return {point:cur, location:curLoc};
    };

    var _length = function(curve) {
        if (_isPoint(curve)) return 0;

        var prev = _pointOnPath(curve, 0),
            tally = 0,
            curLoc = 0,
            direction = 1,
            cur = null;

        while (curLoc < 1) {
            curLoc += (0.005 * direction);
            cur = _pointOnPath(curve, curLoc);
            tally += _dist(cur, prev);
            prev = cur;
        }
        return tally;
    };

    /**
     * finds the point that is 'distance' along the path from 'location'.
     */
    var _pointAlongPathFrom = function(curve, location, distance) {
        return _pointAlongPath(curve, location, distance).point;
    };

    /**
     * finds the location that is 'distance' along the path from 'location'.
     */
    var _locationAlongPathFrom = function(curve, location, distance) {
        return _pointAlongPath(curve, location, distance).location;
    };

    /**
     * returns the gradient of the curve at the given location, which is a decimal between 0 and 1 inclusive.
     *
     * thanks // http://bimixual.org/AnimationLibrary/beziertangents.html
     */
    var _gradientAtPoint = function(curve, location) {
        var p1 = _pointOnPath(curve, location),
            p2 = _pointOnPath(curve.slice(0, curve.length - 1), location),
            dy = p2.y - p1.y, dx = p2.x - p1.x;
        return dy == 0 ? Infinity : Math.atan(dy / dx);
    };

    /**
     returns the gradient of the curve at the point which is 'distance' from the given location.
     if this point is greater than location 1, the gradient at location 1 is returned.
     if this point is less than location 0, the gradient at location 0 is returned.
     */
    var _gradientAtPointAlongPathFrom = function(curve, location, distance) {
        var p = _pointAlongPath(curve, location, distance);
        if (p.location > 1) p.location = 1;
        if (p.location < 0) p.location = 0;
        return _gradientAtPoint(curve, p.location);
    };

    /**
     * calculates a line that is 'length' pixels long, perpendicular to, and centered on, the path at 'distance' pixels from the given location.
     * if distance is not supplied, the perpendicular for the given location is computed (ie. we set distance to zero).
     */
    var _perpendicularToPathAt = function(curve, location, length, distance) {
        distance = distance == null ? 0 : distance;
        var p = _pointAlongPath(curve, location, distance),
            m = _gradientAtPoint(curve, p.location),
            _theta2 = Math.atan(-1 / m),
            y =  length / 2 * Math.sin(_theta2),
            x =  length / 2 * Math.cos(_theta2);
        return [{x:p.point.x + x, y:p.point.y + y}, {x:p.point.x - x, y:p.point.y - y}];
    };

    this.jsBezier = {
        distanceFromCurve : _distanceFromCurve,
        gradientAtPoint : _gradientAtPoint,
        gradientAtPointAlongCurveFrom : _gradientAtPointAlongPathFrom,
        nearestPointOnCurve : _nearestPointOnCurve,
        pointOnCurve : _pointOnPath,
        pointAlongCurveFrom : _pointAlongPathFrom,
        perpendicularToCurveAt : _perpendicularToPathAt,
        locationAlongCurveFrom:_locationAlongPathFrom,
        getLength:_length
    };
}).call(this);

/**
 * Biltong v0.2
 *
 * Various geometry functions written as part of jsPlumb and perhaps useful for others.
 *
 * Copyright (c) 2014 Simon Porritt
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */
;(function() {

	
	"use strict";

	var Biltong = this.Biltong = {};

	var _isa = function(a) { return Object.prototype.toString.call(a) === "[object Array]"; },
		_pointHelper = function(p1, p2, fn) {
		    p1 = _isa(p1) ? p1 : [p1.x, p1.y];
		    p2 = _isa(p2) ? p2 : [p2.x, p2.y];    
		    return fn(p1, p2);
		},
		/**
		* @name Biltong.gradient
		* @function
		* @desc Calculates the gradient of a line between the two points.
		* @param {Point} p1 First point, either as a 2 entry array or object with `left` and `top` properties.
		* @param {Point} p2 Second point, either as a 2 entry array or object with `left` and `top` properties.
		* @return {Float} The gradient of a line between the two points.
		*/
		_gradient = Biltong.gradient = function(p1, p2) {
		    return _pointHelper(p1, p2, function(_p1, _p2) { 
		        if (_p2[0] == _p1[0])
		            return _p2[1] > _p1[1] ? Infinity : -Infinity;
		        else if (_p2[1] == _p1[1]) 
		            return _p2[0] > _p1[0] ? 0 : -0;
		        else 
		            return (_p2[1] - _p1[1]) / (_p2[0] - _p1[0]); 
		    });		
		},
		/**
		* @name Biltong.normal
		* @function
		* @desc Calculates the gradient of a normal to a line between the two points.
		* @param {Point} p1 First point, either as a 2 entry array or object with `left` and `top` properties.
		* @param {Point} p2 Second point, either as a 2 entry array or object with `left` and `top` properties.
		* @return {Float} The gradient of a normal to a line between the two points.
		*/
		_normal = Biltong.normal = function(p1, p2) {
		    return -1 / _gradient(p1, p2);
		},
		/**
		* @name Biltong.lineLength
		* @function
		* @desc Calculates the length of a line between the two points.
		* @param {Point} p1 First point, either as a 2 entry array or object with `left` and `top` properties.
		* @param {Point} p2 Second point, either as a 2 entry array or object with `left` and `top` properties.
		* @return {Float} The length of a line between the two points.
		*/
		_lineLength = Biltong.lineLength = function(p1, p2) {
		    return _pointHelper(p1, p2, function(_p1, _p2) {
		        return Math.sqrt(Math.pow(_p2[1] - _p1[1], 2) + Math.pow(_p2[0] - _p1[0], 2));			
		    });
		},
		/**
		* @name Biltong.quadrant
		* @function
		* @desc Calculates the quadrant in which the angle between the two points lies. 
		* @param {Point} p1 First point, either as a 2 entry array or object with `left` and `top` properties.
		* @param {Point} p2 Second point, either as a 2 entry array or object with `left` and `top` properties.
		* @return {Integer} The quadrant - 1 for upper right, 2 for lower right, 3 for lower left, 4 for upper left.
		*/
		_quadrant = Biltong.quadrant = function(p1, p2) {
		    return _pointHelper(p1, p2, function(_p1, _p2) {
		        if (_p2[0] > _p1[0]) {
		            return (_p2[1] > _p1[1]) ? 2 : 1;
		        }
		        else if (_p2[0] == _p1[0]) {
		            return _p2[1] > _p1[1] ? 2 : 1;    
		        }
		        else {
		            return (_p2[1] > _p1[1]) ? 3 : 4;
		        }
		    });
		},
		/**
		* @name Biltong.theta
		* @function
		* @desc Calculates the angle between the two points. 
		* @param {Point} p1 First point, either as a 2 entry array or object with `left` and `top` properties.
		* @param {Point} p2 Second point, either as a 2 entry array or object with `left` and `top` properties.
		* @return {Float} The angle between the two points.
		*/
		_theta = Biltong.theta = function(p1, p2) {
		    return _pointHelper(p1, p2, function(_p1, _p2) {
		        var m = _gradient(_p1, _p2),
		            t = Math.atan(m),
		            s = _quadrant(_p1, _p2);
		        if ((s == 4 || s== 3)) t += Math.PI;
		        if (t < 0) t += (2 * Math.PI);
		    
		        return t;
		    });
		},
		/**
		* @name Biltong.intersects
		* @function
		* @desc Calculates whether or not the two rectangles intersect.
		* @param {Rectangle} r1 First rectangle, as a js object in the form `{x:.., y:.., w:.., h:..}`
		* @param {Rectangle} r2 Second rectangle, as a js object in the form `{x:.., y:.., w:.., h:..}`
		* @return {Boolean} True if the rectangles intersect, false otherwise.
		*/
		_intersects = Biltong.intersects = function(r1, r2) {
		    var x1 = r1.x, x2 = r1.x + r1.w, y1 = r1.y, y2 = r1.y + r1.h,
		        a1 = r2.x, a2 = r2.x + r2.w, b1 = r2.y, b2 = r2.y + r2.h;
		
			return  ( (x1 <= a1 && a1 <= x2) && (y1 <= b1 && b1 <= y2) ) ||
			        ( (x1 <= a2 && a2 <= x2) && (y1 <= b1 && b1 <= y2) ) ||
			        ( (x1 <= a1 && a1 <= x2) && (y1 <= b2 && b2 <= y2) ) ||
			        ( (x1 <= a2 && a1 <= x2) && (y1 <= b2 && b2 <= y2) ) ||	
			        ( (a1 <= x1 && x1 <= a2) && (b1 <= y1 && y1 <= b2) ) ||
			        ( (a1 <= x2 && x2 <= a2) && (b1 <= y1 && y1 <= b2) ) ||
			        ( (a1 <= x1 && x1 <= a2) && (b1 <= y2 && y2 <= b2) ) ||
			        ( (a1 <= x2 && x1 <= a2) && (b1 <= y2 && y2 <= b2) );
		},
		/**
		* @name Biltong.encloses
		* @function
		* @desc Calculates whether or not r2 is completely enclosed by r1.
		* @param {Rectangle} r1 First rectangle, as a js object in the form `{x:.., y:.., w:.., h:..}`
		* @param {Rectangle} r2 Second rectangle, as a js object in the form `{x:.., y:.., w:.., h:..}`
		* @param {Boolean} [allowSharedEdges=false] If true, the concept of enclosure allows for one or more edges to be shared by the two rectangles.
		* @return {Boolean} True if r1 encloses r2, false otherwise.
		*/
		_encloses = Biltong.encloses = function(r1, r2, allowSharedEdges) {
			var x1 = r1.x, x2 = r1.x + r1.w, y1 = r1.y, y2 = r1.y + r1.h,
		        a1 = r2.x, a2 = r2.x + r2.w, b1 = r2.y, b2 = r2.y + r2.h,
				c = function(v1, v2, v3, v4) { return allowSharedEdges ? v1 <= v2 && v3>= v4 : v1 < v2 && v3 > v4; };
				
			return c(x1,a1,x2,a2) && c(y1,b1,y2,b2);
		},
		_segmentMultipliers = [null, [1, -1], [1, 1], [-1, 1], [-1, -1] ],
		_inverseSegmentMultipliers = [null, [-1, -1], [-1, 1], [1, 1], [1, -1] ],
		/**
		* @name Biltong.pointOnLine
		* @function
		* @desc Calculates a point on the line from `fromPoint` to `toPoint` that is `distance` units along the length of the line.
		* @param {Point} p1 First point, either as a 2 entry array or object with `left` and `top` properties.
		* @param {Point} p2 Second point, either as a 2 entry array or object with `left` and `top` properties.
		* @return {Point} Point on the line, in the form `{ x:..., y:... }`.
		*/
		_pointOnLine = Biltong.pointOnLine = function(fromPoint, toPoint, distance) {
		    var m = _gradient(fromPoint, toPoint),
		        s = _quadrant(fromPoint, toPoint),
		        segmentMultiplier = distance > 0 ? _segmentMultipliers[s] : _inverseSegmentMultipliers[s],
		        theta = Math.atan(m),
		        y = Math.abs(distance * Math.sin(theta)) * segmentMultiplier[1],
		        x =  Math.abs(distance * Math.cos(theta)) * segmentMultiplier[0];
		    return { x:fromPoint.x + x, y:fromPoint.y + y };
		},
		/**
		* @name Biltong.perpendicularLineTo
		* @function
		* @desc Calculates a line of length `length` that is perpendicular to the line from `fromPoint` to `toPoint` and passes through `toPoint`.
		* @param {Point} p1 First point, either as a 2 entry array or object with `left` and `top` properties.
		* @param {Point} p2 Second point, either as a 2 entry array or object with `left` and `top` properties.
		* @return {Line} Perpendicular line, in the form `[ { x:..., y:... }, { x:..., y:... } ]`.
		*/        
		_perpendicularLineTo = Biltong.perpendicularLineTo = function(fromPoint, toPoint, length) {
		    var m = _gradient(fromPoint, toPoint),
		        theta2 = Math.atan(-1 / m),
		        y =  length / 2 * Math.sin(theta2),
		        x =  length / 2 * Math.cos(theta2);
		    return [{x:toPoint.x + x, y:toPoint.y + y}, {x:toPoint.x - x, y:toPoint.y - y}];
		};	
}).call(this);
;
(function () {

    "use strict";

    var root = this,
        Sniff = {
            android: navigator.userAgent.toLowerCase().indexOf("android") > -1
        },
        matchesSelector = function (el, selector, ctx) {
            ctx = ctx || el.parentNode;
            var possibles = ctx.querySelectorAll(selector);
            for (var i = 0; i < possibles.length; i++) {
                if (possibles[i] === el) {
                    return true;
                }
            }
            return false;
        },
        _gel = function (el) {
            return (typeof el == "string" || el.constructor === String) ? document.getElementById(el) : el;
        },
        _t = function (e) {
            return e.srcElement || e.target;
        },
        _d = function (l, fn) {
            for (var i = 0, j = l.length; i < j; i++) {
                if (l[i] == fn) break;
            }
            if (i < l.length) l.splice(i, 1);
        },
        guid = 1,
    //
    // this function generates a guid for every handler, sets it on the handler, then adds
    // it to the associated object's map of handlers for the given event. this is what enables us
    // to unbind all events of some type, or all events (the second of which can be requested by the user,
    // but it also used by Mottle when an element is removed.)
        _store = function (obj, event, fn) {
            var g = guid++;
            obj.__ta = obj.__ta || {};
            obj.__ta[event] = obj.__ta[event] || {};
            // store each handler with a unique guid.
            obj.__ta[event][g] = fn;
            // set the guid on the handler.
            fn.__tauid = g;
            return g;
        },
        _unstore = function (obj, event, fn) {
            obj.__ta && obj.__ta[event] && delete obj.__ta[event][fn.__tauid];
            // a handler might have attached extra functions, so we unbind those too.
            if (fn.__taExtra) {
                for (var i = 0; i < fn.__taExtra.length; i++) {
                    _unbind(obj, fn.__taExtra[i][0], fn.__taExtra[i][1]);
                }
                fn.__taExtra.length = 0;
            }
            // a handler might have attached an unstore callback
            fn.__taUnstore && fn.__taUnstore();
        },
        _curryChildFilter = function (children, obj, fn, evt) {
            if (children == null) return fn;
            else {
                var c = children.split(","),
                    _fn = function (e) {
                        _fn.__tauid = fn.__tauid;
                        var t = _t(e);
                        for (var i = 0; i < c.length; i++) {
                            if (matchesSelector(t, c[i], obj)) {
                                fn.apply(t, arguments);
                            }
                        }
                    };
                registerExtraFunction(fn, evt, _fn);
                return _fn;
            }
        },
    //
    // registers an 'extra' function on some event listener function we were given - a function that we
    // created and bound to the element as part of our housekeeping, and which we want to unbind and remove
    // whenever the given function is unbound.
        registerExtraFunction = function (fn, evt, newFn) {
            fn.__taExtra = fn.__taExtra || [];
            fn.__taExtra.push([evt, newFn]);
        },
        DefaultHandler = function (obj, evt, fn, children) {
            if (isTouchDevice && touchMap[evt]) {
                var tfn = _curryChildFilter(children, obj, fn, touchMap[evt]);
                _bind(obj, touchMap[evt], tfn , fn);
            }
            if (evt === "focus" && obj.getAttribute("tabindex") == null) {
                obj.setAttribute("tabindex", "1");
            }
            _bind(obj, evt, _curryChildFilter(children, obj, fn, evt), fn);
        },
        SmartClickHandler = function (obj, evt, fn, children) {
            if (obj.__taSmartClicks == null) {
                var down = function (e) {
                        obj.__tad = _pageLocation(e);
                    },
                    up = function (e) {
                        obj.__tau = _pageLocation(e);
                    },
                    click = function (e) {
                        if (obj.__tad && obj.__tau && obj.__tad[0] === obj.__tau[0] && obj.__tad[1] === obj.__tau[1]) {
                            for (var i = 0; i < obj.__taSmartClicks.length; i++)
                                obj.__taSmartClicks[i].apply(_t(e), [ e ]);
                        }
                    };
                DefaultHandler(obj, "mousedown", down, children);
                DefaultHandler(obj, "mouseup", up, children);
                DefaultHandler(obj, "click", click, children);
                obj.__taSmartClicks = [];
            }

            // store in the list of callbacks
            obj.__taSmartClicks.push(fn);
            // the unstore function removes this function from the object's listener list for this type.
            fn.__taUnstore = function () {
                _d(obj.__taSmartClicks, fn);
            };
        },
        _tapProfiles = {
            "tap": {touches: 1, taps: 1},
            "dbltap": {touches: 1, taps: 2},
            "contextmenu": {touches: 2, taps: 1}
        },
        TapHandler = function (clickThreshold, dblClickThreshold) {
            return function (obj, evt, fn, children) {
                // if event is contextmenu, for devices which are mouse only, we want to
                // use the default bind.
                if (evt == "contextmenu" && isMouseDevice)
                    DefaultHandler(obj, evt, fn, children);
                else {
                    // the issue here is that this down handler gets registered only for the
                    // child nodes in the first registration. in fact it should be registered with
                    // no child selector and then on down we should cycle through the regustered
                    // functions to see if one of them matches. on mouseup we should execute ALL of
                    // the functions whose children are either null or match the element.
                    if (obj.__taTapHandler == null) {
                        var tt = obj.__taTapHandler = {
                            tap: [],
                            dbltap: [],
                            contextmenu: [],
                            down: false,
                            taps: 0,
                            downSelectors: []
                        };
                        var down = function (e) {
                                var target = e.srcElement || e.target;
                                for (var i = 0; i < tt.downSelectors.length; i++) {
                                    if (tt.downSelectors[i] == null || matchesSelector(target, tt.downSelectors[i], obj)) {
                                        tt.down = true;
                                        setTimeout(clearSingle, clickThreshold);
                                        setTimeout(clearDouble, dblClickThreshold);
                                        break; // we only need one match on mousedown
                                    }
                                }
                            },
                            up = function (e) {
                                if (tt.down) {
                                    var target = e.srcElement || e.target;
                                    tt.taps++;
                                    var tc = _touchCount(e);
                                    for (var eventId in _tapProfiles) {
                                        if (_tapProfiles.hasOwnProperty(eventId)) {
                                            var p = _tapProfiles[eventId];
                                            if (p.touches === tc && (p.taps === 1 || p.taps === tt.taps)) {
                                                for (var i = 0; i < tt[eventId].length; i++) {
                                                    if (tt[eventId][i][1] == null || matchesSelector(target, tt[eventId][i][1], obj))
                                                        tt[eventId][i][0].apply(_t(e), [ e ]);
                                                }
                                            }
                                        }
                                    }
                                }
                            },
                            clearSingle = function () {
                                tt.down = false;
                            },
                            clearDouble = function () {
                                tt.taps = 0;
                            };

                        DefaultHandler(obj, "mousedown", down/*, children*/);
                        DefaultHandler(obj, "mouseup", up/*, children*/);
                    }
                    // add this child selector (it can be null, that's fine).
                    obj.__taTapHandler.downSelectors.push(children);

                    obj.__taTapHandler[evt].push([fn, children]);
                    // the unstore function removes this function from the object's listener list for this type.
                    fn.__taUnstore = function () {
                        _d(obj.__taTapHandler[evt], fn);
                    };
                }
            };
        },
        meeHelper = function (type, evt, obj, target) {
            for (var i in obj.__tamee[type]) {
                if (obj.__tamee[type].hasOwnProperty(i)) {
                    obj.__tamee[type][i].apply(target, [ evt ]);
                }
            }
        },
        MouseEnterExitHandler = function () {
            var activeElements = [];
            return function (obj, evt, fn, children) {
                if (!obj.__tamee) {
                    // __tamee holds a flag saying whether the mouse is currently "in" the element, and a list of
                    // both mouseenter and mouseexit functions.
                    obj.__tamee = { over: false, mouseenter: [], mouseexit: [] };
                    // register over and out functions
                    var over = function (e) {
                            var t = _t(e);
                            if ((children == null && (t == obj && !obj.__tamee.over)) || (matchesSelector(t, children, obj) && (t.__tamee == null || !t.__tamee.over))) {
                                meeHelper("mouseenter", e, obj, t);
                                t.__tamee = t.__tamee || {};
                                t.__tamee.over = true;
                                activeElements.push(t);
                            }
                        },
                        out = function (e) {
                            var t = _t(e);
                            // is the current target one of the activeElements? and is the
                            // related target NOT a descendant of it?
                            for (var i = 0; i < activeElements.length; i++) {
                                if (t == activeElements[i] && !matchesSelector((e.relatedTarget || e.toElement), "*", t)) {
                                    t.__tamee.over = false;
                                    activeElements.splice(i, 1);
                                    meeHelper("mouseexit", e, obj, t);
                                }
                            }
                        };

                    _bind(obj, "mouseover", _curryChildFilter(children, obj, over, "mouseover"), over);
                    _bind(obj, "mouseout", _curryChildFilter(children, obj, out, "mouseout"), out);
                }

                fn.__taUnstore = function () {
                    delete obj.__tamee[evt][fn.__tauid];
                };

                _store(obj, evt, fn);
                obj.__tamee[evt][fn.__tauid] = fn;
            };
        },
        isTouchDevice = "ontouchstart" in document.documentElement,
        isMouseDevice = "onmousedown" in document.documentElement,
        touchMap = { "mousedown": "touchstart", "mouseup": "touchend", "mousemove": "touchmove" },
        touchstart = "touchstart", touchend = "touchend", touchmove = "touchmove",
        iev = (function () {
            var rv = -1;
            if (navigator.appName == 'Microsoft Internet Explorer') {
                var ua = navigator.userAgent,
                    re = new RegExp("MSIE ([0-9]{1,}[\.0-9]{0,})");
                if (re.exec(ua) != null)
                    rv = parseFloat(RegExp.$1);
            }
            return rv;
        })(),
        isIELT9 = iev > -1 && iev < 9,
        _genLoc = function (e, prefix) {
            if (e == null) return [ 0, 0 ];
            var ts = _touches(e), t = _getTouch(ts, 0);
            return [t[prefix + "X"], t[prefix + "Y"]];
        },
        _pageLocation = function (e) {
            if (e == null) return [ 0, 0 ];
            if (isIELT9) {
                return [ e.clientX + document.documentElement.scrollLeft, e.clientY + document.documentElement.scrollTop ];
            }
            else {
                return _genLoc(e, "page");
            }
        },
        _screenLocation = function (e) {
            return _genLoc(e, "screen");
        },
        _clientLocation = function (e) {
            return _genLoc(e, "client");
        },
        _getTouch = function (touches, idx) {
            return touches.item ? touches.item(idx) : touches[idx];
        },
        _touches = function (e) {
            return e.touches && e.touches.length > 0 ? e.touches :
                    e.changedTouches && e.changedTouches.length > 0 ? e.changedTouches :
                    e.targetTouches && e.targetTouches.length > 0 ? e.targetTouches :
                [ e ];
        },
        _touchCount = function (e) {
            return _touches(e).length;
        },
    //http://www.quirksmode.org/blog/archives/2005/10/_and_the_winner_1.html
        _bind = function (obj, type, fn, originalFn) {
            _store(obj, type, fn);
            originalFn.__tauid = fn.__tauid;
            if (obj.addEventListener)
                obj.addEventListener(type, fn, false);
            else if (obj.attachEvent) {
                var key = type + fn.__tauid;
                obj["e" + key] = fn;
                // TODO look at replacing with .call(..)
                obj[key] = function () {
                    obj["e" + key] && obj["e" + key](window.event);
                };
                obj.attachEvent("on" + type, obj[key]);
            }
        },
        _unbind = function (obj, type, fn) {
            if (fn == null) return;
            _each(obj, function () {
                var _el = _gel(this);
                _unstore(_el, type, fn);
                // it has been bound if there is a tauid. otherwise it was not bound and we can ignore it.
                if (fn.__tauid != null) {
                    if (_el.removeEventListener) {
                        _el.removeEventListener(type, fn, false);
                        if (isTouchDevice && touchMap[type]) _el.removeEventListener(touchMap[type], fn, false);
                    }
                    else if (this.detachEvent) {
                        var key = type + fn.__tauid;
                        _el[key] && _el.detachEvent("on" + type, _el[key]);
                        _el[key] = null;
                        _el["e" + key] = null;
                    }
                }

                // if a touch event was also registered, deregister now.
                if (fn.__taTouchProxy) {
                    _unbind(obj, fn.__taTouchProxy[1], fn.__taTouchProxy[0]);
                }
            });
        },
        _each = function (obj, fn) {
            if (obj == null) return;
            // if a list (or list-like), use it. if a string, get a list
            // by running the string through querySelectorAll. else, assume
            // it's an Element.
            // obj.top is "unknown" in IE8.
            obj = (typeof Window !== "undefined" && (typeof obj.top !== "unknown" && obj == obj.top)) ? [ obj ] :
                    (typeof obj !== "string") && (obj.tagName == null && obj.length != null) ? obj :
                    typeof obj === "string" ? document.querySelectorAll(obj)
                : [ obj ];

            for (var i = 0; i < obj.length; i++)
                fn.apply(obj[i]);
        };

    /**
     * Mottle offers support for abstracting out the differences
     * between touch and mouse devices, plus "smart click" functionality
     * (don't fire click if the mouse has moved between mousedown and mouseup),
     * and synthesized click/tap events.
     * @class Mottle
     * @constructor
     * @param {Object} params Constructor params
     * @param {Number} [params.clickThreshold=150] Threshold, in milliseconds beyond which a touchstart followed by a touchend is not considered to be a click.
     * @param {Number} [params.dblClickThreshold=350] Threshold, in milliseconds beyond which two successive tap events are not considered to be a click.
     * @param {Boolean} [params.smartClicks=false] If true, won't fire click events if the mouse has moved between mousedown and mouseup. Note that this functionality
     * requires that Mottle consume the mousedown event, and so may not be viable in all use cases.
     */
    root.Mottle = function (params) {
        params = params || {};
        var clickThreshold = params.clickThreshold || 150,
            dblClickThreshold = params.dblClickThreshold || 350,
            mouseEnterExitHandler = new MouseEnterExitHandler(),
            tapHandler = new TapHandler(clickThreshold, dblClickThreshold),
            _smartClicks = params.smartClicks,
            _doBind = function (obj, evt, fn, children) {
                if (fn == null) return;
                _each(obj, function () {
                    var _el = _gel(this);
                    if (_smartClicks && evt === "click")
                        SmartClickHandler(_el, evt, fn, children);
                    else if (evt === "tap" || evt === "dbltap" || evt === "contextmenu") {
                        tapHandler(_el, evt, fn, children);
                    }
                    else if (evt === "mouseenter" || evt == "mouseexit")
                        mouseEnterExitHandler(_el, evt, fn, children);
                    else
                        DefaultHandler(_el, evt, fn, children);
                });
            };

        /**
         * Removes an element from the DOM, and deregisters all event handlers for it. You should use this
         * to ensure you don't leak memory.
         * @method remove
         * @param {String|Element} el Element, or id of the element, to remove.
         * @return {Mottle} The current Mottle instance; you can chain this method.
         */
        this.remove = function (el) {
            _each(el, function () {
                var _el = _gel(this);
                if (_el.__ta) {
                    for (var evt in _el.__ta) {
                        if (_el.__ta.hasOwnProperty(evt)) {
                            for (var h in _el.__ta[evt]) {
                                if (_el.__ta[evt].hasOwnProperty(h))
                                    _unbind(_el, evt, _el.__ta[evt][h]);
                            }
                        }
                    }
                }
                _el.parentNode && _el.parentNode.removeChild(_el);
            });
            return this;
        };

        /**
         * Register an event handler, optionally as a delegate for some set of descendant elements. Note
         * that this method takes either 3 or 4 arguments - if you supply 3 arguments it is assumed you have
         * omitted the `children` parameter, and that the event handler should be bound directly to the given element.
         * @method on
         * @param {Element[]|Element|String} el Either an Element, or a CSS spec for a list of elements, or an array of Elements.
         * @param {String} [children] Comma-delimited list of selectors identifying allowed children.
         * @param {String} event Event ID.
         * @param {Function} fn Event handler function.
         * @return {Mottle} The current Mottle instance; you can chain this method.
         */
        this.on = function (el, event, children, fn) {
            var _el = arguments[0],
                _c = arguments.length == 4 ? arguments[2] : null,
                _e = arguments[1],
                _f = arguments[arguments.length - 1];

            _doBind(_el, _e, _f, _c);
            return this;
        };

        /**
         * Cancel delegate event handling for the given function. Note that unlike with 'on' you do not supply
         * a list of child selectors here: it removes event delegation from all of the child selectors for which the
         * given function was registered (if any).
         * @method off
         * @param {Element[]|Element|String} el Element - or ID of element - from which to remove event listener.
         * @param {String} event Event ID.
         * @param {Function} fn Event handler function.
         * @return {Mottle} The current Mottle instance; you can chain this method.
         */
        this.off = function (el, event, fn) {
            _unbind(el, event, fn);
            return this;
        };

        /**
         * Triggers some event for a given element.
         * @method trigger
         * @param {Element} el Element for which to trigger the event.
         * @param {String} event Event ID.
         * @param {Event} originalEvent The original event. Should be optional of course, but currently is not, due
         * to the jsPlumb use case that caused this method to be added.
         * @param {Object} [payload] Optional object to set as `payload` on the generated event; useful for message passing.
         * @return {Mottle} The current Mottle instance; you can chain this method.
         */
        this.trigger = function (el, event, originalEvent, payload) {
            // MouseEvent undefined in old IE; that's how we know it's a mouse event.  A fine Microsoft paradox.
            var originalIsMouse = isMouseDevice && (typeof MouseEvent === "undefined" || originalEvent == null || originalEvent.constructor === MouseEvent);

            var eventToBind = (isTouchDevice && !isMouseDevice && touchMap[event]) ? touchMap[event] : event,
                bindingAMouseEvent = !(isTouchDevice && !isMouseDevice && touchMap[event]);

            var pl = _pageLocation(originalEvent), sl = _screenLocation(originalEvent), cl = _clientLocation(originalEvent);
            _each(el, function () {
                var _el = _gel(this), evt;
                originalEvent = originalEvent || {
                    screenX: sl[0],
                    screenY: sl[1],
                    clientX: cl[0],
                    clientY: cl[1]
                };

                var _decorate = function (_evt) {
                    if (payload) _evt.payload = payload;
                };

                var eventGenerators = {
                    "TouchEvent": function (evt) {
                        var touch = document.createTouch(window, _el, 0, pl[0], pl[1],
                            sl[0], sl[1],
                            cl[0], cl[1],
                            0, 0, 0, 0);

                        // https://gist.github.com/sstephenson/448808
                        var touches = document.createTouchList(touch);
                        var targetTouches = document.createTouchList(touch);
                        var changedTouches = document.createTouchList(touch);
                        evt.initTouchEvent(eventToBind, true, true, window, null, sl[0], sl[1],
                            cl[0], cl[1], false, false, false, false,
                            touches, targetTouches, changedTouches, 1, 0);
                    },
                    "MouseEvents": function (evt) {
                        evt.initMouseEvent(eventToBind, true, true, window, 0,
                            sl[0], sl[1],
                            cl[0], cl[1],
                            false, false, false, false, 1, _el);

                        if (Sniff.android) {
                            // Android's touch events are not standard.
                            var t = document.createTouch(window, _el, 0, pl[0], pl[1],
                                sl[0], sl[1],
                                cl[0], cl[1],
                                0, 0, 0, 0);

                            evt.touches = evt.targetTouches = evt.changedTouches = document.createTouchList(t);
                        }
                    }
                };

                if (document.createEvent) {

                    var ite = !bindingAMouseEvent && !originalIsMouse && (isTouchDevice && touchMap[event] && !Sniff.android),
                        evtName = ite ? "TouchEvent" : "MouseEvents";

                    evt = document.createEvent(evtName);
                    eventGenerators[evtName](evt);
                    _decorate(evt);
                    _el.dispatchEvent(evt);
                }
                else if (document.createEventObject) {
                    evt = document.createEventObject();
                    evt.eventType = evt.eventName = eventToBind;
                    evt.screenX = sl[0];
                    evt.screenY = sl[1];
                    evt.clientX = cl[0];
                    evt.clientY = cl[1];
                    _decorate(evt);
                    _el.fireEvent('on' + eventToBind, evt);
                }
            });
            return this;
        }
    };

    /**
     * Static method to assist in 'consuming' an element: uses `stopPropagation` where available, or sets
     * `e.returnValue=false` where it is not.
     * @method Mottle.consume
     * @param {Event} e Event to consume
     * @param {Boolean} [doNotPreventDefault=false] If true, does not call `preventDefault()` on the event.
     */
    root.Mottle.consume = function (e, doNotPreventDefault) {
        if (e.stopPropagation)
            e.stopPropagation();
        else
            e.returnValue = false;

        if (!doNotPreventDefault && e.preventDefault)
            e.preventDefault();
    };

    /**
     * Gets the page location corresponding to the given event. For touch events this means get the page location of the first touch.
     * @method Mottle.pageLocation
     * @param {Event} e Event to get page location for.
     * @return {Integer[]} [left, top] for the given event.
     */
    root.Mottle.pageLocation = _pageLocation;

    /**
     * Forces touch events to be turned "on". Useful for testing: even if you don't have a touch device, you can still
     * trigger a touch event when this is switched on and it will be captured and acted on.
     * @method setForceTouchEvents
     * @param {Boolean} value If true, force touch events to be on.
     */
    root.Mottle.setForceTouchEvents = function (value) {
        isTouchDevice = value;
    };

    /**
     * Forces mouse events to be turned "on". Useful for testing: even if you don't have a mouse, you can still
     * trigger a mouse event when this is switched on and it will be captured and acted on.
     * @method setForceMouseEvents
     * @param {Boolean} value If true, force mouse events to be on.
     */
    root.Mottle.setForceMouseEvents = function (value) {
        isMouseDevice = value;
    };

}).call(this);

/**
 drag/drop functionality for use with jsPlumb but with
 no knowledge of jsPlumb. supports multiple scopes (separated by whitespace), dragging
 multiple elements, constrain to parent, drop filters, drag start filters, custom
 css classes.

 a lot of the functionality of this script is expected to be plugged in:

 addClass
 removeClass

 addEvent
 removeEvent

 getPosition
 setPosition
 getSize

 indexOf
 intersects

 the name came from here:

 http://mrsharpoblunto.github.io/foswig.js/

 copyright 2015 jsPlumb
 */

;(function() {

    "use strict";

    Array.prototype.suggest = function(item, head) {
        if (this.indexOf(item) === -1) {
            head ? this.unshift(item) : this.push(item);
        }
    };

    Array.prototype.vanquish = function(item) {
        var idx = this.indexOf(item);
        if (idx != -1) this.splice(idx, 1);
    };

    var _isString = function(f) {
        return f == null ? false : (typeof f === "string" || f.constructor == String);
    };

    var getOffsetRect = function (elem) {
        // (1)
        var box = elem.getBoundingClientRect(),
            body = document.body,
            docElem = document.documentElement,
        // (2)
            scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop,
            scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft,
        // (3)
            clientTop = docElem.clientTop || body.clientTop || 0,
            clientLeft = docElem.clientLeft || body.clientLeft || 0,
        // (4)
            top  = box.top +  scrollTop - clientTop,
            left = box.left + scrollLeft - clientLeft;

        return { top: Math.round(top), left: Math.round(left) };
    };

    var matchesSelector = function(el, selector, ctx) {
        ctx = ctx || el.parentNode;
        var possibles = ctx.querySelectorAll(selector);
        for (var i = 0; i < possibles.length; i++) {
            if (possibles[i] === el)
                return true;
        }
        return false;
    };

    var iev = (function() {
            var rv = -1;
            if (navigator.appName == 'Microsoft Internet Explorer') {
                var ua = navigator.userAgent,
                    re = new RegExp("MSIE ([0-9]{1,}[\.0-9]{0,})");
                if (re.exec(ua) != null)
                    rv = parseFloat(RegExp.$1);
            }
            return rv;
        })(),
        DEFAULT_GRID_X = 50,
        DEFAULT_GRID_Y = 50,
        isIELT9 = iev > -1 && iev < 9,
        _pl = function(e) {
            if (isIELT9) {
                return [ e.clientX + document.documentElement.scrollLeft, e.clientY + document.documentElement.scrollTop ];
            }
            else {
                var ts = _touches(e), t = _getTouch(ts, 0);
                // this is for iPad. may not fly for Android.
                return [t.pageX, t.pageY];
            }
        },
        _getTouch = function(touches, idx) { return touches.item ? touches.item(idx) : touches[idx]; },
        _touches = function(e) {
            return e.touches && e.touches.length > 0 ? e.touches :
                    e.changedTouches && e.changedTouches.length > 0 ? e.changedTouches :
                    e.targetTouches && e.targetTouches.length > 0 ? e.targetTouches :
                [ e ];
        },
        _classes = {
            draggable:"katavorio-draggable",    // draggable elements
            droppable:"katavorio-droppable",    // droppable elements
            drag : "katavorio-drag",            // elements currently being dragged
            selected:"katavorio-drag-selected", // elements in current drag selection
            active : "katavorio-drag-active",   // droppables that are targets of a currently dragged element
            hover : "katavorio-drag-hover",     // droppables over which a matching drag element is hovering
            noSelect : "katavorio-drag-no-select" // added to the body to provide a hook to suppress text selection
        },
        _defaultScope = "katavorio-drag-scope",
        _events = [ "stop", "start", "drag", "drop", "over", "out", "beforeStart" ],
        _devNull = function() {},
        _true = function() { return true; },
        _foreach = function(l, fn, from) {
            for (var i = 0; i < l.length; i++) {
                if (l[i] != from)
                    fn(l[i]);
            }
        },
        _setDroppablesActive = function(dd, val, andHover, drag) {
            _foreach(dd, function(e) {
                e.setActive(val);
                if (val) e.updatePosition();
                if (andHover) e.setHover(drag, val);
            });
        },
        _each = function(obj, fn) {
            if (obj == null) return;
            obj = !_isString(obj) && (obj.tagName == null && obj.length != null) ? obj : [ obj ];
            for (var i = 0; i < obj.length; i++)
                fn.apply(obj[i], [ obj[i] ]);
        },
        _consume = function(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
                e.preventDefault();
            }
            else {
                e.returnValue = false;
            }
        },
        _defaultInputFilterSelector = "input,textarea,select,button,option",
    //
    // filters out events on all input elements, like textarea, checkbox, input, select.
        _inputFilter = function(e, el, _katavorio) {
            var t = e.srcElement || e.target;
            return !matchesSelector(t, _katavorio.getInputFilterSelector(), el);
        };

    var Super = function(el, params, css, scope) {
        this.params = params || {};
        this.el = el;
        this.params.addClass(this.el, this._class);
        this.uuid = _uuid();
        var enabled = true;
        this.setEnabled = function(e) { enabled = e; };
        this.isEnabled = function() { return enabled; };
        this.toggleEnabled = function() { enabled = !enabled; };
        this.setScope = function(scopes) {
            this.scopes = scopes ? scopes.split(/\s+/) : [ scope ];
        };
        this.addScope = function(scopes) {
            var m = {};
            _each(this.scopes, function(s) { m[s] = true;});
            _each(scopes ? scopes.split(/\s+/) : [], function(s) { m[s] = true;});
            this.scopes = [];
            for (var i in m) this.scopes.push(i);
        };
        this.removeScope = function(scopes) {
            var m = {};
            _each(this.scopes, function(s) { m[s] = true;});
            _each(scopes ? scopes.split(/\s+/) : [], function(s) { delete m[s];});
            this.scopes = [];
            for (var i in m) this.scopes.push(i);
        };
        this.toggleScope = function(scopes) {
            var m = {};
            _each(this.scopes, function(s) { m[s] = true;});
            _each(scopes ? scopes.split(/\s+/) : [], function(s) {
                if (m[s]) delete m[s];
                else m[s] = true;
            });
            this.scopes = [];
            for (var i in m) this.scopes.push(i);
        };
        this.setScope(params.scope);
        this.k = params.katavorio;
        return params.katavorio;
    };

    var Drag = function(el, params, css, scope) {
        this._class = css.draggable;
        var k = Super.apply(this, arguments);
        this.rightButtonCanDrag = this.params.rightButtonCanDrag;
        var downAt = [0,0], posAtDown = null, moving = false,
            consumeStartEvent = this.params.consumeStartEvent !== false,
            dragEl = this.el,
            clone = this.params.clone,
            scroll = this.params.scroll,
            _multipleDrop = params.multipleDrop !== false;

        var snapThreshold = params.snapThreshold || 5,
            _snap = function(pos, x, y, thresholdX, thresholdY) {
                thresholdX = thresholdX || snapThreshold;
                thresholdY = thresholdY || snapThreshold;
                var _dx = Math.floor(pos[0] / x),
                    _dxl = x * _dx,
                    _dxt = _dxl + x,
                    _x = Math.abs(pos[0] - _dxl) <= thresholdX ? _dxl : Math.abs(_dxt - pos[0]) <= thresholdX ? _dxt : pos[0];

                var _dy = Math.floor(pos[1] / y),
                    _dyl = y * _dy,
                    _dyt = _dyl + y,
                    _y = Math.abs(pos[1] - _dyl) <= thresholdY ? _dyl : Math.abs(_dyt - pos[1]) <= thresholdY ? _dyt : pos[1];

                return [ _x, _y];
            };

        this.posses = [];
        this.posseRoles = {};

        this.toGrid = function(pos) {
            if (this.params.grid == null) {
                return pos;
            }
            else {
                return _snap(pos, this.params.grid[0], this.params.grid[1]);
            }
        };

        this.snap = function(x, y) {
            if (dragEl == null) return;
            x = x || (this.params.grid ? this.params.grid[0] : DEFAULT_GRID_X);
            y = y || (this.params.grid ? this.params.grid[1] : DEFAULT_GRID_Y);
            var p = this.params.getPosition(dragEl);
            this.params.setPosition(dragEl, _snap(p, x, y, x, y));
        };

        this.constrain = typeof this.params.constrain === "function" ? this.params.constrain  : (this.params.constrain || this.params.containment) ? function(pos) {
            return [
                Math.max(0, Math.min(constrainRect.w - this.size[0], pos[0])),
                Math.max(0, Math.min(constrainRect.h - this.size[1], pos[1]))
            ];
        } : function(pos) { return pos; };

        var _assignId = function(obj) {
                if (typeof obj == "function") {
                    obj._katavorioId = _uuid();
                    return obj._katavorioId;
                } else {
                    return obj;
                }
            },
        // a map of { spec -> [ fn, exclusion ] } entries.
            _filters = {},
            _testFilter = function(e) {
                for (var key in _filters) {
                    var f = _filters[key];
                    var rv = f[0](e);
                    if (f[1]) rv = !rv;
                    if (!rv) return false;
                }
                return true;
            },
            _setFilter = this.setFilter = function(f, _exclude) {
                if (f) {
                    var key = _assignId(f);
                    _filters[key] = [
                        function(e) {
                            var t = e.srcElement || e.target, m;
                            if (_isString(f)) {
                                m = matchesSelector(t, f, el);
                            }
                            else if (typeof f === "function") {
                                m = f(e, el);
                            }
                            return m;
                        },
                            _exclude !== false
                    ];

                }
            },
            _addFilter = this.addFilter = _setFilter,
            _removeFilter = this.removeFilter = function(f) {
                var key = typeof f == "function" ? f._katavorioId : f;
                delete _filters[key];
            };

        this.clearAllFilters = function() {
            _filters = {};
        };

        this.canDrag = this.params.canDrag || _true;

        var constrainRect,
            matchingDroppables = [], intersectingDroppables = [];

        this.downListener = function(e) {
            var isNotRightClick = this.rightButtonCanDrag || (e.which !== 3 && e.button !== 2);
            if (isNotRightClick && this.isEnabled() && this.canDrag()) {
                var _f =  _testFilter(e) && _inputFilter(e, this.el, this.k);
                if (_f) {
                    if (!clone)
                        dragEl = this.el;
                    else {
                        dragEl = this.el.cloneNode(true);
                        dragEl.setAttribute("id", null);
                        dragEl.style.position = "absolute";
                        // the clone node is added to the body; getOffsetRect gives us a value
                        // relative to the body.
                        var b = getOffsetRect(this.el);
                        dragEl.style.left = b.left + "px";
                        dragEl.style.top = b.top + "px";
                        document.body.appendChild(dragEl);
                    }
                    consumeStartEvent && _consume(e);
                    downAt = _pl(e);
                    //
                    this.params.bind(document, "mousemove", this.moveListener);
                    this.params.bind(document, "mouseup", this.upListener);
                    k.markSelection(this);
                    k.markPosses(this);
                    this.params.addClass(document.body, css.noSelect);
                    _dispatch("beforeStart", {el:this.el, pos:posAtDown, e:e, drag:this});
                }
                else if (this.params.consumeFilteredEvents) {
                    _consume(e);
                }
            }
        }.bind(this);

        this.moveListener = function(e) {
            if (downAt) {
                if (!moving) {
                    var _continue = _dispatch("start", {el:this.el, pos:posAtDown, e:e, drag:this});
                    if (_continue !== false) {
                        if (!downAt) return;
                        this.mark(true);
                        moving = true;
                    }
                }

                // it is possible that the start event caused the drag to be aborted. So we check
                // again that we are currently dragging.
                if (downAt) {
                    intersectingDroppables.length = 0;
                    var pos = _pl(e), dx = pos[0] - downAt[0], dy = pos[1] - downAt[1],
                        z = this.params.ignoreZoom ? 1 : k.getZoom();
                    dx /= z;
                    dy /= z;
                    this.moveBy(dx, dy, e);
                    k.updateSelection(dx, dy, this);
                    k.updatePosses(dx, dy, this);
                }
            }
        }.bind(this);

        this.upListener = function(e) {
            if (downAt) {
                downAt = null;
                this.params.unbind(document, "mousemove", this.moveListener);
                this.params.unbind(document, "mouseup", this.upListener);
                this.params.removeClass(document.body, css.noSelect);
                this.unmark(e);
                k.unmarkSelection(this, e);
                k.unmarkPosses(this, e);
                this.stop(e);
                k.notifySelectionDragStop(this, e);
                moving = false;
                if (clone) {
                    dragEl && dragEl.parentNode && dragEl.parentNode.removeChild(dragEl);
                    dragEl = null;
                }
            }
        }.bind(this);

        this.getFilters = function() { return _filters; };

        this.abort = function() {
            if (downAt != null)
                this.upListener();
        };

        this.getDragElement = function() {
            return dragEl || this.el;
        };

        var listeners = {"start":[], "drag":[], "stop":[], "over":[], "out":[], "beforeStart":[] };
        if (params.events.start) listeners.start.push(params.events.start);
        if (params.events.beforeStart) listeners.beforeStart.push(params.events.beforeStart);
        if (params.events.stop) listeners.stop.push(params.events.stop);
        if (params.events.drag) listeners.drag.push(params.events.drag);

        this.on = function(evt, fn) {
            if (listeners[evt]) listeners[evt].push(fn);
        };

        var _dispatch = function(evt, value) {
            if (listeners[evt]) {
                for (var i = 0; i < listeners[evt].length; i++) {
                    try {
                        listeners[evt][i](value);
                    }
                    catch (e) { }
                }
            }
        };

        this.notifyStart = function(e) {
            _dispatch("start", {el:this.el, pos:this.params.getPosition(dragEl), e:e, drag:this});
        };

        this.stop = function(e, force) {
            if (force || moving) {
                var positions = [],
                    sel = k.getSelection(),
                    dPos = this.params.getPosition(dragEl);

                if (sel.length > 1) {
                    for (var i = 0; i < sel.length; i++) {
                        var p = this.params.getPosition(sel[i].el);
                        positions.push([ sel[i].el, { left: p[0], top: p[1] }, sel[i] ]);
                    }
                }
                else {
                    positions.push([ dragEl, {left:dPos[0], top:dPos[1]}, this ]);
                }

                _dispatch("stop", {
                    el: dragEl, pos: dPos, e: e, drag: this, selection:positions
                });
            }
        };

        this.mark = function(andNotify) {
            posAtDown = this.params.getPosition(dragEl);
            this.size = this.params.getSize(dragEl);
            matchingDroppables = k.getMatchingDroppables(this);
            _setDroppablesActive(matchingDroppables, true, false, this);
            this.params.addClass(dragEl, this.params.dragClass || css.drag);
            if (this.params.constrain || this.params.containment) {
                var cs = this.params.getSize(dragEl.parentNode);
                constrainRect = { w:cs[0], h:cs[1] };
            }
            if (andNotify) {
                k.notifySelectionDragStart(this);
            }
        };
        this.unmark = function(e) {
            _setDroppablesActive(matchingDroppables, false, true, this);
            this.params.removeClass(dragEl, this.params.dragClass || css.drag);
            matchingDroppables.length = 0;
            for (var i = 0; i < intersectingDroppables.length; i++) {
                var retVal = intersectingDroppables[i].drop(this, e);
                if (retVal === true) break;
            }
        };
        this.moveBy = function(dx, dy, e) {
            intersectingDroppables.length = 0;
            var cPos = this.constrain(this.toGrid(([posAtDown[0] + dx, posAtDown[1] + dy])), dragEl),
                rect = { x:cPos[0], y:cPos[1], w:this.size[0], h:this.size[1]},
                focusDropElement = null;

            this.params.setPosition(dragEl, cPos);
            for (var i = 0; i < matchingDroppables.length; i++) {
                var r2 = { x:matchingDroppables[i].position[0], y:matchingDroppables[i].position[1], w:matchingDroppables[i].size[0], h:matchingDroppables[i].size[1]};
                if (this.params.intersects(rect, r2) && (_multipleDrop || focusDropElement == null || focusDropElement == matchingDroppables[i].el) && matchingDroppables[i].canDrop(this)) {
                    if (!focusDropElement) focusDropElement = matchingDroppables[i].el;
                    intersectingDroppables.push(matchingDroppables[i]);
                    matchingDroppables[i].setHover(this, true, e);
                }
                else if (matchingDroppables[i].isHover()) {
                    matchingDroppables[i].setHover(this, false, e);
                }
            }

            _dispatch("drag", {el:this.el, pos:cPos, e:e, drag:this});

            /* test to see if the parent needs to be scrolled
             if (scroll) {
             var pnsl = dragEl.parentNode.scrollLeft, pnst = dragEl.parentNode.scrollTop;
             console.log("scroll!", pnsl, pnst);
             }*/
        };
        this.destroy = function() {
            this.params.unbind(this.el, "mousedown", this.downListener);
            this.params.unbind(document, "mousemove", this.moveListener);
            this.params.unbind(document, "mouseup", this.upListener);
            this.downListener = null;
            this.upListener = null;
            this.moveListener = null;
            //this.params = null;
            //this.el = null;
            //dragEl = null;
        };

        // init:register mousedown, and perhaps set a filter
        this.params.bind(this.el, "mousedown", this.downListener);

        // if handle provded, use that.  otherwise, try to set a filter.
        // note that a `handle` selector always results in filterExclude being set to false, ie.
        // the selector defines the handle element(s).
        if (this.params.handle)
            _setFilter(this.params.handle, false);
        else
            _setFilter(this.params.filter, this.params.filterExclude);
    };

    var Drop = function(el, params, css, scope) {
        this._class = css.droppable;
        this.params = params || {};
        this._activeClass = this.params.activeClass || css.active;
        this._hoverClass = this.params.hoverClass || css.hover;
        Super.apply(this, arguments);
        var hover = false;
        this.allowLoopback = this.params.allowLoopback !== false;

        this.setActive = function(val) {
            this.params[val ? "addClass" : "removeClass"](this.el, this._activeClass);
        };

        this.updatePosition = function() {
            this.position = this.params.getPosition(this.el);
            this.size = this.params.getSize(this.el);
        };

        this.canDrop = this.params.canDrop || function(drag) {
            return true;
        };

        this.isHover = function() { return hover; };

        this.setHover = function(drag, val, e) {
            // if turning off hover but this was not the drag that caused the hover, ignore.
            if (val || this.el._katavorioDragHover == null || this.el._katavorioDragHover == drag.el._katavorio) {
                this.params[val ? "addClass" : "removeClass"](this.el, this._hoverClass);
                //this.el._katavorioDragHover = val ? drag.el._katavorio : null;
                this.el._katavorioDragHover = val ? drag.el._katavorio : null;
                if (hover !== val)
                    this.params.events[val ? "over" : "out"]({el:this.el, e:e, drag:drag, drop:this});
                hover = val;
            }
        };

        this.drop = function(drag, event) {
            return this.params.events["drop"]({ drag:drag, e:event, drop:this });
        };

        this.destroy = function() {
            this._class = null;
            this._activeClass = null;
            this._hoverClass = null;
            //this.params = null;
            hover = null;
            //this.el = null;
        };
    };

    var _uuid = function() {
        return ('xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
            return v.toString(16);
        }));
    };

    var _gel = function(el) {
        if (el == null) return null;
        el = (typeof el === "string" || el.constructor == String)  ? document.getElementById(el) : el;
        if (el == null) return null;
        el._katavorio = el._katavorio || _uuid();
        return el;
    };

    this.Katavorio = function(katavorioParams) {

        var _selection = [],
            _selectionMap = {};

        this._dragsByScope = {};
        this._dropsByScope = {};
        var _zoom = 1,
            _reg = function(obj, map) {
                _each(obj, function(_obj) {
                    for(var i = 0; i < _obj.scopes.length; i++) {
                        map[_obj.scopes[i]] = map[_obj.scopes[i]] || [];
                        map[_obj.scopes[i]].push(_obj);
                    }
                });
            },
            _unreg = function(obj, map) {
                var c = 0;
                _each(obj, function(_obj) {
                    for(var i = 0; i < _obj.scopes.length; i++) {
                        if (map[_obj.scopes[i]]) {
                            var idx = katavorioParams.indexOf(map[_obj.scopes[i]], _obj);
                            if (idx != -1) {
                                map[_obj.scopes[i]].splice(idx, 1);
                                c++;
                            }
                        }
                    }
                });

                return c > 0 ;
            },
            _getMatchingDroppables = this.getMatchingDroppables = function(drag) {
                var dd = [], _m = {};
                for (var i = 0; i < drag.scopes.length; i++) {
                    var _dd = this._dropsByScope[drag.scopes[i]];
                    if (_dd) {
                        for (var j = 0; j < _dd.length; j++) {
                            if (_dd[j].canDrop(drag) &&  !_m[_dd[j].uuid] && (_dd[j].allowLoopback || _dd[j].el !== drag.el)) {
                                _m[_dd[j].uuid] = true;
                                dd.push(_dd[j]);
                            }
                        }
                    }
                }
                return dd;
            },
            _prepareParams = function(p) {
                p = p || {};
                var _p = {
                    events:{}
                }, i;
                for (i in katavorioParams) _p[i] = katavorioParams[i];
                for (i in p) _p[i] = p[i];
                // events

                for (i = 0; i < _events.length; i++) {
                    _p.events[_events[i]] = p[_events[i]] || _devNull;
                }
                _p.katavorio = this;
                return _p;
            }.bind(this),
            _mistletoe = function(existingDrag, params) {
                for (var i = 0; i < _events.length; i++) {
                    if (params[_events[i]]) {
                        existingDrag.on(_events[i], params[_events[i]]);
                    }
                }
            }.bind(this),
            _css = {},
            overrideCss = katavorioParams.css || {},
            _scope = katavorioParams.scope || _defaultScope;

        // prepare map of css classes based on defaults frst, then optional overrides
        for (var i in _classes) _css[i] = _classes[i];
        for (var i in overrideCss) _css[i] = overrideCss[i];

        var inputFilterSelector = katavorioParams.inputFilterSelector || _defaultInputFilterSelector;
        /**
         * Gets the selector identifying which input elements to filter from drag events.
         * @method getInputFilterSelector
         * @return {String} Current input filter selector.
         */
        this.getInputFilterSelector = function() { return inputFilterSelector; };

        /**
         * Sets the selector identifying which input elements to filter from drag events.
         * @method setInputFilterSelector
         * @param {String} selector Input filter selector to set.
         * @return {Katavorio} Current instance; method may be chained.
         */
        this.setInputFilterSelector = function(selector) {
            inputFilterSelector = selector;
            return this;
        };

        this.draggable = function(el, params) {
            var o = [];
            _each(el, function(_el) {
                _el = _gel(_el);
                if (_el != null) {
                    if (_el._katavorioDrag == null) {
                        var p = _prepareParams(params);
                        _el._katavorioDrag = new Drag(_el, p, _css, _scope);
                        _reg(_el._katavorioDrag, this._dragsByScope);
                        o.push(_el._katavorioDrag);
                        katavorioParams.addClass(_el, _css.draggable);
                    }
                    else {
                        _mistletoe(_el._katavorioDrag, params);
                    }
                }
            }.bind(this));
            return o;

        };

        this.droppable = function(el, params) {
            var o = [];
            _each(el, function(_el) {
                _el = _gel(_el);
                if (_el != null) {
                    var drop = new Drop(_el, _prepareParams(params), _css, _scope);
                    _el._katavorioDrop = _el._katavorioDrop || [];
                    _el._katavorioDrop.push(drop);
                    _reg(drop, this._dropsByScope);
                    o.push(drop);
                    katavorioParams.addClass(_el, _css.droppable);
                }
            }.bind(this));
            return o;
        };

        /**
         * @name Katavorio#select
         * @function
         * @desc Adds an element to the current selection (for multiple node drag)
         * @param {Element|String} DOM element - or id of the element - to add.
         */
        this.select = function(el) {
            _each(el, function() {
                var _el = _gel(this);
                if (_el && _el._katavorioDrag) {
                    if (!_selectionMap[_el._katavorio]) {
                        _selection.push(_el._katavorioDrag);
                        _selectionMap[_el._katavorio] = [ _el, _selection.length - 1 ];
                        katavorioParams.addClass(_el, _css.selected);
                    }
                }
            });
            return this;
        };

        /**
         * @name Katavorio#deselect
         * @function
         * @desc Removes an element from the current selection (for multiple node drag)
         * @param {Element|String} DOM element - or id of the element - to remove.
         */
        this.deselect = function(el) {
            _each(el, function() {
                var _el = _gel(this);
                if (_el && _el._katavorio) {
                    var e = _selectionMap[_el._katavorio];
                    if (e) {
                        var _s = [];
                        for (var i = 0; i < _selection.length; i++)
                            if (_selection[i].el !== _el) _s.push(_selection[i]);
                        _selection = _s;
                        delete _selectionMap[_el._katavorio];
                        katavorioParams.removeClass(_el, _css.selected);
                    }
                }
            });
            return this;
        };

        this.deselectAll = function() {
            for (var i in _selectionMap) {
                var d = _selectionMap[i];
                katavorioParams.removeClass(d[0], _css.selected);
            }

            _selection.length = 0;
            _selectionMap = {};
        };

        this.markSelection = function(drag) {
            _foreach(_selection, function(e) { e.mark(); }, drag);
        };

        this.markPosses = function(drag) {
            if (drag.posses) {
                _each(drag.posses, function(p) {
                    if (drag.posseRoles[p] && _posses[p]) {
                        _foreach(_posses[p].members, function (d) {
                            d.mark();
                        }, drag);
                    }
                })
            }
        };

        this.unmarkSelection = function(drag, event) {
            _foreach(_selection, function(e) { e.unmark(event); }, drag);
        };

        this.unmarkPosses = function(drag, event) {
            if (drag.posses) {
                _each(drag.posses, function(p) {
                    if (drag.posseRoles[p] && _posses[p]) {
                        _foreach(_posses[p].members, function (d) {
                            d.unmark(event);
                        }, drag);
                    }
                });
            }
        };

        this.getSelection = function() { return _selection.slice(0); };

        this.updateSelection = function(dx, dy, drag) {
            _foreach(_selection, function(e) { e.moveBy(dx, dy); }, drag);
        };

        this.updatePosses = function(dx, dy, drag) {
            if (drag.posses) {
                _each(drag.posses, function(p) {
                    if (drag.posseRoles[p] && _posses[p]) {
                        _foreach(_posses[p].members, function (e) {
                            e.moveBy(dx, dy);
                        }, drag);
                    }
                });
            }
        };

        this.notifySelectionDragStop = function(drag, evt) {
            _foreach(_selection, function(e) { e.stop(evt, true); }, drag);
        };

        this.notifySelectionDragStart = function(drag, evt) {
            _foreach(_selection, function(e) { e.notifyStart(evt);}, drag);
        };

        this.setZoom = function(z) { _zoom = z; };
        this.getZoom = function() { return _zoom; };

        // does the work of changing scopes
        var _scopeManip = function(kObj, scopes, map, fn) {
            _each(kObj, function(_kObj) {
                _unreg(_kObj, map);  // deregister existing scopes
                _kObj[fn](scopes); // set scopes
                _reg(_kObj, map); // register new ones
            });
        };

        _each([ "set", "add", "remove", "toggle"], function(v) {
            this[v + "Scope"] = function(el, scopes) {
                _scopeManip(el._katavorioDrag, scopes, this._dragsByScope, v + "Scope");
                _scopeManip(el._katavorioDrop, scopes, this._dropsByScope, v + "Scope");
            }.bind(this);
            this[v + "DragScope"] = function(el, scopes) {
                _scopeManip(el._katavorioDrag, scopes, this._dragsByScope, v + "Scope");
            }.bind(this);
            this[v + "DropScope"] = function(el, scopes) {
                _scopeManip(el._katavorioDrop, scopes, this._dropsByScope, v + "Scope");
            }.bind(this);
        }.bind(this));

        this.snapToGrid = function(x, y) {
            for (var s in this._dragsByScope) {
                _foreach(this._dragsByScope[s], function(d) { d.snap(x, y); });
            }
        };

        this.getDragsForScope = function(s) { return this._dragsByScope[s]; };
        this.getDropsForScope = function(s) { return this._dropsByScope[s]; };

        var _destroy = function(el, type, map) {
            el = _gel(el);
            if (el[type]) {
                if (_unreg(el[type], map)) {
                    _each(el[type], function(kObj) { kObj.destroy() });
                }

                el[type] = null;
            }
        };

        this.elementRemoved = function(el) {
            this.destroyDraggable(el);
            this.destroyDroppable(el);
        };

        this.destroyDraggable = function(el) {
            _destroy(el, "_katavorioDrag", this._dragsByScope);
        };

        this.destroyDroppable = function(el) {
            _destroy(el, "_katavorioDrop", this._dropsByScope);
        };

        this.reset = function() {
            this._dragsByScope = {};
            this._dropsByScope = {};
            _selection = [];
            _selectionMap = {};
            _posses = {};
        };

        // ----- groups
        var _posses = {};
        /**
         * Add the given element to the posse with the given id, creating the group if it at first does not exist.
         * @param {Element} el Element to add.
         * @param {String...|Object...} spec Variable args parameters. Each argument can be a either a String, indicating
         * the ID of a Posse to which the element should be added as an active participant, or an Object containing
         * `{ id:"posseId", active:false/true}`. In the latter case, if `active` is not provided it is assumed to be
         * true.
         * @returns {Posse} The Posse to which the element(s) was/were added.
         */
        this.addToPosse = function(el, spec) {

            var posses = [], posseId, active;

            var _one = function(_spec) {
                posseId = _isString(_spec) ? _spec : _spec.id;
                active = _isString(_spec) ? true : _spec.active !== false;
                var posse = _posses[posseId] || (function() {
                    var g = {name:posseId, members:[]};
                    _posses[posseId] = g;
                    return g;
                })();
                _each(el, function(_el) {
                    if (_el._katavorioDrag) {
                        posse.members.suggest(_el._katavorioDrag);
                        _el._katavorioDrag.posses.suggest(posse.name);
                        _el._katavorioDrag.posseRoles[posse.name] = active;
                    }
                });
                posses.push(posse);
            };

            for (var i = 1; i < arguments.length; i++) {
                _one(arguments[i]);
            }



            return posses.length == 1 ? posses[0] : posses;
        };

        /**
         * Remove the given element from the given posse(s).
         * @param {Element} el Element to remove.
         * @param {String...} posseId Varargs parameter: one value for each posse to remove the element from.
         */
        this.removeFromPosse = function(el, posseId) {
            if (arguments.length < 2) throw new TypeError("No posse id provided for remove operation");
            for(var i = 1; i < arguments.length; i++) {
                posseId = arguments[i];
                _each(el, function (_el) {
                    if (_el._katavorioDrag && _el._katavorioDrag.posses) {
                        var d = _el._katavorioDrag;
                        _each(posseId, function (p) {
                            _posses[p].members.vanquish(d);
                            d.posses.vanquish(p);
                            delete d.posseRoles[p];
                        });
                    }
                });
            }
        };

        /**
         * Remove the given element from all Posses to which it belongs.
         * @param {Element|Element[]} el Element to remove from Posses.
         */
        this.removeFromAllPosses = function(el) {
            _each(el, function(_el) {
                if (_el._katavorioDrag && _el._katavorioDrag.posses) {
                    var d = _el._katavorioDrag;
                    _each(d.posses, function(p) {
                        _posses[p].members.vanquish(d);
                    });
                    d.posses.length = 0;
                    d.posseRoles = {};
                }
            });
        };
    };
}).call(this);

/*
 * jsPlumb
 *
 * Title:jsPlumb 2.0.2
 *
 * Provides a way to visually connect elements on an HTML page, using SVG.
 *
 * This file contains utility functions that run in both browsers and headless.
 *
 * Copyright (c) 2010 - 2015 jsPlumb (hello@jsplumbtoolkit.com)
 *
 * http://jsplumbtoolkit.com
 * http://github.com/sporritt/jsplumb
 *
 * Dual licensed under the MIT and GPL2 licenses.
 */

;
(function () {

    var _isa = function (a) {
            return Object.prototype.toString.call(a) === "[object Array]";
        },
        _isnum = function (n) {
            return Object.prototype.toString.call(n) === "[object Number]";
        },
        _iss = function (s) {
            return typeof s === "string";
        },
        _isb = function (s) {
            return typeof s === "boolean";
        },
        _isnull = function (s) {
            return s == null;
        },
        _iso = function (o) {
            return o == null ? false : Object.prototype.toString.call(o) === "[object Object]";
        },
        _isd = function (o) {
            return Object.prototype.toString.call(o) === "[object Date]";
        },
        _isf = function (o) {
            return Object.prototype.toString.call(o) === "[object Function]";
        },
        _ise = function (o) {
            for (var i in o) {
                if (o.hasOwnProperty(i)) return false;
            }
            return true;
        };

    var root = this;
    var exports = root.jsPlumbUtil = {
        isArray: _isa,
        isString: _iss,
        isBoolean: _isb,
        isNull: _isnull,
        isObject: _iso,
        isDate: _isd,
        isFunction: _isf,
        isEmpty: _ise,
        isNumber: _isnum,
        clone: function (a) {
            if (_iss(a)) return "" + a;
            else if (_isb(a)) return !!a;
            else if (_isd(a)) return new Date(a.getTime());
            else if (_isf(a)) return a;
            else if (_isa(a)) {
                var b = [];
                for (var i = 0; i < a.length; i++)
                    b.push(this.clone(a[i]));
                return b;
            }
            else if (_iso(a)) {
                var c = {};
                for (var j in a)
                    c[j] = this.clone(a[j]);
                return c;
            }
            else return a;
        },
        merge: function (a, b, collations) {
            // first change the collations array - if present - into a lookup table, because its faster.
            var cMap = {}, ar, i;
            collations = collations || [];
            for (i = 0; i < collations.length; i++)
                cMap[collations[i]] = true;

            var c = this.clone(a);
            for (i in b) {
                if (c[i] == null) {
                    c[i] = b[i];
                }
                else if (_iss(b[i]) || _isb(b[i])) {
                    if (!cMap[i]) {
                        c[i] = b[i]; // if we dont want to collate, just copy it in.
                    }
                    else {
                        ar = [];
                        // if c's object is also an array we can keep its values.
                        ar.push.apply(ar, _isa(c[i]) ? c[i] : [ c[i] ]);
                        ar.push.apply(ar, _isa(b[i]) ? b[i] : [ b[i] ]);
                        c[i] = ar;
                    }
                }
                else {
                    if (_isa(b[i])) {
                        ar = [];
                        // if c's object is also an array we can keep its values.
                        if (_isa(c[i])) ar.push.apply(ar, c[i]);
                        ar.push.apply(ar, b[i]);
                        c[i] = ar;
                    }
                    else if (_iso(b[i])) {
                        // overwite c's value with an object if it is not already one.
                        if (!_iso(c[i]))
                            c[i] = {};
                        for (var j in b[i]) {
                            c[i][j] = b[i][j];
                        }
                    }
                }

            }
            return c;
        },
        replace: function (inObj, path, value) {
            if (inObj == null) return;
            var q = inObj, t = q;
            path.replace(/([^\.])+/g, function (term, lc, pos, str) {
                var array = term.match(/([^\[0-9]+){1}(\[)([0-9+])/),
                    last = pos + term.length >= str.length,
                    _getArray = function () {
                        return t[array[1]] || (function () {
                            t[array[1]] = [];
                            return t[array[1]];
                        })();
                    };

                if (last) {
                    // set term = value on current t, creating term as array if necessary.
                    if (array)
                        _getArray()[array[3]] = value;
                    else
                        t[term] = value;
                }
                else {
                    // set to current t[term], creating t[term] if necessary.
                    if (array) {
                        var a = _getArray();
                        t = a[array[3]] || (function () {
                            a[array[3]] = {};
                            return a[array[3]];
                        })();
                    }
                    else
                        t = t[term] || (function () {
                            t[term] = {};
                            return t[term];
                        })();
                }
            });

            return inObj;
        },
        //
        // chain a list of functions, supplied by [ object, method name, args ], and return on the first
        // one that returns the failValue. if none return the failValue, return the successValue.
        //
        functionChain: function (successValue, failValue, fns) {
            for (var i = 0; i < fns.length; i++) {
                var o = fns[i][0][fns[i][1]].apply(fns[i][0], fns[i][2]);
                if (o === failValue) {
                    return o;
                }
            }
            return successValue;
        },
        // take the given model and expand out any parameters.
        populate: function (model, values) {
            // for a string, see if it has parameter matches, and if so, try to make the substitutions.
            var getValue = function (fromString) {
                    var matches = fromString.match(/(\${.*?})/g);
                    if (matches != null) {
                        for (var i = 0; i < matches.length; i++) {
                            var val = values[matches[i].substring(2, matches[i].length - 1)] || "";
                            if (val != null) {
                                fromString = fromString.replace(matches[i], val);
                            }
                        }
                    }
                    return fromString;
                },
            // process one entry.
                _one = function (d) {
                    if (d != null) {
                        if (_iss(d)) {
                            return getValue(d);
                        }
                        else if (_isa(d)) {
                            var r = [];
                            for (var i = 0; i < d.length; i++)
                                r.push(_one(d[i]));
                            return r;
                        }
                        else if (_iso(d)) {
                            var s = {};
                            for (var j in d) {
                                s[j] = _one(d[j]);
                            }
                            return s;
                        }
                        else {
                            return d;
                        }
                    }
                };

            return _one(model);
        },
        findWithFunction: function (a, f) {
            if (a)
                for (var i = 0; i < a.length; i++) if (f(a[i])) return i;
            return -1;
        },
        removeWithFunction: function (a, f) {
            var idx = exports.findWithFunction(a, f);
            if (idx > -1) a.splice(idx, 1);
            return idx != -1;
        },
        remove: function (l, v) {
            var idx = l.indexOf(v);
            if (idx > -1) l.splice(idx, 1);
            return idx != -1;
        },
        // TODO support insert index
        addWithFunction: function (list, item, hashFunction) {
            if (exports.findWithFunction(list, hashFunction) == -1) list.push(item);
        },
        addToList: function (map, key, value, insertAtStart) {
            var l = map[key];
            if (l == null) {
                l = [];
                map[key] = l;
            }
            l[insertAtStart ? "unshift" : "push"](value);
            return l;
        },
        //
        // extends the given obj (which can be an array) with the given constructor function, prototype functions, and
        // class members, any of which may be null.
        //
        extend: function (child, parent, _protoFn) {
            var i;
            parent = _isa(parent) ? parent : [ parent ];

            for (i = 0; i < parent.length; i++) {
                for (var j in parent[i].prototype) {
                    if (parent[i].prototype.hasOwnProperty(j)) {
                        child.prototype[j] = parent[i].prototype[j];
                    }
                }
            }

            var _makeFn = function (name, protoFn) {
                return function () {
                    for (i = 0; i < parent.length; i++) {
                        if (parent[i].prototype[name])
                            parent[i].prototype[name].apply(this, arguments);
                    }
                    return protoFn.apply(this, arguments);
                };
            };

            var _oneSet = function (fns) {
                for (var k in fns) {
                    child.prototype[k] = _makeFn(k, fns[k]);
                }
            };

            if (arguments.length > 2) {
                for (i = 2; i < arguments.length; i++)
                    _oneSet(arguments[i]);
            }

            return child;
        },
        uuid: function () {
            return ('xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            }));
        },
        logEnabled: true,
        log: function () {
            if (exports.logEnabled && typeof console != "undefined") {
                try {
                    var msg = arguments[arguments.length - 1];
                    console.log(msg);
                }
                catch (e) {
                }
            }
        },

        /**
         * Wraps one function with another, creating a placeholder for the
         * wrapped function if it was null. this is used to wrap the various
         * drag/drop event functions - to allow jsPlumb to be notified of
         * important lifecycle events without imposing itself on the user's
         * drag/drop functionality.
         * @method jsPlumbUtil.wrap
         * @param {Function} wrappedFunction original function to wrap; may be null.
         * @param {Function} newFunction function to wrap the original with.
         * @param {Object} [returnOnThisValue] Optional. Indicates that the wrappedFunction should
         * not be executed if the newFunction returns a value matching 'returnOnThisValue'.
         * note that this is a simple comparison and only works for primitives right now.
         */
        wrap: function (wrappedFunction, newFunction, returnOnThisValue) {
            wrappedFunction = wrappedFunction || function () {
            };
            newFunction = newFunction || function () {
            };
            return function () {
                var r = null;
                try {
                    r = newFunction.apply(this, arguments);
                } catch (e) {
                    exports.log("jsPlumb function failed : " + e);
                }
                if (returnOnThisValue == null || (r !== returnOnThisValue)) {
                    try {
                        r = wrappedFunction.apply(this, arguments);
                    } catch (e) {
                        exports.log("wrapped function failed : " + e);
                    }
                }
                return r;
            };
        }
    };

    exports.EventGenerator = function () {
        var _listeners = {},
            eventsSuspended = false,
        // this is a list of events that should re-throw any errors that occur during their dispatch. it is current private.
            eventsToDieOn = { "ready": true };

        this.bind = function (event, listener, insertAtStart) {
            var _one = function(evt) {
                exports.addToList(_listeners, evt, listener, insertAtStart);
                listener.__jsPlumb = listener.__jsPlumb || {};
                listener.__jsPlumb[jsPlumbUtil.uuid()] = evt;
            };

            if (typeof event === "string") _one(event);
            else if (event.length != null) {
                for (var i = 0; i < event.length; i++) {
                    _one(event[i]);
                }
            }

            return this;
        };

        this.fire = function (event, value, originalEvent) {
            if (!eventsSuspended && _listeners[event]) {
                var l = _listeners[event].length, i = 0, _gone = false, ret = null;
                if (!this.shouldFireEvent || this.shouldFireEvent(event, value, originalEvent)) {
                    while (!_gone && i < l && ret !== false) {
                        // doing it this way rather than catching and then possibly re-throwing means that an error propagated by this
                        // method will have the whole call stack available in the debugger.
                        if (eventsToDieOn[event])
                            _listeners[event][i].apply(this, [ value, originalEvent]);
                        else {
                            try {
                                ret = _listeners[event][i].apply(this, [ value, originalEvent ]);
                            } catch (e) {
                                exports.log("jsPlumb: fire failed for event " + event + " : " + e);
                            }
                        }
                        i++;
                        if (_listeners == null || _listeners[event] == null)
                            _gone = true;
                    }
                }
            }
            return this;
        };

        this.unbind = function (eventOrListener, listener) {

            if (arguments.length === 0) {
                _listeners = {};
            }
            else if (arguments.length === 1) {
                if (typeof eventOrListener === "string")
                    delete _listeners[eventOrListener];
                else if (eventOrListener.__jsPlumb) {
                    var evt;
                    for (var i in eventOrListener.__jsPlumb) {
                        evt = eventOrListener.__jsPlumb[i];
                        exports.remove(_listeners[evt] || [], eventOrListener);
                    }
                }
            }
            else if (arguments.length === 2) {
                exports.remove(_listeners[eventOrListener] || [], listener);
            }

            return this;
        };

        this.getListener = function (forEvent) {
            return _listeners[forEvent];
        };
        this.setSuspendEvents = function (val) {
            eventsSuspended = val;
        };
        this.isSuspendEvents = function () {
            return eventsSuspended;
        };
        this.silently = function(fn) {
            this.setSuspendEvents(true);
            try {
                fn();
            }
            catch (e) {
                jsPlumbUtil.log("Cannot execute silent function " + e);
            }
            this.setSuspendEvents(false);
        };
        this.cleanupListeners = function () {
            for (var i in _listeners) {
                _listeners[i] = null;
            }
        };
    };

    exports.EventGenerator.prototype = {
        cleanup: function () {
            this.cleanupListeners();
        }
    };

}).call(this);

/*
 * jsPlumb
 *
 * Title:jsPlumb 2.0.2
 *
 * Provides a way to visually connect elements on an HTML page, using SVG.
 *
 * This file contains utility functions that run in browsers only.
 *
 * Copyright (c) 2010 - 2015 jsPlumb (hello@jsplumbtoolkit.com)
 *
 * http://jsplumbtoolkit.com
 * http://github.com/sporritt/jsplumb
 *
 * Dual licensed under the MIT and GPL2 licenses.
 */
 ;(function() {

  "use strict";

   var root = this;
   var exports = root.jsPlumbUtil;

   exports.matchesSelector = function(el, selector, ctx) {
       ctx = ctx || el.parentNode;
       var possibles = ctx.querySelectorAll(selector);
       for (var i = 0; i < possibles.length; i++) {
           if (possibles[i] === el)
               return true;
       }
       return false;
   };

   exports.consume = function(e, doNotPreventDefault) {
       if (e.stopPropagation)
           e.stopPropagation();
       else
           e.returnValue = false;

       if (!doNotPreventDefault && e.preventDefault)
            e.preventDefault();
   };

   /*
    * Function: sizeElement
    * Helper to size and position an element. You would typically use
    * this when writing your own Connector or Endpoint implementation.
    *
    * Parameters:
    *  x - [int] x position for the element origin
    *  y - [int] y position for the element origin
    *  w - [int] width of the element
    *  h - [int] height of the element
    *
    */
   exports.sizeElement = function(el, x, y, w, h) {
       if (el) {
           el.style.height = h + "px";
           el.height = h;
           el.style.width = w + "px";
           el.width = w;
           el.style.left = x + "px";
           el.style.top = y + "px";
       }
   };


 }).call(this);

/*
 * jsPlumb
 * 
 * Title:jsPlumb 2.0.2
 * 
 * Provides a way to visually connect elements on an HTML page, using SVG.
 * 
 * This file contains the core code.
 *
 * Copyright (c) 2010 - 2015 jsPlumb (hello@jsplumbtoolkit.com)
 * 
 * http://jsplumbtoolkit.com
 * http://github.com/sporritt/jsplumb
 * 
 * Dual licensed under the MIT and GPL2 licenses.
 */
(function () {

    "use strict";

    var root = this;
    var connectorTypes = [], rendererTypes;

    var _ju = root.jsPlumbUtil,
        _getOffset = function (el, _instance, relativeToRoot) {
            return _instance.getOffset(el, relativeToRoot);
        },

        /**
         * creates a timestamp, using milliseconds since 1970, but as a string.
         */
        _timestamp = function () {
            return "" + (new Date()).getTime();
        },

    // helper method to update the hover style whenever it, or paintStyle, changes.
    // we use paintStyle as the foundation and merge hoverPaintStyle over the
    // top.
        _updateHoverStyle = function (component) {
            if (component._jsPlumb.paintStyle && component._jsPlumb.hoverPaintStyle) {
                var mergedHoverStyle = {};
                jsPlumb.extend(mergedHoverStyle, component._jsPlumb.paintStyle);
                jsPlumb.extend(mergedHoverStyle, component._jsPlumb.hoverPaintStyle);
                delete component._jsPlumb.hoverPaintStyle;
                // we want the fillStyle of paintStyle to override a gradient, if possible.
                if (mergedHoverStyle.gradient && component._jsPlumb.paintStyle.fillStyle)
                    delete mergedHoverStyle.gradient;
                component._jsPlumb.hoverPaintStyle = mergedHoverStyle;
            }
        },
        events = ["tap", "dbltap", "click", "dblclick", "mouseover", "mouseout", "mousemove", "mousedown", "mouseup", "contextmenu" ],
        eventFilters = { "mouseout": "mouseleave", "mouseexit": "mouseleave" },
        _updateAttachedElements = function (component, state, timestamp, sourceElement) {
            var affectedElements = component.getAttachedElements();
            if (affectedElements) {
                for (var i = 0, j = affectedElements.length; i < j; i++) {
                    if (!sourceElement || sourceElement != affectedElements[i])
                        affectedElements[i].setHover(state, true, timestamp);			// tell the attached elements not to inform their own attached elements.
                }
            }
        },
        _splitType = function (t) {
            return t == null ? null : t.split(" ");
        },
        _mapType = function(map, obj, typeId) {
            for (var i in obj)
                map[i] = typeId;
        },
        _each = function(fn, obj) {
            obj = jsPlumbUtil.isArray(obj) || (obj.length != null && !jsPlumbUtil.isString(obj)) ? obj : [ obj ];
            for (var i = 0; i < obj.length; i++) {
                try {
                    fn.apply(obj[i], [ obj[i] ]);
                }
                catch (e) {
                    jsPlumbUtil.log(".each iteration failed : " + e);
                }
            }
        },
        _applyTypes = function (component, params, doNotRepaint) {
            if (component.getDefaultType) {
                var td = component.getTypeDescriptor(), map = {};
                var defType = component.getDefaultType();
                var o = _ju.merge({}, defType);
                _mapType(map, defType, "__default");
                for (var i = 0, j = component._jsPlumb.types.length; i < j; i++) {
                    var tid = component._jsPlumb.types[i];
                    if (tid !== "__default") {
                        var _t = component._jsPlumb.instance.getType(tid, td);
                        if (_t != null) {
                            o = _ju.merge(o, _t, [ "cssClass" ]);
                            _mapType(map, _t, tid);
                        }
                    }
                }

                if (params) {
                    o = _ju.populate(o, params);
                }

                component.applyType(o, doNotRepaint, map);
                if (!doNotRepaint) component.repaint();
            }
        },

// ------------------------------ BEGIN jsPlumbUIComponent --------------------------------------------

        jsPlumbUIComponent = window.jsPlumbUIComponent = function (params) {

            jsPlumbUtil.EventGenerator.apply(this, arguments);

            var self = this,
                a = arguments,
                idPrefix = self.idPrefix,
                id = idPrefix + (new Date()).getTime();

            this._jsPlumb = {
                instance: params._jsPlumb,
                parameters: params.parameters || {},
                paintStyle: null,
                hoverPaintStyle: null,
                paintStyleInUse: null,
                hover: false,
                beforeDetach: params.beforeDetach,
                beforeDrop: params.beforeDrop,
                overlayPlacements: [],
                hoverClass: params.hoverClass || params._jsPlumb.Defaults.HoverClass,
                types: [],
                typeCache:{}
            };

            this.cacheTypeItem = function(key, item, typeId) {
                this._jsPlumb.typeCache[typeId] = this._jsPlumb.typeCache[typeId] || {};
                this._jsPlumb.typeCache[typeId][key] = item;
            };
            this.getCachedTypeItem = function(key, typeId) {
                return this._jsPlumb.typeCache[typeId] ? this._jsPlumb.typeCache[typeId][key] : null;
            };

            this.getId = function () {
                return id;
            };

// ----------------------------- default type --------------------------------------------


            var o = params.overlays || [], oo = {};
            if (this.defaultOverlayKeys) {
                for (var i = 0; i < this.defaultOverlayKeys.length; i++)
                    Array.prototype.push.apply(o, this._jsPlumb.instance.Defaults[this.defaultOverlayKeys[i]] || []);

                for (i = 0; i < o.length; i++) {
                    // if a string, convert to object representation so that we can store the typeid on it.
                    // also assign an id.
                    var fo = jsPlumb.convertToFullOverlaySpec(o[i]);
                    oo[fo[1].id] = fo;
                }
            }

            var _defaultType = {
                overlays:oo,
                parameters: params.parameters || {},
                scope: params.scope || this._jsPlumb.instance.getDefaultScope()
            };
            this.getDefaultType = function() {
                return _defaultType;
            };
            this.appendToDefaultType = function(obj) {
                for (var i in obj) _defaultType[i] = obj[i];
            };

// ----------------------------- end default type --------------------------------------------

            // all components can generate events

            if (params.events) {
                for (i in params.events)
                    self.bind(i, params.events[i]);
            }

            // all components get this clone function.
            // TODO issue 116 showed a problem with this - it seems 'a' that is in
            // the clone function's scope is shared by all invocations of it, the classic
            // JS closure problem.  for now, jsPlumb does a version of this inline where
            // it used to call clone.  but it would be nice to find some time to look
            // further at this.
            this.clone = function () {
                var o = {};//new Object();
                this.constructor.apply(o, a);
                return o;
            }.bind(this);

            // user can supply a beforeDetach callback, which will be executed before a detach
            // is performed; returning false prevents the detach.
            this.isDetachAllowed = function (connection) {
                var r = true;
                if (this._jsPlumb.beforeDetach) {
                    try {
                        r = this._jsPlumb.beforeDetach(connection);
                    }
                    catch (e) {
                        _ju.log("jsPlumb: beforeDetach callback failed", e);
                    }
                }
                return r;
            };

            // user can supply a beforeDrop callback, which will be executed before a dropped
            // connection is confirmed. user can return false to reject connection.
            this.isDropAllowed = function (sourceId, targetId, scope, connection, dropEndpoint, source, target) {
                var r = this._jsPlumb.instance.checkCondition("beforeDrop", {
                    sourceId: sourceId,
                    targetId: targetId,
                    scope: scope,
                    connection: connection,
                    dropEndpoint: dropEndpoint,
                    source: source, target: target
                });
                if (this._jsPlumb.beforeDrop) {
                    try {
                        r = this._jsPlumb.beforeDrop({
                            sourceId: sourceId,
                            targetId: targetId,
                            scope: scope,
                            connection: connection,
                            dropEndpoint: dropEndpoint,
                            source: source, target: target
                        });
                    }
                    catch (e) {
                        _ju.log("jsPlumb: beforeDrop callback failed", e);
                    }
                }
                return r;
            };

            var boundListeners = [],
                bindAListener = function (obj, type, fn) {
                    boundListeners.push([obj, type, fn]);
                    obj.bind(type, fn);
                },
                domListeners = [];

            // sets the component associated with listener events. for instance, an overlay delegates
            // its events back to a connector. but if the connector is swapped on the underlying connection,
            // then this component must be changed. This is called by setConnector in the Connection class.
            this.setListenerComponent = function (c) {
                for (var i = 0; i < domListeners.length; i++)
                    domListeners[i][3] = c;
            };


        };

    var _removeTypeCssHelper = function (component, typeIndex) {
        var typeId = component._jsPlumb.types[typeIndex],
            type = component._jsPlumb.instance.getType(typeId, component.getTypeDescriptor());

        if (type != null) {

            if (type.cssClass && component.canvas)
                component._jsPlumb.instance.removeClass(component.canvas, type.cssClass);
        }
    };

    jsPlumbUtil.extend(jsPlumbUIComponent, jsPlumbUtil.EventGenerator, {

        getParameter: function (name) {
            return this._jsPlumb.parameters[name];
        },

        setParameter: function (name, value) {
            this._jsPlumb.parameters[name] = value;
        },

        getParameters: function () {
            return this._jsPlumb.parameters;
        },

        setParameters: function (p) {
            this._jsPlumb.parameters = p;
        },

        getClass:function() {
            return jsPlumb.getClass(this.canvas);
        },

        hasClass:function(clazz) {
            return jsPlumb.hasClass(this.canvas, clazz);
        },

        addClass: function (clazz) {
            jsPlumb.addClass(this.canvas, clazz);
        },

        removeClass: function (clazz) {
            jsPlumb.removeClass(this.canvas, clazz);
        },

        updateClasses: function (classesToAdd, classesToRemove) {
            jsPlumb.updateClasses(this.canvas, classesToAdd, classesToRemove);
        },

        setType: function (typeId, params, doNotRepaint) {
            this.clearTypes();
            this._jsPlumb.types = _splitType(typeId) || [];
            _applyTypes(this, params, doNotRepaint);
        },

        getType: function () {
            return this._jsPlumb.types;
        },

        reapplyTypes: function (params, doNotRepaint) {
            _applyTypes(this, params, doNotRepaint);
        },

        hasType: function (typeId) {
            return this._jsPlumb.types.indexOf(typeId) != -1;
        },

        addType: function (typeId, params, doNotRepaint) {
            var t = _splitType(typeId), _cont = false;
            if (t != null) {
                for (var i = 0, j = t.length; i < j; i++) {
                    if (!this.hasType(t[i])) {
                        this._jsPlumb.types.push(t[i]);
                        _cont = true;
                    }
                }
                if (_cont) _applyTypes(this, params, doNotRepaint);
            }
        },

        removeType: function (typeId, doNotRepaint) {
            var t = _splitType(typeId), _cont = false, _one = function (tt) {
                var idx = this._jsPlumb.types.indexOf(tt);
                if (idx != -1) {
                    // remove css class if necessary
                    _removeTypeCssHelper(this, idx);
                    this._jsPlumb.types.splice(idx, 1);
                    return true;
                }
                return false;
            }.bind(this);

            if (t != null) {
                for (var i = 0, j = t.length; i < j; i++) {
                    _cont = _one(t[i]) || _cont;
                }
                if (_cont) _applyTypes(this, null, doNotRepaint);
            }
        },
        clearTypes: function (doNotRepaint) {
            var i = this._jsPlumb.types.length;
            for (var j = 0; j < i; j++) {
                _removeTypeCssHelper(this, 0);
                this._jsPlumb.types.splice(0, 1);
            }
            _applyTypes(this, {}, doNotRepaint);
        },

        toggleType: function (typeId, params, doNotRepaint) {
            var t = _splitType(typeId);
            if (t != null) {
                for (var i = 0, j = t.length; i < j; i++) {
                    var idx = this._jsPlumb.types.indexOf(t[i]);
                    if (idx != -1) {
                        _removeTypeCssHelper(this, idx);
                        this._jsPlumb.types.splice(idx, 1);
                    }
                    else
                        this._jsPlumb.types.push(t[i]);
                }

                _applyTypes(this, params, doNotRepaint);
            }
        },
        applyType: function (t, doNotRepaint) {
            this.setPaintStyle(t.paintStyle, doNotRepaint);
            this.setHoverPaintStyle(t.hoverPaintStyle, doNotRepaint);
            if (t.parameters) {
                for (var i in t.parameters)
                    this.setParameter(i, t.parameters[i]);
            }
            this._jsPlumb.paintStyleInUse = this.getPaintStyle();
        },
        setPaintStyle: function (style, doNotRepaint) {
//		    	this._jsPlumb.paintStyle = jsPlumb.extend({}, style);
// TODO figure out if we want components to clone paintStyle so as not to share it.
            this._jsPlumb.paintStyle = style;
            this._jsPlumb.paintStyleInUse = this._jsPlumb.paintStyle;
            _updateHoverStyle(this);
            if (!doNotRepaint) this.repaint();
        },
        getPaintStyle: function () {
            return this._jsPlumb.paintStyle;
        },
        setHoverPaintStyle: function (style, doNotRepaint) {
            //this._jsPlumb.hoverPaintStyle = jsPlumb.extend({}, style);
// TODO figure out if we want components to clone paintStyle so as not to share it.		    	
            this._jsPlumb.hoverPaintStyle = style;
            _updateHoverStyle(this);
            if (!doNotRepaint) this.repaint();
        },
        getHoverPaintStyle: function () {
            return this._jsPlumb.hoverPaintStyle;
        },
        destroy: function (force) {
            if (force || this.typeId == null) {
                this.cleanupListeners(); // this is on EventGenerator
                this.clone = null;
                this._jsPlumb = null;
            }
        },

        isHover: function () {
            return this._jsPlumb.hover;
        },

        setHover: function (hover, ignoreAttachedElements, timestamp) {
            // while dragging, we ignore these events.  this keeps the UI from flashing and
            // swishing and whatevering.
            if (this._jsPlumb && !this._jsPlumb.instance.currentlyDragging && !this._jsPlumb.instance.isHoverSuspended()) {

                this._jsPlumb.hover = hover;

                if (this.canvas != null) {
                    if (this._jsPlumb.instance.hoverClass != null) {
                        var method = hover ? "addClass" : "removeClass";
                        this._jsPlumb.instance[method](this.canvas, this._jsPlumb.instance.hoverClass);
                    }
                    if (this._jsPlumb.hoverClass != null) {
                        this._jsPlumb.instance[method](this.canvas, this._jsPlumb.hoverClass);
                    }
                }
                if (this._jsPlumb.hoverPaintStyle != null) {
                    this._jsPlumb.paintStyleInUse = hover ? this._jsPlumb.hoverPaintStyle : this._jsPlumb.paintStyle;
                    if (!this._jsPlumb.instance.isSuspendDrawing()) {
                        timestamp = timestamp || _timestamp();
                        this.repaint({timestamp: timestamp, recalc: false});
                    }
                }
                // get the list of other affected elements, if supported by this component.
                // for a connection, its the endpoints.  for an endpoint, its the connections! surprise.
                if (this.getAttachedElements && !ignoreAttachedElements)
                    _updateAttachedElements(this, hover, _timestamp(), this);
            }
        }
    });

// ------------------------------ END jsPlumbUIComponent --------------------------------------------

    var _jsPlumbInstanceIndex = 0,
        getInstanceIndex = function () {
            var i = _jsPlumbInstanceIndex + 1;
            _jsPlumbInstanceIndex++;
            return i;
        };

    var jsPlumbInstance = window.jsPlumbInstance = function (_defaults) {

        this.Defaults = {
            Anchor: "Bottom",
            Anchors: [ null, null ],
            ConnectionsDetachable: true,
            ConnectionOverlays: [ ],
            Connector: "Bezier",
            Container: null,
            DoNotThrowErrors: false,
            DragOptions: { },
            DropOptions: { },
            Endpoint: "Dot",
            EndpointOverlays: [ ],
            Endpoints: [ null, null ],
            EndpointStyle: { fillStyle: "#456" },
            EndpointStyles: [ null, null ],
            EndpointHoverStyle: null,
            EndpointHoverStyles: [ null, null ],
            HoverPaintStyle: null,
            LabelStyle: { color: "black" },
            LogEnabled: false,
            Overlays: [ ],
            MaxConnections: 1,
            PaintStyle: { lineWidth: 4, strokeStyle: "#456" },
            ReattachConnections: false,
            RenderMode: "svg",
            Scope: "jsPlumb_DefaultScope"
        };
        if (_defaults) jsPlumb.extend(this.Defaults, _defaults);

        this.logEnabled = this.Defaults.LogEnabled;
        this._connectionTypes = {};
        this._endpointTypes = {};

        jsPlumbUtil.EventGenerator.apply(this);

        var _currentInstance = this,
            _instanceIndex = getInstanceIndex(),
            _bb = _currentInstance.bind,
            _initialDefaults = {},
            _zoom = 1,
            _info = function (el) {
                if (el == null) return null;
                else if (el.nodeType == 3 || el.nodeType == 8) {
                    return { el:el, text:true };
                }
                else {
                    var _el = _currentInstance.getElement(el);
                    return { el: _el, id: (jsPlumbUtil.isString(el) && _el == null) ? el : _getId(_el) };
                }
            };

        this.getInstanceIndex = function () {
            return _instanceIndex;
        };

        this.setZoom = function (z, repaintEverything) {
            _zoom = z;
            _currentInstance.fire("zoom", _zoom);
            if (repaintEverything) _currentInstance.repaintEverything();
            return true;
        };
        this.getZoom = function () {
            return _zoom;
        };

        for (var i in this.Defaults)
            _initialDefaults[i] = this.Defaults[i];

        var _container, _containerDelegations = [];
        this.unbindContainer = function() {
            if (_container != null && _containerDelegations.length > 0) {
                for (var i = 0; i < _containerDelegations.length; i++) {
                    _currentInstance.off(_container, _containerDelegations[i][0], _containerDelegations[i][1]);
                }
            }
        };
        this.setContainer = function (c) {

            this.unbindContainer();

            // get container as dom element.
            c = this.getElement(c);
            // move existing connections and endpoints, if any.
            this.select().each(function (conn) {
                conn.moveParent(c);
            });
            this.selectEndpoints().each(function (ep) {
                ep.moveParent(c);
            });

            // set container.
            var previousContainer = _container;
            _container = c;
            _containerDelegations.length = 0;

            var _oneDelegateHandler = function (id, e) {
                var t = e.srcElement || e.target,
                    jp = (t && t.parentNode ? t.parentNode._jsPlumb : null) || (t ? t._jsPlumb : null) || (t && t.parentNode && t.parentNode.parentNode ? t.parentNode.parentNode._jsPlumb : null);
                if (jp) {
                    jp.fire(id, jp, e);
                    // jsplumb also fires every event coming from components/overlays. That's what the test for `jp.component` is for.
                    _currentInstance.fire(id, jp.component || jp, e);
                }
            };

            var _addOneDelegate = function(eventId, selector, fn) {
                _containerDelegations.push([eventId, fn]);
                _currentInstance.on(_container, eventId, selector, fn);
            };

            // delegate one event on the container to jsplumb elements. it might be possible to
            // abstract this out: each of endpoint, connection and overlay could register themselves with
            // jsplumb as "component types" or whatever, and provide a suitable selector. this would be
            // done by the renderer (although admittedly from 2.0 onwards we're not supporting vml anymore)
            var _oneDelegate = function (id) {
                // connections.
                //_addOneDelegate(id, ".jsplumb-connector, .jsplumb-connector > *", function (e) {
                _addOneDelegate(id, ".jsplumb-connector > *", function (e) {
                    _oneDelegateHandler(id, e);
                });
                // endpoints. note they can have an enclosing div, or not.
                _addOneDelegate(id, ".jsplumb-endpoint, .jsplumb-endpoint > *, .jsplumb-endpoint svg *", function (e) {
                    _oneDelegateHandler(id, e);
                });
                // overlays
                _addOneDelegate(id, ".jsplumb-overlay, .jsplumb-overlay *", function (e) {
                    _oneDelegateHandler(id, e);
                });
            };

            for (var i = 0; i < events.length; i++)
                _oneDelegate(events[i]);

            // managed elements
            for (var elId in managedElements) {
                var el = managedElements[elId].el;
                if (el.parentNode === previousContainer) {
                    previousContainer.removeChild(el);
                    _container.appendChild(el);
                }
            }

        };
        this.getContainer = function () {
            return _container;
        };

        this.bind = function (event, fn) {
            if ("ready" === event && initialized) fn();
            else _bb.apply(_currentInstance, [event, fn]);
        };

        _currentInstance.importDefaults = function (d) {
            for (var i in d) {
                _currentInstance.Defaults[i] = d[i];
            }
            if (d.Container)
                _currentInstance.setContainer(d.Container);

            return _currentInstance;
        };

        _currentInstance.restoreDefaults = function () {
            _currentInstance.Defaults = jsPlumb.extend({}, _initialDefaults);
            return _currentInstance;
        };

        var log = null,
            initialized = false,
        // TODO remove from window scope
            connections = [],
        // map of element id -> endpoint lists. an element can have an arbitrary
        // number of endpoints on it, and not all of them have to be connected
        // to anything.
            endpointsByElement = {},
            endpointsByUUID = {},
            managedElements = {},
            offsets = {},
            offsetTimestamps = {},
            draggableStates = {},
            connectionBeingDragged = false,
            sizes = [],
            _suspendDrawing = false,
            _suspendedAt = null,
            DEFAULT_SCOPE = this.Defaults.Scope,
            renderMode = null,  // will be set in init()
            _curIdStamp = 1,
            _idstamp = function () {
                return "" + _curIdStamp++;
            },

        //
        // appends an element to some other element, which is calculated as follows:
        //
        // 1. if Container exists, use that element.
        // 2. if the 'parent' parameter exists, use that.
        // 3. otherwise just use the root element.
        //
        //
            _appendElement = function (el, parent) {
                if (_container)
                    _container.appendChild(el);
                else if (!parent)
                    this.appendToRoot(el);
                else
                    this.getElement(parent).appendChild(el);
            }.bind(this),

        //
        // Draws an endpoint and its connections. this is the main entry point into drawing connections as well
        // as endpoints, since jsPlumb is endpoint-centric under the hood.
        //
        // @param element element to draw (of type library specific element object)
        // @param ui UI object from current library's event system. optional.
        // @param timestamp timestamp for this paint cycle. used to speed things up a little by cutting down the amount of offset calculations we do.
        // @param clearEdits defaults to false; indicates that mouse edits for connectors should be cleared
        ///
            _draw = function (element, ui, timestamp, clearEdits) {

                // TODO is it correct to filter by headless at this top level? how would a headless adapter ever repaint?
                // NO. it is not correct.
                if (!jsPlumb.headless && !_suspendDrawing) {
                    var id = _getId(element),
                        repaintEls = _currentInstance.getDragManager().getElementsForDraggable(id);

                    if (timestamp == null) timestamp = _timestamp();

                    // update the offset of everything _before_ we try to draw anything.
                    var o = _updateOffset({ elId: id, offset: ui, recalc: false, timestamp: timestamp });

                    if (repaintEls) {
                        for (var i in repaintEls) {
                            _updateOffset({
                                elId: repaintEls[i].id,
                                offset: {
                                    left: o.o.left + repaintEls[i].offset.left,
                                    top: o.o.top + repaintEls[i].offset.top
                                },
                                recalc: false,
                                timestamp: timestamp
                            });
                        }
                    }

                    _currentInstance.anchorManager.redraw(id, ui, timestamp, null, clearEdits);

                    if (repaintEls) {
                        for (var j in repaintEls) {
                            _currentInstance.anchorManager.redraw(repaintEls[j].id, ui, timestamp, repaintEls[j].offset, clearEdits, true);
                        }
                    }
                }
            },

        //
        // gets an Endpoint by uuid.
        //
            _getEndpoint = function (uuid) {
                return endpointsByUUID[uuid];
            },

            /**
             * inits a draggable if it's not already initialised.
             * TODO: somehow abstract this to the adapter, because the concept of "draggable" has no
             * place on the server.
             */
            _initDraggableIfNecessary = function (element, isDraggable, dragOptions, id) {
                // move to DragManager?
                if (!jsPlumb.headless) {
                    var _draggable = isDraggable == null ? false : isDraggable;
                    if (_draggable) {
                        if (jsPlumb.isDragSupported(element, _currentInstance)) {
                            var options = dragOptions || _currentInstance.Defaults.DragOptions;
                            options = jsPlumb.extend({}, options); // make a copy.
                            if (!jsPlumb.isAlreadyDraggable(element, _currentInstance)) {
                                var dragEvent = jsPlumb.dragEvents.drag,
                                    stopEvent = jsPlumb.dragEvents.stop,
                                    startEvent = jsPlumb.dragEvents.start,
                                    _del = _currentInstance.getElement(element),
                                    _ancestor = _currentInstance.getDragManager().getDragAncestor(_del),
                                    _noOffset = {left: 0, top: 0},
                                    _ancestorOffset = _noOffset,
                                    _started = false;

                                _manage(id, element);

                                options[startEvent] = _ju.wrap(options[startEvent], function () {
                                    _ancestorOffset = _ancestor != null ? _currentInstance.getOffset(_ancestor) : _noOffset;
                                    _currentInstance.setHoverSuspended(true);
                                    _currentInstance.select({source: element}).addClass(_currentInstance.elementDraggingClass + " " + _currentInstance.sourceElementDraggingClass, true);
                                    _currentInstance.select({target: element}).addClass(_currentInstance.elementDraggingClass + " " + _currentInstance.targetElementDraggingClass, true);
                                    _currentInstance.setConnectionBeingDragged(true);
                                    if (options.canDrag) return dragOptions.canDrag();
                                }, false);

                                options[dragEvent] = _ju.wrap(options[dragEvent], function () {
                                    // TODO: here we could actually use getDragObject, and then compute it ourselves,
                                    // since every adapter does the same thing. but i'm not sure why YUI's getDragObject
                                    // differs from getUIPosition so much
                                    var ui = _currentInstance.getUIPosition(arguments, _currentInstance.getZoom());
                                    // adjust by ancestor offset if there is one: this is for the case that a draggable
                                    // is contained inside some other element that is not the Container.
                                    ui.left += _ancestorOffset.left;
                                    ui.top += _ancestorOffset.top;
                                    _draw(element, ui, null, true);
                                    if (_started) _currentInstance.addClass(element, "jsplumb-dragged");
                                    _started = true;
                                });
                                options[stopEvent] = _ju.wrap(options[stopEvent], function () {
                                    var elements = arguments[0].selection;
                                    var uip = _currentInstance.getUIPosition(arguments);

                                    // this is one element
                                    var _one = function (_e) {
                                        _draw(_e[0], uip);
                                        _currentInstance.removeClass(_e[0], "jsplumb-dragged");
                                        _currentInstance.select({source: _e[0]}).removeClass(_currentInstance.elementDraggingClass + " " + _currentInstance.sourceElementDraggingClass, true);
                                        _currentInstance.select({target: _e[0]}).removeClass(_currentInstance.elementDraggingClass + " " + _currentInstance.targetElementDraggingClass, true);
                                        _currentInstance.getDragManager().dragEnded(_e[0]);
                                    };

                                    for (var i = 0; i < elements.length; i++)
                                        _one(elements[i]);

                                    // this is common across all
                                    _started = false;
                                    _currentInstance.setHoverSuspended(false);
                                    _currentInstance.setConnectionBeingDragged(false);
                                });
                                var elId = _getId(element); // need ID
                                draggableStates[elId] = true;
                                var draggable = draggableStates[elId];
                                options.disabled = draggable == null ? false : !draggable;
                                _currentInstance.initDraggable(element, options);
                                _currentInstance.getDragManager().register(element);
                            }
                            else {
                                // already draggable. attach any start, drag or stop listeners to the current Drag.
                                if (dragOptions.force) {
                                    _currentInstance.initDraggable(element, options);
                                }
                            }
                        }
                    }
                }
            },

            _scopeMatch = function (e1, e2) {
                var s1 = e1.scope.split(/\s/), s2 = e2.scope.split(/\s/);
                for (var i = 0; i < s1.length; i++)
                    for (var j = 0; j < s2.length; j++)
                        if (s2[j] == s1[i]) return true;

                return false;
            },

        /*
         * prepares a final params object that can be passed to _newConnection, taking into account defaults, events, etc.
         */
            _prepareConnectionParams = function (params, referenceParams) {
                var _p = jsPlumb.extend({ }, params);
                if (referenceParams) jsPlumb.extend(_p, referenceParams);

                // hotwire endpoints passed as source or target to sourceEndpoint/targetEndpoint, respectively.
                if (_p.source) {
                    if (_p.source.endpoint)
                        _p.sourceEndpoint = _p.source;
                    else
                        _p.source = _currentInstance.getElement(_p.source);
                }
                if (_p.target) {
                    if (_p.target.endpoint)
                        _p.targetEndpoint = _p.target;
                    else
                        _p.target = _currentInstance.getElement(_p.target);
                }

                // test for endpoint uuids to connect
                if (params.uuids) {
                    _p.sourceEndpoint = _getEndpoint(params.uuids[0]);
                    _p.targetEndpoint = _getEndpoint(params.uuids[1]);
                }

                // now ensure that if we do have Endpoints already, they're not full.
                // source:
                if (_p.sourceEndpoint && _p.sourceEndpoint.isFull()) {
                    _ju.log(_currentInstance, "could not add connection; source endpoint is full");
                    return;
                }

                // target:
                if (_p.targetEndpoint && _p.targetEndpoint.isFull()) {
                    _ju.log(_currentInstance, "could not add connection; target endpoint is full");
                    return;
                }

                // if source endpoint mandates connection type and nothing specified in our params, use it.
                if (!_p.type && _p.sourceEndpoint)
                    _p.type = _p.sourceEndpoint.connectionType;

                // copy in any connectorOverlays that were specified on the source endpoint.
                // it doesnt copy target endpoint overlays.  i'm not sure if we want it to or not.
                if (_p.sourceEndpoint && _p.sourceEndpoint.connectorOverlays) {
                    _p.overlays = _p.overlays || [];
                    for (var i = 0, j = _p.sourceEndpoint.connectorOverlays.length; i < j; i++) {
                        _p.overlays.push(_p.sourceEndpoint.connectorOverlays[i]);
                    }
                }

                // pointer events
                if (!_p["pointer-events"] && _p.sourceEndpoint && _p.sourceEndpoint.connectorPointerEvents)
                    _p["pointer-events"] = _p.sourceEndpoint.connectorPointerEvents;

                var _mergeOverrides = function (def, values) {
                    var m = jsPlumb.extend({}, def);
                    for (var i in values) {
                        if (values[i]) m[i] = values[i];
                    }
                    return m;
                };

                var _addEndpoint = function (el, def, idx) {
                    return _currentInstance.addEndpoint(el, _mergeOverrides(def, {
                        anchor: _p.anchors ? _p.anchors[idx] : _p.anchor,
                        endpoint: _p.endpoints ? _p.endpoints[idx] : _p.endpoint,
                        paintStyle: _p.endpointStyles ? _p.endpointStyles[idx] : _p.endpointStyle,
                        hoverPaintStyle: _p.endpointHoverStyles ? _p.endpointHoverStyles[idx] : _p.endpointHoverStyle
                    }));
                };

                // check for makeSource/makeTarget specs.

                var _oneElementDef = function (type, idx, defs, matchType) {
                    if (_p[type] && !_p[type].endpoint && !_p[type + "Endpoint"] && !_p.newConnection) {
                        var tid = _getId(_p[type]), tep = defs[tid];

                        tep = tep ? tep[matchType] : null;

                        if (tep) {
                            // if not enabled, return.
                            if (!tep.enabled) return false;
                            var newEndpoint = tep.endpoint != null && tep.endpoint._jsPlumb ? tep.endpoint : _addEndpoint(_p[type], tep.def, idx);
                            if (newEndpoint.isFull()) return false;
                            _p[type + "Endpoint"] = newEndpoint;
                            newEndpoint._doNotDeleteOnDetach = false; // reset.
                            newEndpoint._deleteOnDetach = true;
                            if (tep.uniqueEndpoint) {
                                if (!tep.endpoint) {
                                    tep.endpoint = newEndpoint;
                                    newEndpoint._deleteOnDetach = false;
                                    newEndpoint._doNotDeleteOnDetach = true;
                                }
                                else
                                    newEndpoint.finalEndpoint = tep.endpoint;
                            }
                        }
                    }
                };

                if (_oneElementDef("source", 0, this.sourceEndpointDefinitions, _p.type || "default") === false) return;
                if (_oneElementDef("target", 1, this.targetEndpointDefinitions, _p.type || "default") === false) return;

                // last, ensure scopes match
                if (_p.sourceEndpoint && _p.targetEndpoint)
                    if (!_scopeMatch(_p.sourceEndpoint, _p.targetEndpoint)) _p = null;

                return _p;
            }.bind(_currentInstance),

            _newConnection = function (params) {
                var connectionFunc = _currentInstance.Defaults.ConnectionType || _currentInstance.getDefaultConnectionType();

                params._jsPlumb = _currentInstance;
                params.newConnection = _newConnection;
                params.newEndpoint = _newEndpoint;
                params.endpointsByUUID = endpointsByUUID;
                params.endpointsByElement = endpointsByElement;
                params.finaliseConnection = _finaliseConnection;
                params.id = "con_" + _idstamp();
                var con = new connectionFunc(params);

                // if the connection is draggable, then maybe we need to tell the target endpoint to init the
                // dragging code. it won't run again if it already configured to be draggable.
                if (con.isDetachable()) {
                    con.endpoints[0].initDraggable("_jsPlumbSource");
                    con.endpoints[1].initDraggable("_jsPlumbTarget");
                }

                return con;
            },

        //
        // adds the connection to the backing model, fires an event if necessary and then redraws
        //
            _finaliseConnection = _currentInstance.finaliseConnection = function (jpc, params, originalEvent, doInformAnchorManager) {
                params = params || {};
                // add to list of connections (by scope).
                if (!jpc.suspendedEndpoint)
                    connections.push(jpc);

                jpc.pending = null;

                // turn off isTemporarySource on the source endpoint (only viable on first draw)
                jpc.endpoints[0].isTemporarySource = false;

                // always inform the anchor manager
                // except that if jpc has a suspended endpoint it's not true to say the
                // connection is new; it has just (possibly) moved. the question is whether
                // to make that call here or in the anchor manager.  i think perhaps here.
                if (doInformAnchorManager !== false)
                    _currentInstance.anchorManager.newConnection(jpc);

                // force a paint
                _draw(jpc.source);

                // fire an event
                if (!params.doNotFireConnectionEvent && params.fireEvent !== false) {

                    var eventArgs = {
                        connection: jpc,
                        source: jpc.source, target: jpc.target,
                        sourceId: jpc.sourceId, targetId: jpc.targetId,
                        sourceEndpoint: jpc.endpoints[0], targetEndpoint: jpc.endpoints[1]
                    };

                    _currentInstance.fire("connection", eventArgs, originalEvent);
                }
            },

        /*
         factory method to prepare a new endpoint.  this should always be used instead of creating Endpoints
         manually, since this method attaches event listeners and an id.
         */
            _newEndpoint = function (params, id) {
                var endpointFunc = _currentInstance.Defaults.EndpointType || jsPlumb.Endpoint;
                var _p = jsPlumb.extend({}, params);
                _p._jsPlumb = _currentInstance;
                _p.newConnection = _newConnection;
                _p.newEndpoint = _newEndpoint;
                _p.endpointsByUUID = endpointsByUUID;
                _p.endpointsByElement = endpointsByElement;
                _p.fireDetachEvent = fireDetachEvent;
                _p.elementId = id || _getId(_p.source);
                var ep = new endpointFunc(_p);
                ep.id = "ep_" + _idstamp();
                _manage(_p.elementId, _p.source);

                if (!jsPlumb.headless)
                    _currentInstance.getDragManager().endpointAdded(_p.source, id);

                return ep;
            },

        /*
         * performs the given function operation on all the connections found
         * for the given element id; this means we find all the endpoints for
         * the given element, and then for each endpoint find the connectors
         * connected to it. then we pass each connection in to the given
         * function.
         */
            _operation = function (elId, func, endpointFunc) {
                var endpoints = endpointsByElement[elId];
                if (endpoints && endpoints.length) {
                    for (var i = 0, ii = endpoints.length; i < ii; i++) {
                        for (var j = 0, jj = endpoints[i].connections.length; j < jj; j++) {
                            var retVal = func(endpoints[i].connections[j]);
                            // if the function passed in returns true, we exit.
                            // most functions return false.
                            if (retVal) return;
                        }
                        if (endpointFunc) endpointFunc(endpoints[i]);
                    }
                }
            },

            _setDraggable = function (element, draggable) {
                return jsPlumb.each(element, function (el) {
                    if (_currentInstance.isDragSupported(el)) {
                        draggableStates[_currentInstance.getAttribute(el, "id")] = draggable;
                        _currentInstance.setElementDraggable(el, draggable);
                    }
                });
            },
        /*
         * private method to do the business of hiding/showing.
         *
         * @param el
         *            either Id of the element in question or a library specific
         *            object for the element.
         * @param state
         *            String specifying a value for the css 'display' property
         *            ('block' or 'none').
         */
            _setVisible = function (el, state, alsoChangeEndpoints) {
                state = state === "block";
                var endpointFunc = null;
                if (alsoChangeEndpoints) {
                    if (state) endpointFunc = function (ep) {
                        ep.setVisible(true, true, true);
                    };
                    else endpointFunc = function (ep) {
                        ep.setVisible(false, true, true);
                    };
                }
                var info = _info(el);
                _operation(info.id, function (jpc) {
                    if (state && alsoChangeEndpoints) {
                        // this test is necessary because this functionality is new, and i wanted to maintain backwards compatibility.
                        // this block will only set a connection to be visible if the other endpoint in the connection is also visible.
                        var oidx = jpc.sourceId === info.id ? 1 : 0;
                        if (jpc.endpoints[oidx].isVisible()) jpc.setVisible(true);
                    }
                    else  // the default behaviour for show, and what always happens for hide, is to just set the visibility without getting clever.
                        jpc.setVisible(state);
                }, endpointFunc);
            },
        /*
         * toggles the draggable state of the given element(s).
         * el is either an id, or an element object, or a list of ids/element objects.
         */
            _toggleDraggable = function (el) {
                return jsPlumb.each(el, function (el) {
                    var elId = _currentInstance.getAttribute(el, "id");
                    var state = draggableStates[elId] == null ? false : draggableStates[elId];
                    state = !state;
                    draggableStates[elId] = state;
                    _currentInstance.setDraggable(el, state);
                    return state;
                }.bind(this));
            },
            /**
             * private method to do the business of toggling hiding/showing.
             */
            _toggleVisible = function (elId, changeEndpoints) {
                var endpointFunc = null;
                if (changeEndpoints) {
                    endpointFunc = function (ep) {
                        var state = ep.isVisible();
                        ep.setVisible(!state);
                    };
                }
                _operation(elId, function (jpc) {
                    var state = jpc.isVisible();
                    jpc.setVisible(!state);
                }, endpointFunc);
            },

        // TODO comparison performance
            _getCachedData = function (elId) {
                var o = offsets[elId];
                if (!o)
                    return _updateOffset({elId: elId});
                else
                    return {o: o, s: sizes[elId]};
            },

            /**
             * gets an id for the given element, creating and setting one if
             * necessary.  the id is of the form
             *
             *    jsPlumb_<instance index>_<index in instance>
             *
             * where "index in instance" is a monotonically increasing integer that starts at 0,
             * for each instance.  this method is used not only to assign ids to elements that do not
             * have them but also to connections and endpoints.
             */
            _getId = function (element, uuid, doNotCreateIfNotFound) {
                if (jsPlumbUtil.isString(element)) return element;
                if (element == null) return null;
                var id = _currentInstance.getAttribute(element, "id");
                if (!id || id === "undefined") {
                    // check if fixed uuid parameter is given
                    if (arguments.length == 2 && arguments[1] !== undefined)
                        id = uuid;
                    else if (arguments.length == 1 || (arguments.length == 3 && !arguments[2]))
                        id = "jsPlumb_" + _instanceIndex + "_" + _idstamp();

                    if (!doNotCreateIfNotFound) _currentInstance.setAttribute(element, "id", id);
                }
                return id;
            };

        this.setConnectionBeingDragged = function (v) {
            connectionBeingDragged = v;
        };
        this.isConnectionBeingDragged = function () {
            return connectionBeingDragged;
        };

        /**
         * Returns a map of all the elements this jsPlumbInstance is currently managing.
         * @returns {Object} Map of [id-> {el, endpoint[], connection, position}] information.
         */
        this.getManagedElements = function() {
            return managedElements;
        };

        this.getRenderMode = function() { return "svg"; };

        this.connectorClass = "jsplumb-connector";
        this.connectorOutlineClass = "jsplumb-connector-outline";
        this.connectedClass = "jsplumb-connected";
        this.hoverClass = "jsplumb-hover";
        this.endpointClass = "jsplumb-endpoint";
        this.endpointConnectedClass = "jsplumb-endpoint-connected";
        this.endpointFullClass = "jsplumb-endpoint-full";
        this.endpointDropAllowedClass = "jsplumb-endpoint-drop-allowed";
        this.endpointDropForbiddenClass = "jsplumb-endpoint-drop-forbidden";
        this.overlayClass = "jsplumb-overlay";
        this.draggingClass = "jsplumb-dragging";
        this.elementDraggingClass = "jsplumb-element-dragging";
        this.sourceElementDraggingClass = "jsplumb-source-element-dragging";
        this.targetElementDraggingClass = "jsplumb-target-element-dragging";
        this.endpointAnchorClassPrefix = "jsplumb-endpoint-anchor";
        this.hoverSourceClass = "jsplumb-source-hover";
        this.hoverTargetClass = "jsplumb-target-hover";
        this.dragSelectClass = "jsplumb-drag-select";

        this.Anchors = {};
        this.Connectors = {  "svg": {} };
        this.Endpoints = { "svg": {} };
        this.Overlays = { "svg": {} } ;
        this.ConnectorRenderers = {};
        this.SVG = "svg";

// --------------------------- jsPlumbInstance public API ---------------------------------------------------------


        this.addEndpoint = function (el, params, referenceParams) {
            referenceParams = referenceParams || {};
            var p = jsPlumb.extend({}, referenceParams);
            jsPlumb.extend(p, params);
            p.endpoint = p.endpoint || _currentInstance.Defaults.Endpoint;
            p.paintStyle = p.paintStyle || _currentInstance.Defaults.EndpointStyle;

            var results = [],
                inputs = (_ju.isArray(el) || (el.length != null && !_ju.isString(el))) ? el : [ el ];

            for (var i = 0, j = inputs.length; i < j; i++) {
                p.source = _currentInstance.getElement(inputs[i]);
                _ensureContainer(p.source);

                var id = _getId(p.source), e = _newEndpoint(p, id);

                // SP new. here we have introduced a class-wide element manager, which is responsible
                // for getting object dimensions and width/height, and for updating these values only
                // when necessary (after a drag, or on a forced refresh call).
                var myOffset = _manage(id, p.source).info.o;
                _ju.addToList(endpointsByElement, id, e);

                if (!_suspendDrawing) {
                    e.paint({
                        anchorLoc: e.anchor.compute({ xy: [ myOffset.left, myOffset.top ], wh: sizes[id], element: e, timestamp: _suspendedAt }),
                        timestamp: _suspendedAt
                    });
                }

                results.push(e);
                e._doNotDeleteOnDetach = true; // mark this as being added via addEndpoint.
            }

            return results.length == 1 ? results[0] : results;
        };

        this.addEndpoints = function (el, endpoints, referenceParams) {
            var results = [];
            for (var i = 0, j = endpoints.length; i < j; i++) {
                var e = _currentInstance.addEndpoint(el, endpoints[i], referenceParams);
                if (_ju.isArray(e))
                    Array.prototype.push.apply(results, e);
                else results.push(e);
            }
            return results;
        };

        this.animate = function (el, properties, options) {
            if (!this.animationSupported) return false;

            options = options || {};
            var del = _currentInstance.getElement(el),
                id = _getId(del),
                stepFunction = jsPlumb.animEvents.step,
                completeFunction = jsPlumb.animEvents.complete;

            options[stepFunction] = _ju.wrap(options[stepFunction], function () {
                _currentInstance.revalidate(id);
            });

            // onComplete repaints, just to make sure everything looks good at the end of the animation.
            options[completeFunction] = _ju.wrap(options[completeFunction], function () {
                _currentInstance.revalidate(id);
            });

            _currentInstance.doAnimate(del, properties, options);
        };

        /**
         * checks for a listener for the given condition, executing it if found, passing in the given value.
         * condition listeners would have been attached using "bind" (which is, you could argue, now overloaded, since
         * firing click events etc is a bit different to what this does).  i thought about adding a "bindCondition"
         * or something, but decided against it, for the sake of simplicity. jsPlumb will never fire one of these
         * condition events anyway.
         */
        this.checkCondition = function (conditionName, args) {
            var l = _currentInstance.getListener(conditionName),
                r = true;

            if (l && l.length > 0) {
                var values = Array.prototype.slice.call(arguments, 1);
                try {
                    for (var i = 0, j = l.length; i < j; i++) {
                        r = r && l[i].apply(l[i], values);
                    }
                }
                catch (e) {
                    _ju.log(_currentInstance, "cannot check condition [" + conditionName + "]" + e);
                }
            }
            return r;
        };

        this.connect = function (params, referenceParams) {
            // prepare a final set of parameters to create connection with
            var _p = _prepareConnectionParams(params, referenceParams), jpc;
            // TODO probably a nicer return value if the connection was not made.  _prepareConnectionParams
            // will return null (and log something) if either endpoint was full.  what would be nicer is to
            // create a dedicated 'error' object.
            if (_p) {
                if (_p.source == null && _p.sourceEndpoint == null) {
                    jsPlumbUtil.log("Cannot establish connection - source does not exist");
                    return;
                }
                if (_p.target == null && _p.targetEndpoint == null) {
                    jsPlumbUtil.log("Cannot establish connection - target does not exist");
                    return;
                }
                _ensureContainer(_p.source);
                // create the connection.  it is not yet registered
                jpc = _newConnection(_p);
                // now add it the model, fire an event, and redraw
                _finaliseConnection(jpc, _p);
            }
            return jpc;
        };

        var stTypes = [
            { el: "source", elId: "sourceId", epDefs: "sourceEndpointDefinitions" },
            { el: "target", elId: "targetId", epDefs: "targetEndpointDefinitions" }
        ];

        var _set = function (c, el, idx, doNotRepaint) {
            var ep, _st = stTypes[idx], cId = c[_st.elId], cEl = c[_st.el], sid, sep,
                oldEndpoint = c.endpoints[idx];

            var evtParams = {
                index: idx,
                originalSourceId: idx === 0 ? cId : c.sourceId,
                newSourceId: c.sourceId,
                originalTargetId: idx == 1 ? cId : c.targetId,
                newTargetId: c.targetId,
                connection: c
            };

            if (el.constructor == jsPlumb.Endpoint) { // TODO here match the current endpoint class; users can change it {
                ep = el;
                ep.addConnection(c);
            }
            else {
                sid = _getId(el);
                sep = this[_st.epDefs][sid];

                if (sid === c[_st.elId])
                    ep = null;  // dont change source/target if the element is already the one given.
                else if (sep) {
                    for (var t in sep) {
                        if (!sep[t].enabled) return;
                        ep = sep[t].endpoint != null && sep[t].endpoint._jsPlumb ? sep[t].endpoint : this.addEndpoint(el, sep[t].def);
                        if (sep[t].uniqueEndpoint) sep[t].endpoint = ep;
                        ep._doNotDeleteOnDetach = false;
                        ep._deleteOnDetach = true;
                        ep.addConnection(c);
                    }
                }
                else {
                    ep = c.makeEndpoint(idx === 0, el, sid);
                    ep._doNotDeleteOnDetach = false;
                    ep._deleteOnDetach = true;
                }
            }

            if (ep != null) {
                oldEndpoint.detachFromConnection(c);
                c.endpoints[idx] = ep;
                c[_st.el] = ep.element;
                c[_st.elId] = ep.elementId;
                evtParams[idx === 0 ? "newSourceId" : "newTargetId"] = ep.elementId;

                fireMoveEvent(evtParams);

                if (!doNotRepaint)
                    c.repaint();
            }

            return evtParams;

        }.bind(this);

        this.setSource = function (connection, el, doNotRepaint) {
            var p = _set(connection, el, 0, doNotRepaint);
            this.anchorManager.sourceChanged(p.originalSourceId, p.newSourceId, connection);
        };
        this.setTarget = function (connection, el, doNotRepaint) {
            var p = _set(connection, el, 1, doNotRepaint);
            this.anchorManager.updateOtherEndpoint(p.originalSourceId, p.originalTargetId, p.newTargetId, connection);
        };

        this.deleteEndpoint = function (object, dontUpdateHover) {
            var endpoint = (typeof object === "string") ? endpointsByUUID[object] : object;
            if (endpoint) {
                _currentInstance.deleteObject({ endpoint: endpoint, dontUpdateHover: dontUpdateHover });
            }
            return _currentInstance;
        };

        this.deleteEveryEndpoint = function () {
            var _is = _currentInstance.setSuspendDrawing(true);
            for (var id in endpointsByElement) {
                var endpoints = endpointsByElement[id];
                if (endpoints && endpoints.length) {
                    for (var i = 0, j = endpoints.length; i < j; i++) {
                        _currentInstance.deleteEndpoint(endpoints[i], true);
                    }
                }
            }
            endpointsByElement = {};
            // SP new
            managedElements = {};
            endpointsByUUID = {};
            offsets = {};
            offsetTimestamps = {};
            _currentInstance.anchorManager.reset();
            _currentInstance.getDragManager().reset();
            if (!_is) _currentInstance.setSuspendDrawing(false);
            return _currentInstance;
        };

        var fireDetachEvent = function (jpc, doFireEvent, originalEvent) {
            // may have been given a connection, or in special cases, an object
            var connType = _currentInstance.Defaults.ConnectionType || _currentInstance.getDefaultConnectionType(),
                argIsConnection = jpc.constructor == connType,
                params = argIsConnection ? {
                    connection: jpc,
                    source: jpc.source, target: jpc.target,
                    sourceId: jpc.sourceId, targetId: jpc.targetId,
                    sourceEndpoint: jpc.endpoints[0], targetEndpoint: jpc.endpoints[1]
                } : jpc;

            if (doFireEvent)
                _currentInstance.fire("connectionDetached", params, originalEvent);

            _currentInstance.anchorManager.connectionDetached(params);
        };

        var fireMoveEvent = _currentInstance.fireMoveEvent = function (params, evt) {
            _currentInstance.fire("connectionMoved", params, evt);
        };

        this.unregisterEndpoint = function (endpoint) {
            //if (endpoint._jsPlumb == null) return;
            if (endpoint._jsPlumb.uuid) endpointsByUUID[endpoint._jsPlumb.uuid] = null;
            _currentInstance.anchorManager.deleteEndpoint(endpoint);
            // TODO at least replace this with a removeWithFunction call.
            for (var e in endpointsByElement) {
                var endpoints = endpointsByElement[e];
                if (endpoints) {
                    var newEndpoints = [];
                    for (var i = 0, j = endpoints.length; i < j; i++)
                        if (endpoints[i] != endpoint) newEndpoints.push(endpoints[i]);

                    endpointsByElement[e] = newEndpoints;
                }
                if (endpointsByElement[e].length < 1) {
                    delete endpointsByElement[e];
                }
            }
        };

        this.detach = function () {

            if (arguments.length === 0) return;
            var connType = _currentInstance.Defaults.ConnectionType || _currentInstance.getDefaultConnectionType(),
                firstArgIsConnection = arguments[0].constructor == connType,
                params = arguments.length == 2 ? firstArgIsConnection ? (arguments[1] || {}) : arguments[0] : arguments[0],
                fireEvent = (params.fireEvent !== false),
                forceDetach = params.forceDetach,
                conn = firstArgIsConnection ? arguments[0] : params.connection;

            if (conn) {
                if (forceDetach || jsPlumbUtil.functionChain(true, false, [
                    [ conn.endpoints[0], "isDetachAllowed", [ conn ] ],
                    [ conn.endpoints[1], "isDetachAllowed", [ conn ] ],
                    [ conn, "isDetachAllowed", [ conn ] ],
                    [ _currentInstance, "checkCondition", [ "beforeDetach", conn ] ]
                ])) {

                    conn.endpoints[0].detach(conn, false, true, fireEvent);
                }
            }
            else {
                var _p = jsPlumb.extend({}, params); // a backwards compatibility hack: source should be thought of as 'params' in this case.
                // test for endpoint uuids to detach
                if (_p.uuids) {
                    _getEndpoint(_p.uuids[0]).detachFrom(_getEndpoint(_p.uuids[1]), fireEvent);
                } else if (_p.sourceEndpoint && _p.targetEndpoint) {
                    _p.sourceEndpoint.detachFrom(_p.targetEndpoint);
                } else {
                    var sourceId = _getId(_currentInstance.getElement(_p.source)),
                        targetId = _getId(_currentInstance.getElement(_p.target));
                    _operation(sourceId, function (jpc) {
                        if ((jpc.sourceId == sourceId && jpc.targetId == targetId) || (jpc.targetId == sourceId && jpc.sourceId == targetId)) {
                            if (_currentInstance.checkCondition("beforeDetach", jpc)) {
                                jpc.endpoints[0].detach(jpc, false, true, fireEvent);
                            }
                        }
                    });
                }
            }
        };

        this.detachAllConnections = function (el, params) {
            params = params || {};
            el = _currentInstance.getElement(el);
            var id = _getId(el),
                endpoints = endpointsByElement[id];
            if (endpoints && endpoints.length) {
                for (var i = 0, j = endpoints.length; i < j; i++) {
                    endpoints[i].detachAll(params.fireEvent !== false, params.forceDetach);
                }
            }
            return _currentInstance;
        };

        this.detachEveryConnection = function (params) {
            params = params || {};
            _currentInstance.batch(function () {
                for (var id in endpointsByElement) {
                    var endpoints = endpointsByElement[id];
                    if (endpoints && endpoints.length) {
                        for (var i = 0, j = endpoints.length; i < j; i++) {
                            endpoints[i].detachAll(params.fireEvent !== false, params.forceDetach);
                        }
                    }
                }
                connections.length = 0;
            });
            return _currentInstance;
        };

        /// not public.  but of course its exposed. how to change this.
        this.deleteObject = function (params) {
            var result = {
                    endpoints: {},
                    connections: {},
                    endpointCount: 0,
                    connectionCount: 0
                },
                fireEvent = params.fireEvent !== false,
                deleteAttachedObjects = params.deleteAttachedObjects !== false;

            var unravelConnection = function (connection) {
                if (connection != null && result.connections[connection.id] == null) {
                    if (!params.dontUpdateHover && connection._jsPlumb != null) connection.setHover(false);
                    result.connections[connection.id] = connection;
                    result.connectionCount++;
                    if (deleteAttachedObjects) {
                        for (var j = 0; j < connection.endpoints.length; j++) {
                            if (connection.endpoints[j]._deleteOnDetach)
                                unravelEndpoint(connection.endpoints[j]);
                        }
                    }
                }
            };
            var unravelEndpoint = function (endpoint) {
                if (endpoint != null && result.endpoints[endpoint.id] == null) {
                    if (!params.dontUpdateHover && endpoint._jsPlumb != null) endpoint.setHover(false);
                    result.endpoints[endpoint.id] = endpoint;
                    result.endpointCount++;

                    if (deleteAttachedObjects) {
                        for (var i = 0; i < endpoint.connections.length; i++) {
                            var c = endpoint.connections[i];
                            unravelConnection(c);
                        }
                    }
                }
            };

            if (params.connection)
                unravelConnection(params.connection);
            else unravelEndpoint(params.endpoint);

            // loop through connections
            for (var i in result.connections) {
                var c = result.connections[i];
                if (c._jsPlumb) {
                    jsPlumbUtil.removeWithFunction(connections, function (_c) {
                        return c.id == _c.id;
                    });

                    fireDetachEvent(c, params.fireEvent === false ? false : !c.pending, params.originalEvent);

                    c.endpoints[0].detachFromConnection(c);
                    c.endpoints[1].detachFromConnection(c);
                    c.cleanup(true);
                    c.destroy(true);
                }
            }

            // loop through endpoints
            for (var j in result.endpoints) {
                var e = result.endpoints[j];
                if (e._jsPlumb) {
                    _currentInstance.unregisterEndpoint(e);
                    // FIRE some endpoint deleted event?
                    e.cleanup(true);
                    e.destroy(true);
                }
            }

            return result;
        };

        this.draggable = function (el, options) {
            var info;
            _each(function(_el) {
                 info = _info(_el);
                if (info.el) _initDraggableIfNecessary(info.el, true, options, info.id);
            }, el);
            return _currentInstance;
        };

        this.droppable = function(el, options) {
            var info;
            options = options || {};
            options.allowLoopback = false;
            _each(function(_el) {
                info = _info(_el);
                if (info.el) _currentInstance.initDroppable(info.el, options);
            }, el);
            return _currentInstance;
        };

        // helpers for select/selectEndpoints
        var _setOperation = function (list, func, args, selector) {
                for (var i = 0, j = list.length; i < j; i++) {
                    list[i][func].apply(list[i], args);
                }
                return selector(list);
            },
            _getOperation = function (list, func, args) {
                var out = [];
                for (var i = 0, j = list.length; i < j; i++) {
                    out.push([ list[i][func].apply(list[i], args), list[i] ]);
                }
                return out;
            },
            setter = function (list, func, selector) {
                return function () {
                    return _setOperation(list, func, arguments, selector);
                };
            },
            getter = function (list, func) {
                return function () {
                    return _getOperation(list, func, arguments);
                };
            },
            prepareList = function (input, doNotGetIds) {
                var r = [];
                if (input) {
                    if (typeof input == 'string') {
                        if (input === "*") return input;
                        r.push(input);
                    }
                    else {
                        if (doNotGetIds) r = input;
                        else {
                            if (input.length) {
                                for (var i = 0, j = input.length; i < j; i++)
                                    r.push(_info(input[i]).id);
                            }
                            else
                                r.push(_info(input).id);
                        }
                    }
                }
                return r;
            },
            filterList = function (list, value, missingIsFalse) {
                if (list === "*") return true;
                return list.length > 0 ? list.indexOf(value) != -1 : !missingIsFalse;
            };

        // get some connections, specifying source/target/scope
        this.getConnections = function (options, flat) {
            if (!options) {
                options = {};
            } else if (options.constructor == String) {
                options = { "scope": options };
            }
            var scope = options.scope || _currentInstance.getDefaultScope(),
                scopes = prepareList(scope, true),
                sources = prepareList(options.source),
                targets = prepareList(options.target),
                results = (!flat && scopes.length > 1) ? {} : [],
                _addOne = function (scope, obj) {
                    if (!flat && scopes.length > 1) {
                        var ss = results[scope];
                        if (ss == null) {
                            ss = results[scope] = [];
                        }
                        ss.push(obj);
                    } else results.push(obj);
                };

            for (var j = 0, jj = connections.length; j < jj; j++) {
                var c = connections[j];
                if (filterList(scopes, c.scope) && filterList(sources, c.sourceId) && filterList(targets, c.targetId))
                    _addOne(c.scope, c);
            }

            return results;
        };

        var _curryEach = function (list, executor) {
                return function (f) {
                    for (var i = 0, ii = list.length; i < ii; i++) {
                        f(list[i]);
                    }
                    return executor(list);
                };
            },
            _curryGet = function (list) {
                return function (idx) {
                    return list[idx];
                };
            };

        var _makeCommonSelectHandler = function (list, executor) {
            var out = {
                    length: list.length,
                    each: _curryEach(list, executor),
                    get: _curryGet(list)
                },
                setters = ["setHover", "removeAllOverlays", "setLabel", "addClass", "addOverlay", "removeOverlay",
                    "removeOverlays", "showOverlay", "hideOverlay", "showOverlays", "hideOverlays", "setPaintStyle",
                    "setHoverPaintStyle", "setSuspendEvents", "setParameter", "setParameters", "setVisible",
                    "repaint", "addType", "toggleType", "removeType", "removeClass", "setType", "bind", "unbind" ],

                getters = ["getLabel", "getOverlay", "isHover", "getParameter", "getParameters", "getPaintStyle",
                    "getHoverPaintStyle", "isVisible", "hasType", "getType", "isSuspendEvents" ],
                i, ii;

            for (i = 0, ii = setters.length; i < ii; i++)
                out[setters[i]] = setter(list, setters[i], executor);

            for (i = 0, ii = getters.length; i < ii; i++)
                out[getters[i]] = getter(list, getters[i]);

            return out;
        };

        var _makeConnectionSelectHandler = function (list) {
            var common = _makeCommonSelectHandler(list, _makeConnectionSelectHandler);
            return jsPlumb.extend(common, {
                // setters
                setDetachable: setter(list, "setDetachable", _makeConnectionSelectHandler),
                setReattach: setter(list, "setReattach", _makeConnectionSelectHandler),
                setConnector: setter(list, "setConnector", _makeConnectionSelectHandler),
                detach: function () {
                    for (var i = 0, ii = list.length; i < ii; i++)
                        _currentInstance.detach(list[i]);
                },
                // getters
                isDetachable: getter(list, "isDetachable"),
                isReattach: getter(list, "isReattach")
            });
        };

        var _makeEndpointSelectHandler = function (list) {
            var common = _makeCommonSelectHandler(list, _makeEndpointSelectHandler);
            return jsPlumb.extend(common, {
                setEnabled: setter(list, "setEnabled", _makeEndpointSelectHandler),
                setAnchor: setter(list, "setAnchor", _makeEndpointSelectHandler),
                isEnabled: getter(list, "isEnabled"),
                detachAll: function () {
                    for (var i = 0, ii = list.length; i < ii; i++)
                        list[i].detachAll();
                },
                "remove": function () {
                    for (var i = 0, ii = list.length; i < ii; i++)
                        _currentInstance.deleteObject({endpoint: list[i]});
                }
            });
        };

        this.select = function (params) {
            params = params || {};
            params.scope = params.scope || "*";
            return _makeConnectionSelectHandler(params.connections || _currentInstance.getConnections(params, true));
        };

        this.selectEndpoints = function (params) {
            params = params || {};
            params.scope = params.scope || "*";
            var noElementFilters = !params.element && !params.source && !params.target,
                elements = noElementFilters ? "*" : prepareList(params.element),
                sources = noElementFilters ? "*" : prepareList(params.source),
                targets = noElementFilters ? "*" : prepareList(params.target),
                scopes = prepareList(params.scope, true);

            var ep = [];

            for (var el in endpointsByElement) {
                var either = filterList(elements, el, true),
                    source = filterList(sources, el, true),
                    sourceMatchExact = sources != "*",
                    target = filterList(targets, el, true),
                    targetMatchExact = targets != "*";

                // if they requested 'either' then just match scope. otherwise if they requested 'source' (not as a wildcard) then we have to match only endpoints that have isSource set to to true, and the same thing with isTarget.
                if (either || source || target) {
                    inner:
                        for (var i = 0, ii = endpointsByElement[el].length; i < ii; i++) {
                            var _ep = endpointsByElement[el][i];
                            if (filterList(scopes, _ep.scope, true)) {

                                var noMatchSource = (sourceMatchExact && sources.length > 0 && !_ep.isSource),
                                    noMatchTarget = (targetMatchExact && targets.length > 0 && !_ep.isTarget);

                                if (noMatchSource || noMatchTarget)
                                    continue inner;

                                ep.push(_ep);
                            }
                        }
                }
            }

            return _makeEndpointSelectHandler(ep);
        };

        // get all connections managed by the instance of jsplumb.
        this.getAllConnections = function () {
            return connections;
        };
        this.getDefaultScope = function () {
            return DEFAULT_SCOPE;
        };
        // get an endpoint by uuid.
        this.getEndpoint = _getEndpoint;
        // get endpoints for some element.
        this.getEndpoints = function (el) {
            return endpointsByElement[_info(el).id];
        };
        // gets the default endpoint type. used when subclassing. see wiki.
        this.getDefaultEndpointType = function () {
            return jsPlumb.Endpoint;
        };
        // gets the default connection type. used when subclassing.  see wiki.
        this.getDefaultConnectionType = function () {
            return jsPlumb.Connection;
        };
        /*
         * Gets an element's id, creating one if necessary. really only exposed
         * for the lib-specific functionality to access; would be better to pass
         * the current instance into the lib-specific code (even though this is
         * a static call. i just don't want to expose it to the public API).
         */
        this.getId = _getId;

        this.appendElement = _appendElement;

        var _hoverSuspended = false;
        this.isHoverSuspended = function () {
            return _hoverSuspended;
        };
        this.setHoverSuspended = function (s) {
            _hoverSuspended = s;
        };

        // set an element's connections to be hidden
        this.hide = function (el, changeEndpoints) {
            _setVisible(el, "none", changeEndpoints);
            return _currentInstance;
        };

        // exposed for other objects to use to get a unique id.
        this.idstamp = _idstamp;

        this.connectorsInitialized = false;
        this.registerConnectorType = function (connector, name) {
            connectorTypes.push([connector, name]);
        };

        // ensure that, if the current container exists, it is a DOM element and not a selector.
        // if it does not exist and `candidate` is supplied, the offset parent of that element will be set as the Container.
        // this is used to do a better default behaviour for the case that the user has not set a container:
        // addEndpoint, makeSource, makeTarget and connect all call this method with the offsetParent of the
        // element in question (for connect it is the source element). So if no container is set, it is inferred
        // to be the offsetParent of the first element the user tries to connect.
        var _ensureContainer = function (candidate) {
            if (!_container && candidate) {
                var can = _currentInstance.getElement(candidate);
                if (can.offsetParent) _currentInstance.setContainer(can.offsetParent);
            }
        };

        var _getContainerFromDefaults = function () {
            if (_currentInstance.Defaults.Container)
                _currentInstance.setContainer(_currentInstance.Defaults.Container);
        };

        // check if a given element is managed or not. if not, add to our map. if drawing is not suspended then
        // we'll also stash its dimensions; otherwise we'll do this in a lazy way through updateOffset.
        var _manage = _currentInstance.manage = function (id, element, transient) {
            if (!managedElements[id]) {
                managedElements[id] = {
                    el: element,
                    endpoints: [],
                    connections: []
                };

                managedElements[id].info = _updateOffset({ elId: id, timestamp: _suspendedAt });
                if (!transient) {
                    _currentInstance.fire("manageElement", { id:id, info:managedElements[id].info, el:element });
                }
            }

            return managedElements[id];
        };

        var _unmanage = function(id) {
            if (managedElements[id]) {
                delete managedElements[id];
                _currentInstance.fire("unmanageElement", id);
            }
        };

        /**
         * updates the offset and size for a given element, and stores the
         * values. if 'offset' is not null we use that (it would have been
         * passed in from a drag call) because it's faster; but if it is null,
         * or if 'recalc' is true in order to force a recalculation, we get the current values.
         */
        var _updateOffset = this.updateOffset = function (params) {

            var timestamp = params.timestamp, recalc = params.recalc, offset = params.offset, elId = params.elId, s;
            if (_suspendDrawing && !timestamp) timestamp = _suspendedAt;
            if (!recalc) {
                if (timestamp && timestamp === offsetTimestamps[elId]) {
                    return {o: params.offset || offsets[elId], s: sizes[elId]};
                }
            }
            if (recalc || (!offset && offsets[elId] == null)) { // if forced repaint or no offset available, we recalculate.

                // get the current size and offset, and store them
                s = managedElements[elId] ? managedElements[elId].el : null;
                if (s != null) {
                    sizes[elId] = _currentInstance.getSize(s);
                    offsets[elId] = _currentInstance.getOffset(s);
                    offsetTimestamps[elId] = timestamp;
                }
            } else {
                offsets[elId] = offset || offsets[elId];
                if (sizes[elId] == null) {
                    s = managedElements[elId].el;
                    if (s != null) sizes[elId] = _currentInstance.getSize(s);
                }
                offsetTimestamps[elId] = timestamp;
            }

            if (offsets[elId] && !offsets[elId].right) {
                offsets[elId].right = offsets[elId].left + sizes[elId][0];
                offsets[elId].bottom = offsets[elId].top + sizes[elId][1];
                offsets[elId].width = sizes[elId][0];
                offsets[elId].height = sizes[elId][1];
                offsets[elId].centerx = offsets[elId].left + (offsets[elId].width / 2);
                offsets[elId].centery = offsets[elId].top + (offsets[elId].height / 2);
            }

            return {o: offsets[elId], s: sizes[elId]};
        };

        /**
         * callback from the current library to tell us to prepare ourselves (attach
         * mouse listeners etc; can't do that until the library has provided a bind method)
         */
        this.init = function () {
            rendererTypes = jsPlumb.getRenderModes();

            var _oneType = function (renderer, name, fn) {
                jsPlumb.Connectors[renderer][name] = function () {
                    fn.apply(this, arguments);
                    jsPlumb.ConnectorRenderers[renderer].apply(this, arguments);
                };
                jsPlumbUtil.extend(jsPlumb.Connectors[renderer][name], [ fn, jsPlumb.ConnectorRenderers[renderer]]);
            };

            if (!jsPlumb.connectorsInitialized) {
                for (var i = 0; i < connectorTypes.length; i++) {
                    for (var j = 0; j < rendererTypes.length; j++) {
                        _oneType(rendererTypes[j], connectorTypes[i][1], connectorTypes[i][0]);
                    }

                }
                jsPlumb.connectorsInitialized = true;
            }

            if (!initialized) {
                _getContainerFromDefaults();
                _currentInstance.anchorManager = new jsPlumb.AnchorManager({jsPlumbInstance: _currentInstance});
                initialized = true;
                _currentInstance.fire("ready", _currentInstance);
            }
        }.bind(this);

        this.log = log;
        this.jsPlumbUIComponent = jsPlumbUIComponent;

        /*
         * Creates an anchor with the given params.
         *
         *
         * Returns: The newly created Anchor.
         * Throws: an error if a named anchor was not found.
         */
        this.makeAnchor = function () {
            var pp, _a = function (t, p) {
                if (jsPlumb.Anchors[t]) return new jsPlumb.Anchors[t](p);
                if (!_currentInstance.Defaults.DoNotThrowErrors)
                    throw { msg: "jsPlumb: unknown anchor type '" + t + "'" };
            };
            if (arguments.length === 0) return null;
            var specimen = arguments[0], elementId = arguments[1], jsPlumbInstance = arguments[2], newAnchor = null;
            // if it appears to be an anchor already...
            if (specimen.compute && specimen.getOrientation) return specimen;  //TODO hazy here about whether it should be added or is already added somehow.
            // is it the name of an anchor type?
            else if (typeof specimen == "string") {
                newAnchor = _a(arguments[0], {elementId: elementId, jsPlumbInstance: _currentInstance});
            }
            // is it an array? it will be one of:
            // 		an array of [spec, params] - this defines a single anchor, which may be dynamic, but has parameters.
            //		an array of arrays - this defines some dynamic anchors
            //		an array of numbers - this defines a single anchor.
            else if (_ju.isArray(specimen)) {
                if (_ju.isArray(specimen[0]) || _ju.isString(specimen[0])) {
                    // if [spec, params] format
                    if (specimen.length == 2 && _ju.isObject(specimen[1])) {
                        // if first arg is a string, its a named anchor with params
                        if (_ju.isString(specimen[0])) {
                            pp = jsPlumb.extend({elementId: elementId, jsPlumbInstance: _currentInstance}, specimen[1]);
                            newAnchor = _a(specimen[0], pp);
                        }
                        // otherwise first arg is array, second is params. we treat as a dynamic anchor, which is fine
                        // even if the first arg has only one entry. you could argue all anchors should be implicitly dynamic in fact.
                        else {
                            pp = jsPlumb.extend({elementId: elementId, jsPlumbInstance: _currentInstance, anchors: specimen[0]}, specimen[1]);
                            newAnchor = new jsPlumb.DynamicAnchor(pp);
                        }
                    }
                    else
                        newAnchor = new jsPlumb.DynamicAnchor({anchors: specimen, selector: null, elementId: elementId, jsPlumbInstance: _currentInstance});

                }
                else {
                    var anchorParams = {
                        x: specimen[0], y: specimen[1],
                        orientation: (specimen.length >= 4) ? [ specimen[2], specimen[3] ] : [0, 0],
                        offsets: (specimen.length >= 6) ? [ specimen[4], specimen[5] ] : [ 0, 0 ],
                        elementId: elementId,
                        jsPlumbInstance: _currentInstance,
                        cssClass: specimen.length == 7 ? specimen[6] : null
                    };
                    newAnchor = new jsPlumb.Anchor(anchorParams);
                    newAnchor.clone = function () {
                        return new jsPlumb.Anchor(anchorParams);
                    };
                }
            }

            if (!newAnchor.id) newAnchor.id = "anchor_" + _idstamp();
            return newAnchor;
        };

        /**
         * makes a list of anchors from the given list of types or coords, eg
         * ["TopCenter", "RightMiddle", "BottomCenter", [0, 1, -1, -1] ]
         */
        this.makeAnchors = function (types, elementId, jsPlumbInstance) {
            var r = [];
            for (var i = 0, ii = types.length; i < ii; i++) {
                if (typeof types[i] == "string")
                    r.push(jsPlumb.Anchors[types[i]]({elementId: elementId, jsPlumbInstance: jsPlumbInstance}));
                else if (_ju.isArray(types[i]))
                    r.push(_currentInstance.makeAnchor(types[i], elementId, jsPlumbInstance));
            }
            return r;
        };

        /**
         * Makes a dynamic anchor from the given list of anchors (which may be in shorthand notation as strings or dimension arrays, or Anchor
         * objects themselves) and the given, optional, anchorSelector function (jsPlumb uses a default if this is not provided; most people will
         * not need to provide this - i think).
         */
        this.makeDynamicAnchor = function (anchors, anchorSelector) {
            return new jsPlumb.DynamicAnchor({anchors: anchors, selector: anchorSelector, elementId: null, jsPlumbInstance: _currentInstance});
        };

// --------------------- makeSource/makeTarget ---------------------------------------------- 

        this.targetEndpointDefinitions = {};
        var _setEndpointPaintStylesAndAnchor = function (ep, epIndex, _instance) {
           /* ep.paintStyle = ep.paintStyle ||
                _instance.Defaults.EndpointStyles[epIndex] ||
                _instance.Defaults.EndpointStyle;

            ep.hoverPaintStyle = ep.hoverPaintStyle ||
                _instance.Defaults.EndpointHoverStyles[epIndex] ||
                _instance.Defaults.EndpointHoverStyle;

            ep.anchor = ep.anchor ||
                _instance.Defaults.Anchors[epIndex] ||
                _instance.Defaults.Anchor;

            ep.endpoint = ep.endpoint ||
                _instance.Defaults.Endpoints[epIndex] ||
                _instance.Defaults.Endpoint;*/
        };

        // TODO put all the source stuff inside one parent, keyed by id.
        this.sourceEndpointDefinitions = {};

        var selectorFilter = function (evt, _el, selector, _instance, negate) {
            var t = evt.target || evt.srcElement, ok = false,
                sel = _instance.getSelector(_el, selector);
            for (var j = 0; j < sel.length; j++) {
                if (sel[j] == t) {
                    ok = true;
                    break;
                }
            }
            return negate ? !ok : ok;
        };

        // SP target source refactor
        var _makeElementDropHandler = function (elInfo, p, dropOptions, isSource, isTarget) {
            var proxyComponent = new jsPlumbUIComponent(p);
            var _drop = p._jsPlumb.EndpointDropHandler({
                jsPlumb: _currentInstance,
                enabled: function () {
                    return elInfo.def.enabled;
                },
                isFull: function () {
                    var targetCount = _currentInstance.select({target: elInfo.id}).length;
                    return elInfo.def.maxConnections > 0 && targetCount >= elInfo.def.maxConnections;
                },
                element: elInfo.el,
                elementId: elInfo.id,
                isSource: isSource,
                isTarget: isTarget,
                addClass: function (clazz) {
                    _currentInstance.addClass(elInfo.el, clazz);
                },
                removeClass: function (clazz) {
                    _currentInstance.removeClass(elInfo.el, clazz);
                },
                onDrop: function (jpc) {
                    var source = jpc.endpoints[0];
                    source.anchor.locked = false;
                },
                isDropAllowed: function () {
                    return proxyComponent.isDropAllowed.apply(proxyComponent, arguments);
                },
                isRedrop:function(jpc) {
                    return (jpc.suspendedElement != null && jpc.suspendedEndpoint != null && jpc.suspendedEndpoint.element === elInfo.el);
                },
                getEndpoint: function (jpc) {

                    // make a new Endpoint for the target, or get it from the cache if uniqueEndpoint
                    // is set. if its a redrop the new endpoint will be immediately cleaned up.

                    var newEndpoint = elInfo.def.endpoint;

                    // if no cached endpoint, or there was one but it has been cleaned up
                    // (ie. detached), create a new one
                    if (newEndpoint == null || newEndpoint._jsPlumb == null) {
                        var eps = _currentInstance.deriveEndpointAndAnchorSpec(jpc.getType().join(" "), true);
                        var pp = eps.endpoints ? jsPlumb.extend(p, {
                            endpoint:elInfo.def.def.endpoint || eps.endpoints[1]
                        }) :p;
                        if (eps.anchors) {
                            pp = jsPlumb.extend(pp, {
                                anchor:elInfo.def.def.anchor || eps.anchors[1]
                            });
                        }
                        newEndpoint = _currentInstance.addEndpoint(elInfo.el, pp);
                        newEndpoint._mtNew = true;
                    }

                    if (p.uniqueEndpoint) elInfo.def.endpoint = newEndpoint;  // may of course just store what it just pulled out. that's ok.
                    // TODO test options to makeTarget to see if we should do this?
                    newEndpoint._doNotDeleteOnDetach = false; // reset.
                    newEndpoint._deleteOnDetach = true;

                    // if connection is detachable, init the new endpoint to be draggable, to support that happening.
                    if (jpc.isDetachable())
                        newEndpoint.initDraggable();

                    // if the anchor has a 'positionFinder' set, then delegate to that function to find
                    // out where to locate the anchor.
                    if (newEndpoint.anchor.positionFinder != null) {
                        var dropPosition = _currentInstance.getUIPosition(arguments, _currentInstance.getZoom()),
                            elPosition = _currentInstance.getOffset(elInfo.el),
                            elSize = _currentInstance.getSize(elInfo.el),
                            ap = newEndpoint.anchor.positionFinder(dropPosition, elPosition, elSize, newEndpoint.anchor.constructorParams);

                        newEndpoint.anchor.x = ap[0];
                        newEndpoint.anchor.y = ap[1];
                        // now figure an orientation for it..kind of hard to know what to do actually. probably the best thing i can do is to
                        // support specifying an orientation in the anchor's spec. if one is not supplied then i will make the orientation
                        // be what will cause the most natural link to the source: it will be pointing at the source, but it needs to be
                        // specified in one axis only, and so how to make that choice? i think i will use whichever axis is the one in which
                        // the target is furthest away from the source.
                    }

                    return newEndpoint;
                },
                maybeCleanup: function (ep) {
                    if (ep._mtNew && ep.connections.length === 0) {
                        _currentInstance.deleteObject({endpoint: ep});
                    }
                    else
                        delete ep._mtNew;
                }
            });

            // wrap drop events as needed and initialise droppable
            var dropEvent = jsPlumb.dragEvents.drop;
            dropOptions.scope = dropOptions.scope || (p.scope || _currentInstance.Defaults.Scope);
            dropOptions[dropEvent] = _ju.wrap(dropOptions[dropEvent], _drop, true);

            // if target, return true from the over event. this will cause katavorio to stop setting drops to hover
            // if multipleDrop is set to false.
            if (isTarget) {
                dropOptions[jsPlumb.dragEvents.over] = function () { return true; };
            }

            // vanilla jsplumb only
            if (p.allowLoopback === false) {
                dropOptions.canDrop = function (_drag) {
                    var de = _drag.getDragElement()._jsPlumbRelatedElement;
                    return de != elInfo.el;
                };
            }
            _currentInstance.initDroppable(elInfo.el, dropOptions, "internal");

            return _drop;

        };

        // see API docs
        this.makeTarget = function (el, params, referenceParams) {

            // put jsplumb ref into params without altering the params passed in
            var p = jsPlumb.extend({_jsPlumb: this}, referenceParams);
            jsPlumb.extend(p, params);

            // calculate appropriate paint styles and anchor from the params given
            _setEndpointPaintStylesAndAnchor(p, 1, this);

            var deleteEndpointsOnDetach = !(p.deleteEndpointsOnDetach === false),
                maxConnections = p.maxConnections || -1,

                _doOne = function (el) {

                    // get the element's id and store the endpoint definition for it.  jsPlumb.connect calls will look for one of these,
                    // and use the endpoint definition if found.
                    // decode the info for this element (id and element)
                    var elInfo = _info(el),
                        elid = elInfo.id,
                        dropOptions = jsPlumb.extend({}, p.dropOptions || {}),
                        type = "default";

                    this.targetEndpointDefinitions[elid] = this.targetEndpointDefinitions[elid] || {};

                    _ensureContainer(elid);

                    // store the definition
                    var _def = {
                        def: jsPlumb.extend({}, p),
                        uniqueEndpoint: p.uniqueEndpoint,
                        maxConnections: maxConnections,
                        enabled: true
                    };
                    elInfo.def = _def;
                    this.targetEndpointDefinitions[elid][type] = _def;
                    _makeElementDropHandler(elInfo, p, dropOptions, p.isSource === true, true);

                }.bind(this);

            // make an array if only given one element
            var inputs = el.length && el.constructor != String ? el : [ el ];

            // register each one in the list.
            for (var i = 0, ii = inputs.length; i < ii; i++) {
                _doOne(inputs[i]);
            }

            return this;
        };

        // see api docs
        this.unmakeTarget = function (el, doNotClearArrays) {
            var info = _info(el);
            jsPlumb.destroyDroppable(info.el);
            if (!doNotClearArrays) {
                delete this.targetEndpointDefinitions[info.id];
            }

            return this;
        };

        // see api docs
        this.makeSource = function (el, params, referenceParams) {
            var p = jsPlumb.extend({_jsPlumb: this}, referenceParams);
            jsPlumb.extend(p, params);
            var type = p.connectionType || "default";
            var aae = _currentInstance.deriveEndpointAndAnchorSpec(type);
            p.endpoint = p.endpoint || aae.endpoints[0];
            p.anchor = p.anchor || aae.anchors[0];
            _setEndpointPaintStylesAndAnchor(p, 0, this);
            var maxConnections = p.maxConnections || -1,
                onMaxConnections = p.onMaxConnections,
                _doOne = function (elInfo) {
                    // get the element's id and store the endpoint definition for it.  jsPlumb.connect calls will look for one of these,
                    // and use the endpoint definition if found.
                    var elid = elInfo.id,
                        _del = this.getElement(elInfo.el);

                    this.sourceEndpointDefinitions[elid] = this.sourceEndpointDefinitions[elid] || {};
                    _ensureContainer(elid);

                    var _def = {
                        def:jsPlumb.extend({}, p),
                        uniqueEndpoint: p.uniqueEndpoint,
                        maxConnections: maxConnections,
                        enabled: true
                    };


                    this.sourceEndpointDefinitions[elid][type] = _def;
                    elInfo.def = _def;

                    var stopEvent = jsPlumb.dragEvents.stop,
                        dragEvent = jsPlumb.dragEvents.drag,
                        dragOptions = jsPlumb.extend({ }, p.dragOptions || {}),
                        existingDrag = dragOptions.drag,
                        existingStop = dragOptions.stop,
                        ep = null,
                        endpointAddedButNoDragYet = false;

                    // set scope if its not set in dragOptions but was passed in in params
                    dragOptions.scope = dragOptions.scope || p.scope;

                    dragOptions[dragEvent] = _ju.wrap(dragOptions[dragEvent], function () {
                        if (existingDrag) existingDrag.apply(this, arguments);
                        endpointAddedButNoDragYet = false;
                    });

                    dragOptions[stopEvent] = _ju.wrap(dragOptions[stopEvent], function () {

                        if (existingStop) existingStop.apply(this, arguments);
                        this.currentlyDragging = false;
                        if (ep._jsPlumb != null) { // if not cleaned up...

                            // reset the anchor to the anchor that was initially provided. the one we were using to drag
                            // the connection was just a placeholder that was located at the place the user pressed the
                            // mouse button to initiate the drag.
                            var anchorDef = p.anchor || this.Defaults.Anchor,
                                oldAnchor = ep.anchor,
                                oldConnection = ep.connections[0];

                            // if the connection has a type, try to get an anchor spec for it.
                            /*if (oldConnection != null) {
                                var aae = _currentInstance.deriveEndpointAndAnchorSpec(oldConnection.getType().join(" "), false);
                                if (aae.anchors) anchorDef = aae.anchor[0];
                                if (aae.endpoints) ep.setEndpoint(aae.endpoints[0]);
                            }*/

                            var    newAnchor = this.makeAnchor(anchorDef, elid, this),
                                _el = ep.element;

                            // if the anchor has a 'positionFinder' set, then delegate to that function to find
                            // out where to locate the anchor. issue 117.
                            if (newAnchor.positionFinder != null) {
                                var elPosition = _currentInstance.getOffset(_el),
                                    elSize = this.getSize(_el),
                                    dropPosition = { left: elPosition.left + (oldAnchor.x * elSize[0]), top: elPosition.top + (oldAnchor.y * elSize[1]) },
                                    ap = newAnchor.positionFinder(dropPosition, elPosition, elSize, newAnchor.constructorParams);

                                newAnchor.x = ap[0];
                                newAnchor.y = ap[1];
                            }

                            ep.setAnchor(newAnchor, true);
                            ep.repaint();
                            this.repaint(ep.elementId);
                            if (oldConnection != null) this.repaint(oldConnection.targetId);
                        }
                    }.bind(this));

                    // when the user presses the mouse, add an Endpoint, if we are enabled.
                    var mouseDownListener = function (e) {
                        // on right mouse button, abort.
                        if (e.which === 3 || e.button === 2) return;

                        // TODO store def on element.
                        var def = this.sourceEndpointDefinitions[elid][type];

                        // if disabled, return.
                        if (!def.enabled) return;

                        elid = this.getId(this.getElement(elInfo.el)); // elid might have changed since this method was called to configure the element.

                        // if a filter was given, run it, and return if it says no.
                        if (p.filter) {
                            var r = jsPlumbUtil.isString(p.filter) ? selectorFilter(e, elInfo.el, p.filter, this, p.filterExclude) : p.filter(e, elInfo.el);
                            if (r === false) return;
                        }

                        // if maxConnections reached
                        var sourceCount = this.select({source: elid}).length;
                        if (def.maxConnections >= 0 && (sourceCount >= def.maxConnections)) {
                            if (onMaxConnections) {
                                onMaxConnections({
                                    element: elInfo.el,
                                    maxConnections: maxConnections
                                }, e);
                            }
                            return false;
                        }

                        // find the position on the element at which the mouse was pressed; this is where the endpoint
                        // will be located.
                        var elxy = jsPlumb.getPositionOnElement(e, _del, _zoom);

                        // we need to override the anchor in here, and force 'isSource', but we don't want to mess with
                        // the params passed in, because after a connection is established we're going to reset the endpoint
                        // to have the anchor we were given.
                        var tempEndpointParams = {};
                        jsPlumb.extend(tempEndpointParams, p);
                        tempEndpointParams.isTemporarySource = true;
                        tempEndpointParams.anchor = [ elxy[0], elxy[1] , 0, 0];
                        tempEndpointParams.dragOptions = dragOptions;

                        if (def.def.scope) tempEndpointParams.scope = def.def.scope;

                        ep = this.addEndpoint(elid, tempEndpointParams);
                        endpointAddedButNoDragYet = true;
                        ep._doNotDeleteOnDetach = false; // reset.
                        ep._deleteOnDetach = true;

                        // if unique endpoint and it's already been created, push it onto the endpoint we create. at the end
                        // of a successful connection we'll switch to that endpoint.
                        // TODO this is the same code as the programmatic endpoints create on line 1050 ish
                        if (def.uniqueEndpoint) {
                            if (!def.endpoint) {
                                def.endpoint = ep;
                                ep._deleteOnDetach = false;
                                ep._doNotDeleteOnDetach = true;
                            }
                            else
                                ep.finalEndpoint = def.endpoint;
                        }

                        var _delTempEndpoint = function () {
                            // this mouseup event is fired only if no dragging occurred, by jquery and yui, but for mootools
                            // it is fired even if dragging has occurred, in which case we would blow away a perfectly
                            // legitimate endpoint, were it not for this check.  the flag is set after adding an
                            // endpoint and cleared in a drag listener we set in the dragOptions above.
                            _currentInstance.off(ep.canvas, "mouseup", _delTempEndpoint);
                            _currentInstance.off(elInfo.el, "mouseup", _delTempEndpoint);
                            if (endpointAddedButNoDragYet) {
                                endpointAddedButNoDragYet = false;
                                _currentInstance.deleteEndpoint(ep);
                            }
                        };

                        _currentInstance.on(ep.canvas, "mouseup", _delTempEndpoint);
                        _currentInstance.on(elInfo.el, "mouseup", _delTempEndpoint);

                        // optionally check for attributes to extract from the source element
                        var payload = {};
                        if (def.def.extract) {
                            for (var att in def.def.extract) {
                                var v = e.srcElement.getAttribute(att);
                                if (v) {
                                    payload[def.def.extract[att]] = v;
                                }
                            }
                        }

                        // and then trigger its mousedown event, which will kick off a drag, which will start dragging
                        // a new connection from this endpoint.
                        _currentInstance.trigger(ep.canvas, "mousedown", e, payload);

                        jsPlumbUtil.consume(e);

                    }.bind(this);

                    this.on(elInfo.el, "mousedown", mouseDownListener);
                    _def.trigger = mouseDownListener;

                    // if a filter was provided, set it as a dragFilter on the element,
                    // to prevent the element drag function from kicking in when we want to
                    // drag a new connection
                    if (p.filter && (jsPlumbUtil.isString(p.filter) || jsPlumbUtil.isFunction(p.filter))) {
                        _currentInstance.setDragFilter(elInfo.el, p.filter);
                    }

                    var dropOptions = jsPlumb.extend({}, p.dropOptions || {});

                    _makeElementDropHandler(elInfo, p, dropOptions, true, p.isTarget === true);

                }.bind(this);

            var inputs = el.length && el.constructor != String ? el : [ el ];
            for (var i = 0, ii = inputs.length; i < ii; i++) {
                _doOne(_info(inputs[i]));
            }

            return this;
        };

        // see api docs
        this.unmakeSource = function (el, connectionType, doNotClearArrays) {
            var info = _info(el);
            var eldefs = this.sourceEndpointDefinitions[info.id];
            if (eldefs) {
                for (var def in eldefs) {
                    if (connectionType == null || connectionType === def) {
                        var mouseDownListener = eldefs[def].trigger;
                        if (mouseDownListener)
                            _currentInstance.off(info.el, "mousedown", mouseDownListener);
                        if (!doNotClearArrays) {
                            delete this.sourceEndpointDefinitions[info.id][def];
                        }
                    }
                }
            }

            return this;
        };

        // see api docs
        this.unmakeEverySource = function () {
            for (var i in this.sourceEndpointDefinitions)
                _currentInstance.unmakeSource(i, null, true);

            this.sourceEndpointDefinitions = {};
            return this;
        };

        var _getScope = function (el, types, connectionType) {
            types = jsPlumbUtil.isArray(types) ? types : [ types ];
            var id = _getId(el);
            connectionType = connectionType || "default";
            for (var i = 0; i < types.length; i++) {
                var eldefs = this[types[i]][id];
                if (eldefs && eldefs[connectionType]) return eldefs[connectionType].def.scope || this.Defaults.Scope;
            }
        }.bind(this);

        var _setScope = function (el, scope, types, connectionType) {
            types = jsPlumbUtil.isArray(types) ? types : [ types ];
            var id = _getId(el);
            connectionType = connectionType || "default";
            for (var i = 0; i < types.length; i++) {
                var eldefs = this[types[i]][id];
                if (eldefs && eldefs[connectionType]) {
                    eldefs[connectionType].def.scope = scope;
                }
            }

        }.bind(this);

        this.getScope = function (el, scope) {
            return _getScope(el, [ "sourceEndpointDefinitions", "targetEndpointDefinitions" ]);
        };
        this.getSourceScope = function (el) {
            return _getScope(el, "sourceEndpointDefinitions");
        };
        this.getTargetScope = function (el) {
            return _getScope(el, "targetEndpointDefinitions");
        };
        this.setScope = function (el, scope, connectionType) {
            this.setSourceScope(el, scope, connectionType);
            this.setTargetScope(el, scope, connectionType);
        };
        this.setSourceScope = function (el, scope, connectionType) {
            _setScope(el, scope, "sourceEndpointDefinitions", connectionType);
            // we get the source scope during the mousedown event, but we also want to set this.
            this.setDragScope(el, scope);
        };
        this.setTargetScope = function (el, scope, connectionType) {
            _setScope(el, scope, "targetEndpointDefinitions", connectionType);
            this.setDropScope(el, scope);
        };

        // see api docs
        this.unmakeEveryTarget = function () {
            for (var i in this.targetEndpointDefinitions)
                _currentInstance.unmakeTarget(i, true);

            this.targetEndpointDefinitions = {};
            return this;
        };

        // does the work of setting a source enabled or disabled.
        var _setEnabled = function (type, el, state, toggle, connectionType) {
            var a = type == "source" ? this.sourceEndpointDefinitions : this.targetEndpointDefinitions;
            connectionType = connectionType || "default";


            if (_ju.isString(el) && a[el] && a[el][connectionType]) {
                a[el][connectionType].enabled = toggle ? !a[el][connectionType].enabled : state;
            }
            else if (el.length) {
                for (var i = 0, ii = el.length; i < ii; i++) {
                    var info = _info(el[i]);
                    if (a[info.id] && a[info.id][connectionType])
                        a[info.id][connectionType].enabled = toggle ? !a[info.id][connectionType].enabled : state;
                }
            }
            // otherwise a DOM element
            else {
                var id = _info(el).id;
                if (a[id] && a[id][connectionType])
                    a[id][connectionType].enabled = toggle ? !a[id][connectionType].enabled : state;
            }
            return this;
        }.bind(this);

        var _first = function (el, fn) {
            if (_ju.isString(el) || !el.length)
                return fn.apply(this, [ el ]);
            else if (el.length)
                return fn.apply(this, [ el[0] ]);

        }.bind(this);

        this.toggleSourceEnabled = function (el, connectionType) {
            _setEnabled("source", el, null, true, connectionType);
            return this.isSourceEnabled(el, connectionType);
        };

        this.setSourceEnabled = function (el, state, connectionType) {
            return _setEnabled("source", el, state, null, connectionType);
        };
        this.isSource = function (el, connectionType) {
            connectionType = connectionType || "default";
            return _first(el, function (_el) {
                var eldefs = this.sourceEndpointDefinitions[_info(_el).id];
                return eldefs != null && eldefs[connectionType] != null;
            }.bind(this));
        };
        this.isSourceEnabled = function (el, connectionType) {
            connectionType = connectionType || "default";
            return _first(el, function (_el) {
                var sep = this.sourceEndpointDefinitions[_info(_el).id];
                return sep && sep[connectionType] && sep[connectionType].enabled === true;
            }.bind(this));
        };

        this.toggleTargetEnabled = function (el, connectionType) {
            _setEnabled("target", el, null, true, connectionType);
            return this.isTargetEnabled(el, connectionType);
        };

        this.isTarget = function (el, connectionType) {
            connectionType = connectionType || "default";
            return _first(el, function (_el) {
                var eldefs = this.targetEndpointDefinitions[_info(_el).id];
                return eldefs != null && eldefs[connectionType] != null;
            }.bind(this));
        };
        this.isTargetEnabled = function (el, connectionType) {
            connectionType = connectionType || "default";
            return _first(el, function (_el) {
                var tep = this.targetEndpointDefinitions[_info(_el).id];
                return tep && tep[connectionType] && tep[connectionType].enabled === true;
            }.bind(this));
        };
        this.setTargetEnabled = function (el, state, connectionType) {
            return _setEnabled("target", el, state, null, connectionType);
        };

// --------------------- end makeSource/makeTarget ---------------------------------------------- 				

        this.ready = function (fn) {
            _currentInstance.bind("ready", fn);
        };

        var _elEach = function(el, fn) {
            // support both lists...
            if (typeof el == 'object' && el.length)
                for (var i = 0, ii = el.length; i < ii; i++) {
                    fn(el[i]);
                }
            else // ...and single strings or elements.
                fn(el);

            return _currentInstance;
        };

        // repaint some element's endpoints and connections
        this.repaint = function (el, ui, timestamp) {
            return _elEach(el, function(_el) {
                _draw(_el, ui, timestamp);
            });
        };

        this.revalidate = function (el, timestamp, isIdAlready) {
            return _elEach(el, function(_el) {
                var elId = isIdAlready ? _el : _currentInstance.getId(_el);
                _currentInstance.updateOffset({ elId: elId, recalc: true, timestamp:timestamp });
                _currentInstance.repaint(_el);
            });
        };

        // repaint every endpoint and connection.
        this.repaintEverything = function () {
            // TODO this timestamp causes continuous anchors to not repaint properly.
            // fix this. do not just take out the timestamp. it runs a lot faster with
            // the timestamp included.
            var timestamp = _timestamp(), elId;

            for (elId in endpointsByElement) {
                _currentInstance.updateOffset({ elId: elId, recalc: true, timestamp: timestamp });
            }

            for (elId in endpointsByElement) {
                _draw(elId, null, timestamp);
            }

            return this;
        };

        this.removeAllEndpoints = function (el, recurse, affectedElements) {
            affectedElements = affectedElements || [];
            var _one = function (_el) {
                var info = _info(_el),
                    ebe = endpointsByElement[info.id],
                    i, ii;

                if (ebe) {
                    affectedElements.push(info);
                    for (i = 0, ii = ebe.length; i < ii; i++)
                        _currentInstance.deleteEndpoint(ebe[i], false);
                }
                delete endpointsByElement[info.id];

                if (recurse) {
                    if (info.el && info.el.nodeType != 3 && info.el.nodeType != 8) {
                        for (i = 0, ii = info.el.childNodes.length; i < ii; i++) {
                            _one(info.el.childNodes[i]);
                        }
                    }
                }

            };
            _one(el);
            return this;
        };

        var _doRemove = function(info, affectedElements) {
            _currentInstance.removeAllEndpoints(info.id, true, affectedElements);
            var _one = function(_info) {
                _currentInstance.getDragManager().elementRemoved(_info.id);
                _currentInstance.anchorManager.clearFor(_info.id);
                _currentInstance.anchorManager.removeFloatingConnection(_info.id);
                delete _currentInstance.floatingConnections[_info.id];
                delete managedElements[_info.id];
                delete offsets[_info.id];
                if (_info.el) {
                    _currentInstance.removeElement(_info.el);
                    _info.el._jsPlumb = null;
                }
            };

            // remove all affected child elements
            for (var ae = 1; ae < affectedElements.length; ae++) {
                _one(affectedElements[ae]);
            }
            // and always remove the requested one from the dom.
            _one(info);
        };

        /**
         * Remove the given element, including cleaning up all endpoints registered for it.
         * This is exposed in the public API but also used internally by jsPlumb when removing the
         * element associated with a connection drag.
         */
        this.remove = function (el, doNotRepaint) {
            var info = _info(el), affectedElements = [];
            if (info.text) {
                info.el.parentNode.removeChild(info.el);
            }
            else if (info.id) {
                _currentInstance.batch(function () {
                    _doRemove(info, affectedElements);
                }, doNotRepaint === false);
            }
            return _currentInstance;
        };

        this.empty = function (el, doNotRepaint) {
            var affectedElements = [];
            var _one = function(el, dontRemoveFocus) {
                var info = _info(el);
                if (info.text) {
                    info.el.parentNode.removeChild(info.el);
                }
                else if (info.el) {
                    while(info.el.childNodes.length > 0) {
                        _one(info.el.childNodes[0]);
                    }
                    if (!dontRemoveFocus) _doRemove(info, affectedElements);
                }
            };

            _currentInstance.batch(function() {
                _one(el, true);
            }, doNotRepaint === false);

            return _currentInstance;
        };

        this.reset = function () {
            _currentInstance.silently(function() {
                _currentInstance.deleteEveryEndpoint();
                _currentInstance.unbind();
                this.targetEndpointDefinitions = {};
                this.sourceEndpointDefinitions = {};
                connections.length = 0;
                if (this.doReset) this.doReset();
            }.bind(this));
        };

        var _clearObject = function (obj) {
            if (obj.canvas && obj.canvas.parentNode)
                obj.canvas.parentNode.removeChild(obj.canvas);
            obj.cleanup();
            obj.destroy();
        };

        this.clear = function () {
            _currentInstance.select().each(_clearObject);
            _currentInstance.selectEndpoints().each(_clearObject);

            endpointsByElement = {};
            endpointsByUUID = {};
        };

        this.setDefaultScope = function (scope) {
            DEFAULT_SCOPE = scope;
            return _currentInstance;
        };

        // sets whether or not some element should be currently draggable.
        this.setDraggable = _setDraggable;

        this.deriveEndpointAndAnchorSpec = function(type, dontPrependDefault) {
            var bits = ((dontPrependDefault ? "" : "default ") + type).split(/[\s]/), eps = null, ep = null, a = null, as = null;
            for (var i = 0; i < bits.length; i++) {
                var _t = _currentInstance.getType(bits[i], "connection");
                if (_t) {
                    if (_t.endpoints) eps = _t.endpoints;
                    if (_t.endpoint) ep = _t.endpoint;
                    if (_t.anchors) as = _t.anchors;
                    if (_t.anchor) a = _t.anchor;
                }
            }
            return { endpoints: eps ? eps : [ ep, ep ], anchors: as ? as : [a, a ]};
        };

        // sets the id of some element, changing whatever we need to to keep track.
        this.setId = function (el, newId, doNotSetAttribute) {
            //
            var id;

            if (jsPlumbUtil.isString(el)) {
                id = el;
            }
            else {
                el = this.getElement(el);
                id = this.getId(el);
            }

            var sConns = this.getConnections({source: id, scope: '*'}, true),
                tConns = this.getConnections({target: id, scope: '*'}, true);

            newId = "" + newId;

            if (!doNotSetAttribute) {
                el = this.getElement(id);
                this.setAttribute(el, "id", newId);
            }
            else
                el = this.getElement(newId);

            endpointsByElement[newId] = endpointsByElement[id] || [];
            for (var i = 0, ii = endpointsByElement[newId].length; i < ii; i++) {
                endpointsByElement[newId][i].setElementId(newId);
                endpointsByElement[newId][i].setReferenceElement(el);
            }
            delete endpointsByElement[id];

            this.sourceEndpointDefinitions[newId] = this.sourceEndpointDefinitions[id];
            delete this.sourceEndpointDefinitions[id];
            this.targetEndpointDefinitions[newId] = this.targetEndpointDefinitions[id];
            delete this.targetEndpointDefinitions[id];

            this.anchorManager.changeId(id, newId);
            this.getDragManager().changeId(id, newId);
            managedElements[newId] = managedElements[id];
            delete managedElements[id];

            var _conns = function (list, epIdx, type) {
                for (var i = 0, ii = list.length; i < ii; i++) {
                    list[i].endpoints[epIdx].setElementId(newId);
                    list[i].endpoints[epIdx].setReferenceElement(el);
                    list[i][type + "Id"] = newId;
                    list[i][type] = el;
                }
            };
            _conns(sConns, 0, "source");
            _conns(tConns, 1, "target");

            this.repaint(newId);
        };

        this.setDebugLog = function (debugLog) {
            log = debugLog;
        };

        this.setSuspendDrawing = function (val, repaintAfterwards) {
            var curVal = _suspendDrawing;
            _suspendDrawing = val;
            if (val) _suspendedAt = new Date().getTime(); else _suspendedAt = null;
            if (repaintAfterwards) this.repaintEverything();
            return curVal;
        };

        // returns whether or not drawing is currently suspended.
        this.isSuspendDrawing = function () {
            return _suspendDrawing;
        };

        // return timestamp for when drawing was suspended.
        this.getSuspendedAt = function () {
            return _suspendedAt;
        };

        this.batch = function (fn, doNotRepaintAfterwards) {
            var _wasSuspended = this.isSuspendDrawing();
            if (!_wasSuspended)
                this.setSuspendDrawing(true);
            try {
                fn();
            }
            catch (e) {
                _ju.log("Function run while suspended failed", e);
            }
            if (!_wasSuspended)
                this.setSuspendDrawing(false, !doNotRepaintAfterwards);
        };

        this.doWhileSuspended = this.batch;

        this.getCachedData = _getCachedData;
        this.timestamp = _timestamp;
        this.show = function (el, changeEndpoints) {
            _setVisible(el, "block", changeEndpoints);
            return _currentInstance;
        };

        // TODO: update this method to return the current state.
        this.toggleVisible = _toggleVisible;
        this.toggleDraggable = _toggleDraggable;
        this.addListener = this.bind;
    };

    jsPlumbUtil.extend(jsPlumbInstance, jsPlumbUtil.EventGenerator, {
        setAttribute: function (el, a, v) {
            this.setAttribute(el, a, v);
        },
        getAttribute: function (el, a) {
            return this.getAttribute(jsPlumb.getElement(el), a);
        },
        convertToFullOverlaySpec: function(spec) {
            if (jsPlumbUtil.isString(spec)) {
                spec = [ spec, { } ];
            }
            spec[1].id = spec[1].id || jsPlumbUtil.uuid();
            return spec;
        },
        registerConnectionType: function (id, type) {
            this._connectionTypes[id] = jsPlumb.extend({}, type);
            if (type.overlays) {
                var to = {};
                for (var i = 0; i < type.overlays.length; i++) {
                    // if a string, convert to object representation so that we can store the typeid on it.
                    // also assign an id.
                    var fo = this.convertToFullOverlaySpec(type.overlays[i]);
                    to[fo[1].id] = fo;
                }
                this._connectionTypes[id].overlays = to;
            }
        },
        registerConnectionTypes: function (types) {
            for (var i in types)
                this.registerConnectionType(i, types[i]);
        },
        registerEndpointType: function (id, type) {
            this._endpointTypes[id] = jsPlumb.extend({}, type);
            if (type.overlays) {
                var to = {};
                for (var i = 0; i < type.overlays.length; i++) {
                    // if a string, convert to object representation so that we can store the typeid on it.
                    // also assign an id.
                    var fo = this.convertToFullOverlaySpec(type.overlays[i]);
                    to[fo[1].id] = fo;
                }
                this._endpointTypes[id].overlays = to;
            }
        },
        registerEndpointTypes: function (types) {
            for (var i in types)
                //this._endpointTypes[i] = jsPlumb.extend({}, types[i]);
                this.registerEndpointType(i, types[i]);
        },
        getType: function (id, typeDescriptor) {
            return typeDescriptor === "connection" ? this._connectionTypes[id] : this._endpointTypes[id];
        },
        setIdChanged: function (oldId, newId) {
            this.setId(oldId, newId, true);
        },
        // set parent: change the parent for some node and update all the registrations we need to.
        setParent: function (el, newParent) {
            var _dom = this.getElement(el),
                _id = this.getId(_dom),
                _pdom = this.getElement(newParent),
                _pid = this.getId(_pdom);

            _dom.parentNode.removeChild(_dom);
            _pdom.appendChild(_dom);
            this.getDragManager().setParent(_dom, _id, _pdom, _pid);
        },
        extend: function (o1, o2, names) {
            var i;
            if (names) {
                for (i = 0; i < names.length; i++)
                    o1[names[i]] = o2[names[i]];
            }
            else
                for (i in o2) o1[i] = o2[i];
            return o1;
        },
        floatingConnections: {},
        getFloatingAnchorIndex: function (jpc) {
            return jpc.endpoints[0].isFloating() ? 0 : jpc.endpoints[1].isFloating() ? 1 : -1;
        }
    });

// --------------------- static instance + AMD registration -------------------------------------------	

// create static instance and assign to window if window exists.	
    var jsPlumb = new jsPlumbInstance();
    // register on window if defined (lets us run on server)
    if (typeof window != 'undefined') window.jsPlumb = jsPlumb;
    // add 'getInstance' method to static instance
    jsPlumb.getInstance = function (_defaults) {
        var j = new jsPlumbInstance(_defaults);
        j.init();
        return j;
    };
    jsPlumb.each = function (spec, fn) {
        if (spec == null) return;
        if (typeof spec === "string")
            fn(jsPlumb.getElement(spec));
        else if (spec.length != null) {
            for (var i = 0; i < spec.length; i++)
                fn(jsPlumb.getElement(spec[i]));
        }
        else
            fn(spec); // assume it's an element.
    };
// maybe register static instance as an AMD module, and getInstance method too.
    if (typeof define === "function") {
        define("jsplumb", [], function () {
            return jsPlumb;
        });
        define("jsplumbinstance", [], function () {
            return jsPlumb.getInstance();
        });
    }
    // CommonJS
    if (typeof exports !== 'undefined') {
        exports.jsPlumb = jsPlumb;
    }


// --------------------- end static instance + AMD registration -------------------------------------------		

}).call(this);

/*
 * jsPlumb
 *
 * Title:jsPlumb 2.0.2
 *
 * Provides a way to visually connect elements on an HTML page, using SVG.
 *
 * This file contains the base functionality for DOM type adapters.
 *
 * Copyright (c) 2010 - 2015 jsPlumb (hello@jsplumbtoolkit.com)
 *
 * http://jsplumbtoolkit.com
 * http://github.com/sporritt/jsplumb
 *
 * Dual licensed under the MIT and GPL2 licenses.
 */
;
(function () {

    var root = this, _ju = root.jsPlumbUtil;

    var svgAvailable = !!window.SVGAngle || document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1"),

        _genLoc = function (e, prefix) {
            if (e == null) return [ 0, 0 ];
            var ts = _touches(e), t = _getTouch(ts, 0);
            return [t[prefix + "X"], t[prefix + "Y"]];
        },
        _pageLocation = function (e) {
            if (e == null) return [ 0, 0 ];
            return _genLoc(e, "page");
        },
        _screenLocation = function (e) {
            return _genLoc(e, "screen");
        },
        _clientLocation = function (e) {
            return _genLoc(e, "client");
        },
        _getTouch = function (touches, idx) {
            return touches.item ? touches.item(idx) : touches[idx];
        },
        _touches = function (e) {
            return e.touches && e.touches.length > 0 ? e.touches :
                    e.changedTouches && e.changedTouches.length > 0 ? e.changedTouches :
                    e.targetTouches && e.targetTouches.length > 0 ? e.targetTouches :
                [ e ];
        };

    /**
     Manages dragging for some instance of jsPlumb.

     TODO instead of this being accessed directly, it should subscribe to events on the jsPlumb instance: every method
     in here is called directly by jsPlumb. But what should happen is that we have unpublished events that this listens
     to.  The only trick is getting one of these instantiated with every jsPlumb instance: it needs to have a hook somehow.
     Basically the general idea is to pull ALL the drag code out (prototype method registrations plus this) into a
     dedicated drag script), that does not necessarily need to be included.


     */
    var DragManager = function (_currentInstance) {
        var _draggables = {}, _dlist = [], _delements = {}, _elementsWithEndpoints = {},
        // elementids mapped to the draggable to which they belong.
            _draggablesForElements = {};

        /**
         register some element as draggable.  right now the drag init stuff is done elsewhere, and it is
         possible that will continue to be the case.
         */
        this.register = function (el) {
            var id = _currentInstance.getId(el),
                parentOffset = _currentInstance.getOffset(el);

            if (!_draggables[id]) {
                _draggables[id] = el;
                _dlist.push(el);
                _delements[id] = {};
            }

            // look for child elements that have endpoints and register them against this draggable.
            var _oneLevel = function (p) {
                if (p) {
                    for (var i = 0; i < p.childNodes.length; i++) {
                        if (p.childNodes[i].nodeType != 3 && p.childNodes[i].nodeType != 8) {
                            var cEl = jsPlumb.getElement(p.childNodes[i]),
                                cid = _currentInstance.getId(p.childNodes[i], null, true);
                            if (cid && _elementsWithEndpoints[cid] && _elementsWithEndpoints[cid] > 0) {
                                var cOff = _currentInstance.getOffset(cEl);
                                _delements[id][cid] = {
                                    id: cid,
                                    offset: {
                                        left: cOff.left - parentOffset.left,
                                        top: cOff.top - parentOffset.top
                                    }
                                };
                                _draggablesForElements[cid] = id;
                            }
                            _oneLevel(p.childNodes[i]);
                        }
                    }
                }
            };

            _oneLevel(el);
        };

        // refresh the offsets for child elements of this element.
        this.updateOffsets = function (elId) {
            if (elId != null) {
                var domEl = jsPlumb.getElement(elId),
                    id = _currentInstance.getId(domEl),
                    children = _delements[id],
                    parentOffset = _currentInstance.getOffset(domEl);

                if (children) {
                    for (var i in children) {
                        if (children.hasOwnProperty(i)) {
                            var cel = jsPlumb.getElement(i),
                                cOff = _currentInstance.getOffset(cel);

                            _delements[id][i] = {
                                id: i,
                                offset: {
                                    left: cOff.left - parentOffset.left,
                                    top: cOff.top - parentOffset.top
                                }
                            };
                            _draggablesForElements[i] = id;
                        }
                    }
                }
            }
        };

        /**
         notification that an endpoint was added to the given el.  we go up from that el's parent
         node, looking for a parent that has been registered as a draggable. if we find one, we add this
         el to that parent's list of elements to update on drag (if it is not there already)
         */
        this.endpointAdded = function (el, id) {

            id = id || _currentInstance.getId(el);

            var b = document.body,
                p = el.parentNode;

            _elementsWithEndpoints[id] = _elementsWithEndpoints[id] ? _elementsWithEndpoints[id] + 1 : 1;

            while (p != null && p != b) {
                var pid = _currentInstance.getId(p, null, true);
                if (pid && _draggables[pid]) {
                    var pLoc = _currentInstance.getOffset(p);

                    if (_delements[pid][id] == null) {
                        var cLoc = _currentInstance.getOffset(el);
                        _delements[pid][id] = {
                            id: id,
                            offset: {
                                left: cLoc.left - pLoc.left,
                                top: cLoc.top - pLoc.top
                            }
                        };
                        _draggablesForElements[id] = pid;
                    }
                    break;
                }
                p = p.parentNode;
            }
        };

        this.endpointDeleted = function (endpoint) {
            if (_elementsWithEndpoints[endpoint.elementId]) {
                _elementsWithEndpoints[endpoint.elementId]--;
                if (_elementsWithEndpoints[endpoint.elementId] <= 0) {
                    for (var i in _delements) {
                        if (_delements.hasOwnProperty(i) && _delements[i]) {
                            delete _delements[i][endpoint.elementId];
                            delete _draggablesForElements[endpoint.elementId];
                        }
                    }
                }
            }
        };

        this.changeId = function (oldId, newId) {
            _delements[newId] = _delements[oldId];
            _delements[oldId] = {};
            _draggablesForElements[newId] = _draggablesForElements[oldId];
            _draggablesForElements[oldId] = null;
        };

        this.getElementsForDraggable = function (id) {
            return _delements[id];
        };

        this.elementRemoved = function (elementId) {
            var elId = _draggablesForElements[elementId];
            if (elId) {
                delete _delements[elId][elementId];
                delete _draggablesForElements[elementId];
            }
        };

        this.reset = function () {
            _draggables = {};
            _dlist = [];
            _delements = {};
            _elementsWithEndpoints = {};
        };

        //
        // notification drag ended. We check automatically if need to update some
        // ancestor's offsets.
        //
        this.dragEnded = function (el) {
            var id = _currentInstance.getId(el),
                ancestor = _draggablesForElements[id];

            if (ancestor) this.updateOffsets(ancestor);
        };

        this.setParent = function (el, elId, p, pId) {
            var current = _draggablesForElements[elId];
            if (current) {
                if (!_delements[pId])
                    _delements[pId] = {};
                _delements[pId][elId] = _delements[current][elId];
                delete _delements[current][elId];
                var pLoc = _currentInstance.getOffset(p),
                    cLoc = _currentInstance.getOffset(el);
                _delements[pId][elId].offset = {
                    left: cLoc.left - pLoc.left,
                    top: cLoc.top - pLoc.top
                };
                _draggablesForElements[elId] = pId;
            }
        };

        this.getDragAncestor = function (el) {
            var de = jsPlumb.getElement(el),
                id = _currentInstance.getId(de),
                aid = _draggablesForElements[id];

            if (aid)
                return jsPlumb.getElement(aid);
            else
                return null;
        };

    };

    var trim = function (str) {
            return str == null ? null : (str.replace(/^\s\s*/, '').replace(/\s\s*$/, ''));
        },
        _setClassName = function (el, cn) {
            cn = trim(cn);
            if (typeof el.className.baseVal != "undefined")  // SVG
                el.className.baseVal = cn;
            else
                el.className = cn;
        },
        _getClassName = function (el) {
            return (typeof el.className.baseVal == "undefined") ? el.className : el.className.baseVal;
        },
        _classManip = function (el, classesToAdd, classesToRemove) {
            classesToAdd = classesToAdd == null ? [] : jsPlumbUtil.isArray(classesToAdd) ? classesToAdd : classesToAdd.split(/\s+/);
            classesToRemove = classesToRemove == null ? [] : jsPlumbUtil.isArray(classesToRemove) ? classesToRemove : classesToRemove.split(/\s+/);

            var className = _getClassName(el),
                curClasses = className.split(/\s+/);

            var _oneSet = function (add, classes) {
                for (var i = 0; i < classes.length; i++) {
                    if (add) {
                        if (curClasses.indexOf(classes[i]) == -1)
                            curClasses.push(classes[i]);
                    }
                    else {
                        var idx = curClasses.indexOf(classes[i]);
                        if (idx != -1)
                            curClasses.splice(idx, 1);
                    }
                }
            };

            _oneSet(true, classesToAdd);
            _oneSet(false, classesToRemove);

            _setClassName(el, curClasses.join(" "));
        };

    jsPlumb.extend(jsPlumbInstance.prototype, {

        headless: false,

        pageLocation: _pageLocation,
        screenLocation: _screenLocation,
        clientLocation: _clientLocation,

        getDragManager:function() {
            if (this.dragManager == null)
                this.dragManager = new DragManager(this);

            return this.dragManager;
        },

        recalculateOffsets:function(elId) {
            this.getDragManager().updateOffsets(elId);
        },

        createElement:function(tag, style, clazz, atts) {
            return this.createElementNS(null, tag, style, clazz, atts);
        },

        createElementNS:function(ns, tag, style, clazz, atts) {
            var e = ns == null ? document.createElement(tag) : document.createElementNS(ns, tag);
            var i;
            style = style || {};
            for (i in style)
                e.style[i] = style[i];

            if (clazz)
                e.className = clazz;

            atts = atts || {};
            for (i in atts)
                e.setAttribute(i, "" + atts[i]);

            return e;
        },

        getAttribute: function (el, attName) {
            return el.getAttribute != null ? el.getAttribute(attName) : null;
        },

        setAttribute: function (el, a, v) {
            if (el.setAttribute != null) el.setAttribute(a, v);
        },

        setAttributes: function (el, atts) {
            for (var i in atts)
                if (atts.hasOwnProperty(i)) el.setAttribute(i, atts[i]);
        },
        appendToRoot: function (node) {
            document.body.appendChild(node);
        },
        getRenderModes: function () {
            return [ "svg"  ];
        },
        getClass:_getClassName,
        addClass: function (el, clazz) {
            jsPlumb.each(el, function (e) {
                _classManip(e, clazz);
            });
        },
        hasClass: function (el, clazz) {
            el = jsPlumb.getElement(el);
            if (el.classList) return el.classList.contains(clazz);
            else {
                return _getClassName(el).indexOf(clazz) != -1;
            }
        },
        removeClass: function (el, clazz) {
            jsPlumb.each(el, function (e) {
                _classManip(e, null, clazz);
            });
        },
        updateClasses: function (el, toAdd, toRemove) {
            jsPlumb.each(el, function (e) {
                _classManip(e, toAdd, toRemove);
            });
        },
        setClass: function (el, clazz) {
            jsPlumb.each(el, function (e) {
                _setClassName(e, clazz);
            });
        },
        setPosition: function (el, p) {
            el.style.left = p.left + "px";
            el.style.top = p.top + "px";
        },
        getPosition: function (el) {
            var _one = function (prop) {
                var v = el.style[prop];
                return v ? v.substring(0, v.length - 2) : 0;
            };
            return {
                left: _one("left"),
                top: _one("top")
            };
        },
        getStyle:function(el, prop) {
            if (typeof window.getComputedStyle !== 'undefined') {
                return getComputedStyle(el, null).getPropertyValue(prop);
            } else {
                return el.currentStyle[prop];
            }
        },
        getSelector: function (ctx, spec) {
            var sel = null;
            if (arguments.length == 1) {
                sel = ctx.nodeType != null ? ctx : document.querySelectorAll(ctx);
            }
            else
                sel = ctx.querySelectorAll(spec);

            return sel;
        },
        getOffset:function(el, relativeToRoot, container) {
            el = jsPlumb.getElement(el);
            container = container || this.getContainer();
            var out = {
                    left: el.offsetLeft,
                    top: el.offsetTop
                },
                op = (relativeToRoot  || (container != null && (el != container && el.offsetParent != container))) ?  el.offsetParent : null,
                _maybeAdjustScroll = function(offsetParent) {
                    if (offsetParent != null && offsetParent !== document.body && (offsetParent.scrollTop > 0 || offsetParent.scrollLeft > 0)) {
                        out.left -= offsetParent.scrollLeft;
                        out.top -= offsetParent.scrollTop;
                    }
                }.bind(this);

            while (op != null) {
                out.left += op.offsetLeft;
                out.top += op.offsetTop;
                _maybeAdjustScroll(op);
                op = relativeToRoot ? op.offsetParent :
                        op.offsetParent == container ? null : op.offsetParent;
            }

            // if container is scrolled and the element (or its offset parent) is not absolute or fixed, adjust accordingly.
            if (container != null && !relativeToRoot && (container.scrollTop > 0 || container.scrollLeft > 0)) {
                var pp = el.offsetParent != null ? this.getStyle(el.offsetParent, "position") : "static",
                    p = this.getStyle(el, "position");
                if (p !== "absolute" && p !== "fixed" && pp !== "absolute" && pp != "fixed") {
                    out.left -= container.scrollLeft;
                    out.top -= container.scrollTop;
                }
            }
            return out;
        },
        //
        // return x+y proportion of the given element's size corresponding to the location of the given event.
        //
        getPositionOnElement: function (evt, el, zoom) {
            var box = typeof el.getBoundingClientRect !== "undefined" ? el.getBoundingClientRect() : { left: 0, top: 0, width: 0, height: 0 },
                body = document.body,
                docElem = document.documentElement,
                scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop,
                scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft,
                clientTop = docElem.clientTop || body.clientTop || 0,
                clientLeft = docElem.clientLeft || body.clientLeft || 0,
                pst = 0,
                psl = 0,
                top = box.top + scrollTop - clientTop + (pst * zoom),
                left = box.left + scrollLeft - clientLeft + (psl * zoom),
                cl = jsPlumb.pageLocation(evt),
                w = box.width || (el.offsetWidth * zoom),
                h = box.height || (el.offsetHeight * zoom),
                x = (cl[0] - left) / w,
                y = (cl[1] - top) / h;

            return [ x, y ];
        },

        /**
         * Gets the absolute position of some element as read from the left/top properties in its style.
         * @method getAbsolutePosition
         * @param {Element} el The element to retrieve the absolute coordinates from. **Note** this is a DOM element, not a selector from the underlying library.
         * @return {Number[]} [left, top] pixel values.
         */
        getAbsolutePosition: function (el) {
            var _one = function (s) {
                var ss = el.style[s];
                if (ss) return parseFloat(ss.substring(0, ss.length - 2));
            };
            return [ _one("left"), _one("top") ];
        },

        /**
         * Sets the absolute position of some element by setting the left/top properties in its style.
         * @method setAbsolutePosition
         * @param {Element} el The element to set the absolute coordinates on. **Note** this is a DOM element, not a selector from the underlying library.
         * @param {Number[]} xy x and y coordinates
         * @param {Number[]} [animateFrom] Optional previous xy to animate from.
         * @param {Object} [animateOptions] Options for the animation.
         */
        setAbsolutePosition: function (el, xy, animateFrom, animateOptions) {
            if (animateFrom) {
                this.animate(el, {
                    left: "+=" + (xy[0] - animateFrom[0]),
                    top: "+=" + (xy[1] - animateFrom[1])
                }, animateOptions);
            }
            else {
                el.style.left = xy[0] + "px";
                el.style.top = xy[1] + "px";
            }
        },
        /**
         * gets the size for the element, in an array : [ width, height ].
         */
        getSize: function (el) {
            return [ el.offsetWidth, el.offsetHeight ];
        },
        getWidth: function (el) {
            return el.offsetWidth;
        },
        getHeight: function (el) {
            return el.offsetHeight;
        }

    });
}).call(this);

/*
 * jsPlumb
 *
 * Title:jsPlumb 2.0.2
 *
 * Provides a way to visually connect elements on an HTML page, using SVG.
 *
 * This file contains code for components that support overlays.
 *
 * Copyright (c) 2010 - 2015 jsPlumb (hello@jsplumbtoolkit.com)
 *
 * http://jsplumbtoolkit.com
 * http://github.com/sporritt/jsplumb
 *
 * Dual licensed under the MIT and GPL2 licenses.
 */
;(function() {

    "use strict";
    var root = this, _jp = root.jsPlumb, _ju = root.jsPlumbUtil;

    // ------------------------------ BEGIN OverlayCapablejsPlumbUIComponent --------------------------------------------

    var _internalLabelOverlayId = "__label",
    // this is a shortcut helper method to let people add a label as
    // overlay.
        _makeLabelOverlay = function (component, params) {

            var _params = {
                    cssClass: params.cssClass,
                    labelStyle: component.labelStyle,
                    id: _internalLabelOverlayId,
                    component: component,
                    _jsPlumb: component._jsPlumb.instance  // TODO not necessary, since the instance can be accessed through the component.
                },
                mergedParams = jsPlumb.extend(_params, params);

            return new _jp.Overlays[component._jsPlumb.instance.getRenderMode()].Label(mergedParams);
        },
        _processOverlay = function (component, o) {
            var _newOverlay = null;
            if (_ju.isArray(o)) {	// this is for the shorthand ["Arrow", { width:50 }] syntax
                // there's also a three arg version:
                // ["Arrow", { width:50 }, {location:0.7}]
                // which merges the 3rd arg into the 2nd.
                var type = o[0],
                // make a copy of the object so as not to mess up anyone else's reference...
                    p = _jp.extend({component: component, _jsPlumb: component._jsPlumb.instance}, o[1]);
                if (o.length == 3) _jp.extend(p, o[2]);
                _newOverlay = new _jp.Overlays[component._jsPlumb.instance.getRenderMode()][type](p);
            } else if (o.constructor == String) {
                _newOverlay = new _jp.Overlays[component._jsPlumb.instance.getRenderMode()][o]({component: component, _jsPlumb: component._jsPlumb.instance});
            } else {
                _newOverlay = o;
            }

            _newOverlay.id = _newOverlay.id || _ju.uuid();
            component.cacheTypeItem("overlay", _newOverlay, _newOverlay.id);
            //component._jsPlumb.overlays.push(_newOverlay);
            component._jsPlumb.overlays[_newOverlay.id] = _newOverlay;

            return _newOverlay;
        };

    _jp.OverlayCapableJsPlumbUIComponent = function (params) {

        jsPlumbUIComponent.apply(this, arguments);
        this._jsPlumb.overlays = {};
        this._jsPlumb.overlayPositions = {};

        if (params.label) {
            this.getDefaultType().overlays[_internalLabelOverlayId] = ["Label", {
                label: params.label,
                location: params.labelLocation || this.defaultLabelLocation || 0.5,
                labelStyle: params.labelStyle || this._jsPlumb.instance.Defaults.LabelStyle,
                id:_internalLabelOverlayId
            }];
        }

        this.setListenerComponent = function (c) {
            if (this._jsPlumb) {
                for (var i in this._jsPlumb.overlays)
                    this._jsPlumb.overlays[i].setListenerComponent(c);
            }
        };
    };

    _jp.OverlayCapableJsPlumbUIComponent.applyType = function (component, t) {
        if (t.overlays) {
            // loop through the ones in the type. if already present on the component,
            // dont remove or re-add.
            var keep = {}, i;

            for (i in t.overlays) {

                var existing = component._jsPlumb.overlays[t.overlays[i][1].id];
                if (existing) {
                    // maybe update from data, if there were parameterised values for instance.
                    existing.updateFrom(t.overlays[i][1]);
                    keep[t.overlays[i][1].id] = true;
                }
                else {
                    var c = component.getCachedTypeItem("overlay", t.overlays[i][1].id);
                    if (c != null) {
                        c.reattach(component._jsPlumb.instance);
                        // maybe update from data, if there were parameterised values for instance.
                        c.updateFrom(t.overlays[i][1]);
                        component._jsPlumb.overlays[c.id] = c;
                    }
                    else {
                        c = component.addOverlay(t.overlays[i], true);
                    }
                    keep[c.id] = true;
                }
            }

            // now loop through the full overlays and remove those that we dont want to keep
            for (i in component._jsPlumb.overlays) {
                if (keep[component._jsPlumb.overlays[i].id] == null)
                    component.removeOverlay(component._jsPlumb.overlays[i].id);
            }
        }
    };

    _ju.extend(_jp.OverlayCapableJsPlumbUIComponent, jsPlumbUIComponent, {

        setHover: function (hover, ignoreAttachedElements) {
            if (this._jsPlumb && !this._jsPlumb.instance.isConnectionBeingDragged()) {
                for (var i in this._jsPlumb.overlays) {
                    this._jsPlumb.overlays[i][hover ? "addClass" : "removeClass"](this._jsPlumb.instance.hoverClass);
                }
            }
        },
        addOverlay: function (overlay, doNotRepaint) {
            var o = _processOverlay(this, overlay);
            if (!doNotRepaint) this.repaint();
            return o;
        },
        getOverlay: function (id) {
            return this._jsPlumb.overlays[id];
        },
        getOverlays: function () {
            return this._jsPlumb.overlays;
        },
        hideOverlay: function (id) {
            var o = this.getOverlay(id);
            if (o) o.hide();
        },
        hideOverlays: function () {
            for (var i in this._jsPlumb.overlays)
                this._jsPlumb.overlays[i].hide();
        },
        showOverlay: function (id) {
            var o = this.getOverlay(id);
            if (o) o.show();
        },
        showOverlays: function () {
            for (var i in this._jsPlumb.overlays)
                this._jsPlumb.overlays[i].show();
        },
        removeAllOverlays: function (doNotRepaint) {
            for (var i in this._jsPlumb.overlays) {
                if (this._jsPlumb.overlays[i].cleanup) this._jsPlumb.overlays[i].cleanup();
            }

            this._jsPlumb.overlays = {};
            this._jsPlumb.overlayPositions = null;
            if (!doNotRepaint)
                this.repaint();
        },
        removeOverlay: function (overlayId) {
            var o = this._jsPlumb.overlays[overlayId];
            if (o) {
                if (o.cleanup) o.cleanup();
                delete this._jsPlumb.overlays[overlayId];
                if (this._jsPlumb.overlayPositions)
                    delete this._jsPlumb.overlayPositions[overlayId];
            }
        },
        removeOverlays: function () {
            for (var i = 0, j = arguments.length; i < j; i++)
                this.removeOverlay(arguments[i]);
        },
        moveParent: function (newParent) {
            if (this.bgCanvas) {
                this.bgCanvas.parentNode.removeChild(this.bgCanvas);
                newParent.appendChild(this.bgCanvas);
            }

            if (this.canvas && this.canvas.parentNode) {
                this.canvas.parentNode.removeChild(this.canvas);
                newParent.appendChild(this.canvas);

                for (var i in this._jsPlumb.overlays) {
                    if (this._jsPlumb.overlays[i].isAppendedAtTopLevel) {
                        var el = this._jsPlumb.overlays[i].getElement();
                        el.parentNode.removeChild(el);
                        newParent.appendChild(el);
                    }
                }
            }
        },
        getLabel: function () {
            var lo = this.getOverlay(_internalLabelOverlayId);
            return lo != null ? lo.getLabel() : null;
        },
        getLabelOverlay: function () {
            return this.getOverlay(_internalLabelOverlayId);
        },
        setLabel: function (l) {
            var lo = this.getOverlay(_internalLabelOverlayId);
            if (!lo) {
                var params = l.constructor == String || l.constructor == Function ? { label: l } : l;
                lo = _makeLabelOverlay(this, params);
                this._jsPlumb.overlays[_internalLabelOverlayId] = lo;
            }
            else {
                if (l.constructor == String || l.constructor == Function) lo.setLabel(l);
                else {
                    if (l.label) lo.setLabel(l.label);
                    if (l.location) lo.setLocation(l.location);
                }
            }

            if (!this._jsPlumb.instance.isSuspendDrawing())
                this.repaint();
        },
        cleanup: function (force) {
            for (var i in this._jsPlumb.overlays) {
                this._jsPlumb.overlays[i].cleanup(force);
                this._jsPlumb.overlays[i].destroy(force);
            }
            if (force) {
                this._jsPlumb.overlays = {};
                this._jsPlumb.overlayPositions = null;
            }
        },
        setVisible: function (v) {
            this[v ? "showOverlays" : "hideOverlays"]();
        },
        setAbsoluteOverlayPosition: function (overlay, xy) {
            this._jsPlumb.overlayPositions[overlay.id] = xy;
        },
        getAbsoluteOverlayPosition: function (overlay) {
            return this._jsPlumb.overlayPositions ? this._jsPlumb.overlayPositions[overlay.id] : null;
        }
    });

// ------------------------------ END OverlayCapablejsPlumbUIComponent --------------------------------------------

}).call(this);

/*
 * jsPlumb
 * 
 * Title:jsPlumb 2.0.2
 * 
 * Provides a way to visually connect elements on an HTML page, using SVG.
 * 
 * This file contains the code for Endpoints.
 *
 * Copyright (c) 2010 - 2015 jsPlumb (hello@jsplumbtoolkit.com)
 * 
 * http://jsplumbtoolkit.com
 * http://github.com/sporritt/jsplumb
 * 
 * Dual licensed under the MIT and GPL2 licenses.
 */
(function () {

    "use strict";
    var root = this, _jp = root.jsPlumb, _ju = root.jsPlumbUtil;

    // create the drag handler for a connection
    var _makeConnectionDragHandler = function (endpoint, placeholder, _jsPlumb) {
        var stopped = false;
        return {
            drag: function () {
                if (stopped) {
                    stopped = false;
                    return true;
                }

                if (placeholder.element) {
                    var _ui = _jsPlumb.getUIPosition(arguments, _jsPlumb.getZoom());
                    jsPlumb.setPosition(placeholder.element, _ui);
                    _jsPlumb.repaint(placeholder.element, _ui);
                    // always repaint the source endpoint, because only continuous/dynamic anchors cause the endpoint
                    // to be repainted, so static anchors need to be told (or the endpoint gets dragged around)
                    endpoint.paint({anchorPoint:endpoint.anchor.getCurrentLocation({element:endpoint.element})});
                }
            },
            stopDrag: function () {
                stopped = true;
            }
        };
    };

    // creates a placeholder div for dragging purposes, adds it, and pre-computes its offset.
    var _makeDraggablePlaceholder = function (placeholder, _jsPlumb, ipco, ips) {
        var n = jsPlumb.createElement("div", { position : "absolute" });
        _jsPlumb.appendElement(n);
        var id = _jsPlumb.getId(n);
        jsPlumb.setPosition(n, ipco);
        n.style.width = ips[0] + "px";
        n.style.height = ips[1] + "px";
        _jsPlumb.manage(id, n, true); // TRANSIENT MANAGE
        // create and assign an id, and initialize the offset.
        placeholder.id = id;
        placeholder.element = n;
    };

    // create a floating endpoint (for drag connections)
    var _makeFloatingEndpoint = function (paintStyle, referenceAnchor, endpoint, referenceCanvas, sourceElement, _jsPlumb, _newEndpoint, scope) {
        var floatingAnchor = new _jp.FloatingAnchor({ reference: referenceAnchor, referenceCanvas: referenceCanvas, jsPlumbInstance: _jsPlumb });
        //setting the scope here should not be the way to fix that mootools issue.  it should be fixed by not
        // adding the floating endpoint as a droppable.  that makes more sense anyway!
        // TRANSIENT MANAGE
        return _newEndpoint({
            paintStyle: paintStyle,
            endpoint: endpoint,
            anchor: floatingAnchor,
            source: sourceElement,
            scope: scope
        });
    };

    var typeParameters = [ "connectorStyle", "connectorHoverStyle", "connectorOverlays",
        "connector", "connectionType", "connectorClass", "connectorHoverClass" ];

    // a helper function that tries to find a connection to the given element, and returns it if so. if elementWithPrecedence is null,
    // or no connection to it is found, we return the first connection in our list.
    var findConnectionToUseForDynamicAnchor = function (ep, elementWithPrecedence) {
        var idx = 0;
        if (elementWithPrecedence != null) {
            for (var i = 0; i < ep.connections.length; i++) {
                if (ep.connections[i].sourceId == elementWithPrecedence || ep.connections[i].targetId == elementWithPrecedence) {
                    idx = i;
                    break;
                }
            }
        }

        return ep.connections[idx];
    };

    _jp.Endpoint = function (params) {
        var _jsPlumb = params._jsPlumb,
            _newConnection = params.newConnection,
            _newEndpoint = params.newEndpoint;

        this.idPrefix = "_jsplumb_e_";
        this.defaultLabelLocation = [ 0.5, 0.5 ];
        this.defaultOverlayKeys = ["Overlays", "EndpointOverlays"];
        _jp.OverlayCapableJsPlumbUIComponent.apply(this, arguments);

// TYPE

        this.appendToDefaultType({
            connectionType:params.connectionType,
            maxConnections: params.maxConnections == null ? this._jsPlumb.instance.Defaults.MaxConnections : params.maxConnections, // maximum number of connections this endpoint can be the source of.,
            paintStyle: params.endpointStyle || params.paintStyle || params.style || this._jsPlumb.instance.Defaults.EndpointStyle || _jp.Defaults.EndpointStyle,
            hoverPaintStyle: params.endpointHoverStyle || params.hoverPaintStyle || this._jsPlumb.instance.Defaults.EndpointHoverStyle || _jp.Defaults.EndpointHoverStyle,
            connectorStyle: params.connectorStyle,
            connectorHoverStyle: params.connectorHoverStyle,
            connectorClass: params.connectorClass,
            connectorHoverClass: params.connectorHoverClass,
            connectorOverlays: params.connectorOverlays,
            connector: params.connector,
            connectorTooltip: params.connectorTooltip
        });

// END TYPE

        this._jsPlumb.enabled = !(params.enabled === false);
        this._jsPlumb.visible = true;
        this.element = _jp.getElement(params.source);
        this._jsPlumb.uuid = params.uuid;
        this._jsPlumb.floatingEndpoint = null;
        var inPlaceCopy = null;
        if (this._jsPlumb.uuid) params.endpointsByUUID[this._jsPlumb.uuid] = this;
        this.elementId = params.elementId;
        this.dragProxy = params.dragProxy;

        this._jsPlumb.connectionCost = params.connectionCost;
        this._jsPlumb.connectionsDirected = params.connectionsDirected;
        this._jsPlumb.currentAnchorClass = "";
        this._jsPlumb.events = {};

        var _updateAnchorClass = function () {
            // stash old, get new
            var oldAnchorClass = _jsPlumb.endpointAnchorClassPrefix + "-" + this._jsPlumb.currentAnchorClass;
            this._jsPlumb.currentAnchorClass = this.anchor.getCssClass();
            var anchorClass = _jsPlumb.endpointAnchorClassPrefix + (this._jsPlumb.currentAnchorClass ? "-" + this._jsPlumb.currentAnchorClass : "");

            this.removeClass(oldAnchorClass);
            this.addClass(anchorClass);
            // add and remove at the same time to reduce the number of reflows.
            jsPlumb.updateClasses(this.element, anchorClass, oldAnchorClass);
        }.bind(this);

        this.prepareAnchor = function(anchorParams) {
            var a = this._jsPlumb.instance.makeAnchor(anchorParams, this.elementId, _jsPlumb);
            a.bind("anchorChanged", function (currentAnchor) {
                this.fire("anchorChanged", {endpoint: this, anchor: currentAnchor});
                _updateAnchorClass();
            }.bind(this));
            return a;
        };

        this.setPreparedAnchor = function(anchor, doNotRepaint) {
            this._jsPlumb.instance.continuousAnchorFactory.clear(this.elementId);
            this.anchor = anchor;
            _updateAnchorClass();

            if (!doNotRepaint)
                this._jsPlumb.instance.repaint(this.elementId);

            return this;
        };

        this.setAnchor = function (anchorParams, doNotRepaint) {
            var a = this.prepareAnchor(anchorParams);
            this.setPreparedAnchor(a, doNotRepaint);
            return this;
        };

        var internalHover = function (state) {
            if (this.connections.length > 0) {
                for (var i = 0; i < this.connections.length; i++)
                    this.connections[i].setHover(state, false);
            }
            else
                this.setHover(state);
        }.bind(this);

        this.bind("mouseover", function () {
            internalHover(true);
        });
        this.bind("mouseout", function () {
            internalHover(false);
        });

        // ANCHOR MANAGER
        if (!params._transient) // in place copies, for example, are transient.  they will never need to be retrieved during a paint cycle, because they dont move, and then they are deleted.
            this._jsPlumb.instance.anchorManager.add(this, this.elementId);

        this.prepareEndpoint = function(ep, typeId) {
            var _e = function (t, p) {
                var rm = _jsPlumb.getRenderMode();
                if (_jp.Endpoints[rm][t]) return new _jp.Endpoints[rm][t](p);
                if (!_jsPlumb.Defaults.DoNotThrowErrors)
                    throw { msg: "jsPlumb: unknown endpoint type '" + t + "'" };
            };

            var endpointArgs = {
                _jsPlumb: this._jsPlumb.instance,
                cssClass: params.cssClass,
                container: params.container,
                tooltip: params.tooltip,
                connectorTooltip: params.connectorTooltip,
                endpoint: this
            };

            var endpoint;

            if (_ju.isString(ep))
                endpoint = _e(ep, endpointArgs);
            else if (_ju.isArray(ep)) {
                endpointArgs = _ju.merge(ep[1], endpointArgs);
                endpoint = _e(ep[0], endpointArgs);
            }
            else {
                endpoint = ep.clone();
            }

            // assign a clone function using a copy of endpointArgs. this is used when a drag starts: the endpoint that was dragged is cloned,
            // and the clone is left in its place while the original one goes off on a magical journey.
            // the copy is to get around a closure problem, in which endpointArgs ends up getting shared by
            // the whole world.
            //var argsForClone = jsPlumb.extend({}, endpointArgs);
            endpoint.clone = function () {
                // TODO this, and the code above, can be refactored to be more dry.
                if (_ju.isString(ep))
                    return _e(ep, endpointArgs);
                else if (_ju.isArray(ep)) {
                    endpointArgs = _ju.merge(ep[1], endpointArgs);
                    return _e(ep[0], endpointArgs);
                }
            }.bind(this);

            endpoint.typeId = typeId;
            return endpoint;
        };

        this.setEndpoint = function(ep, doNotRepaint) {
            var _ep = this.prepareEndpoint(ep);
            this.setPreparedEndpoint(_ep, true);
        };

        this.setPreparedEndpoint = function (ep, doNotRepaint) {
            if (this.endpoint != null) {
                this.endpoint.cleanup();
                this.endpoint.destroy();
            }
            this.endpoint = ep;
            this.type = this.endpoint.type;
            this.canvas = this.endpoint.canvas;
        };

        _jp.extend(this, params, typeParameters);

        this.isSource = params.isSource || false;
        this.isTemporarySource = params.isTemporarySource || false;
        this.isTarget = params.isTarget || false;

        this.connections = params.connections || [];
        this.connectorPointerEvents = params["connector-pointer-events"];

        this.scope = params.scope || _jsPlumb.getDefaultScope();
        this.timestamp = null;
        this.reattachConnections = params.reattach || _jsPlumb.Defaults.ReattachConnections;
        this.connectionsDetachable = _jsPlumb.Defaults.ConnectionsDetachable;
        if (params.connectionsDetachable === false || params.detachable === false)
            this.connectionsDetachable = false;
        this.dragAllowedWhenFull = params.dragAllowedWhenFull !== false;

        if (params.onMaxConnections)
            this.bind("maxConnections", params.onMaxConnections);

        //
        // add a connection. not part of public API.
        //
        this.addConnection = function (connection) {
            this.connections.push(connection);
            this[(this.connections.length > 0 ? "add" : "remove") + "Class"](_jsPlumb.endpointConnectedClass);
            this[(this.isFull() ? "add" : "remove") + "Class"](_jsPlumb.endpointFullClass);
        };

        this.detachFromConnection = function (connection, idx, doNotCleanup) {
            //idx = idx == null ? findConnectionIndex(connection, this) : idx;
            idx = idx == null ? this.connections.indexOf(connection) : idx;
            if (idx >= 0) {
                this.connections.splice(idx, 1);
                this[(this.connections.length > 0 ? "add" : "remove") + "Class"](_jsPlumb.endpointConnectedClass);
                this[(this.isFull() ? "add" : "remove") + "Class"](_jsPlumb.endpointFullClass);
            }

            if (!doNotCleanup && this._deleteOnDetach && this.connections.length === 0) {
                _jsPlumb.deleteObject({
                    endpoint: this,
                    fireEvent: false,
                    deleteAttachedObjects: false
                });
            }
        };

        this.detach = function (connection, ignoreTarget, forceDetach, fireEvent, originalEvent, endpointBeingDeleted, connectionIndex) {

            var idx = connectionIndex == null ? this.connections.indexOf(connection) : connectionIndex,
                actuallyDetached = false;
            fireEvent = (fireEvent !== false);

            if (idx >= 0) {

                if (forceDetach || connection._forceDetach || (connection.isDetachable() && connection.isDetachAllowed(connection) && this.isDetachAllowed(connection) && _jsPlumb.checkCondition("beforeDetach", connection, endpointBeingDeleted) )) {

                    _jsPlumb.deleteObject({
                        connection: connection,
                        fireEvent: (!ignoreTarget && fireEvent),
                        originalEvent: originalEvent,
                        deleteAttachedObjects: false/**/
                    });
                    actuallyDetached = true;
                }
            }
            return actuallyDetached;
        };

        this.detachAll = function (fireEvent, forceDetach) {
            var unaffectedConns = [];
            while (this.connections.length > 0) {
                // TODO this could pass the index in to the detach method to save some time (index will always be zero in this while loop)
                var actuallyDetached = this.detach(this.connections[0], false, forceDetach === true, fireEvent !== false, null, this, 0);
                if (!actuallyDetached) {
                    unaffectedConns.push(this.connections[0]);
                    this.connections.splice(0, 1);
                }
            }
            this.connections = unaffectedConns;
            return this;
        };
        this.detachFrom = function (targetEndpoint, fireEvent, originalEvent) {
            var c = [];
            for (var i = 0; i < this.connections.length; i++) {
                if (this.connections[i].endpoints[1] == targetEndpoint || this.connections[i].endpoints[0] == targetEndpoint) {
                    c.push(this.connections[i]);
                }
            }
            for (var j = 0; j < c.length; j++) {
                this.detach(c[j], false, true, fireEvent, originalEvent);
            }
            return this;
        };

        this.getElement = function () {
            return this.element;
        };

        this.setElement = function (el) {
            var parentId = this._jsPlumb.instance.getId(el),
                curId = this.elementId;
            // remove the endpoint from the list for the current endpoint's element
            _ju.removeWithFunction(params.endpointsByElement[this.elementId], function (e) {
                return e.id == this.id;
            }.bind(this));
            this.element = jsPlumb.getElement(el);
            this.elementId = _jsPlumb.getId(this.element);
            _jsPlumb.anchorManager.rehomeEndpoint(this, curId, this.element);
            _jsPlumb.dragManager.endpointAdded(this.element);
            _ju.addToList(params.endpointsByElement, parentId, this);
            return this;
        };

        /**
         * private but must be exposed.
         */
        this.makeInPlaceCopy = function () {
            var loc = this.anchor.getCurrentLocation({element: this}),
                o = this.anchor.getOrientation(this),
                acc = this.anchor.getCssClass(),
                inPlaceAnchor = {
                    bind: function () {
                    },
                    compute: function () {
                        return [ loc[0], loc[1] ];
                    },
                    getCurrentLocation: function () {
                        return [ loc[0], loc[1] ];
                    },
                    getOrientation: function () {
                        return o;
                    },
                    getCssClass: function () {
                        return acc;
                    }
                };

            return _newEndpoint({
                dropOptions: params.dropOptions,
                anchor: inPlaceAnchor,
                source: this.element,
                paintStyle: this.getPaintStyle(),
                endpoint: params.hideOnDrag ? "Blank" : this.endpoint,
                _transient: true,
                scope: this.scope,
                reference:this
            });
        };

        /**
         * returns a connection from the pool; used when dragging starts.  just gets the head of the array if it can.
         */
        this.connectorSelector = function () {
            var candidate = this.connections[0];
            // SP target source refactor
            if (/*this.isTarget && */candidate) return candidate;
            else {
                return (this.connections.length < this._jsPlumb.maxConnections) || this._jsPlumb.maxConnections == -1 ? null : candidate;
            }
        };

        this.setStyle = this.setPaintStyle;

        this.paint = function (params) {
            params = params || {};
            var timestamp = params.timestamp, recalc = !(params.recalc === false);
            if (!timestamp || this.timestamp !== timestamp) {

                var info = _jsPlumb.updateOffset({ elId: this.elementId, timestamp: timestamp });

                var xy = params.offset ? params.offset.o : info.o;
                if (xy != null) {
                    var ap = params.anchorPoint, connectorPaintStyle = params.connectorPaintStyle;
                    if (ap == null) {
                        var wh = params.dimensions || info.s,
                            anchorParams = { xy: [ xy.left, xy.top ], wh: wh, element: this, timestamp: timestamp };
                        if (recalc && this.anchor.isDynamic && this.connections.length > 0) {
                            var c = findConnectionToUseForDynamicAnchor(this, params.elementWithPrecedence),
                                oIdx = c.endpoints[0] == this ? 1 : 0,
                                oId = oIdx === 0 ? c.sourceId : c.targetId,
                                oInfo = _jsPlumb.getCachedData(oId),
                                oOffset = oInfo.o, oWH = oInfo.s;
                            anchorParams.txy = [ oOffset.left, oOffset.top ];
                            anchorParams.twh = oWH;
                            anchorParams.tElement = c.endpoints[oIdx];
                        }
                        ap = this.anchor.compute(anchorParams);
                    }

                    this.endpoint.compute(ap, this.anchor.getOrientation(this), this._jsPlumb.paintStyleInUse, connectorPaintStyle || this.paintStyleInUse);
                    this.endpoint.paint(this._jsPlumb.paintStyleInUse, this.anchor);
                    this.timestamp = timestamp;

                    // paint overlays
                    for (var i in this._jsPlumb.overlays) {
                        if (this._jsPlumb.overlays.hasOwnProperty(i)) {
                            var o = this._jsPlumb.overlays[i];
                            if (o.isVisible()) {
                                this._jsPlumb.overlayPlacements[i] = o.draw(this.endpoint, this._jsPlumb.paintStyleInUse);
                                o.paint(this._jsPlumb.overlayPlacements[i]);
                            }
                        }
                    }
                }
            }
        };

        this.getTypeDescriptor = function () {
            return "endpoint";
        };
        this.isVisible = function () {
            return this._jsPlumb.visible;
        };

        this.repaint = this.paint;

        var draggingInitialised = false;
        this.initDraggable = function () {

            // is this a connection source? we make it draggable and have the
            // drag listener maintain a connection with a floating endpoint.
            if (!draggingInitialised && _jp.isDragSupported(this.element)) {
                var placeholderInfo = { id: null, element: null },
                    jpc = null,
                    existingJpc = false,
                    existingJpcParams = null,
                    _dragHandler = _makeConnectionDragHandler(this, placeholderInfo, _jsPlumb),
                    dragOptions = params.dragOptions || {},
                    defaultOpts = {},
                    startEvent = _jp.dragEvents.start,
                    stopEvent = _jp.dragEvents.stop,
                    dragEvent = _jp.dragEvents.drag,
                    beforeStartEvent = _jp.dragEvents.beforeStart,
                    payload;

                // respond to beforeStart from katavorio; this will have, optionally, a payload of attribute values
                // that were placed there by the makeSource mousedown listener.
                var beforeStart = function(beforeStartParams) {
                    payload = beforeStartParams.e.payload || {};
                };

                var start = function (startParams) {

// -------------   first, get a connection to drag. this may be null, in which case we are dragging a new one.

                    jpc = this.connectorSelector();

// -------------------------------- now a bunch of tests about whether or not to proceed -------------------------

                    var _continue = true;
                    // if not enabled, return
                    if (!this.isEnabled()) _continue = false;
                    // if no connection and we're not a source - or temporarily a source, as is the case with makeSource - return.
                    if (jpc == null && !this.isSource && !this.isTemporarySource) _continue = false;
                    // otherwise if we're full and not allowed to drag, also return false.
                    if (this.isSource && this.isFull() && !(jpc != null && this.dragAllowedWhenFull)) _continue = false;
                    // if the connection was setup as not detachable or one of its endpoints
                    // was setup as connectionsDetachable = false, or Defaults.ConnectionsDetachable
                    // is set to false...
                    if (jpc != null && !jpc.isDetachable(this)) _continue = false;

                    var beforeDrag = _jsPlumb.checkCondition(jpc == null ? "beforeDrag" : "beforeStartDetach", {
                        endpoint:this,
                        source:this.element,
                        sourceId:this.elementId,
                        connection:jpc
                    });
                    if (beforeDrag === false) _continue = false;
                    // else we might have been given some data. we'll pass it in to a new connection as 'data'.
                    // here we also merge in the optional payload we were given on mousedown.
                    else if (typeof beforeDrag === "object") {
                        jsPlumb.extend(beforeDrag, payload || {});
                    }
                    else
                        // or if no beforeDrag data, maybe use the payload on its own.
                        beforeDrag = payload || {};

                    if (_continue === false) {
                        // this is for mootools and yui. returning false from this causes jquery to stop drag.
                        // the events are wrapped in both mootools and yui anyway, but i don't think returning
                        // false from the start callback would stop a drag.
                        if (_jsPlumb.stopDrag) _jsPlumb.stopDrag(this.canvas);
                        _dragHandler.stopDrag();
                        return false;
                    }

// ---------------------------------------------------------------------------------------------------------------------

                    // ok to proceed.

                    // clear hover for all connections for this endpoint before continuing.
                    for (var i = 0; i < this.connections.length; i++)
                        this.connections[i].setHover(false);

                    this.addClass("endpointDrag");
                    _jsPlumb.setConnectionBeingDragged(true);

                    // if we're not full but there was a connection, make it null. we'll create a new one.
                    if (jpc && !this.isFull() && this.isSource) jpc = null;

                    _jsPlumb.updateOffset({ elId: this.elementId });

// ----------------    make the element we will drag around, and position it -----------------------------

                    var ipco = this._jsPlumb.instance.getOffset(this.canvas),
                        canvasElement = this.canvas,
                        ips = this._jsPlumb.instance.getSize(this.canvas);

                    _makeDraggablePlaceholder(placeholderInfo, _jsPlumb, ipco, ips);

                    // store the id of the dragging div and the source element. the drop function will pick these up.                   
                    _jsPlumb.setAttributes(this.canvas, {
                        "dragId": placeholderInfo.id,
                        "elId": this.elementId
                    });

// ------------------- create an endpoint that will be our floating endpoint ------------------------------------

                    var endpointToFloat = this.dragProxy || this.endpoint;
                    if (this.dragProxy == null && this.connectionType != null) {
                        var aae = this._jsPlumb.instance.deriveEndpointAndAnchorSpec(this.connectionType);
                        if (aae.endpoints[1]) endpointToFloat = aae.endpoints[1];
                    }
                    var centerAnchor = this._jsPlumb.instance.makeAnchor("Center");
                    centerAnchor.isFloating = true;
                    this._jsPlumb.floatingEndpoint = _makeFloatingEndpoint(this.getPaintStyle(), centerAnchor, endpointToFloat, this.canvas, placeholderInfo.element, _jsPlumb, _newEndpoint, this.scope);
                    var _savedAnchor = this._jsPlumb.floatingEndpoint.anchor;


                    if (jpc == null) {

                        this.setHover(false, false);
                        // create a connection. one end is this endpoint, the other is a floating endpoint.                    
                        jpc = _newConnection({
                            sourceEndpoint: this,
                            targetEndpoint: this._jsPlumb.floatingEndpoint,
                            source: this.element,  // for makeSource with parent option.  ensure source element is represented correctly.
                            target: placeholderInfo.element,
                            anchors: [ this.anchor, this._jsPlumb.floatingEndpoint.anchor ],
                            paintStyle: params.connectorStyle, // this can be null. Connection will use the default.
                            hoverPaintStyle: params.connectorHoverStyle,
                            connector: params.connector, // this can also be null. Connection will use the default.
                            overlays: params.connectorOverlays,
                            type: this.connectionType,
                            cssClass: this.connectorClass,
                            hoverClass: this.connectorHoverClass,
                            data:beforeDrag
                        });
                        jpc.pending = true;
                        jpc.addClass(_jsPlumb.draggingClass);
                        this._jsPlumb.floatingEndpoint.addClass(_jsPlumb.draggingClass);
                        this._jsPlumb.floatingEndpoint.anchor = _savedAnchor;
                        // fire an event that informs that a connection is being dragged
                        _jsPlumb.fire("connectionDrag", jpc);

                        // register the new connection on the drag manager. This connection, at this point, is 'pending',
                        // and has as its target a temporary element (the 'placeholder'). If the connection subsequently
                        // becomes established, the anchor manager is informed that the target of the connection has
                        // changed.

                        _jsPlumb.anchorManager.newConnection(jpc);

                    } else {
                        existingJpc = true;
                        jpc.setHover(false);
                        // new anchor idx
                        var anchorIdx = jpc.endpoints[0].id == this.id ? 0 : 1;
                        this.detachFromConnection(jpc, null, true);                         // detach from the connection while dragging is occurring. but dont cleanup automatically.

                        // store the original scope (issue 57)
                        var dragScope = _jsPlumb.getDragScope(canvasElement);
                        _jsPlumb.setAttribute(this.canvas, "originalScope", dragScope);

                        // fire an event that informs that a connection is being dragged. we do this before
                        // replacing the original target with the floating element info.
                        _jsPlumb.fire("connectionDrag", jpc);

                        // now we replace ourselves with the temporary div we created above:
                        if (anchorIdx === 0) {
                            existingJpcParams = [ jpc.source, jpc.sourceId, canvasElement, dragScope ];
                            jpc.source = placeholderInfo.element;
                            jpc.sourceId = placeholderInfo.id;

                            _jsPlumb.anchorManager.sourceChanged(jpc.endpoints[anchorIdx].elementId, jpc.sourceId, jpc);

                        } else {
                            existingJpcParams = [ jpc.target, jpc.targetId, canvasElement, dragScope ];
                            jpc.target = placeholderInfo.element;
                            jpc.targetId = placeholderInfo.id;

                            _jsPlumb.anchorManager.updateOtherEndpoint(jpc.sourceId, jpc.endpoints[anchorIdx].elementId, jpc.targetId, jpc);
                        }

                        // lock the other endpoint; if it is dynamic it will not move while the drag is occurring.
                        // TODO SP i commented this out as part of the rewirte; i think now we want the other endpoint
                        // to behave naturally.
                        // SJP
                        //jpc.endpoints[anchorIdx === 0 ? 1 : 0].anchor.locked = true;


                        // store the original endpoint and assign the new floating endpoint for the drag.
                        jpc.suspendedEndpoint = jpc.endpoints[anchorIdx];

                        // PROVIDE THE SUSPENDED ELEMENT, BE IT A SOURCE OR TARGET (ISSUE 39)
                        jpc.suspendedElement = jpc.endpoints[anchorIdx].getElement();
                        jpc.suspendedElementId = jpc.endpoints[anchorIdx].elementId;
                        jpc.suspendedElementType = anchorIdx === 0 ? "source" : "target";

                        jpc.suspendedEndpoint.setHover(false);
                        this._jsPlumb.floatingEndpoint.referenceEndpoint = jpc.suspendedEndpoint;
                        jpc.endpoints[anchorIdx] = this._jsPlumb.floatingEndpoint;

                        jpc.addClass(_jsPlumb.draggingClass);
                        this._jsPlumb.floatingEndpoint.addClass(_jsPlumb.draggingClass);
                    }

                    // register it and register connection on it.
                    _jsPlumb.floatingConnections[placeholderInfo.id] = jpc;
                    // only register for the target endpoint; we will not be dragging the source at any time
                    // before this connection is either discarded or made into a permanent connection.
                    _ju.addToList(params.endpointsByElement, placeholderInfo.id, this._jsPlumb.floatingEndpoint);
                    // tell jsplumb about it
                    _jsPlumb.currentlyDragging = true;
                }.bind(this);

                var stop = function () {
                    _jsPlumb.setConnectionBeingDragged(false);

                    if (jpc && jpc.endpoints != null) {
                        // get the actual drop event (decode from library args to stop function)
                        var originalEvent = _jsPlumb.getDropEvent(arguments);
                        // unlock the other endpoint (if it is dynamic, it would have been locked at drag start)
                        var idx = _jsPlumb.getFloatingAnchorIndex(jpc);
                        jpc.endpoints[idx === 0 ? 1 : 0].anchor.locked = false;
                        // TODO: Dont want to know about css classes inside jsplumb, ideally.
                        jpc.removeClass(_jsPlumb.draggingClass);

                        // if we have the floating endpoint then the connection has not been dropped
                        // on another endpoint.  If it is a new connection we throw it away. If it is an
                        // existing connection we check to see if we should reattach it, throwing it away
                        // if not.
                        if (this._jsPlumb && (jpc.deleteConnectionNow || jpc.endpoints[idx] == this._jsPlumb.floatingEndpoint)) {
                            // 6a. if the connection was an existing one...
                            if (existingJpc && jpc.suspendedEndpoint) {
                                // fix for issue35, thanks Sylvain Gizard: when firing the detach event make sure the
                                // floating endpoint has been replaced.
                                if (idx === 0) {
                                    jpc.floatingElement = jpc.source;
                                    jpc.floatingId = jpc.sourceId;
                                    jpc.floatingEndpoint = jpc.endpoints[0];
                                    jpc.floatingIndex = 0;
                                    jpc.source = existingJpcParams[0];
                                    jpc.sourceId = existingJpcParams[1];
                                } else {
                                    // keep a copy of the floating element; the anchor manager will want to clean up.
                                    jpc.floatingElement = jpc.target;
                                    jpc.floatingId = jpc.targetId;
                                    jpc.floatingEndpoint = jpc.endpoints[1];
                                    jpc.floatingIndex = 1;
                                    jpc.target = existingJpcParams[0];
                                    jpc.targetId = existingJpcParams[1];
                                }

                                var fe = this._jsPlumb.floatingEndpoint; // store for later removal.
                                // restore the original scope (issue 57)
                                _jsPlumb.setDragScope(existingJpcParams[2], existingJpcParams[3]);
                                jpc.endpoints[idx] = jpc.suspendedEndpoint;
                                // IF the connection should be reattached, or the other endpoint refuses detach, then
                                // reset the connection to its original state
                                if (jpc.isReattach() || jpc._forceReattach || jpc._forceDetach || !jpc.endpoints[idx === 0 ? 1 : 0].detach(jpc, false, false, true, originalEvent, true)) {
                                    jpc.setHover(false);
                                    jpc._forceDetach = null;
                                    jpc._forceReattach = null;
                                    this._jsPlumb.floatingEndpoint.detachFromConnection(jpc);
                                    jpc.suspendedEndpoint.addConnection(jpc);

                                    // TODO this code is duplicated in lots of places...and there is nothing external
                                    // in the code; it all refers to the connection itself. we could add a
                                    // `checkSanity(connection)` method to anchorManager that did this.
                                    if (idx == 1) {
                                        _jsPlumb.anchorManager.updateOtherEndpoint(jpc.sourceId, jpc.floatingId, jpc.targetId, jpc);
                                    }
                                    else {
                                        _jsPlumb.anchorManager.sourceChanged(jpc.floatingId, jpc.sourceId, jpc);
                                    }

                                    _jsPlumb.repaint(existingJpcParams[1]);
                                }
                                else {
                                    _jsPlumb.deleteObject({endpoint: fe});
                                }
                            }
                        }

                        // makeTargets sets this flag, to tell us we have been replaced and should delete this object.
                        if (this.deleteAfterDragStop) {
                            _jsPlumb.deleteObject({endpoint: this});
                        }
                        else {
                            if (this._jsPlumb) {
                                 this.paint({recalc: false});
                            }
                        }

                        // although the connection is no longer valid, there are use cases where this is useful.
                        _jsPlumb.fire("connectionDragStop", jpc, originalEvent);
                        // tell jsplumb that dragging is finished.
                        _jsPlumb.currentlyDragging = false;
                        jpc = null;
                    }

                    // if no endpoints, jpc already cleaned up. but still we want to ensure we're reset properly.
                    // remove the element associated with the floating endpoint
                    // (and its associated floating endpoint and visual artefacts)
                    if (placeholderInfo && placeholderInfo.element) {
                        _jsPlumb.remove(placeholderInfo.element, false, false);
                    }
                    // remove the inplace copy
                    if (inPlaceCopy) {
                        _jsPlumb.deleteObject({endpoint: inPlaceCopy});
                    }

                    if (this._jsPlumb) {
                        // make our canvas visible (TODO: hand off to library; we should not know about DOM)
                        this.canvas.style.visibility = "visible";
                        // unlock our anchor
                        this.anchor.locked = false;
                        // clear floating anchor.
                        this._jsPlumb.floatingEndpoint = null;
                    }

                }.bind(this);

                dragOptions = _jp.extend(defaultOpts, dragOptions);
                dragOptions.scope = this.scope || dragOptions.scope;
                dragOptions[beforeStartEvent] = _ju.wrap(dragOptions[beforeStartEvent], beforeStart, false);
                dragOptions[startEvent] = _ju.wrap(dragOptions[startEvent], start, false);
                // extracted drag handler function so can be used by makeSource
                dragOptions[dragEvent] = _ju.wrap(dragOptions[dragEvent], _dragHandler.drag);
                dragOptions[stopEvent] = _ju.wrap(dragOptions[stopEvent], stop);
                dragOptions.multipleDrop = false;

                dragOptions.canDrag = function () {
                    return this.isSource || this.isTemporarySource || /*(this.isTarget && */this.connections.length > 0/*)*/;
                }.bind(this);

                _jsPlumb.initDraggable(this.canvas, dragOptions, "internal");

                this.canvas._jsPlumbRelatedElement = this.element;

                draggingInitialised = true;
            }
        };

        var ep = params.endpoint || this._jsPlumb.instance.Defaults.Endpoint || _jp.Defaults.Endpoint;
        this.setEndpoint(ep, true);
        var anchorParamsToUse = params.anchor ? params.anchor : params.anchors ? params.anchors : (_jsPlumb.Defaults.Anchor || "Top");
        this.setAnchor(anchorParamsToUse, true);

        // finally, set type if it was provided
        var type = [ "default", (params.type || "")].join(" ");
        this.addType(type, params.data, true);
        this.canvas = this.endpoint.canvas;
        this.canvas._jsPlumb = this;

        this.initDraggable();

        // pulled this out into a function so we can reuse it for the inPlaceCopy canvas; you can now drop detached connections
        // back onto the endpoint you detached it from.
        var _initDropTarget = function (canvas, isTransient, endpoint, referenceEndpoint) {

            if (_jp.isDropSupported(this.element)) {
                var dropOptions = params.dropOptions || _jsPlumb.Defaults.DropOptions || _jp.Defaults.DropOptions;
                dropOptions = _jp.extend({}, dropOptions);
                dropOptions.scope = dropOptions.scope || this.scope;
                var dropEvent = _jp.dragEvents.drop,
                    overEvent = _jp.dragEvents.over,
                    outEvent = _jp.dragEvents.out,
                    _ep = this,
                    drop = _jsPlumb.EndpointDropHandler({
                        getEndpoint: function () {
                            return _ep;
                        },
                        jsPlumb: _jsPlumb,
                        enabled: function () {
                            return endpoint != null ? endpoint.isEnabled() : true;
                        },
                        isFull: function () {
                            return endpoint.isFull();
                        },
                        element: this.element,
                        elementId: this.elementId,
                        isSource: this.isSource,
                        isTarget: this.isTarget,
                        addClass: function (clazz) {
                            _ep.addClass(clazz);
                        },
                        removeClass: function (clazz) {
                            _ep.removeClass(clazz);
                        },
                        isDropAllowed: function () {
                            return _ep.isDropAllowed.apply(_ep, arguments);
                        },
                        reference:referenceEndpoint,
                        isRedrop:function(jpc, dhParams) {
                            return jpc.suspendedEndpoint && dhParams.reference && (jpc.suspendedEndpoint.id === dhParams.reference.id);
                        }
                    });

                dropOptions[dropEvent] = _ju.wrap(dropOptions[dropEvent], drop, true);
                dropOptions[overEvent] = _ju.wrap(dropOptions[overEvent], function () {
                    var draggable = _jp.getDragObject(arguments),
                        id = _jsPlumb.getAttribute(_jp.getElement(draggable), "dragId"),
                        _jpc = _jsPlumb.floatingConnections[id];

                    if (_jpc != null) {
                        var idx = _jsPlumb.getFloatingAnchorIndex(_jpc);
                        // here we should fire the 'over' event if we are a target and this is a new connection,
                        // or we are the same as the floating endpoint.
                        var _cont = (this.isTarget && idx !== 0) || (_jpc.suspendedEndpoint && this.referenceEndpoint && this.referenceEndpoint.id == _jpc.suspendedEndpoint.id);
                        if (_cont) {
                            var bb = _jsPlumb.checkCondition("checkDropAllowed", {
                                sourceEndpoint: _jpc.endpoints[idx],
                                targetEndpoint: this,
                                connection: _jpc
                            });
                            this[(bb ? "add" : "remove") + "Class"](_jsPlumb.endpointDropAllowedClass);
                            this[(bb ? "remove" : "add") + "Class"](_jsPlumb.endpointDropForbiddenClass);
                            _jpc.endpoints[idx].anchor.over(this.anchor, this);
                        }
                    }
                }.bind(this));

                dropOptions[outEvent] = _ju.wrap(dropOptions[outEvent], function () {
                    var draggable = _jp.getDragObject(arguments),
                        id = draggable == null ? null : _jsPlumb.getAttribute(_jp.getElement(draggable), "dragId"),
                        _jpc = id ? _jsPlumb.floatingConnections[id] : null;

                    if (_jpc != null) {
                        var idx = _jsPlumb.getFloatingAnchorIndex(_jpc);
                        var _cont = (this.isTarget && idx !== 0) || (_jpc.suspendedEndpoint && this.referenceEndpoint && this.referenceEndpoint.id == _jpc.suspendedEndpoint.id);
                        if (_cont) {
                            this.removeClass(_jsPlumb.endpointDropAllowedClass);
                            this.removeClass(_jsPlumb.endpointDropForbiddenClass);
                            _jpc.endpoints[idx].anchor.out();
                        }
                    }
                }.bind(this));

                _jsPlumb.initDroppable(canvas, dropOptions, "internal", isTransient);
            }
        }.bind(this);

        // Initialise the endpoint's canvas as a drop target. The drop handler will take care of the logic of whether
        // something can actually be dropped.
        if (!this.anchor.isFloating)
            _initDropTarget(this.canvas, !(params._transient || this.anchor.isFloating), this, params.reference);


        return this;
    };

    _ju.extend(_jp.Endpoint, _jp.OverlayCapableJsPlumbUIComponent, {

        setVisible: function (v, doNotChangeConnections, doNotNotifyOtherEndpoint) {
            this._jsPlumb.visible = v;
            if (this.canvas) this.canvas.style.display = v ? "block" : "none";
            this[v ? "showOverlays" : "hideOverlays"]();
            if (!doNotChangeConnections) {
                for (var i = 0; i < this.connections.length; i++) {
                    this.connections[i].setVisible(v);
                    if (!doNotNotifyOtherEndpoint) {
                        var oIdx = this === this.connections[i].endpoints[0] ? 1 : 0;
                        // only change the other endpoint if this is its only connection.
                        if (this.connections[i].endpoints[oIdx].connections.length == 1) this.connections[i].endpoints[oIdx].setVisible(v, true, true);
                    }
                }
            }
        },
        getAttachedElements: function () {
            return this.connections;
        },
        applyType: function (t, doNotRepaint) {
            this.setPaintStyle(t.endpointStyle || t.paintStyle, doNotRepaint);
            this.setHoverPaintStyle(t.endpointHoverStyle || t.hoverPaintStyle, doNotRepaint);
            if (t.maxConnections != null) this._jsPlumb.maxConnections = t.maxConnections;
            if (t.scope) this.scope = t.scope;
            _jp.extend(this, t, typeParameters);
            if (t.cssClass != null && this.canvas) this._jsPlumb.instance.addClass(this.canvas, t.cssClass);
            _jp.OverlayCapableJsPlumbUIComponent.applyType(this, t);
        },
        isEnabled: function () {
            return this._jsPlumb.enabled;
        },
        setEnabled: function (e) {
            this._jsPlumb.enabled = e;
        },
        cleanup: function () {
            var anchorClass = this._jsPlumb.instance.endpointAnchorClassPrefix + (this._jsPlumb.currentAnchorClass ? "-" + this._jsPlumb.currentAnchorClass : "");
            jsPlumb.removeClass(this.element, anchorClass);
            this.anchor = null;
            this.endpoint.cleanup(true);
            this.endpoint.destroy();
            this.endpoint = null;
            // drag/drop
            this._jsPlumb.instance.destroyDraggable(this.canvas, "internal");
            this._jsPlumb.instance.destroyDroppable(this.canvas, "internal");
        },
        setHover: function (h) {
            if (this.endpoint && this._jsPlumb && !this._jsPlumb.instance.isConnectionBeingDragged())
                this.endpoint.setHover(h);
        },
        isFull: function () {
            return this._jsPlumb.maxConnections === 0 ? true : !(this.isFloating() || this._jsPlumb.maxConnections < 0 || this.connections.length < this._jsPlumb.maxConnections);
        },
        /**
         * private but needs to be exposed.
         */
        isFloating: function () {
            return this.anchor != null && this.anchor.isFloating;
        },
        isConnectedTo: function (endpoint) {
            var found = false;
            if (endpoint) {
                for (var i = 0; i < this.connections.length; i++) {
                    if (this.connections[i].endpoints[1] == endpoint || this.connections[i].endpoints[0] == endpoint) {
                        found = true;
                        break;
                    }
                }
            }
            return found;
        },
        getConnectionCost: function () {
            return this._jsPlumb.connectionCost;
        },
        setConnectionCost: function (c) {
            this._jsPlumb.connectionCost = c;
        },
        areConnectionsDirected: function () {
            return this._jsPlumb.connectionsDirected;
        },
        setConnectionsDirected: function (b) {
            this._jsPlumb.connectionsDirected = b;
        },
        setElementId: function (_elId) {
            this.elementId = _elId;
            this.anchor.elementId = _elId;
        },
        setReferenceElement: function (_el) {
            this.element = _jp.getElement(_el);
        },
        setDragAllowedWhenFull: function (allowed) {
            this.dragAllowedWhenFull = allowed;
        },
        equals: function (endpoint) {
            return this.anchor.equals(endpoint.anchor);
        },
        getUuid: function () {
            return this._jsPlumb.uuid;
        },
        computeAnchor: function (params) {
            return this.anchor.compute(params);
        }
    });

    root.jsPlumbInstance.prototype.EndpointDropHandler = function (dhParams) {
        return function (e) {

            var _jsPlumb = dhParams.jsPlumb;

            // remove the classes that are added dynamically. drop is neither forbidden nor allowed now that
            // the drop is finishing.
            dhParams.removeClass(_jsPlumb.endpointDropAllowedClass);
            dhParams.removeClass(_jsPlumb.endpointDropForbiddenClass);

            var originalEvent = _jsPlumb.getDropEvent(arguments),
                draggable = _jsPlumb.getDragObject(arguments),
                id = _jsPlumb.getAttribute(draggable, "dragId"),
                elId = _jsPlumb.getAttribute(draggable, "elId"),
                scope = _jsPlumb.getAttribute(draggable, "originalScope"),
                jpc = _jsPlumb.floatingConnections[id];

            // if no active connection, bail.
            if (jpc == null) return;

            // calculate if this is an existing connection.
            var existingConnection = jpc.suspendedEndpoint != null;

            // if suspended endpoint exists but has been cleaned up, bail. This means it's an existing connection
            // that has been detached and will shortly be discarded.
            if (existingConnection && jpc.suspendedEndpoint._jsPlumb == null) return;

            // get the drop endpoint. for a normal connection this is just the one that would replace the currently
            // floating endpoint. for a makeTarget this is a new endpoint that is created on drop. But we leave that to
            // the handler to figure out.
            var _ep = dhParams.getEndpoint(jpc);

            // If we're not given an endpoint to use, bail.
            if (_ep == null) return;

            // if this is a drop back where the connection came from, mark it force reattach and
            // return; the stop handler will reattach. without firing an event.
            if (dhParams.isRedrop(jpc, dhParams)) {
                jpc._forceReattach = true;
                jpc.setHover(false);
                if (dhParams.maybeCleanup) dhParams.maybeCleanup(_ep);
                return;
            }

            // ensure we dont bother trying to drop sources on non-source eps, and same for target.
            var idx = _jsPlumb.getFloatingAnchorIndex(jpc);
            if ((idx === 0 && !dhParams.isSource)|| (idx === 1 && !dhParams.isTarget)){
                if (dhParams.maybeCleanup) dhParams.maybeCleanup(_ep);
                return;
            }

            if (dhParams.onDrop) dhParams.onDrop(jpc);

            // restore the original scope if necessary (issue 57)
            if (scope) _jsPlumb.setDragScope(draggable, scope);

            // if the target of the drop is full, fire an event (we abort below)
            // makeTarget: keep.
            var isFull = dhParams.isFull(e);
            if (isFull) {
                _ep.fire("maxConnections", {
                    endpoint: this,
                    connection: jpc,
                    maxConnections: _ep._jsPlumb.maxConnections
                }, originalEvent);
            }
            //
            // if endpoint enabled, not full, and matches the index of the floating endpoint...
            if (!isFull &&  dhParams.enabled()) {
                var _doContinue = true;

                // before testing for beforeDrop, reset the connection's source/target to be the actual DOM elements
                // involved (that is, stash any temporary stuff used for dragging. but we need to keep it around in
                // order that the anchor manager can clean things up properly).
                if (idx === 0) {
                    jpc.floatingElement = jpc.source;
                    jpc.floatingId = jpc.sourceId;
                    jpc.floatingEndpoint = jpc.endpoints[0];
                    jpc.floatingIndex = 0;
                    jpc.source = dhParams.element;
                    jpc.sourceId = dhParams.elementId;
                } else {
                    jpc.floatingElement = jpc.target;
                    jpc.floatingId = jpc.targetId;
                    jpc.floatingEndpoint = jpc.endpoints[1];
                    jpc.floatingIndex = 1;
                    jpc.target = dhParams.element;
                    jpc.targetId = dhParams.elementId;
                }

                // if this is an existing connection and detach is not allowed we won't continue. The connection's
                // endpoints have been reinstated; everything is back to how it was.
                if (existingConnection && jpc.suspendedEndpoint.id != _ep.id) {

                    if (!jpc.isDetachAllowed(jpc) || !jpc.endpoints[idx].isDetachAllowed(jpc) || !jpc.suspendedEndpoint.isDetachAllowed(jpc) || !_jsPlumb.checkCondition("beforeDetach", jpc))
                        _doContinue = false;
                }

// ------------ wrap the execution path in a function so we can support asynchronous beforeDrop

                var continueFunction = function (optionalData) {
                    // remove this jpc from the current endpoint, which is a floating endpoint that we will
                    // subsequently discard.
                    jpc.endpoints[idx].detachFromConnection(jpc);

                    // if there's a suspended endpoint, detach it from the connection.
                    if (jpc.suspendedEndpoint) jpc.suspendedEndpoint.detachFromConnection(jpc);

                    jpc.endpoints[idx] = _ep;
                    _ep.addConnection(jpc);

                    // copy our parameters in to the connection:
                    var params = _ep.getParameters();
                    for (var aParam in params)
                        jpc.setParameter(aParam, params[aParam]);

                    if (!existingConnection) {
                        // if not an existing connection and
                        if (params.draggable)
                            _jsPlumb.initDraggable(this.element, dragOptions, "internal", _jsPlumb);
                    }
                    else {
                        var suspendedElementId = jpc.suspendedEndpoint.elementId;
                        _jsPlumb.fireMoveEvent({
                            index: idx,
                            originalSourceId: idx === 0 ? suspendedElementId : jpc.sourceId,
                            newSourceId: idx === 0 ? _ep.elementId : jpc.sourceId,
                            originalTargetId: idx == 1 ? suspendedElementId : jpc.targetId,
                            newTargetId: idx == 1 ? _ep.elementId : jpc.targetId,
                            originalSourceEndpoint: idx === 0 ? jpc.suspendedEndpoint : jpc.endpoints[0],
                            newSourceEndpoint: idx === 0 ? _ep : jpc.endpoints[0],
                            originalTargetEndpoint: idx == 1 ? jpc.suspendedEndpoint : jpc.endpoints[1],
                            newTargetEndpoint: idx == 1 ? _ep : jpc.endpoints[1],
                            connection: jpc
                        }, originalEvent);
                    }

                    if (idx == 1) {
                        _jsPlumb.anchorManager.updateOtherEndpoint(jpc.sourceId, jpc.floatingId, jpc.targetId, jpc);
                    }
                    else {
                        _jsPlumb.anchorManager.sourceChanged(jpc.floatingId, jpc.sourceId, jpc);
                    }

                    // when makeSource has uniqueEndpoint:true, we want to create connections with new endpoints
                    // that are subsequently deleted. So makeSource sets `finalEndpoint`, which is the Endpoint to
                    // which the connection should be attached. The `detachFromConnection` call below results in the
                    // temporary endpoint being cleaned up.
                    if (jpc.endpoints[0].finalEndpoint) {
                        var _toDelete = jpc.endpoints[0];
                        _toDelete.detachFromConnection(jpc);
                        jpc.endpoints[0] = jpc.endpoints[0].finalEndpoint;
                        jpc.endpoints[0].addConnection(jpc);
                    }

                    // if optionalData was given, merge it onto the connection's data.
                    if (jsPlumbUtil.isObject(optionalData)) {
                        jpc.mergeData(optionalData);
                    }
                    // finalise will inform the anchor manager and also add to
                    // connectionsByScope if necessary.
                    _jsPlumb.finaliseConnection(jpc, null, originalEvent, false);
                    jpc.setHover(false);

                }.bind(this);

                var dontContinueFunction = function () {
                    // otherwise just put it back on the endpoint it was on before the drag.
                    if (jpc.suspendedEndpoint) {
                        jpc.endpoints[idx] = jpc.suspendedEndpoint;
                        jpc.setHover(false);
                        jpc._forceDetach = true;
                        if (idx === 0) {
                            jpc.source = jpc.suspendedEndpoint.element;
                            jpc.sourceId = jpc.suspendedEndpoint.elementId;
                        } else {
                            jpc.target = jpc.suspendedEndpoint.element;
                            jpc.targetId = jpc.suspendedEndpoint.elementId;
                        }
                        jpc.suspendedEndpoint.addConnection(jpc);

                        // TODO checkSanity
                        if (idx == 1) {
                            _jsPlumb.anchorManager.updateOtherEndpoint(jpc.sourceId, jpc.floatingId, jpc.targetId, jpc);
                        }
                        else {
                            _jsPlumb.anchorManager.sourceChanged(jpc.floatingId, jpc.sourceId, jpc);
                        }

                        _jsPlumb.repaint(jpc.sourceId);
                        jpc._forceDetach = false;
                    }
                };

// --------------------------------------
                // now check beforeDrop.  this will be available only on Endpoints that are setup to
                // have a beforeDrop condition (although, secretly, under the hood all Endpoints and
                // the Connection have them, because they are on jsPlumbUIComponent.  shhh!), because
                // it only makes sense to have it on a target endpoint.
                _doContinue = _doContinue && dhParams.isDropAllowed(jpc.sourceId, jpc.targetId, jpc.scope, jpc, _ep);// && jpc.pending;

                if (_doContinue) {
                    continueFunction(_doContinue);
                    return true;
                }
                else {
                    dontContinueFunction();
                }
            }

            if (dhParams.maybeCleanup) dhParams.maybeCleanup(_ep);

            _jsPlumb.currentlyDragging = false;
        };
    };
}).call(this);

/*
 * jsPlumb
 * 
 * Title:jsPlumb 2.0.2
 * 
 * Provides a way to visually connect elements on an HTML page, using SVG.
 * 
 * This file contains the code for Connections.
 *
 * Copyright (c) 2010 - 2015 jsPlumb (hello@jsplumbtoolkit.com)
 * 
 * http://jsplumbtoolkit.com
 * http://github.com/sporritt/jsplumb
 * 
 * Dual licensed under the MIT and GPL2 licenses.
 */
;
(function () {

    "use strict";
    var root = this,
        _jp = root.jsPlumb,
        _ju = root.jsPlumbUtil;


    var makeConnector = function (_jsPlumb, renderMode, connectorName, connectorArgs, forComponent) {
            if (!_jsPlumb.Defaults.DoNotThrowErrors && jsPlumb.Connectors[renderMode][connectorName] == null)
                throw { msg: "jsPlumb: unknown connector type '" + connectorName + "'" };

            return new _jp.Connectors[renderMode][connectorName](connectorArgs, forComponent);
        },
        _makeAnchor = function (anchorParams, elementId, _jsPlumb) {
            return (anchorParams) ? _jsPlumb.makeAnchor(anchorParams, elementId, _jsPlumb) : null;
        },
        _updateConnectedClass = function (conn, element, _jsPlumb, remove) {
            if (element != null) {
                element._jsPlumbConnections = element._jsPlumbConnections || {};
                if (remove)
                    delete element._jsPlumbConnections[conn.id];
                else
                    element._jsPlumbConnections[conn.id] = true;

                if (_ju.isEmpty(element._jsPlumbConnections)) {
                    _jsPlumb.removeClass(element, _jsPlumb.connectedClass);
                }
                else
                    _jsPlumb.addClass(element, _jsPlumb.connectedClass);
            }
        };

    _jp.Connection = function (params) {
        var _newEndpoint = params.newEndpoint;

        this.id = params.id;
        this.connector = null;
        this.idPrefix = "_jsplumb_c_";
        this.defaultLabelLocation = 0.5;
        this.defaultOverlayKeys = ["Overlays", "ConnectionOverlays"];
        // if a new connection is the result of moving some existing connection, params.previousConnection
        // will have that Connection in it. listeners for the jsPlumbConnection event can look for that
        // member and take action if they need to.
        this.previousConnection = params.previousConnection;
        this.source = _jp.getElement(params.source);
        this.target = _jp.getElement(params.target);
        // sourceEndpoint and targetEndpoint override source/target, if they are present. but 
        // source is not overridden if the Endpoint has declared it is not the final target of a connection;
        // instead we use the source that the Endpoint declares will be the final source element.
        if (params.sourceEndpoint) this.source = params.sourceEndpoint.getElement();
        if (params.targetEndpoint) this.target = params.targetEndpoint.getElement();

        _jp.OverlayCapableJsPlumbUIComponent.apply(this, arguments);

        this.sourceId = this._jsPlumb.instance.getId(this.source);
        this.targetId = this._jsPlumb.instance.getId(this.target);
        this.scope = params.scope; // scope may have been passed in to the connect call. if it wasn't, we will pull it from the source endpoint, after having initialised the endpoints.            
        this.endpoints = [];
        this.endpointStyles = [];

        var _jsPlumb = this._jsPlumb.instance;

        _jsPlumb.manage(this.sourceId, this.source);
        _jsPlumb.manage(this.targetId, this.target);

        this._jsPlumb.visible = true;
        this._jsPlumb.editable = params.editable === true;
        this._jsPlumb.params = {
            cssClass: params.cssClass,
            container: params.container,
            "pointer-events": params["pointer-events"],
            editorParams: params.editorParams,
            overlays: params.overlays
        };
        this._jsPlumb.lastPaintedAt = null;

        // listen to mouseover and mouseout events passed from the container delegate.
        this.bind("mouseover", function () {
            this.setHover(true);
        }.bind(this));
        this.bind("mouseout", function () {
            this.setHover(false);
        }.bind(this));

// INITIALISATION CODE

        this.makeEndpoint = function (isSource, el, elId, ep) {
            elId = elId || this._jsPlumb.instance.getId(el);
            return this.prepareEndpoint(_jsPlumb, _newEndpoint, this, ep, isSource ? 0 : 1, params, el, elId);
        };

        // if type given, get the endpoint definitions mapping to that type from the jsplumb instance, and use those.
        // we apply types at the end of this constructor but endpoints are only honoured in a type definition at
        // create time.
        if (params.type) {
            params.endpoints = this._jsPlumb.instance.deriveEndpointAndAnchorSpec(params.type).endpoints;
        }

        var eS = this.makeEndpoint(true, this.source, this.sourceId, params.sourceEndpoint),
            eT = this.makeEndpoint(false, this.target, this.targetId, params.targetEndpoint);

        if (eS) _ju.addToList(params.endpointsByElement, this.sourceId, eS);
        if (eT) _ju.addToList(params.endpointsByElement, this.targetId, eT);
        // if scope not set, set it to be the scope for the source endpoint.
        if (!this.scope) this.scope = this.endpoints[0].scope;

        // if explicitly told to (or not to) delete endpoints on detach, override endpoint's preferences
        if (params.deleteEndpointsOnDetach != null) {
            this.endpoints[0]._deleteOnDetach = params.deleteEndpointsOnDetach;
            this.endpoints[1]._deleteOnDetach = params.deleteEndpointsOnDetach;
        }
        else {
            // otherwise, unless the endpoints say otherwise, mark them for deletion.
            if (!this.endpoints[0]._doNotDeleteOnDetach) this.endpoints[0]._deleteOnDetach = true;
            if (!this.endpoints[1]._doNotDeleteOnDetach) this.endpoints[1]._deleteOnDetach = true;
        }

// -------------------------- DEFAULT TYPE ---------------------------------------------

        // DETACHABLE
        var _detachable = _jsPlumb.Defaults.ConnectionsDetachable;
        if (params.detachable === false) _detachable = false;
        if (this.endpoints[0].connectionsDetachable === false) _detachable = false;
        if (this.endpoints[1].connectionsDetachable === false) _detachable = false;
        // REATTACH
        var _reattach = params.reattach || this.endpoints[0].reattachConnections || this.endpoints[1].reattachConnections || _jsPlumb.Defaults.ReattachConnections;

        this.appendToDefaultType({
            detachable: _detachable,
            rettach: _reattach,
            paintStyle:this.endpoints[0].connectorStyle || this.endpoints[1].connectorStyle || params.paintStyle || _jsPlumb.Defaults.PaintStyle || jsPlumb.Defaults.PaintStyle,
            hoverPaintStyle:this.endpoints[0].connectorHoverStyle || this.endpoints[1].connectorHoverStyle || params.hoverPaintStyle || _jsPlumb.Defaults.HoverPaintStyle || jsPlumb.Defaults.HoverPaintStyle
        });


        var _suspendedAt = _jsPlumb.getSuspendedAt();
        if (!_jsPlumb.isSuspendDrawing()) {
            // paint the endpoints
            var myInfo = _jsPlumb.getCachedData(this.sourceId),
                myOffset = myInfo.o, myWH = myInfo.s,
                otherInfo = _jsPlumb.getCachedData(this.targetId),
                otherOffset = otherInfo.o,
                otherWH = otherInfo.s,
                initialTimestamp = _suspendedAt || _jsPlumb.timestamp(),
                anchorLoc = this.endpoints[0].anchor.compute({
                    xy: [ myOffset.left, myOffset.top ], wh: myWH, element: this.endpoints[0],
                    elementId: this.endpoints[0].elementId,
                    txy: [ otherOffset.left, otherOffset.top ], twh: otherWH, tElement: this.endpoints[1],
                    timestamp: initialTimestamp
                });

            this.endpoints[0].paint({ anchorLoc: anchorLoc, timestamp: initialTimestamp });

            anchorLoc = this.endpoints[1].anchor.compute({
                xy: [ otherOffset.left, otherOffset.top ], wh: otherWH, element: this.endpoints[1],
                elementId: this.endpoints[1].elementId,
                txy: [ myOffset.left, myOffset.top ], twh: myWH, tElement: this.endpoints[0],
                timestamp: initialTimestamp
            });
            this.endpoints[1].paint({ anchorLoc: anchorLoc, timestamp: initialTimestamp });
        }

        this.getTypeDescriptor = function () {
            return "connection";
        };
        this.getAttachedElements = function () {
            return this.endpoints;
        };

        this.isDetachable = function () {
            return this._jsPlumb.detachable === true;
        };
        this.setDetachable = function (detachable) {
            this._jsPlumb.detachable = detachable === true;
        };
        this.isReattach = function () {
            return this._jsPlumb.reattach === true || this.endpoints[0].reattachConnections === true || this.endpoints[1].reattachConnections === true;
        };
        this.setReattach = function (reattach) {
            this._jsPlumb.reattach = reattach === true;
        };

// END INITIALISATION CODE


// COST + DIRECTIONALITY
        // if cost not supplied, try to inherit from source endpoint
        this._jsPlumb.cost = params.cost || this.endpoints[0].getConnectionCost();
        this._jsPlumb.directed = params.directed;
        // inherit directed flag if set no source endpoint
        if (params.directed == null) this._jsPlumb.directed = this.endpoints[0].areConnectionsDirected();
// END COST + DIRECTIONALITY

// PARAMETERS
        // merge all the parameters objects into the connection.  parameters set
        // on the connection take precedence; then source endpoint params, then
        // finally target endpoint params.
        var _p = jsPlumb.extend({}, this.endpoints[1].getParameters());
        _jp.extend(_p, this.endpoints[0].getParameters());
        _jp.extend(_p, this.getParameters());
        this.setParameters(_p);
// END PARAMETERS

// PAINTING

        this.setConnector(this.endpoints[0].connector || this.endpoints[1].connector || params.connector || _jsPlumb.Defaults.Connector || _jp.Defaults.Connector, true);
        var data = params.data == null || !jsPlumbUtil.isObject(params.data) ? {} : params.data;
        this.getData = function() { return data; };
        this.setData = function(d) { data = d || {}; };
        this.mergeData = function(d) { data = jsPlumb.extend(data, d); };

        // the very last thing we do is apply types, if there are any.
        var _types = [ "default", this.endpoints[0].connectionType, this.endpoints[1].connectionType,  params.type ].join(" ");
        if (/[^\s]/.test(_types))
            this.addType(_types, params.data, true);

        this.updateConnectedClass();

// END PAINTING    
    };

    _ju.extend(_jp.Connection, _jp.OverlayCapableJsPlumbUIComponent, {
        applyType: function (t, doNotRepaint, typeMap) {

            // none of these things result in the creation of objects so can be ignored.
            if (t.detachable != null) this.setDetachable(t.detachable);
            if (t.reattach != null) this.setReattach(t.reattach);
            if (t.scope) this.scope = t.scope;

            if (t.cssClass != null && this.canvas) this._jsPlumb.instance.addClass(this.canvas, t.cssClass);

            var _anchors = null;
            // this also results in the creation of objects.
            if (t.anchor) {
                // note that even if the param was anchor, we store `anchors`.
                _anchors = this.getCachedTypeItem("anchors", typeMap.anchor);
                if (_anchors == null) {
                    _anchors = [ this._jsPlumb.instance.makeAnchor(t.anchor), this._jsPlumb.instance.makeAnchor(t.anchor) ];
                    this.cacheTypeItem("anchors", _anchors, typeMap.anchor);
                }
            }
            else if (t.anchors) {
                _anchors = this.getCachedTypeItem("anchors", typeMap.anchors);
                if (_anchors == null) {
                    _anchors = [
                        this._jsPlumb.instance.makeAnchor(t.anchors[0]),
                        this._jsPlumb.instance.makeAnchor(t.anchors[1])
                    ];
                    this.cacheTypeItem("anchors", _anchors, typeMap.anchors);
                }
            }
            if (_anchors != null) {
                this.endpoints[0].anchor = _anchors[0];
                this.endpoints[1].anchor = _anchors[1];
                if (this.endpoints[1].anchor.isDynamic) this._jsPlumb.instance.repaint(this.endpoints[1].elementId);
            }

            _jp.OverlayCapableJsPlumbUIComponent.applyType(this, t);
        },
        addClass: function (c, informEndpoints) {
            if (informEndpoints) {
                this.endpoints[0].addClass(c);
                this.endpoints[1].addClass(c);
                if (this.suspendedEndpoint) this.suspendedEndpoint.addClass(c);
            }
            if (this.connector) {
                this.connector.addClass(c);
            }
        },
        removeClass: function (c, informEndpoints) {
            if (informEndpoints) {
                this.endpoints[0].removeClass(c);
                this.endpoints[1].removeClass(c);
                if (this.suspendedEndpoint) this.suspendedEndpoint.removeClass(c);
            }
            if (this.connector) {
                this.connector.removeClass(c);
            }
        },
        isVisible: function () {
            return this._jsPlumb.visible;
        },
        setVisible: function (v) {
            this._jsPlumb.visible = v;
            if (this.connector)
                this.connector.setVisible(v);
            this.repaint();
        },
        cleanup: function () {
            this.updateConnectedClass(true);
            this.endpoints = null;
            this.source = null;
            this.target = null;
            if (this.connector != null) {
                this.connector.cleanup(true);
                this.connector.destroy(true);
            }
            this.connector = null;
        },
        updateConnectedClass:function(remove) {
            _updateConnectedClass(this, this.source, this._jsPlumb.instance, remove);
            _updateConnectedClass(this, this.target, this._jsPlumb.instance, remove);
        },
        setHover: function (state) {
            if (this.connector && this._jsPlumb && !this._jsPlumb.instance.isConnectionBeingDragged()) {
                this.connector.setHover(state);
                root.jsPlumb[state ? "addClass" : "removeClass"](this.source, this._jsPlumb.instance.hoverSourceClass);
                root.jsPlumb[state ? "addClass" : "removeClass"](this.target, this._jsPlumb.instance.hoverTargetClass);
            }
        },
        getUuids:function() {
            return [ this.endpoints[0].getUuid(), this.endpoints[1].getUuid() ];
        },
        getCost: function () {
            return this._jsPlumb.cost;
        },
        setCost: function (c) {
            this._jsPlumb.cost = c;
        },
        isDirected: function () {
            return this._jsPlumb.directed === true;
        },
        getConnector: function () {
            return this.connector;
        },
        prepareConnector:function(connectorSpec, typeId) {
            var connectorArgs = {
                    _jsPlumb: this._jsPlumb.instance,
                    cssClass: this._jsPlumb.params.cssClass,
                    container: this._jsPlumb.params.container,
                    "pointer-events": this._jsPlumb.params["pointer-events"]
                },
                renderMode = this._jsPlumb.instance.getRenderMode(),
                connector;

            if (_ju.isString(connectorSpec))
                connector = makeConnector(this._jsPlumb.instance, renderMode, connectorSpec, connectorArgs, this); // lets you use a string as shorthand.
            else if (_ju.isArray(connectorSpec)) {
                if (connectorSpec.length == 1)
                    connector = makeConnector(this._jsPlumb.instance, renderMode, connectorSpec[0], connectorArgs, this);
                else
                    connector = makeConnector(this._jsPlumb.instance, renderMode, connectorSpec[0], _ju.merge(connectorSpec[1], connectorArgs), this);
            }
            if (typeId != null) connector.typeId = typeId;
            return connector;
        },
        setPreparedConnector: function(connector, doNotRepaint, doNotChangeListenerComponent, typeId) {

            var previous, previousClasses = "";
            // the connector will not be cleaned up if it was set as part of a type, because `typeId` will be set on it
            // and we havent passed in `true` for "force" here.
            if (this.connector != null) {
                previous = this.connector;
                previousClasses = previous.getClass();
                this.connector.cleanup();
                this.connector.destroy();
            }

            this.connector = connector;
            if (typeId) {
                this.cacheTypeItem("connector", connector, typeId);
            }

            this.canvas = this.connector.canvas;
            this.bgCanvas = this.connector.bgCanvas;

            // put classes from prior connector onto the canvas
            this.addClass(previousClasses);

            // new: instead of binding listeners per connector, we now just have one delegate on the container.
            // so for that handler we set the connection as the '_jsPlumb' member of the canvas element, and
            // bgCanvas, if it exists, which it does right now in the VML renderer, so it won't from v 2.0.0 onwards.
            if (this.canvas) this.canvas._jsPlumb = this;
            if (this.bgCanvas) this.bgCanvas._jsPlumb = this;

            if (previous != null) {
                var o = this.getOverlays();
                for (var i = 0; i < o.length; i++) {
                    if (o[i].transfer) o[i].transfer(this.connector);
                }
            }

            if (!doNotChangeListenerComponent) this.setListenerComponent(this.connector);
            if (!doNotRepaint) this.repaint();
        },
        setConnector: function (connectorSpec, doNotRepaint, doNotChangeListenerComponent, typeId) {
            var connector = this.prepareConnector(connectorSpec, typeId);
            this.setPreparedConnector(connector, doNotRepaint, doNotChangeListenerComponent, typeId);
        },
        paint: function (params) {

            if (!this._jsPlumb.instance.isSuspendDrawing() && this._jsPlumb.visible) {
                params = params || {};
                var timestamp = params.timestamp,
                // if the moving object is not the source we must transpose the two references.
                    swap = false,
                    tId = swap ? this.sourceId : this.targetId, sId = swap ? this.targetId : this.sourceId,
                    tIdx = swap ? 0 : 1, sIdx = swap ? 1 : 0;

                if (timestamp == null || timestamp != this._jsPlumb.lastPaintedAt) {
                    var sourceInfo = this._jsPlumb.instance.updateOffset({elId:sId}).o,
                        targetInfo = this._jsPlumb.instance.updateOffset({elId:tId}).o,
                        sE = this.endpoints[sIdx], tE = this.endpoints[tIdx];

                    var sAnchorP = sE.anchor.getCurrentLocation({xy: [sourceInfo.left, sourceInfo.top], wh: [sourceInfo.width, sourceInfo.height], element: sE, timestamp: timestamp}),
                        tAnchorP = tE.anchor.getCurrentLocation({xy: [targetInfo.left, targetInfo.top], wh: [targetInfo.width, targetInfo.height], element: tE, timestamp: timestamp});

                    this.connector.resetBounds();

                    this.connector.compute({
                        sourcePos: sAnchorP,
                        targetPos: tAnchorP,
                        sourceEndpoint: this.endpoints[sIdx],
                        targetEndpoint: this.endpoints[tIdx],
                        lineWidth: this._jsPlumb.paintStyleInUse.lineWidth,
                        sourceInfo: sourceInfo,
                        targetInfo: targetInfo
                    });

                    var overlayExtents = { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity };

                    // compute overlays. we do this first so we can get their placements, and adjust the
                    // container if needs be (if an overlay would be clipped)
                    for (var i in this._jsPlumb.overlays) {
                        if (this._jsPlumb.overlays.hasOwnProperty(i)) {
                            var o = this._jsPlumb.overlays[i];
                            if (o.isVisible()) {
                                this._jsPlumb.overlayPlacements[i] = o.draw(this.connector, this._jsPlumb.paintStyleInUse, this.getAbsoluteOverlayPosition(o));
                                overlayExtents.minX = Math.min(overlayExtents.minX, this._jsPlumb.overlayPlacements[i].minX);
                                overlayExtents.maxX = Math.max(overlayExtents.maxX, this._jsPlumb.overlayPlacements[i].maxX);
                                overlayExtents.minY = Math.min(overlayExtents.minY, this._jsPlumb.overlayPlacements[i].minY);
                                overlayExtents.maxY = Math.max(overlayExtents.maxY, this._jsPlumb.overlayPlacements[i].maxY);
                            }
                        }
                    }

                    var lineWidth = parseFloat(this._jsPlumb.paintStyleInUse.lineWidth || 1) / 2,
                        outlineWidth = parseFloat(this._jsPlumb.paintStyleInUse.lineWidth || 0),
                        extents = {
                            xmin: Math.min(this.connector.bounds.minX - (lineWidth + outlineWidth), overlayExtents.minX),
                            ymin: Math.min(this.connector.bounds.minY - (lineWidth + outlineWidth), overlayExtents.minY),
                            xmax: Math.max(this.connector.bounds.maxX + (lineWidth + outlineWidth), overlayExtents.maxX),
                            ymax: Math.max(this.connector.bounds.maxY + (lineWidth + outlineWidth), overlayExtents.maxY)
                        };
                    // paint the connector.
                    this.connector.paint(this._jsPlumb.paintStyleInUse, null, extents);
                    // and then the overlays
                    for (var j in this._jsPlumb.overlays) {
                        if (this._jsPlumb.overlays.hasOwnProperty(j)) {
                            var p = this._jsPlumb.overlays[j];
                            if (p.isVisible()) {
                                p.paint(this._jsPlumb.overlayPlacements[j], extents);
                            }
                        }
                    }
                }
                this._jsPlumb.lastPaintedAt = timestamp;
            }
        },
        repaint: function (params) {
            params = params || {};
            this.paint({ elId: this.sourceId, recalc: !(params.recalc === false), timestamp: params.timestamp});
        },
        prepareEndpoint: function (_jsPlumb, _newEndpoint, conn, existing, index, params, element, elementId) {
            var e;
            if (existing) {
                conn.endpoints[index] = existing;
                existing.addConnection(conn);
            } else {
                if (!params.endpoints) params.endpoints = [ null, null ];
                var ep = params.endpoints[index] || params.endpoint || _jsPlumb.Defaults.Endpoints[index] || jsPlumb.Defaults.Endpoints[index] || _jsPlumb.Defaults.Endpoint || jsPlumb.Defaults.Endpoint;
                if (!params.endpointStyles) params.endpointStyles = [ null, null ];
                if (!params.endpointHoverStyles) params.endpointHoverStyles = [ null, null ];
                var es = params.endpointStyles[index] || params.endpointStyle || _jsPlumb.Defaults.EndpointStyles[index] || jsPlumb.Defaults.EndpointStyles[index] || _jsPlumb.Defaults.EndpointStyle || jsPlumb.Defaults.EndpointStyle;
                // Endpoints derive their fillStyle from the connector's strokeStyle, if no fillStyle was specified.
                if (es.fillStyle == null && params.paintStyle != null)
                    es.fillStyle = params.paintStyle.strokeStyle;

                if (es.outlineColor == null && params.paintStyle != null)
                    es.outlineColor = params.paintStyle.outlineColor;
                if (es.outlineWidth == null && params.paintStyle != null)
                    es.outlineWidth = params.paintStyle.outlineWidth;

                var ehs = params.endpointHoverStyles[index] || params.endpointHoverStyle || _jsPlumb.Defaults.EndpointHoverStyles[index] || jsPlumb.Defaults.EndpointHoverStyles[index] || _jsPlumb.Defaults.EndpointHoverStyle || jsPlumb.Defaults.EndpointHoverStyle;
                // endpoint hover fill style is derived from connector's hover stroke style
                if (params.hoverPaintStyle != null) {
                    if (ehs == null) ehs = {};
                    if (ehs.fillStyle == null) {
                        ehs.fillStyle = params.hoverPaintStyle.strokeStyle;
                    }
                }
                var a = params.anchors ? params.anchors[index] :
                        params.anchor ? params.anchor :
                            _makeAnchor(_jsPlumb.Defaults.Anchors[index], elementId, _jsPlumb) ||
                            _makeAnchor(_jp.Defaults.Anchors[index], elementId, _jsPlumb) ||
                            _makeAnchor(_jsPlumb.Defaults.Anchor, elementId, _jsPlumb) ||
                            _makeAnchor(_jp.Defaults.Anchor, elementId, _jsPlumb),
                    u = params.uuids ? params.uuids[index] : null;

                e = _newEndpoint({
                    paintStyle: es, hoverPaintStyle: ehs, endpoint: ep, connections: [ conn ],
                    uuid: u, anchor: a, source: element, scope: params.scope,
                    reattach: params.reattach || _jsPlumb.Defaults.ReattachConnections,
                    detachable: params.detachable || _jsPlumb.Defaults.ConnectionsDetachable
                });
                conn.endpoints[index] = e;

                if (params.drawEndpoints === false) e.setVisible(false, true, true);

            }
            return e;
        }

    }); // END Connection class            
}).call(this);

/*
 * jsPlumb
 * 
 * Title:jsPlumb 2.0.2
 * 
 * Provides a way to visually connect elements on an HTML page, using SVG.
 * 
 * This file contains the code for creating and manipulating anchors.
 *
 * Copyright (c) 2010 - 2015 jsPlumb (hello@jsplumbtoolkit.com)
 * 
 * http://jsplumbtoolkit.com
 * http://github.com/sporritt/jsplumb
 * 
 * Dual licensed under the MIT and GPL2 licenses.
 */
;
(function () {

    "use strict";

    var root = this,
        _ju = root.jsPlumbUtil,
        _jp = root.jsPlumb;

    //
    // manages anchors for all elements.
    //
    _jp.AnchorManager = function (params) {
        var _amEndpoints = {},
            continuousAnchorLocations = {},
            userDefinedContinuousAnchorLocations = {},
            continuousAnchorOrientations = {},
            Orientation = { HORIZONTAL: "horizontal", VERTICAL: "vertical", DIAGONAL: "diagonal", IDENTITY: "identity" },
            axes = ["left", "top", "right", "bottom"],
            connectionsByElementId = {},
            self = this,
            anchorLists = {},
            jsPlumbInstance = params.jsPlumbInstance,
            floatingConnections = {},
            calculateOrientation = function (sourceId, targetId, sd, td, sourceAnchor, targetAnchor) {

                if (sourceId === targetId) return {
                    orientation: Orientation.IDENTITY,
                    a: ["top", "top"]
                };

                var theta = Math.atan2((td.centery - sd.centery), (td.centerx - sd.centerx)),
                    theta2 = Math.atan2((sd.centery - td.centery), (sd.centerx - td.centerx));

// --------------------------------------------------------------------------------------

                // improved face calculation. get midpoints of each face for source and target, then put in an array with all combinations of
                // source/target faces. sort this array by distance between midpoints. the entry at index 0 is our preferred option. we can
                // go through the array one by one until we find an entry in which each requested face is supported.
                var candidates = [], midpoints = { };
                (function (types, dim) {
                    for (var i = 0; i < types.length; i++) {
                        midpoints[types[i]] = {
                            "left": [ dim[i].left, dim[i].centery ],
                            "right": [ dim[i].right, dim[i].centery ],
                            "top": [ dim[i].centerx, dim[i].top ],
                            "bottom": [ dim[i].centerx , dim[i].bottom]
                        };
                    }
                })([ "source", "target" ], [ sd, td ]);

                for (var sf = 0; sf < axes.length; sf++) {
                    for (var tf = 0; tf < axes.length; tf++) {
                        if (sf != tf) {
                            candidates.push({
                                source: axes[sf],
                                target: axes[tf],
                                dist: Biltong.lineLength(midpoints.source[axes[sf]], midpoints.target[axes[tf]])
                            });
                        }
                    }
                }

                candidates.sort(function (a, b) {
                    return a.dist < b.dist ? -1 : a.dist > b.dist ? 1 : 0;
                });

                // now go through this list and try to get an entry that satisfies both (there will be one, unless one of the anchors
                // declares no available faces)
                var sourceEdge = candidates[0].source, targetEdge = candidates[0].target;
                for (var i = 0; i < candidates.length; i++) {

                    if (!sourceAnchor.isContinuous || sourceAnchor.isEdgeSupported(candidates[i].source))
                        sourceEdge = candidates[i].source;
                    else
                        sourceEdge = null;

                    if (!targetAnchor.isContinuous || targetAnchor.isEdgeSupported(candidates[i].target))
                        targetEdge = candidates[i].target;
                    else {
                        targetEdge = null;
                    }

                    if (sourceEdge != null && targetEdge != null) break;
                }

// --------------------------------------------------------------------------------------

                return {
                    a: [ sourceEdge, targetEdge ],
                    theta: theta,
                    theta2: theta2
                };
            },
        // used by placeAnchors function
            placeAnchorsOnLine = function (desc, elementDimensions, elementPosition, connections, horizontal, otherMultiplier, reverse) {
                var a = [], step = elementDimensions[horizontal ? 0 : 1] / (connections.length + 1);

                for (var i = 0; i < connections.length; i++) {
                    var val = (i + 1) * step, other = otherMultiplier * elementDimensions[horizontal ? 1 : 0];
                    if (reverse)
                        val = elementDimensions[horizontal ? 0 : 1] - val;

                    var dx = (horizontal ? val : other), x = elementPosition[0] + dx, xp = dx / elementDimensions[0],
                        dy = (horizontal ? other : val), y = elementPosition[1] + dy, yp = dy / elementDimensions[1];

                    a.push([ x, y, xp, yp, connections[i][1], connections[i][2] ]);
                }

                return a;
            },
        // used by edgeSortFunctions
            currySort = function (reverseAngles) {
                return function (a, b) {
                    var r = true;
                    if (reverseAngles) {
                        r = a[0][0] < b[0][0];
                    }
                    else {
                        r = a[0][0] > b[0][0];
                    }
                    return r === false ? -1 : 1;
                };
            },
        // used by edgeSortFunctions
            leftSort = function (a, b) {
                // first get adjusted values
                var p1 = a[0][0] < 0 ? -Math.PI - a[0][0] : Math.PI - a[0][0],
                    p2 = b[0][0] < 0 ? -Math.PI - b[0][0] : Math.PI - b[0][0];
                if (p1 > p2) return 1;
                else return a[0][1] > b[0][1] ? 1 : -1;
            },
        // used by placeAnchors
            edgeSortFunctions = {
                "top": function (a, b) {
                    return a[0] > b[0] ? 1 : -1;
                },
                "right": currySort(true),
                "bottom": currySort(true),
                "left": leftSort
            },
        // used by placeAnchors
            _sortHelper = function (_array, _fn) {
                return _array.sort(_fn);
            },
        // used by AnchorManager.redraw
            placeAnchors = function (elementId, _anchorLists) {
                var cd = jsPlumbInstance.getCachedData(elementId), sS = cd.s, sO = cd.o,
                    placeSomeAnchors = function (desc, elementDimensions, elementPosition, unsortedConnections, isHorizontal, otherMultiplier, orientation) {
                        if (unsortedConnections.length > 0) {
                            var sc = _sortHelper(unsortedConnections, edgeSortFunctions[desc]), // puts them in order based on the target element's pos on screen
                                reverse = desc === "right" || desc === "top",
                                anchors = placeAnchorsOnLine(desc, elementDimensions,
                                    elementPosition, sc,
                                    isHorizontal, otherMultiplier, reverse);

                            // takes a computed anchor position and adjusts it for parent offset and scroll, then stores it.
                            var _setAnchorLocation = function (endpoint, anchorPos) {
                                continuousAnchorLocations[endpoint.id] = [ anchorPos[0], anchorPos[1], anchorPos[2], anchorPos[3] ];
                                continuousAnchorOrientations[endpoint.id] = orientation;
                            };

                            for (var i = 0; i < anchors.length; i++) {
                                var c = anchors[i][4], weAreSource = c.endpoints[0].elementId === elementId, weAreTarget = c.endpoints[1].elementId === elementId;
                                if (weAreSource)
                                    _setAnchorLocation(c.endpoints[0], anchors[i]);
                                else if (weAreTarget)
                                    _setAnchorLocation(c.endpoints[1], anchors[i]);
                            }
                        }
                    };

                placeSomeAnchors("bottom", sS, [sO.left, sO.top], _anchorLists.bottom, true, 1, [0, 1]);
                placeSomeAnchors("top", sS, [sO.left, sO.top], _anchorLists.top, true, 0, [0, -1]);
                placeSomeAnchors("left", sS, [sO.left, sO.top], _anchorLists.left, false, 0, [-1, 0]);
                placeSomeAnchors("right", sS, [sO.left, sO.top], _anchorLists.right, false, 1, [1, 0]);
            };

        this.reset = function () {
            _amEndpoints = {};
            connectionsByElementId = {};
            anchorLists = {};
        };
        this.addFloatingConnection = function (key, conn) {
            floatingConnections[key] = conn;
        };
        this.removeFloatingConnection = function (key) {
            delete floatingConnections[key];
        };
        this.newConnection = function (conn) {
            var sourceId = conn.sourceId, targetId = conn.targetId,
                ep = conn.endpoints,
                doRegisterTarget = true,
                registerConnection = function (otherIndex, otherEndpoint, otherAnchor, elId, c) {
                    if ((sourceId == targetId) && otherAnchor.isContinuous) {
                        // remove the target endpoint's canvas.  we dont need it.
                        conn._jsPlumb.instance.removeElement(ep[1].canvas);
                        doRegisterTarget = false;
                    }
                    _ju.addToList(connectionsByElementId, elId, [c, otherEndpoint, otherAnchor.constructor == _jp.DynamicAnchor]);
                };

            registerConnection(0, ep[0], ep[0].anchor, targetId, conn);
            if (doRegisterTarget)
                registerConnection(1, ep[1], ep[1].anchor, sourceId, conn);
        };
        var removeEndpointFromAnchorLists = function (endpoint) {
            (function (list, eId) {
                if (list) {  // transient anchors dont get entries in this list.
                    var f = function (e) {
                        return e[4] == eId;
                    };
                    _ju.removeWithFunction(list.top, f);
                    _ju.removeWithFunction(list.left, f);
                    _ju.removeWithFunction(list.bottom, f);
                    _ju.removeWithFunction(list.right, f);
                }
            })(anchorLists[endpoint.elementId], endpoint.id);
        };
        this.connectionDetached = function (connInfo, doNotRedraw) {
            var connection = connInfo.connection || connInfo,
                sourceId = connInfo.sourceId,
                targetId = connInfo.targetId,
                ep = connection.endpoints,
                removeConnection = function (otherIndex, otherEndpoint, otherAnchor, elId, c) {
                   _ju.removeWithFunction(connectionsByElementId[elId], function (_c) {
                        return _c[0].id == c.id;
                    });
                };

            removeConnection(1, ep[1], ep[1].anchor, sourceId, connection);
            removeConnection(0, ep[0], ep[0].anchor, targetId, connection);
            if (connection.floatingId) {
                removeConnection(connection.floatingIndex, connection.floatingEndpoint, connection.floatingEndpoint.anchor, connection.floatingId, connection);
                removeEndpointFromAnchorLists(connection.floatingEndpoint);
            }

            // remove from anchorLists            
            removeEndpointFromAnchorLists(connection.endpoints[0]);
            removeEndpointFromAnchorLists(connection.endpoints[1]);

            if (!doNotRedraw) {
                self.redraw(connection.sourceId);
                if (connection.targetId !== connection.sourceId)
                    self.redraw(connection.targetId);
            }
        };
        this.add = function (endpoint, elementId) {
            _ju.addToList(_amEndpoints, elementId, endpoint);
        };
        this.changeId = function (oldId, newId) {
            connectionsByElementId[newId] = connectionsByElementId[oldId];
            _amEndpoints[newId] = _amEndpoints[oldId];
            delete connectionsByElementId[oldId];
            delete _amEndpoints[oldId];
        };
        this.getConnectionsFor = function (elementId) {
            return connectionsByElementId[elementId] || [];
        };
        this.getEndpointsFor = function (elementId) {
            return _amEndpoints[elementId] || [];
        };
        this.deleteEndpoint = function (endpoint) {
            _ju.removeWithFunction(_amEndpoints[endpoint.elementId], function (e) {
                return e.id == endpoint.id;
            });
            removeEndpointFromAnchorLists(endpoint);
        };
        this.clearFor = function (elementId) {
            delete _amEndpoints[elementId];
            _amEndpoints[elementId] = [];
        };
        // updates the given anchor list by either updating an existing anchor's info, or adding it. this function
        // also removes the anchor from its previous list, if the edge it is on has changed.
        // all connections found along the way (those that are connected to one of the faces this function
        // operates on) are added to the connsToPaint list, as are their endpoints. in this way we know to repaint
        // them wthout having to calculate anything else about them.
        var _updateAnchorList = function (lists, theta, order, conn, aBoolean, otherElId, idx, reverse, edgeId, elId, connsToPaint, endpointsToPaint) {
            // first try to find the exact match, but keep track of the first index of a matching element id along the way.s
            var exactIdx = -1,
                firstMatchingElIdx = -1,
                endpoint = conn.endpoints[idx],
                endpointId = endpoint.id,
                oIdx = [1, 0][idx],
                values = [
                    [ theta, order ],
                    conn,
                    aBoolean,
                    otherElId,
                    endpointId
                ],
                listToAddTo = lists[edgeId],
                listToRemoveFrom = endpoint._continuousAnchorEdge ? lists[endpoint._continuousAnchorEdge] : null,
                i,
                candidate;

            if (listToRemoveFrom) {
                var rIdx = _ju.findWithFunction(listToRemoveFrom, function (e) {
                    return e[4] == endpointId;
                });
                if (rIdx != -1) {
                    listToRemoveFrom.splice(rIdx, 1);
                    // get all connections from this list
                    for (i = 0; i < listToRemoveFrom.length; i++) {
                        candidate = listToRemoveFrom[i][1];
                        _ju.addWithFunction(connsToPaint, candidate, function (c) {
                            return c.id == candidate.id;
                        });
                        _ju.addWithFunction(endpointsToPaint, listToRemoveFrom[i][1].endpoints[idx], function (e) {
                            return e.id == candidate.endpoints[idx].id;
                        });
                        _ju.addWithFunction(endpointsToPaint, listToRemoveFrom[i][1].endpoints[oIdx], function (e) {
                            return e.id == candidate.endpoints[oIdx].id;
                        });
                    }
                }
            }

            for (i = 0; i < listToAddTo.length; i++) {
                candidate = listToAddTo[i][1];
                if (params.idx == 1 && listToAddTo[i][3] === otherElId && firstMatchingElIdx == -1)
                    firstMatchingElIdx = i;
                _ju.addWithFunction(connsToPaint, candidate, function (c) {
                    return c.id == candidate.id;
                });
                _ju.addWithFunction(endpointsToPaint, listToAddTo[i][1].endpoints[idx], function (e) {
                    return e.id == candidate.endpoints[idx].id;
                });
                _ju.addWithFunction(endpointsToPaint, listToAddTo[i][1].endpoints[oIdx], function (e) {
                    return e.id == candidate.endpoints[oIdx].id;
                });
            }
            if (exactIdx != -1) {
                listToAddTo[exactIdx] = values;
            }
            else {
                var insertIdx = reverse ? firstMatchingElIdx != -1 ? firstMatchingElIdx : 0 : listToAddTo.length; // of course we will get this from having looked through the array shortly.
                listToAddTo.splice(insertIdx, 0, values);
            }

            // store this for next time.
            endpoint._continuousAnchorEdge = edgeId;
        };

        //
        // find the entry in an endpoint's list for this connection and update its target endpoint
        // with the current target in the connection.
        // 
        //
        this.updateOtherEndpoint = function (elId, oldTargetId, newTargetId, connection) {
            var sIndex = _ju.findWithFunction(connectionsByElementId[elId], function (i) {
                    return i[0].id === connection.id;
                }),
                tIndex = _ju.findWithFunction(connectionsByElementId[oldTargetId], function (i) {
                    return i[0].id === connection.id;
                });

            // update or add data for source
            if (sIndex != -1) {
                connectionsByElementId[elId][sIndex][0] = connection;
                connectionsByElementId[elId][sIndex][1] = connection.endpoints[1];
                connectionsByElementId[elId][sIndex][2] = connection.endpoints[1].anchor.constructor == _jp.DynamicAnchor;
            }

            // remove entry for previous target (if there)
            if (tIndex > -1) {
                connectionsByElementId[oldTargetId].splice(tIndex, 1);
                // add entry for new target
                _ju.addToList(connectionsByElementId, newTargetId, [connection, connection.endpoints[0], connection.endpoints[0].anchor.constructor == _jp.DynamicAnchor]);
            }

            connection.updateConnectedClass();
        };

        //
        // notification that the connection given has changed source from the originalId to the newId.
        // This involves:
        // 1. removing the connection from the list of connections stored for the originalId
        // 2. updating the source information for the target of the connection
        // 3. re-registering the connection in connectionsByElementId with the newId
        //
        this.sourceChanged = function (originalId, newId, connection) {
            if (originalId !== newId) {
                // remove the entry that points from the old source to the target
                _ju.removeWithFunction(connectionsByElementId[originalId], function (info) {
                    return info[0].id === connection.id;
                });
                // find entry for target and update it
                var tIdx = _ju.findWithFunction(connectionsByElementId[connection.targetId], function (i) {
                    return i[0].id === connection.id;
                });
                if (tIdx > -1) {
                    connectionsByElementId[connection.targetId][tIdx][0] = connection;
                    connectionsByElementId[connection.targetId][tIdx][1] = connection.endpoints[0];
                    connectionsByElementId[connection.targetId][tIdx][2] = connection.endpoints[0].anchor.constructor == _jp.DynamicAnchor;
                }
                // add entry for new source
                _ju.addToList(connectionsByElementId, newId, [connection, connection.endpoints[1], connection.endpoints[1].anchor.constructor == _jp.DynamicAnchor]);

                // TODO SP not final on this yet. when a user drags an existing connection and it turns into a self
                // loop, then this code hides the target endpoint (by removing it from the DOM) But I think this should
                // occur only if the anchor is Continuous
                if (connection.endpoints[1].anchor.isContinuous) {
                    if (connection.source === connection.target) {
                        connection._jsPlumb.instance.removeElement(connection.endpoints[1].canvas);
                    }
                    else {
                        if (connection.endpoints[1].canvas.parentNode == null) {
                            connection._jsPlumb.instance.appendElement(connection.endpoints[1].canvas);
                        }
                    }
                }

                connection.updateConnectedClass();
            }
        };

        //
        // moves the given endpoint from `currentId` to `element`.
        // This involves:
        //
        // 1. changing the key in _amEndpoints under which the endpoint is stored
        // 2. changing the source or target values in all of the endpoint's connections
        // 3. changing the array in connectionsByElementId in which the endpoint's connections
        //    are stored (done by either sourceChanged or updateOtherEndpoint)
        //
        this.rehomeEndpoint = function (ep, currentId, element) {
            var eps = _amEndpoints[currentId] || [],
                elementId = jsPlumbInstance.getId(element);

            if (elementId !== currentId) {
                var idx = eps.indexOf(ep);
                if (idx > -1) {
                    var _ep = eps.splice(idx, 1)[0];
                    self.add(_ep, elementId);
                }
            }

            for (var i = 0; i < ep.connections.length; i++) {
                if (ep.connections[i].sourceId == currentId) {
                    ep.connections[i].sourceId = ep.elementId;
                    ep.connections[i].source = ep.element;
                    self.sourceChanged(currentId, ep.elementId, ep.connections[i]);
                }
                else if (ep.connections[i].targetId == currentId) {
                    ep.connections[i].targetId = ep.elementId;
                    ep.connections[i].target = ep.element;
                    self.updateOtherEndpoint(ep.connections[i].sourceId, currentId, ep.elementId, ep.connections[i]);
                }
            }
        };

        this.redraw = function (elementId, ui, timestamp, offsetToUI, clearEdits, doNotRecalcEndpoint) {

            if (!jsPlumbInstance.isSuspendDrawing()) {
                // get all the endpoints for this element
                var ep = _amEndpoints[elementId] || [],
                    endpointConnections = connectionsByElementId[elementId] || [],
                    connectionsToPaint = [],
                    endpointsToPaint = [],
                    anchorsToUpdate = [];

                timestamp = timestamp || jsPlumbInstance.timestamp();
                // offsetToUI are values that would have been calculated in the dragManager when registering
                // an endpoint for an element that had a parent (somewhere in the hierarchy) that had been
                // registered as draggable.
                offsetToUI = offsetToUI || {left: 0, top: 0};
                if (ui) {
                    ui = {
                        left: ui.left + offsetToUI.left,
                        top: ui.top + offsetToUI.top
                    };
                }

                // valid for one paint cycle.
                var myOffset = jsPlumbInstance.updateOffset({ elId: elementId, offset: ui, recalc: false, timestamp: timestamp }),
                    orientationCache = {};

                // actually, first we should compute the orientation of this element to all other elements to which
                // this element is connected with a continuous anchor (whether both ends of the connection have
                // a continuous anchor or just one)

                for (var i = 0; i < endpointConnections.length; i++) {
                    var conn = endpointConnections[i][0],
                        sourceId = conn.sourceId,
                        targetId = conn.targetId,
                        sourceContinuous = conn.endpoints[0].anchor.isContinuous,
                        targetContinuous = conn.endpoints[1].anchor.isContinuous;

                    if (sourceContinuous || targetContinuous) {
                        var oKey = sourceId + "_" + targetId,
                            o = orientationCache[oKey],
                            oIdx = conn.sourceId == elementId ? 1 : 0;

                        if (sourceContinuous && !anchorLists[sourceId]) anchorLists[sourceId] = { top: [], right: [], bottom: [], left: [] };
                        if (targetContinuous && !anchorLists[targetId]) anchorLists[targetId] = { top: [], right: [], bottom: [], left: [] };

                        if (elementId != targetId) jsPlumbInstance.updateOffset({ elId: targetId, timestamp: timestamp });
                        if (elementId != sourceId) jsPlumbInstance.updateOffset({ elId: sourceId, timestamp: timestamp });

                        var td = jsPlumbInstance.getCachedData(targetId),
                            sd = jsPlumbInstance.getCachedData(sourceId);

                        if (targetId == sourceId && (sourceContinuous || targetContinuous)) {
                            // here we may want to improve this by somehow determining the face we'd like
                            // to put the connector on.  ideally, when drawing, the face should be calculated
                            // by determining which face is closest to the point at which the mouse button
                            // was released.  for now, we're putting it on the top face.
                            _updateAnchorList(
                                anchorLists[sourceId],
                                    -Math.PI / 2,
                                0,
                                conn,
                                false,
                                targetId,
                                0, false, "top", sourceId, connectionsToPaint, endpointsToPaint);
                        }
                        else {
                            if (!o) {
                                o = calculateOrientation(sourceId, targetId, sd.o, td.o, conn.endpoints[0].anchor, conn.endpoints[1].anchor);
                                orientationCache[oKey] = o;
                                // this would be a performance enhancement, but the computed angles need to be clamped to
                                //the (-PI/2 -> PI/2) range in order for the sorting to work properly.
                                /*  orientationCache[oKey2] = {
                                 orientation:o.orientation,
                                 a:[o.a[1], o.a[0]],
                                 theta:o.theta + Math.PI,
                                 theta2:o.theta2 + Math.PI
                                 };*/
                            }
                            if (sourceContinuous) _updateAnchorList(anchorLists[sourceId], o.theta, 0, conn, false, targetId, 0, false, o.a[0], sourceId, connectionsToPaint, endpointsToPaint);
                            if (targetContinuous) _updateAnchorList(anchorLists[targetId], o.theta2, -1, conn, true, sourceId, 1, true, o.a[1], targetId, connectionsToPaint, endpointsToPaint);
                        }

                        if (sourceContinuous) _ju.addWithFunction(anchorsToUpdate, sourceId, function (a) {
                            return a === sourceId;
                        });
                        if (targetContinuous) _ju.addWithFunction(anchorsToUpdate, targetId, function (a) {
                            return a === targetId;
                        });
                        _ju.addWithFunction(connectionsToPaint, conn, function (c) {
                            return c.id == conn.id;
                        });
                        if ((sourceContinuous && oIdx === 0) || (targetContinuous && oIdx === 1))
                            _ju.addWithFunction(endpointsToPaint, conn.endpoints[oIdx], function (e) {
                                return e.id == conn.endpoints[oIdx].id;
                            });
                    }
                }

                // place Endpoints whose anchors are continuous but have no Connections
                for (i = 0; i < ep.length; i++) {
                    if (ep[i].connections.length === 0 && ep[i].anchor.isContinuous) {
                        if (!anchorLists[elementId]) anchorLists[elementId] = { top: [], right: [], bottom: [], left: [] };
                        _updateAnchorList(anchorLists[elementId], -Math.PI / 2, 0, {endpoints: [ep[i], ep[i]], paint: function () {
                        }}, false, elementId, 0, false, ep[i].anchor.getDefaultFace(), elementId, connectionsToPaint, endpointsToPaint);
                        _ju.addWithFunction(anchorsToUpdate, elementId, function (a) {
                            return a === elementId;
                        });
                    }
                }


                // now place all the continuous anchors we need to;
                for (i = 0; i < anchorsToUpdate.length; i++) {
                    placeAnchors(anchorsToUpdate[i], anchorLists[anchorsToUpdate[i]]);
                }

                // now that continuous anchors have been placed, paint all the endpoints for this element
                // TODO performance: add the endpoint ids to a temp array, and then when iterating in the next
                // loop, check that we didn't just paint that endpoint. we can probably shave off a few more milliseconds this way.
                for (i = 0; i < ep.length; i++) {
                    ep[i].paint({ timestamp: timestamp, offset: myOffset, dimensions: myOffset.s, recalc: doNotRecalcEndpoint !== true });
                }

                // ... and any other endpoints we came across as a result of the continuous anchors.
                for (i = 0; i < endpointsToPaint.length; i++) {
                    var cd = jsPlumbInstance.getCachedData(endpointsToPaint[i].elementId);
                    endpointsToPaint[i].paint({ timestamp: timestamp, offset: cd, dimensions: cd.s });
                }

                // paint all the standard and "dynamic connections", which are connections whose other anchor is
                // static and therefore does need to be recomputed; we make sure that happens only one time.

                // TODO we could have compiled a list of these in the first pass through connections; might save some time.
                for (i = 0; i < endpointConnections.length; i++) {
                    var otherEndpoint = endpointConnections[i][1];
                    if (otherEndpoint.anchor.constructor == _jp.DynamicAnchor) {
                        otherEndpoint.paint({ elementWithPrecedence: elementId, timestamp: timestamp });
                        _ju.addWithFunction(connectionsToPaint, endpointConnections[i][0], function (c) {
                            return c.id == endpointConnections[i][0].id;
                        });
                        // all the connections for the other endpoint now need to be repainted
                        for (var k = 0; k < otherEndpoint.connections.length; k++) {
                            if (otherEndpoint.connections[k] !== endpointConnections[i][0])
                                _ju.addWithFunction(connectionsToPaint, otherEndpoint.connections[k], function (c) {
                                    return c.id == otherEndpoint.connections[k].id;
                                });
                        }
                    } else if (otherEndpoint.anchor.constructor == _jp.Anchor) {
                        _ju.addWithFunction(connectionsToPaint, endpointConnections[i][0], function (c) {
                            return c.id == endpointConnections[i][0].id;
                        });
                    }
                }

                // paint current floating connection for this element, if there is one.
                var fc = floatingConnections[elementId];
                if (fc)
                    fc.paint({timestamp: timestamp, recalc: false, elId: elementId});

                // paint all the connections
                for (i = 0; i < connectionsToPaint.length; i++) {
                    connectionsToPaint[i].paint({elId: elementId, timestamp: timestamp, recalc: false, clearEdits: clearEdits});
                }
            }
        };

        var ContinuousAnchor = function (anchorParams) {
            _ju.EventGenerator.apply(this);
            this.type = "Continuous";
            this.isDynamic = true;
            this.isContinuous = true;
            var faces = anchorParams.faces || ["top", "right", "bottom", "left"],
                clockwise = !(anchorParams.clockwise === false),
                availableFaces = { },
                opposites = { "top": "bottom", "right": "left", "left": "right", "bottom": "top" },
                clockwiseOptions = { "top": "right", "right": "bottom", "left": "top", "bottom": "left" },
                antiClockwiseOptions = { "top": "left", "right": "top", "left": "bottom", "bottom": "right" },
                secondBest = clockwise ? clockwiseOptions : antiClockwiseOptions,
                lastChoice = clockwise ? antiClockwiseOptions : clockwiseOptions,
                cssClass = anchorParams.cssClass || "";

            for (var i = 0; i < faces.length; i++) {
                availableFaces[faces[i]] = true;
            }

            this.getDefaultFace = function () {
                return faces.length === 0 ? "top" : faces[0];
            };

            // if the given edge is supported, returns it. otherwise looks for a substitute that _is_
            // supported. if none supported we also return the request edge.
            this.verifyEdge = function (edge) {
                if (availableFaces[edge]) return edge;
                else if (availableFaces[opposites[edge]]) return opposites[edge];
                else if (availableFaces[secondBest[edge]]) return secondBest[edge];
                else if (availableFaces[lastChoice[edge]]) return lastChoice[edge];
                return edge; // we have to give them something.
            };

            this.isEdgeSupported = function (edge) {
                return availableFaces[edge] === true;
            };

            this.compute = function (params) {
                return userDefinedContinuousAnchorLocations[params.element.id] || continuousAnchorLocations[params.element.id] || [0, 0];
            };
            this.getCurrentLocation = function (params) {
                return userDefinedContinuousAnchorLocations[params.element.id] || continuousAnchorLocations[params.element.id] || [0, 0];
            };
            this.getOrientation = function (endpoint) {
                return continuousAnchorOrientations[endpoint.id] || [0, 0];
            };
            this.clearUserDefinedLocation = function () {
                delete userDefinedContinuousAnchorLocations[anchorParams.elementId];
            };
            this.setUserDefinedLocation = function (loc) {
                userDefinedContinuousAnchorLocations[anchorParams.elementId] = loc;
            };
            this.getCssClass = function () {
                return cssClass;
            };
        };

        // continuous anchors
        jsPlumbInstance.continuousAnchorFactory = {
            get: function (params) {
                return new ContinuousAnchor(params);
            },
            clear: function (elementId) {
                delete userDefinedContinuousAnchorLocations[elementId];
                delete continuousAnchorLocations[elementId];
            }
        };
    };

    /**
     * Anchors model a position on some element at which an Endpoint may be located.  They began as a first class citizen of jsPlumb, ie. a user
     * was required to create these themselves, but over time this has been replaced by the concept of referring to them either by name (eg. "TopMiddle"),
     * or by an array describing their coordinates (eg. [ 0, 0.5, 0, -1 ], which is the same as "TopMiddle").  jsPlumb now handles all of the
     * creation of Anchors without user intervention.
     */
    _jp.Anchor = function (params) {
        this.x = params.x || 0;
        this.y = params.y || 0;
        this.elementId = params.elementId;
        this.cssClass = params.cssClass || "";
        this.userDefinedLocation = null;
        this.orientation = params.orientation || [ 0, 0 ];
        this.lastReturnValue = null;
        this.offsets = params.offsets || [ 0, 0 ];
        this.timestamp = null;

        _ju.EventGenerator.apply(this);

        this.compute = function (params) {

            var xy = params.xy, wh = params.wh, timestamp = params.timestamp;

            if (params.clearUserDefinedLocation)
                this.userDefinedLocation = null;

            if (timestamp && timestamp === self.timestamp)
                return this.lastReturnValue;

            if (this.userDefinedLocation != null) {
                this.lastReturnValue = this.userDefinedLocation;
            }
            else {
                this.lastReturnValue = [ xy[0] + (this.x * wh[0]) + this.offsets[0], xy[1] + (this.y * wh[1]) + this.offsets[1] ];
            }

            this.timestamp = timestamp;
            return this.lastReturnValue;
        };

        this.getCurrentLocation = function (params) {
            params = params || {};
            return (this.lastReturnValue == null || (params.timestamp != null && this.timestamp != params.timestamp)) ? this.compute(params) : this.lastReturnValue;
        };
    };
    _ju.extend(_jp.Anchor, _ju.EventGenerator, {
        equals: function (anchor) {
            if (!anchor) return false;
            var ao = anchor.getOrientation(),
                o = this.getOrientation();
            return this.x == anchor.x && this.y == anchor.y && this.offsets[0] == anchor.offsets[0] && this.offsets[1] == anchor.offsets[1] && o[0] == ao[0] && o[1] == ao[1];
        },
        getUserDefinedLocation: function () {
            return this.userDefinedLocation;
        },
        setUserDefinedLocation: function (l) {
            this.userDefinedLocation = l;
        },
        clearUserDefinedLocation: function () {
            this.userDefinedLocation = null;
        },
        getOrientation: function () {
            return this.orientation;
        },
        getCssClass: function () {
            return this.cssClass;
        }
    });

    /**
     * An Anchor that floats. its orientation is computed dynamically from
     * its position relative to the anchor it is floating relative to.  It is used when creating
     * a connection through drag and drop.
     *
     * TODO FloatingAnchor could totally be refactored to extend Anchor just slightly.
     */
    _jp.FloatingAnchor = function (params) {

        _jp.Anchor.apply(this, arguments);

        // this is the anchor that this floating anchor is referenced to for
        // purposes of calculating the orientation.
        var ref = params.reference,
            // the canvas this refers to.
            refCanvas = params.referenceCanvas,
            size = _jp.getSize(refCanvas),
            // these are used to store the current relative position of our
            // anchor wrt the reference anchor. they only indicate
            // direction, so have a value of 1 or -1 (or, very rarely, 0). these
            // values are written by the compute method, and read
            // by the getOrientation method.
            xDir = 0, yDir = 0,
            // temporary member used to store an orientation when the floating
            // anchor is hovering over another anchor.
            orientation = null,
            _lastResult = null;

        // clear from parent. we want floating anchor orientation to always be computed.
        this.orientation = null;

        // set these to 0 each; they are used by certain types of connectors in the loopback case,
        // when the connector is trying to clear the element it is on. but for floating anchor it's not
        // very important.
        this.x = 0;
        this.y = 0;

        this.isFloating = true;

        this.compute = function (params) {
            var xy = params.xy,
                result = [ xy[0] + (size[0] / 2), xy[1] + (size[1] / 2) ]; // return origin of the element. we may wish to improve this so that any object can be the drag proxy.
            _lastResult = result;
            return result;
        };

        this.getOrientation = function (_endpoint) {
            if (orientation) return orientation;
            else {
                var o = ref.getOrientation(_endpoint);
                // here we take into account the orientation of the other
                // anchor: if it declares zero for some direction, we declare zero too. this might not be the most awesome. perhaps we can come
                // up with a better way. it's just so that the line we draw looks like it makes sense. maybe this wont make sense.
                return [ Math.abs(o[0]) * xDir * -1,
                        Math.abs(o[1]) * yDir * -1 ];
            }
        };

        /**
         * notification the endpoint associated with this anchor is hovering
         * over another anchor; we want to assume that anchor's orientation
         * for the duration of the hover.
         */
        this.over = function (anchor, endpoint) {
            orientation = anchor.getOrientation(endpoint);
        };

        /**
         * notification the endpoint associated with this anchor is no
         * longer hovering over another anchor; we should resume calculating
         * orientation as we normally do.
         */
        this.out = function () {
            orientation = null;
        };

        this.getCurrentLocation = function (params) {
            return _lastResult == null ? this.compute(params) : _lastResult;
        };
    };
    _ju.extend(_jp.FloatingAnchor, _jp.Anchor);

    var _convertAnchor = function (anchor, jsPlumbInstance, elementId) {
        return anchor.constructor == _jp.Anchor ? anchor : jsPlumbInstance.makeAnchor(anchor, elementId, jsPlumbInstance);
    };

    /* 
     * A DynamicAnchor is an Anchor that contains a list of other Anchors, which it cycles
     * through at compute time to find the one that is located closest to
     * the center of the target element, and returns that Anchor's compute
     * method result. this causes endpoints to follow each other with
     * respect to the orientation of their target elements, which is a useful
     * feature for some applications.
     * 
     */
    _jp.DynamicAnchor = function (params) {
        _jp.Anchor.apply(this, arguments);

        this.isDynamic = true;
        this.anchors = [];
        this.elementId = params.elementId;
        this.jsPlumbInstance = params.jsPlumbInstance;

        for (var i = 0; i < params.anchors.length; i++)
            this.anchors[i] = _convertAnchor(params.anchors[i], this.jsPlumbInstance, this.elementId);

        this.getAnchors = function () {
            return this.anchors;
        };
        this.locked = false;
        var _curAnchor = this.anchors.length > 0 ? this.anchors[0] : null,
            _lastAnchor = _curAnchor,
            self = this,

        // helper method to calculate the distance between the centers of the two elements.
            _distance = function (anchor, cx, cy, xy, wh) {
                var ax = xy[0] + (anchor.x * wh[0]), ay = xy[1] + (anchor.y * wh[1]),
                    acx = xy[0] + (wh[0] / 2), acy = xy[1] + (wh[1] / 2);
                return (Math.sqrt(Math.pow(cx - ax, 2) + Math.pow(cy - ay, 2)) +
                    Math.sqrt(Math.pow(acx - ax, 2) + Math.pow(acy - ay, 2)));
            },
        // default method uses distance between element centers.  you can provide your own method in the dynamic anchor
        // constructor (and also to jsPlumb.makeDynamicAnchor). the arguments to it are four arrays:
        // xy - xy loc of the anchor's element
        // wh - anchor's element's dimensions
        // txy - xy loc of the element of the other anchor in the connection
        // twh - dimensions of the element of the other anchor in the connection.
        // anchors - the list of selectable anchors
            _anchorSelector = params.selector || function (xy, wh, txy, twh, anchors) {
                var cx = txy[0] + (twh[0] / 2), cy = txy[1] + (twh[1] / 2);
                var minIdx = -1, minDist = Infinity;
                for (var i = 0; i < anchors.length; i++) {
                    var d = _distance(anchors[i], cx, cy, xy, wh);
                    if (d < minDist) {
                        minIdx = i + 0;
                        minDist = d;
                    }
                }
                return anchors[minIdx];
            };

        this.compute = function (params) {
            var xy = params.xy, wh = params.wh, txy = params.txy, twh = params.twh;

            this.timestamp = params.timestamp;

            var udl = self.getUserDefinedLocation();
            if (udl != null) {
                return udl;
            }

            // if anchor is locked or an opposite element was not given, we
            // maintain our state. anchor will be locked
            // if it is the source of a drag and drop.
            if (this.locked || txy == null || twh == null)
                return _curAnchor.compute(params);
            else
                params.timestamp = null; // otherwise clear this, i think. we want the anchor to compute.

            _curAnchor = _anchorSelector(xy, wh, txy, twh, this.anchors);
            this.x = _curAnchor.x;
            this.y = _curAnchor.y;

            if (_curAnchor != _lastAnchor)
                this.fire("anchorChanged", _curAnchor);

            _lastAnchor = _curAnchor;

            return _curAnchor.compute(params);
        };

        this.getCurrentLocation = function (params) {
            return this.getUserDefinedLocation() || (_curAnchor != null ? _curAnchor.getCurrentLocation(params) : null);
        };

        this.getOrientation = function (_endpoint) {
            return _curAnchor != null ? _curAnchor.getOrientation(_endpoint) : [ 0, 0 ];
        };
        this.over = function (anchor, endpoint) {
            if (_curAnchor != null) _curAnchor.over(anchor, endpoint);
        };
        this.out = function () {
            if (_curAnchor != null) _curAnchor.out();
        };

        this.getCssClass = function () {
            return (_curAnchor && _curAnchor.getCssClass()) || "";
        };
    };
    _ju.extend(_jp.DynamicAnchor, _jp.Anchor);

// -------- basic anchors ------------------    
    var _curryAnchor = function (x, y, ox, oy, type, fnInit) {
        _jp.Anchors[type] = function (params) {
            var a = params.jsPlumbInstance.makeAnchor([ x, y, ox, oy, 0, 0 ], params.elementId, params.jsPlumbInstance);
            a.type = type;
            if (fnInit) fnInit(a, params);
            return a;
        };
    };

    _curryAnchor(0.5, 0, 0, -1, "TopCenter");
    _curryAnchor(0.5, 1, 0, 1, "BottomCenter");
    _curryAnchor(0, 0.5, -1, 0, "LeftMiddle");
    _curryAnchor(1, 0.5, 1, 0, "RightMiddle");

    _curryAnchor(0.5, 0, 0, -1, "Top");
    _curryAnchor(0.5, 1, 0, 1, "Bottom");
    _curryAnchor(0, 0.5, -1, 0, "Left");
    _curryAnchor(1, 0.5, 1, 0, "Right");
    _curryAnchor(0.5, 0.5, 0, 0, "Center");
    _curryAnchor(1, 0, 0, -1, "TopRight");
    _curryAnchor(1, 1, 0, 1, "BottomRight");
    _curryAnchor(0, 0, 0, -1, "TopLeft");
    _curryAnchor(0, 1, 0, 1, "BottomLeft");

// ------- dynamic anchors -------------------    

    // default dynamic anchors chooses from Top, Right, Bottom, Left
    _jp.Defaults.DynamicAnchors = function (params) {
        return params.jsPlumbInstance.makeAnchors(["TopCenter", "RightMiddle", "BottomCenter", "LeftMiddle"], params.elementId, params.jsPlumbInstance);
    };

    // default dynamic anchors bound to name 'AutoDefault'
    _jp.Anchors.AutoDefault = function (params) {
        var a = params.jsPlumbInstance.makeDynamicAnchor(_jp.Defaults.DynamicAnchors(params));
        a.type = "AutoDefault";
        return a;
    };

// ------- continuous anchors -------------------    

    var _curryContinuousAnchor = function (type, faces) {
        _jp.Anchors[type] = function (params) {
            var a = params.jsPlumbInstance.makeAnchor(["Continuous", { faces: faces }], params.elementId, params.jsPlumbInstance);
            a.type = type;
            return a;
        };
    };

    _jp.Anchors.Continuous = function (params) {
        return params.jsPlumbInstance.continuousAnchorFactory.get(params);
    };

    _curryContinuousAnchor("ContinuousLeft", ["left"]);
    _curryContinuousAnchor("ContinuousTop", ["top"]);
    _curryContinuousAnchor("ContinuousBottom", ["bottom"]);
    _curryContinuousAnchor("ContinuousRight", ["right"]);

// ------- position assign anchors -------------------    

    // this anchor type lets you assign the position at connection time.
    _curryAnchor(0, 0, 0, 0, "Assign", function (anchor, params) {
        // find what to use as the "position finder". the user may have supplied a String which represents
        // the id of a position finder in jsPlumb.AnchorPositionFinders, or the user may have supplied the
        // position finder as a function.  we find out what to use and then set it on the anchor.
        var pf = params.position || "Fixed";
        anchor.positionFinder = pf.constructor == String ? params.jsPlumbInstance.AnchorPositionFinders[pf] : pf;
        // always set the constructor params; the position finder might need them later (the Grid one does,
        // for example)
        anchor.constructorParams = params;
    });

    // these are the default anchor positions finders, which are used by the makeTarget function.  supplying
    // a position finder argument to that function allows you to specify where the resulting anchor will
    // be located
    jsPlumbInstance.prototype.AnchorPositionFinders = {
        "Fixed": function (dp, ep, es) {
            return [ (dp.left - ep.left) / es[0], (dp.top - ep.top) / es[1] ];
        },
        "Grid": function (dp, ep, es, params) {
            var dx = dp.left - ep.left, dy = dp.top - ep.top,
                gx = es[0] / (params.grid[0]), gy = es[1] / (params.grid[1]),
                mx = Math.floor(dx / gx), my = Math.floor(dy / gy);
            return [ ((mx * gx) + (gx / 2)) / es[0], ((my * gy) + (gy / 2)) / es[1] ];
        }
    };

// ------- perimeter anchors -------------------    

    _jp.Anchors.Perimeter = function (params) {
        params = params || {};
        var anchorCount = params.anchorCount || 60,
            shape = params.shape;

        if (!shape) throw new Error("no shape supplied to Perimeter Anchor type");

        var _circle = function () {
                var r = 0.5, step = Math.PI * 2 / anchorCount, current = 0, a = [];
                for (var i = 0; i < anchorCount; i++) {
                    var x = r + (r * Math.sin(current)),
                        y = r + (r * Math.cos(current));
                    a.push([ x, y, 0, 0 ]);
                    current += step;
                }
                return a;
            },
            _path = function (segments) {
                var anchorsPerFace = anchorCount / segments.length, a = [],
                    _computeFace = function (x1, y1, x2, y2, fractionalLength) {
                        anchorsPerFace = anchorCount * fractionalLength;
                        var dx = (x2 - x1) / anchorsPerFace, dy = (y2 - y1) / anchorsPerFace;
                        for (var i = 0; i < anchorsPerFace; i++) {
                            a.push([
                                    x1 + (dx * i),
                                    y1 + (dy * i),
                                0,
                                0
                            ]);
                        }
                    };

                for (var i = 0; i < segments.length; i++)
                    _computeFace.apply(null, segments[i]);

                return a;
            },
            _shape = function (faces) {
                var s = [];
                for (var i = 0; i < faces.length; i++) {
                    s.push([faces[i][0], faces[i][1], faces[i][2], faces[i][3], 1 / faces.length]);
                }
                return _path(s);
            },
            _rectangle = function () {
                return _shape([
                    [ 0, 0, 1, 0 ],
                    [ 1, 0, 1, 1 ],
                    [ 1, 1, 0, 1 ],
                    [ 0, 1, 0, 0 ]
                ]);
            };

        var _shapes = {
                "Circle": _circle,
                "Ellipse": _circle,
                "Diamond": function () {
                    return _shape([
                        [ 0.5, 0, 1, 0.5 ],
                        [ 1, 0.5, 0.5, 1 ],
                        [ 0.5, 1, 0, 0.5 ],
                        [ 0, 0.5, 0.5, 0 ]
                    ]);
                },
                "Rectangle": _rectangle,
                "Square": _rectangle,
                "Triangle": function () {
                    return _shape([
                        [ 0.5, 0, 1, 1 ],
                        [ 1, 1, 0, 1 ],
                        [ 0, 1, 0.5, 0]
                    ]);
                },
                "Path": function (params) {
                    var points = params.points, p = [], tl = 0;
                    for (var i = 0; i < points.length - 1; i++) {
                        var l = Math.sqrt(Math.pow(points[i][2] - points[i][0]) + Math.pow(points[i][3] - points[i][1]));
                        tl += l;
                        p.push([points[i][0], points[i][1], points[i + 1][0], points[i + 1][1], l]);
                    }
                    for (var j = 0; j < p.length; j++) {
                        p[j][4] = p[j][4] / tl;
                    }
                    return _path(p);
                }
            },
            _rotate = function (points, amountInDegrees) {
                var o = [], theta = amountInDegrees / 180 * Math.PI;
                for (var i = 0; i < points.length; i++) {
                    var _x = points[i][0] - 0.5,
                        _y = points[i][1] - 0.5;

                    o.push([
                            0.5 + ((_x * Math.cos(theta)) - (_y * Math.sin(theta))),
                            0.5 + ((_x * Math.sin(theta)) + (_y * Math.cos(theta))),
                        points[i][2],
                        points[i][3]
                    ]);
                }
                return o;
            };

        if (!_shapes[shape]) throw new Error("Shape [" + shape + "] is unknown by Perimeter Anchor type");

        var da = _shapes[shape](params);
        if (params.rotation) da = _rotate(da, params.rotation);
        var a = params.jsPlumbInstance.makeDynamicAnchor(da);
        a.type = "Perimeter";
        return a;
    };
}).call(this);
/*
 * jsPlumb
 * 
 * Title:jsPlumb 2.0.2
 * 
 * Provides a way to visually connect elements on an HTML page, using SVG.
 * 
 * This file contains the default Connectors, Endpoint and Overlay definitions.
 *
 * Copyright (c) 2010 - 2015 jsPlumb (hello@jsplumbtoolkit.com)
 * 
 * http://jsplumbtoolkit.com
 * http://github.com/sporritt/jsplumb
 * 
 * Dual licensed under the MIT and GPL2 licenses.
 */
;
(function () {

    "use strict";
    var root = this, _jp = root.jsPlumb, _ju = root.jsPlumbUtil, _jg = root.Biltong;

    _jp.Segments = {

        /*
         * Class: AbstractSegment
         * A Connector is made up of 1..N Segments, each of which has a Type, such as 'Straight', 'Arc',
         * 'Bezier'. This is new from 1.4.2, and gives us a lot more flexibility when drawing connections: things such
         * as rounded corners for flowchart connectors, for example, or a straight line stub for Bezier connections, are
         * much easier to do now.
         *
         * A Segment is responsible for providing coordinates for painting it, and also must be able to report its length.
         * 
         */
        AbstractSegment: function (params) {
            this.params = params;

            /**
             * Function: findClosestPointOnPath
             * Finds the closest point on this segment to the given [x, y],
             * returning both the x and y of the point plus its distance from
             * the supplied point, and its location along the length of the
             * path inscribed by the segment.  This implementation returns
             * Infinity for distance and null values for everything else;
             * subclasses are expected to override.
             */
            this.findClosestPointOnPath = function (x, y) {
                return {
                    d: Infinity,
                    x: null,
                    y: null,
                    l: null
                };
            };

            this.getBounds = function () {
                return {
                    minX: Math.min(params.x1, params.x2),
                    minY: Math.min(params.y1, params.y2),
                    maxX: Math.max(params.x1, params.x2),
                    maxY: Math.max(params.y1, params.y2)
                };
            };
        },
        Straight: function (params) {
            var _super = _jp.Segments.AbstractSegment.apply(this, arguments),
                length, m, m2, x1, x2, y1, y2,
                _recalc = function () {
                    length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                    m = _jg.gradient({x: x1, y: y1}, {x: x2, y: y2});
                    m2 = -1 / m;
                };

            this.type = "Straight";

            this.getLength = function () {
                return length;
            };
            this.getGradient = function () {
                return m;
            };

            this.getCoordinates = function () {
                return { x1: x1, y1: y1, x2: x2, y2: y2 };
            };
            this.setCoordinates = function (coords) {
                x1 = coords.x1;
                y1 = coords.y1;
                x2 = coords.x2;
                y2 = coords.y2;
                _recalc();
            };
            this.setCoordinates({x1: params.x1, y1: params.y1, x2: params.x2, y2: params.y2});

            this.getBounds = function () {
                return {
                    minX: Math.min(x1, x2),
                    minY: Math.min(y1, y2),
                    maxX: Math.max(x1, x2),
                    maxY: Math.max(y1, y2)
                };
            };

            /**
             * returns the point on the segment's path that is 'location' along the length of the path, where 'location' is a decimal from
             * 0 to 1 inclusive. for the straight line segment this is simple maths.
             */
            this.pointOnPath = function (location, absolute) {
                if (location === 0 && !absolute)
                    return { x: x1, y: y1 };
                else if (location == 1 && !absolute)
                    return { x: x2, y: y2 };
                else {
                    var l = absolute ? location > 0 ? location : length + location : location * length;
                    return _jg.pointOnLine({x: x1, y: y1}, {x: x2, y: y2}, l);
                }
            };

            /**
             * returns the gradient of the segment at the given point - which for us is constant.
             */
            this.gradientAtPoint = function (_) {
                return m;
            };

            /**
             * returns the point on the segment's path that is 'distance' along the length of the path from 'location', where
             * 'location' is a decimal from 0 to 1 inclusive, and 'distance' is a number of pixels.
             * this hands off to jsPlumbUtil to do the maths, supplying two points and the distance.
             */
            this.pointAlongPathFrom = function (location, distance, absolute) {
                var p = this.pointOnPath(location, absolute),
                    farAwayPoint = distance <= 0 ? {x: x1, y: y1} : {x: x2, y: y2 };

                /*
                 location == 1 ? {
                 x:x1 + ((x2 - x1) * 10),
                 y:y1 + ((y1 - y2) * 10)
                 } :
                 */

                if (distance <= 0 && Math.abs(distance) > 1) distance *= -1;

                return _jg.pointOnLine(p, farAwayPoint, distance);
            };

            // is c between a and b?
            var within = function (a, b, c) {
                return c >= Math.min(a, b) && c <= Math.max(a, b);
            };
            // find which of a and b is closest to c
            var closest = function (a, b, c) {
                return Math.abs(c - a) < Math.abs(c - b) ? a : b;
            };

            /**
             Function: findClosestPointOnPath
             Finds the closest point on this segment to [x,y]. See
             notes on this method in AbstractSegment.
             */
            this.findClosestPointOnPath = function (x, y) {
                var out = {
                    d: Infinity,
                    x: null,
                    y: null,
                    l: null,
                    x1: x1,
                    x2: x2,
                    y1: y1,
                    y2: y2
                };

                if (m === 0) {
                    out.y = y1;
                    out.x = within(x1, x2, x) ? x : closest(x1, x2, x);
                }
                else if (m == Infinity || m == -Infinity) {
                    out.x = x1;
                    out.y = within(y1, y2, y) ? y : closest(y1, y2, y);
                }
                else {
                    // closest point lies on normal from given point to this line.  
                    var b = y1 - (m * x1),
                        b2 = y - (m2 * x),
                    // y1 = m.x1 + b and y1 = m2.x1 + b2
                    // so m.x1 + b = m2.x1 + b2
                    // x1(m - m2) = b2 - b
                    // x1 = (b2 - b) / (m - m2)
                        _x1 = (b2 - b) / (m - m2),
                        _y1 = (m * _x1) + b;

                    out.x = within(x1, x2, _x1) ? _x1 : closest(x1, x2, _x1);//_x1;
                    out.y = within(y1, y2, _y1) ? _y1 : closest(y1, y2, _y1);//_y1;
                }

                var fractionInSegment = _jg.lineLength([ out.x, out.y ], [ x1, y1 ]);
                out.d = _jg.lineLength([x, y], [out.x, out.y]);
                out.l = fractionInSegment / length;
                return out;
            };
        },

        /*
         Arc Segment. You need to supply:

         r   -   radius
         cx  -   center x for the arc
         cy  -   center y for the arc
         ac  -   whether the arc is anticlockwise or not. default is clockwise.

         and then either:

         startAngle  -   startAngle for the arc.
         endAngle    -   endAngle for the arc.

         or:

         x1          -   x for start point
         y1          -   y for start point
         x2          -   x for end point
         y2          -   y for end point

         */
        Arc: function (params) {
            var _super = _jp.Segments.AbstractSegment.apply(this, arguments),
                _calcAngle = function (_x, _y) {
                    return _jg.theta([params.cx, params.cy], [_x, _y]);
                },
                _calcAngleForLocation = function (segment, location) {
                    if (segment.anticlockwise) {
                        var sa = segment.startAngle < segment.endAngle ? segment.startAngle + TWO_PI : segment.startAngle,
                            s = Math.abs(sa - segment.endAngle);
                        return sa - (s * location);
                    }
                    else {
                        var ea = segment.endAngle < segment.startAngle ? segment.endAngle + TWO_PI : segment.endAngle,
                            ss = Math.abs(ea - segment.startAngle);

                        return segment.startAngle + (ss * location);
                    }
                },
                TWO_PI = 2 * Math.PI;

            this.radius = params.r;
            this.anticlockwise = params.ac;
            this.type = "Arc";

            if (params.startAngle && params.endAngle) {
                this.startAngle = params.startAngle;
                this.endAngle = params.endAngle;
                this.x1 = params.cx + (this.radius * Math.cos(params.startAngle));
                this.y1 = params.cy + (this.radius * Math.sin(params.startAngle));
                this.x2 = params.cx + (this.radius * Math.cos(params.endAngle));
                this.y2 = params.cy + (this.radius * Math.sin(params.endAngle));
            }
            else {
                this.startAngle = _calcAngle(params.x1, params.y1);
                this.endAngle = _calcAngle(params.x2, params.y2);
                this.x1 = params.x1;
                this.y1 = params.y1;
                this.x2 = params.x2;
                this.y2 = params.y2;
            }

            if (this.endAngle < 0) this.endAngle += TWO_PI;
            if (this.startAngle < 0) this.startAngle += TWO_PI;

            // segment is used by vml     
            //this.segment = _jg.quadrant([this.x1, this.y1], [this.x2, this.y2]);

            // we now have startAngle and endAngle as positive numbers, meaning the
            // absolute difference (|d|) between them is the sweep (s) of this arc, unless the
            // arc is 'anticlockwise' in which case 's' is given by 2PI - |d|.

            var ea = this.endAngle < this.startAngle ? this.endAngle + TWO_PI : this.endAngle;
            this.sweep = Math.abs(ea - this.startAngle);
            if (this.anticlockwise) this.sweep = TWO_PI - this.sweep;
            var circumference = 2 * Math.PI * this.radius,
                frac = this.sweep / TWO_PI,
                length = circumference * frac;

            this.getLength = function () {
                return length;
            };

            this.getBounds = function () {
                return {
                    minX: params.cx - params.r,
                    maxX: params.cx + params.r,
                    minY: params.cy - params.r,
                    maxY: params.cy + params.r
                };
            };

            var VERY_SMALL_VALUE = 0.0000000001,
                gentleRound = function (n) {
                    var f = Math.floor(n), r = Math.ceil(n);
                    if (n - f < VERY_SMALL_VALUE)
                        return f;
                    else if (r - n < VERY_SMALL_VALUE)
                        return r;
                    return n;
                };

            /**
             * returns the point on the segment's path that is 'location' along the length of the path, where 'location' is a decimal from
             * 0 to 1 inclusive.
             */
            this.pointOnPath = function (location, absolute) {

                if (location === 0) {
                    return { x: this.x1, y: this.y1, theta: this.startAngle };
                }
                else if (location == 1) {
                    return { x: this.x2, y: this.y2, theta: this.endAngle };
                }

                if (absolute) {
                    location = location / length;
                }

                var angle = _calcAngleForLocation(this, location),
                    _x = params.cx + (params.r * Math.cos(angle)),
                    _y = params.cy + (params.r * Math.sin(angle));

                return { x: gentleRound(_x), y: gentleRound(_y), theta: angle };
            };

            /**
             * returns the gradient of the segment at the given point.
             */
            this.gradientAtPoint = function (location, absolute) {
                var p = this.pointOnPath(location, absolute);
                var m = _jg.normal([ params.cx, params.cy ], [p.x, p.y ]);
                if (!this.anticlockwise && (m == Infinity || m == -Infinity)) m *= -1;
                return m;
            };

            this.pointAlongPathFrom = function (location, distance, absolute) {
                var p = this.pointOnPath(location, absolute),
                    arcSpan = distance / circumference * 2 * Math.PI,
                    dir = this.anticlockwise ? -1 : 1,
                    startAngle = p.theta + (dir * arcSpan),
                    startX = params.cx + (this.radius * Math.cos(startAngle)),
                    startY = params.cy + (this.radius * Math.sin(startAngle));

                return {x: startX, y: startY};
            };
        },

        Bezier: function (params) {
            this.curve = [
                { x: params.x1, y: params.y1},
                { x: params.cp1x, y: params.cp1y },
                { x: params.cp2x, y: params.cp2y },
                { x: params.x2, y: params.y2 }
            ];

            var _super = _jp.Segments.AbstractSegment.apply(this, arguments);
            // although this is not a strictly rigorous determination of bounds
            // of a bezier curve, it works for the types of curves that this segment
            // type produces.
            this.bounds = {
                minX: Math.min(params.x1, params.x2, params.cp1x, params.cp2x),
                minY: Math.min(params.y1, params.y2, params.cp1y, params.cp2y),
                maxX: Math.max(params.x1, params.x2, params.cp1x, params.cp2x),
                maxY: Math.max(params.y1, params.y2, params.cp1y, params.cp2y)
            };

            this.type = "Bezier";

            var _translateLocation = function (_curve, location, absolute) {
                if (absolute)
                    location = root.jsBezier.locationAlongCurveFrom(_curve, location > 0 ? 0 : 1, location);

                return location;
            };

            /**
             * returns the point on the segment's path that is 'location' along the length of the path, where 'location' is a decimal from
             * 0 to 1 inclusive.
             */
            this.pointOnPath = function (location, absolute) {
                location = _translateLocation(this.curve, location, absolute);
                return root.jsBezier.pointOnCurve(this.curve, location);
            };

            /**
             * returns the gradient of the segment at the given point.
             */
            this.gradientAtPoint = function (location, absolute) {
                location = _translateLocation(this.curve, location, absolute);
                return root.jsBezier.gradientAtPoint(this.curve, location);
            };

            this.pointAlongPathFrom = function (location, distance, absolute) {
                location = _translateLocation(this.curve, location, absolute);
                return root.jsBezier.pointAlongCurveFrom(this.curve, location, distance);
            };

            this.getLength = function () {
                return root.jsBezier.getLength(this.curve);
            };

            this.getBounds = function () {
                return this.bounds;
            };
        }
    };

    /*
     Class: AbstractComponent
     Superclass for AbstractConnector and AbstractEndpoint.
     */
    var AbstractComponent = function () {
        this.resetBounds = function () {
            this.bounds = { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity };
        };
        this.resetBounds();
    };

    /*
     * Class: AbstractConnector
     * Superclass for all Connectors; here is where Segments are managed.  This is exposed on jsPlumb just so it
     * can be accessed from other files. You should not try to instantiate one of these directly.
     *
     * When this class is asked for a pointOnPath, or gradient etc, it must first figure out which segment to dispatch
     * that request to. This is done by keeping track of the total connector length as segments are added, and also
     * their cumulative ratios to the total length.  Then when the right segment is found it is a simple case of dispatching
     * the request to it (and adjusting 'location' so that it is relative to the beginning of that segment.)
     */
    _jp.Connectors.AbstractConnector = function (params) {

        AbstractComponent.apply(this, arguments);

        var segments = [],
            totalLength = 0,
            segmentProportions = [],
            segmentProportionalLengths = [],
            stub = params.stub || 0,
            sourceStub = _ju.isArray(stub) ? stub[0] : stub,
            targetStub = _ju.isArray(stub) ? stub[1] : stub,
            gap = params.gap || 0,
            sourceGap = _ju.isArray(gap) ? gap[0] : gap,
            targetGap = _ju.isArray(gap) ? gap[1] : gap,
            userProvidedSegments = null,
            edited = false,
            paintInfo = null;

        // to be overridden by subclasses.
        this.getPath = function () {
        };
        this.setPath = function (path) {
        };

        /**
         * Function: findSegmentForPoint
         * Returns the segment that is closest to the given [x,y],
         * null if nothing found.  This function returns a JS
         * object with:
         *
         *   d   -   distance from segment
         *   l   -   proportional location in segment
         *   x   -   x point on the segment
         *   y   -   y point on the segment
         *   s   -   the segment itself.
         */
        this.findSegmentForPoint = function (x, y) {
            var out = { d: Infinity, s: null, x: null, y: null, l: null };
            for (var i = 0; i < segments.length; i++) {
                var _s = segments[i].findClosestPointOnPath(x, y);
                if (_s.d < out.d) {
                    out.d = _s.d;
                    out.l = _s.l;
                    out.x = _s.x;
                    out.y = _s.y;
                    out.s = segments[i];
                    out.x1 = _s.x1;
                    out.x2 = _s.x2;
                    out.y1 = _s.y1;
                    out.y2 = _s.y2;
                    out.index = i;
                }
            }

            return out;
        };

        var _updateSegmentProportions = function () {
                var curLoc = 0;
                for (var i = 0; i < segments.length; i++) {
                    var sl = segments[i].getLength();
                    segmentProportionalLengths[i] = sl / totalLength;
                    segmentProportions[i] = [curLoc, (curLoc += (sl / totalLength)) ];
                }
            },

            /**
             * returns [segment, proportion of travel in segment, segment index] for the segment
             * that contains the point which is 'location' distance along the entire path, where
             * 'location' is a decimal between 0 and 1 inclusive. in this connector type, paths
             * are made up of a list of segments, each of which contributes some fraction to
             * the total length.
             * From 1.3.10 this also supports the 'absolute' property, which lets us specify a location
             * as the absolute distance in pixels, rather than a proportion of the total path.
             */
            _findSegmentForLocation = function (location, absolute) {
                if (absolute) {
                    location = location > 0 ? location / totalLength : (totalLength + location) / totalLength;
                }
                var idx = segmentProportions.length - 1, inSegmentProportion = 1;
                for (var i = 0; i < segmentProportions.length; i++) {
                    if (segmentProportions[i][1] >= location) {
                        idx = i;
                        // todo is this correct for all connector path types?
                        inSegmentProportion = location == 1 ? 1 : location === 0 ? 0 : (location - segmentProportions[i][0]) / segmentProportionalLengths[i];
                        break;
                    }
                }
                return { segment: segments[idx], proportion: inSegmentProportion, index: idx };
            },
            _addSegment = function (conn, type, params) {
                if (params.x1 == params.x2 && params.y1 == params.y2) return;
                var s = new _jp.Segments[type](params);
                segments.push(s);
                totalLength += s.getLength();
                conn.updateBounds(s);
            },
            _clearSegments = function () {
                totalLength = segments.length = segmentProportions.length = segmentProportionalLengths.length = 0;
            };

        this.setSegments = function (_segs) {
            userProvidedSegments = [];
            totalLength = 0;
            for (var i = 0; i < _segs.length; i++) {
                userProvidedSegments.push(_segs[i]);
                totalLength += _segs[i].getLength();
            }
        };

        this.getLength = function() {
            return totalLength;
        };

        var _prepareCompute = function (params) {
            this.lineWidth = params.lineWidth;
            var segment = _jg.quadrant(params.sourcePos, params.targetPos),
                swapX = params.targetPos[0] < params.sourcePos[0],
                swapY = params.targetPos[1] < params.sourcePos[1],
                lw = params.lineWidth || 1,
                so = params.sourceEndpoint.anchor.getOrientation(params.sourceEndpoint),
                to = params.targetEndpoint.anchor.getOrientation(params.targetEndpoint),
                x = swapX ? params.targetPos[0] : params.sourcePos[0],
                y = swapY ? params.targetPos[1] : params.sourcePos[1],
                w = Math.abs(params.targetPos[0] - params.sourcePos[0]),
                h = Math.abs(params.targetPos[1] - params.sourcePos[1]);

            // if either anchor does not have an orientation set, we derive one from their relative
            // positions.  we fix the axis to be the one in which the two elements are further apart, and
            // point each anchor at the other element.  this is also used when dragging a new connection.
            if (so[0] === 0 && so[1] === 0 || to[0] === 0 && to[1] === 0) {
                var index = w > h ? 0 : 1, oIndex = [1, 0][index];
                so = [];
                to = [];
                so[index] = params.sourcePos[index] > params.targetPos[index] ? -1 : 1;
                to[index] = params.sourcePos[index] > params.targetPos[index] ? 1 : -1;
                so[oIndex] = 0;
                to[oIndex] = 0;
            }

            var sx = swapX ? w + (sourceGap * so[0]) : sourceGap * so[0],
                sy = swapY ? h + (sourceGap * so[1]) : sourceGap * so[1],
                tx = swapX ? targetGap * to[0] : w + (targetGap * to[0]),
                ty = swapY ? targetGap * to[1] : h + (targetGap * to[1]),
                oProduct = ((so[0] * to[0]) + (so[1] * to[1]));

            var result = {
                sx: sx, sy: sy, tx: tx, ty: ty, lw: lw,
                xSpan: Math.abs(tx - sx),
                ySpan: Math.abs(ty - sy),
                mx: (sx + tx) / 2,
                my: (sy + ty) / 2,
                so: so, to: to, x: x, y: y, w: w, h: h,
                segment: segment,
                startStubX: sx + (so[0] * sourceStub),
                startStubY: sy + (so[1] * sourceStub),
                endStubX: tx + (to[0] * targetStub),
                endStubY: ty + (to[1] * targetStub),
                isXGreaterThanStubTimes2: Math.abs(sx - tx) > (sourceStub + targetStub),
                isYGreaterThanStubTimes2: Math.abs(sy - ty) > (sourceStub + targetStub),
                opposite: oProduct == -1,
                perpendicular: oProduct === 0,
                orthogonal: oProduct == 1,
                sourceAxis: so[0] === 0 ? "y" : "x",
                points: [x, y, w, h, sx, sy, tx, ty ]
            };
            result.anchorOrientation = result.opposite ? "opposite" : result.orthogonal ? "orthogonal" : "perpendicular";
            return result;
        };

        this.getSegments = function () {
            return segments;
        };

        this.updateBounds = function (segment) {
            var segBounds = segment.getBounds();
            this.bounds.minX = Math.min(this.bounds.minX, segBounds.minX);
            this.bounds.maxX = Math.max(this.bounds.maxX, segBounds.maxX);
            this.bounds.minY = Math.min(this.bounds.minY, segBounds.minY);
            this.bounds.maxY = Math.max(this.bounds.maxY, segBounds.maxY);
        };

        var dumpSegmentsToConsole = function () {
            console.log("SEGMENTS:");
            for (var i = 0; i < segments.length; i++) {
                console.log(segments[i].type, segments[i].getLength(), segmentProportions[i]);
            }
        };

        this.pointOnPath = function (location, absolute) {
            var seg = _findSegmentForLocation(location, absolute);
            return seg.segment && seg.segment.pointOnPath(seg.proportion, false) || [0, 0];
        };

        this.gradientAtPoint = function (location, absolute) {
            var seg = _findSegmentForLocation(location, absolute);
            return seg.segment && seg.segment.gradientAtPoint(seg.proportion, false) || 0;
        };

        this.pointAlongPathFrom = function (location, distance, absolute) {
            var seg = _findSegmentForLocation(location, absolute);
            // TODO what happens if this crosses to the next segment?
            return seg.segment && seg.segment.pointAlongPathFrom(seg.proportion, distance, false) || [0, 0];
        };

        this.compute = function (params) {
            if (!edited)
                paintInfo = _prepareCompute.call(this, params);

            _clearSegments();
            this._compute(paintInfo, params);
            this.x = paintInfo.points[0];
            this.y = paintInfo.points[1];
            this.w = paintInfo.points[2];
            this.h = paintInfo.points[3];
            this.segment = paintInfo.segment;
            _updateSegmentProportions();
        };

        return {
            addSegment: _addSegment,
            prepareCompute: _prepareCompute,
            sourceStub: sourceStub,
            targetStub: targetStub,
            maxStub: Math.max(sourceStub, targetStub),
            sourceGap: sourceGap,
            targetGap: targetGap,
            maxGap: Math.max(sourceGap, targetGap)
        };
    };
    _ju.extend(_jp.Connectors.AbstractConnector, AbstractComponent);

    /**
     * Class: Connectors.Straight
     * The Straight connector draws a simple straight line between the two anchor points.  It does not have any constructor parameters.
     */
    var Straight = _jp.Connectors.Straight = function () {
        this.type = "Straight";
        var _super = _jp.Connectors.AbstractConnector.apply(this, arguments);

        this._compute = function (paintInfo, _) {
            _super.addSegment(this, "Straight", {x1: paintInfo.sx, y1: paintInfo.sy, x2: paintInfo.startStubX, y2: paintInfo.startStubY});
            _super.addSegment(this, "Straight", {x1: paintInfo.startStubX, y1: paintInfo.startStubY, x2: paintInfo.endStubX, y2: paintInfo.endStubY});
            _super.addSegment(this, "Straight", {x1: paintInfo.endStubX, y1: paintInfo.endStubY, x2: paintInfo.tx, y2: paintInfo.ty});
        };
    };
    _ju.extend(_jp.Connectors.Straight, _jp.Connectors.AbstractConnector);
    _jp.registerConnectorType(Straight, "Straight");


    // ********************************* END OF CONNECTOR TYPES *******************************************************************

    // ********************************* ENDPOINT TYPES *******************************************************************

    _jp.Endpoints.AbstractEndpoint = function (params) {
        AbstractComponent.apply(this, arguments);
        var compute = this.compute = function (anchorPoint, orientation, endpointStyle, connectorPaintStyle) {
            var out = this._compute.apply(this, arguments);
            this.x = out[0];
            this.y = out[1];
            this.w = out[2];
            this.h = out[3];
            this.bounds.minX = this.x;
            this.bounds.minY = this.y;
            this.bounds.maxX = this.x + this.w;
            this.bounds.maxY = this.y + this.h;
            return out;
        };
        return {
            compute: compute,
            cssClass: params.cssClass
        };
    };
    _ju.extend(_jp.Endpoints.AbstractEndpoint, AbstractComponent);

    /**
     * Class: Endpoints.Dot
     * A round endpoint, with default radius 10 pixels.
     */

    /**
     * Function: Constructor
     *
     * Parameters:
     *
     *    radius    -    radius of the endpoint.  defaults to 10 pixels.
     */
    _jp.Endpoints.Dot = function (params) {
        this.type = "Dot";
        var _super = _jp.Endpoints.AbstractEndpoint.apply(this, arguments);
        params = params || {};
        this.radius = params.radius || 10;
        this.defaultOffset = 0.5 * this.radius;
        this.defaultInnerRadius = this.radius / 3;

        this._compute = function (anchorPoint, orientation, endpointStyle, connectorPaintStyle) {
            this.radius = endpointStyle.radius || this.radius;
            var x = anchorPoint[0] - this.radius,
                y = anchorPoint[1] - this.radius,
                w = this.radius * 2,
                h = this.radius * 2;

            if (endpointStyle.strokeStyle) {
                var lw = endpointStyle.lineWidth || 1;
                x -= lw;
                y -= lw;
                w += (lw * 2);
                h += (lw * 2);
            }
            return [ x, y, w, h, this.radius ];
        };
    };
    _ju.extend(_jp.Endpoints.Dot, _jp.Endpoints.AbstractEndpoint);

    _jp.Endpoints.Rectangle = function (params) {
        this.type = "Rectangle";
        var _super = _jp.Endpoints.AbstractEndpoint.apply(this, arguments);
        params = params || {};
        this.width = params.width || 20;
        this.height = params.height || 20;

        this._compute = function (anchorPoint, orientation, endpointStyle, connectorPaintStyle) {
            var width = endpointStyle.width || this.width,
                height = endpointStyle.height || this.height,
                x = anchorPoint[0] - (width / 2),
                y = anchorPoint[1] - (height / 2);

            return [ x, y, width, height];
        };
    };
    _ju.extend(_jp.Endpoints.Rectangle, _jp.Endpoints.AbstractEndpoint);

    var DOMElementEndpoint = function (params) {
        _jp.jsPlumbUIComponent.apply(this, arguments);
        this._jsPlumb.displayElements = [];
    };
    _ju.extend(DOMElementEndpoint, _jp.jsPlumbUIComponent, {
        getDisplayElements: function () {
            return this._jsPlumb.displayElements;
        },
        appendDisplayElement: function (el) {
            this._jsPlumb.displayElements.push(el);
        }
    });

    /**
     * Class: Endpoints.Image
     * Draws an image as the Endpoint.
     */
    /**
     * Function: Constructor
     *
     * Parameters:
     *
     *    src    -    location of the image to use.

     TODO: multiple references to self. not sure quite how to get rid of them entirely. perhaps self = null in the cleanup
     function will suffice

     TODO this class still might leak memory.

     */
    _jp.Endpoints.Image = function (params) {

        this.type = "Image";
        DOMElementEndpoint.apply(this, arguments);
        _jp.Endpoints.AbstractEndpoint.apply(this, arguments);

        var _onload = params.onload,
            src = params.src || params.url,
            clazz = params.cssClass ? " " + params.cssClass : "";

        this._jsPlumb.img = new Image();
        this._jsPlumb.ready = false;
        this._jsPlumb.initialized = false;
        this._jsPlumb.deleted = false;
        this._jsPlumb.widthToUse = params.width;
        this._jsPlumb.heightToUse = params.height;
        this._jsPlumb.endpoint = params.endpoint;

        this._jsPlumb.img.onload = function () {
            if (this._jsPlumb != null) {
                this._jsPlumb.ready = true;
                this._jsPlumb.widthToUse = this._jsPlumb.widthToUse || this._jsPlumb.img.width;
                this._jsPlumb.heightToUse = this._jsPlumb.heightToUse || this._jsPlumb.img.height;
                if (_onload) {
                    _onload(this);
                }
            }
        }.bind(this);

        /*
         Function: setImage
         Sets the Image to use in this Endpoint.

         Parameters:
         img         -   may be a URL or an Image object
         onload      -   optional; a callback to execute once the image has loaded.
         */
        this._jsPlumb.endpoint.setImage = function (_img, onload) {
            var s = _img.constructor == String ? _img : _img.src;
            _onload = onload;
            this._jsPlumb.img.src = s;

            if (this.canvas != null)
                this.canvas.setAttribute("src", this._jsPlumb.img.src);
        }.bind(this);

        this._jsPlumb.endpoint.setImage(src, _onload);
        this._compute = function (anchorPoint, orientation, endpointStyle, connectorPaintStyle) {
            this.anchorPoint = anchorPoint;
            if (this._jsPlumb.ready) return [anchorPoint[0] - this._jsPlumb.widthToUse / 2, anchorPoint[1] - this._jsPlumb.heightToUse / 2,
                this._jsPlumb.widthToUse, this._jsPlumb.heightToUse];
            else return [0, 0, 0, 0];
        };

        this.canvas = jsPlumb.createElement("img", {
            position:"absolute",
            margin:0,
            padding:0,
            outline:0
        }, this._jsPlumb.instance.endpointClass + clazz);

        if (this._jsPlumb.widthToUse) this.canvas.setAttribute("width", this._jsPlumb.widthToUse);
        if (this._jsPlumb.heightToUse) this.canvas.setAttribute("height", this._jsPlumb.heightToUse);
        this._jsPlumb.instance.appendElement(this.canvas);

        this.actuallyPaint = function (d, style, anchor) {
            if (!this._jsPlumb.deleted) {
                if (!this._jsPlumb.initialized) {
                    this.canvas.setAttribute("src", this._jsPlumb.img.src);
                    this.appendDisplayElement(this.canvas);
                    this._jsPlumb.initialized = true;
                }
                var x = this.anchorPoint[0] - (this._jsPlumb.widthToUse / 2),
                    y = this.anchorPoint[1] - (this._jsPlumb.heightToUse / 2);
                _ju.sizeElement(this.canvas, x, y, this._jsPlumb.widthToUse, this._jsPlumb.heightToUse);
            }
        };

        this.paint = function (style, anchor) {
            if (this._jsPlumb != null) {  // may have been deleted
                if (this._jsPlumb.ready) {
                    this.actuallyPaint(style, anchor);
                }
                else {
                    root.setTimeout(function () {
                        this.paint(style, anchor);
                    }.bind(this), 200);
                }
            }
        };
    };
    _ju.extend(_jp.Endpoints.Image, [ DOMElementEndpoint, _jp.Endpoints.AbstractEndpoint ], {
        cleanup: function (force) {
            if (force) {
                this._jsPlumb.deleted = true;
                if (this.canvas) this.canvas.parentNode.removeChild(this.canvas);
                this.canvas = null;
            }
        }
    });

    /*
     * Class: Endpoints.Blank
     * An Endpoint that paints nothing (visible) on the screen.  Supports cssClass and hoverClass parameters like all Endpoints.
     */
    _jp.Endpoints.Blank = function (params) {
        var _super = _jp.Endpoints.AbstractEndpoint.apply(this, arguments);
        this.type = "Blank";
        DOMElementEndpoint.apply(this, arguments);
        this._compute = function (anchorPoint, orientation, endpointStyle, connectorPaintStyle) {
            return [anchorPoint[0], anchorPoint[1], 10, 0];
        };

        var clazz = params.cssClass ? " " + params.cssClass : "";

        this.canvas = jsPlumb.createElement("div", {
            display: "block",
            width: "1px",
            height: "1px",
            background: "transparent",
            position: "absolute"
        }, this._jsPlumb.instance.endpointClass + clazz);

        this._jsPlumb.instance.appendElement(this.canvas);

        this.paint = function (style, anchor) {
            _ju.sizeElement(this.canvas, this.x, this.y, this.w, this.h);
        };
    };
    _ju.extend(_jp.Endpoints.Blank, [_jp.Endpoints.AbstractEndpoint, DOMElementEndpoint], {
        cleanup: function () {
            if (this.canvas && this.canvas.parentNode) {
                this.canvas.parentNode.removeChild(this.canvas);
            }
        }
    });

    /*
     * Class: Endpoints.Triangle
     * A triangular Endpoint.
     */
    /*
     * Function: Constructor
     *
     * Parameters:
     *
     * 	width	-	width of the triangle's base.  defaults to 55 pixels.
     * 	height	-	height of the triangle from base to apex.  defaults to 55 pixels.
     */
    _jp.Endpoints.Triangle = function (params) {
        this.type = "Triangle";
        _jp.Endpoints.AbstractEndpoint.apply(this, arguments);
        params = params || {  };
        params.width = params.width || 55;
        params.height = params.height || 55;
        this.width = params.width;
        this.height = params.height;
        this._compute = function (anchorPoint, orientation, endpointStyle, connectorPaintStyle) {
            var width = endpointStyle.width || self.width,
                height = endpointStyle.height || self.height,
                x = anchorPoint[0] - (width / 2),
                y = anchorPoint[1] - (height / 2);
            return [ x, y, width, height ];
        };
    };
// ********************************* END OF ENDPOINT TYPES *******************************************************************


// ********************************* OVERLAY DEFINITIONS ***********************************************************************    

    var AbstractOverlay = _jp.Overlays.AbstractOverlay = function (params) {
        this.visible = true;
        this.isAppendedAtTopLevel = true;
        this.component = params.component;
        this.loc = params.location == null ? 0.5 : params.location;
        this.endpointLoc = params.endpointLocation == null ? [ 0.5, 0.5] : params.endpointLocation;
    };
    AbstractOverlay.prototype = {
        cleanup: function (force) {
            if (force) {
                this.component = null;
                this.canvas = null;
                this.endpointLoc = null;
            }
        },
        reattach:function(instance) {

        },
        setVisible: function (val) {
            this.visible = val;
            this.component.repaint();
        },
        isVisible: function () {
            return this.visible;
        },
        hide: function () {
            this.setVisible(false);
        },
        show: function () {
            this.setVisible(true);
        },
        incrementLocation: function (amount) {
            this.loc += amount;
            this.component.repaint();
        },
        setLocation: function (l) {
            this.loc = l;
            this.component.repaint();
        },
        getLocation: function () {
            return this.loc;
        },
        updateFrom:function() { }
    };


    /*
     * Class: Overlays.Arrow
     *
     * An arrow overlay, defined by four points: the head, the two sides of the tail, and a 'foldback' point at some distance along the length
     * of the arrow that lines from each tail point converge into.  The foldback point is defined using a decimal that indicates some fraction
     * of the length of the arrow and has a default value of 0.623.  A foldback point value of 1 would mean that the arrow had a straight line
     * across the tail.
     */
    /*
     * Function: Constructor
     *
     * Parameters:
     *
     * 	length - distance in pixels from head to tail baseline. default 20.
     * 	width - width in pixels of the tail baseline. default 20.
     * 	fillStyle - style to use when filling the arrow.  defaults to "black".
     * 	strokeStyle - style to use when stroking the arrow. defaults to null, which means the arrow is not stroked.
     * 	lineWidth - line width to use when stroking the arrow. defaults to 1, but only used if strokeStyle is not null.
     * 	foldback - distance (as a decimal from 0 to 1 inclusive) along the length of the arrow marking the point the tail points should fold back to.  defaults to 0.623.
     * 	location - distance (as a decimal from 0 to 1 inclusive) marking where the arrow should sit on the connector. defaults to 0.5.
     * 	direction - indicates the direction the arrow points in. valid values are -1 and 1; 1 is default.
     */
    _jp.Overlays.Arrow = function (params) {
        this.type = "Arrow";
        AbstractOverlay.apply(this, arguments);
        this.isAppendedAtTopLevel = false;
        params = params || {};

        this.length = params.length || 20;
        this.width = params.width || 20;
        this.id = params.id;
        var direction = (params.direction || 1) < 0 ? -1 : 1,
            paintStyle = params.paintStyle || { lineWidth: 1 },
        // how far along the arrow the lines folding back in come to. default is 62.3%.
            foldback = params.foldback || 0.623;

        this.computeMaxSize = function () {
            return self.width * 1.5;
        };

        this.draw = function (component, currentConnectionPaintStyle) {

            var hxy, mid, txy, tail, cxy;
            if (component.pointAlongPathFrom) {

                if (_ju.isString(this.loc) || this.loc > 1 || this.loc < 0) {
                    var l = parseInt(this.loc, 10),
                        fromLoc = this.loc < 0 ? 1 : 0;
                    hxy = component.pointAlongPathFrom(fromLoc, l, false);
                    mid = component.pointAlongPathFrom(fromLoc, l - (direction * this.length / 2), false);
                    txy = _jg.pointOnLine(hxy, mid, this.length);
                }
                else if (this.loc == 1) {
                    hxy = component.pointOnPath(this.loc);
                    mid = component.pointAlongPathFrom(this.loc, -(this.length));
                    txy = _jg.pointOnLine(hxy, mid, this.length);

                    if (direction == -1) {
                        var _ = txy;
                        txy = hxy;
                        hxy = _;
                    }
                }
                else if (this.loc === 0) {
                    txy = component.pointOnPath(this.loc);
                    mid = component.pointAlongPathFrom(this.loc, this.length);
                    hxy = _jg.pointOnLine(txy, mid, this.length);
                    if (direction == -1) {
                        var __ = txy;
                        txy = hxy;
                        hxy = __;
                    }
                }
                else {
                    hxy = component.pointAlongPathFrom(this.loc, direction * this.length / 2);
                    mid = component.pointOnPath(this.loc);
                    txy = _jg.pointOnLine(hxy, mid, this.length);
                }

                tail = _jg.perpendicularLineTo(hxy, txy, this.width);
                cxy = _jg.pointOnLine(hxy, txy, foldback * this.length);

                var d = { hxy: hxy, tail: tail, cxy: cxy },
                    strokeStyle = paintStyle.strokeStyle || currentConnectionPaintStyle.strokeStyle,
                    fillStyle = paintStyle.fillStyle || currentConnectionPaintStyle.strokeStyle,
                    lineWidth = paintStyle.lineWidth || currentConnectionPaintStyle.lineWidth;

                return {
                    component: component,
                    d: d,
                    lineWidth: lineWidth,
                    strokeStyle: strokeStyle,
                    fillStyle: fillStyle,
                    minX: Math.min(hxy.x, tail[0].x, tail[1].x),
                    maxX: Math.max(hxy.x, tail[0].x, tail[1].x),
                    minY: Math.min(hxy.y, tail[0].y, tail[1].y),
                    maxY: Math.max(hxy.y, tail[0].y, tail[1].y)
                };
            }
            else return {component: component, minX: 0, maxX: 0, minY: 0, maxY: 0};
        };
    };
    _ju.extend(_jp.Overlays.Arrow, AbstractOverlay, {
        updateFrom:function(d) {
            this.length = d.length || this.length;
            this.width = d.width|| this.width;
            this.direction = d.direction != null ? d.direction : this.direction;
            this.foldback = d.foldback|| this.foldback;
        }
    });

    /*
     * Class: Overlays.PlainArrow
     *
     * A basic arrow.  This is in fact just one instance of the more generic case in which the tail folds back on itself to some
     * point along the length of the arrow: in this case, that foldback point is the full length of the arrow.  so it just does
     * a 'call' to Arrow with foldback set appropriately.
     */
    /*
     * Function: Constructor
     * See <Overlays.Arrow> for allowed parameters for this overlay.
     */
    _jp.Overlays.PlainArrow = function (params) {
        params = params || {};
        var p = _jp.extend(params, {foldback: 1});
        _jp.Overlays.Arrow.call(this, p);
        this.type = "PlainArrow";
    };
    _ju.extend(_jp.Overlays.PlainArrow, _jp.Overlays.Arrow);

    /*
     * Class: Overlays.Diamond
     * 
     * A diamond. Like PlainArrow, this is a concrete case of the more generic case of the tail points converging on some point...it just
     * happens that in this case, that point is greater than the length of the the arrow.
     *
     *      this could probably do with some help with positioning...due to the way it reuses the Arrow paint code, what Arrow thinks is the
     *      center is actually 1/4 of the way along for this guy.  but we don't have any knowledge of pixels at this point, so we're kind of
     *      stuck when it comes to helping out the Arrow class. possibly we could pass in a 'transpose' parameter or something. the value
     *      would be -l/4 in this case - move along one quarter of the total length.
     */
    /*
     * Function: Constructor
     * See <Overlays.Arrow> for allowed parameters for this overlay.
     */
    _jp.Overlays.Diamond = function (params) {
        params = params || {};
        var l = params.length || 40,
            p = jsPlumb.extend(params, {length: l / 2, foldback: 2});
        _jp.Overlays.Arrow.call(this, p);
        this.type = "Diamond";
    };
    _ju.extend(_jp.Overlays.Diamond, _jp.Overlays.Arrow);

    var _getDimensions = function (component, forceRefresh) {
        if (component._jsPlumb.cachedDimensions == null || forceRefresh)
            component._jsPlumb.cachedDimensions = component.getDimensions();
        return component._jsPlumb.cachedDimensions;
    };

    // abstract superclass for overlays that add an element to the DOM.
    var AbstractDOMOverlay = function (params) {
        _jp.jsPlumbUIComponent.apply(this, arguments);
        AbstractOverlay.apply(this, arguments);

        // hand off fired events to associated component.
        var _f = this.fire;
        this.fire = function () {
            _f.apply(this, arguments);
            if (this.component) this.component.fire.apply(this.component, arguments);
        };

        this.detached=false;
        this.id = params.id;
        this._jsPlumb.div = null;
        this._jsPlumb.initialised = false;
        this._jsPlumb.component = params.component;
        this._jsPlumb.cachedDimensions = null;
        this._jsPlumb.create = params.create;
        this._jsPlumb.initiallyInvisible = params.visible === false;

        this.getElement = function () {
            if (this._jsPlumb.div == null) {
                var div = this._jsPlumb.div = jsPlumb.getElement(this._jsPlumb.create(this._jsPlumb.component));
                div.style.position = "absolute";
                div.className = this._jsPlumb.instance.overlayClass + " " +
                    (this.cssClass ? this.cssClass :
                        params.cssClass ? params.cssClass : "");
                this._jsPlumb.instance.appendElement(div);
                this._jsPlumb.instance.getId(div);
                this.canvas = div;

                // in IE the top left corner is what it placed at the desired location.  This will not
                // be fixed. IE8 is not going to be supported for much longer.
                var ts = "translate(-50%, -50%)";
                div.style.webkitTransform = ts;
                div.style.mozTransform = ts;
                div.style.msTransform = ts;
                div.style.oTransform = ts;
                div.style.transform = ts;

                // write the related component into the created element
                div._jsPlumb = this;

                if (params.visible === false)
                    div.style.display = "none";
            }
            return this._jsPlumb.div;
        };

        this.draw = function (component, currentConnectionPaintStyle, absolutePosition) {
            var td = _getDimensions(this);
            if (td != null && td.length == 2) {
                var cxy = { x: 0, y: 0 };

                // absolutePosition would have been set by a call to connection.setAbsoluteOverlayPosition.
                if (absolutePosition) {
                    cxy = { x: absolutePosition[0], y: absolutePosition[1] };
                }
                else if (component.pointOnPath) {
                    var loc = this.loc, absolute = false;
                    if (_ju.isString(this.loc) || this.loc < 0 || this.loc > 1) {
                        loc = parseInt(this.loc, 10);
                        absolute = true;
                    }
                    cxy = component.pointOnPath(loc, absolute);  // a connection
                }
                else {
                    var locToUse = this.loc.constructor == Array ? this.loc : this.endpointLoc;
                    cxy = { x: locToUse[0] * component.w,
                        y: locToUse[1] * component.h };
                }

                var minx = cxy.x - (td[0] / 2),
                    miny = cxy.y - (td[1] / 2);

                return {
                    component: component,
                    d: { minx: minx, miny: miny, td: td, cxy: cxy },
                    minX: minx,
                    maxX: minx + td[0],
                    minY: miny,
                    maxY: miny + td[1]
                };
            }
            else return {minX: 0, maxX: 0, minY: 0, maxY: 0};
        };
    };
    _ju.extend(AbstractDOMOverlay, [_jp.jsPlumbUIComponent, AbstractOverlay], {
        getDimensions: function () {
            return [1,1];
        },
        setVisible: function (state) {
            if (this._jsPlumb.div) {
                this._jsPlumb.div.style.display = state ? "block" : "none";
                // if initially invisible, dimensions are 0,0 and never get updated
                if (state && this._jsPlumb.initiallyInvisible) {
                    _getDimensions(this, true);
                    this.component.repaint();
                    this._jsPlumb.initiallyInvisible = false;
                }
            }
        },
        /*
         * Function: clearCachedDimensions
         * Clears the cached dimensions for the label. As a performance enhancement, label dimensions are
         * cached from 1.3.12 onwards. The cache is cleared when you change the label text, of course, but
         * there are other reasons why the text dimensions might change - if you make a change through CSS, for
         * example, you might change the font size.  in that case you should explicitly call this method.
         */
        clearCachedDimensions: function () {
            this._jsPlumb.cachedDimensions = null;
        },
        cleanup: function (force) {
            if (force) {
                if (this._jsPlumb.div != null) {
                    this._jsPlumb.div._jsPlumb = null;
                    this._jsPlumb.instance.removeElement(this._jsPlumb.div);
                }
            }
            else {
                // if not a forced cleanup, just detach child from parent for now.
                if (this._jsPlumb && this._jsPlumb.div && this._jsPlumb.div.parentNode)
                    this._jsPlumb.div.parentNode.removeChild(this._jsPlumb.div);
                this.detached = true;
            }

        },
        reattach:function(instance) {
            if (this._jsPlumb.div != null) instance.getContainer().appendChild(this._jsPlumb.div);
            this.detached = false;
        },
        computeMaxSize: function () {
            var td = _getDimensions(this);
            return Math.max(td[0], td[1]);
        },
        paint: function (p, containerExtents) {
            if (!this._jsPlumb.initialised) {
                this.getElement();
                p.component.appendDisplayElement(this._jsPlumb.div);
                this._jsPlumb.initialised = true;
                if (this.detached) this._jsPlumb.div.parentNode.removeChild(this._jsPlumb.div);
            }
            this._jsPlumb.div.style.left = (p.component.x + p.d.minx) + "px";
            this._jsPlumb.div.style.top = (p.component.y + p.d.miny) + "px";
        }
    });

    /*
     * Class: Overlays.Custom
     * A Custom overlay. You supply a 'create' function which returns some DOM element, and jsPlumb positions it.
     * The 'create' function is passed a Connection or Endpoint.
     */
    /*
     * Function: Constructor
     * 
     * Parameters:
     * 	create - function for jsPlumb to call that returns a DOM element.
     * 	location - distance (as a decimal from 0 to 1 inclusive) marking where the label should sit on the connector. defaults to 0.5.
     * 	id - optional id to use for later retrieval of this overlay.
     * 	
     */
    _jp.Overlays.Custom = function (params) {
        this.type = "Custom";
        AbstractDOMOverlay.apply(this, arguments);
    };
    _ju.extend(_jp.Overlays.Custom, AbstractDOMOverlay);

    _jp.Overlays.GuideLines = function () {
        var self = this;
        self.length = 50;
        self.lineWidth = 5;
        this.type = "GuideLines";
        AbstractOverlay.apply(this, arguments);
        _jp.jsPlumbUIComponent.apply(this, arguments);
        this.draw = function (connector, currentConnectionPaintStyle) {

            var head = connector.pointAlongPathFrom(self.loc, self.length / 2),
                mid = connector.pointOnPath(self.loc),
                tail = _jg.pointOnLine(head, mid, self.length),
                tailLine = _jg.perpendicularLineTo(head, tail, 40),
                headLine = _jg.perpendicularLineTo(tail, head, 20);

            return {
                connector: connector,
                head: head,
                tail: tail,
                headLine: headLine,
                tailLine: tailLine,
                minX: Math.min(head.x, tail.x, headLine[0].x, headLine[1].x),
                minY: Math.min(head.y, tail.y, headLine[0].y, headLine[1].y),
                maxX: Math.max(head.x, tail.x, headLine[0].x, headLine[1].x),
                maxY: Math.max(head.y, tail.y, headLine[0].y, headLine[1].y)
            };
        };

        // this.cleanup = function() { };  // nothing to clean up for GuideLines
    };

    /*
     * Class: Overlays.Label

     */
    /*
     * Function: Constructor
     * 
     * Parameters:
     * 	cssClass - optional css class string to append to css class. This string is appended "as-is", so you can of course have multiple classes
     *             defined.  This parameter is preferred to using labelStyle, borderWidth and borderStyle.
     * 	label - the label to paint.  May be a string or a function that returns a string.  Nothing will be painted if your label is null or your
     *         label function returns null.  empty strings _will_ be painted.
     * 	location - distance (as a decimal from 0 to 1 inclusive) marking where the label should sit on the connector. defaults to 0.5.
     * 	id - optional id to use for later retrieval of this overlay.
     * 
     * 	
     */
    _jp.Overlays.Label = function (params) {
        this.labelStyle = params.labelStyle;

        var labelWidth = null, labelHeight = null, labelText = null, labelPadding = null;
        this.cssClass = this.labelStyle != null ? this.labelStyle.cssClass : null;
        var p = _jp.extend({
            create: function () {
                return jsPlumb.createElement("div");
            }}, params);
        _jp.Overlays.Custom.call(this, p);
        this.type = "Label";
        this.label = params.label || "";
        this.labelText = null;
        if (this.labelStyle) {
            var el = this.getElement();
            this.labelStyle.font = this.labelStyle.font || "12px sans-serif";
            el.style.font = this.labelStyle.font;
            el.style.color = this.labelStyle.color || "black";
            if (this.labelStyle.fillStyle) el.style.background = this.labelStyle.fillStyle;
            if (this.labelStyle.borderWidth > 0) {
                var dStyle = this.labelStyle.borderStyle ? this.labelStyle.borderStyle : "black";
                el.style.border = this.labelStyle.borderWidth + "px solid " + dStyle;
            }
            if (this.labelStyle.padding) el.style.padding = this.labelStyle.padding;
        }

    };
    _ju.extend(_jp.Overlays.Label, _jp.Overlays.Custom, {
        cleanup: function (force) {
            if (force) {
                this.div = null;
                this.label = null;
                this.labelText = null;
                this.cssClass = null;
                this.labelStyle = null;
            }
        },
        getLabel: function () {
            return this.label;
        },
        /*
         * Function: setLabel
         * sets the label's, um, label.  you would think i'd call this function
         * 'setText', but you can pass either a Function or a String to this, so
         * it makes more sense as 'setLabel'. This uses innerHTML on the label div, so keep
         * that in mind if you need escaped HTML.
         */
        setLabel: function (l) {
            this.label = l;
            this.labelText = null;
            this.clearCachedDimensions();
            this.update();
            this.component.repaint();
        },
        getDimensions: function () {
            this.update();
            return AbstractDOMOverlay.prototype.getDimensions.apply(this, arguments);
        },
        update: function () {
            if (typeof this.label == "function") {
                var lt = this.label(this);
                this.getElement().innerHTML = lt.replace(/\r\n/g, "<br/>");
            }
            else {
                if (this.labelText == null) {
                    this.labelText = this.label;
                    this.getElement().innerHTML = this.labelText.replace(/\r\n/g, "<br/>");
                }
            }
        },
        updateFrom:function(d) {
            if(d.label) this.setLabel(d.label);
        }
    });

    // ********************************* END OF OVERLAY DEFINITIONS ***********************************************************************

}).call(this);

/*
 * jsPlumb
 *
 * Title:jsPlumb 2.0.2
 *
 * Provides a way to visually connect elements on an HTML page, using SVG.
 *
 * This file contains the base class for library adapters.
 *
 * Copyright (c) 2010 - 2015 jsPlumb (hello@jsplumbtoolkit.com)
 *
 * http://jsplumbtoolkit.com
 * http://github.com/sporritt/jsplumb
 *
 * Dual licensed under the MIT and GPL2 licenses.
 */
;(function() {
    "use strict";
    var root = this,
        _jp = root.jsPlumb;

    var _getEventManager = function(instance) {
        var e = instance._mottle;
        if (!e) {
            e = instance._mottle = new root.Mottle();
        }
        return e;
    };

    _jp.extend(root.jsPlumbInstance.prototype, {
        getEventManager:function() {
            return _getEventManager(this);
        },
        on : function(el, event, callback) {
            // TODO: here we would like to map the tap event if we know its
            // an internal bind to a click. we have to know its internal because only
            // then can we be sure that the UP event wont be consumed (tap is a synthesized
            // event from a mousedown followed by a mouseup).
            //event = { "click":"tap", "dblclick":"dbltap"}[event] || event;
            this.getEventManager().on.apply(this, arguments);
            return this;
        },
        off : function(el, event, callback) {
            this.getEventManager().off.apply(this, arguments);
            return this;
        }
    });


}).call(this);
/*
 * jsPlumb
 * 
 * Title:jsPlumb 2.0.2
 * 
 * Provides a way to visually connect elements on an HTML page, using SVG.
 * 
 * This file contains the 'flowchart' connectors, consisting of vertical and horizontal line segments.
 *
 * Copyright (c) 2010 - 2015 jsPlumb (hello@jsplumbtoolkit.com)
 * 
 * http://jsplumbtoolkit.com
 * http://github.com/sporritt/jsplumb
 * 
 * Dual licensed under the MIT and GPL2 licenses.
 */
;
(function () {

    "use strict";
    var root = this, _jp = root.jsPlumb, _ju = root.jsPlumbUtil;

    var Flowchart = function (params) {
        this.type = "Flowchart";
        params = params || {};
        params.stub = params.stub == null ? 30 : params.stub;
        var segments,
            _super = _jp.Connectors.AbstractConnector.apply(this, arguments),
            midpoint = params.midpoint == null ? 0.5 : params.midpoint,
            alwaysRespectStubs = params.alwaysRespectStubs === true,
            userSuppliedSegments = null,
            lastx = null, lasty = null, lastOrientation,
            cornerRadius = params.cornerRadius != null ? params.cornerRadius : 0,
            sgn = function (n) {
                return n < 0 ? -1 : n === 0 ? 0 : 1;
            },
            /**
             * helper method to add a segment.
             */
            addSegment = function (segments, x, y, paintInfo) {
                if (lastx == x && lasty == y) return;
                var lx = lastx == null ? paintInfo.sx : lastx,
                    ly = lasty == null ? paintInfo.sy : lasty,
                    o = lx == x ? "v" : "h",
                    sgnx = sgn(x - lx),
                    sgny = sgn(y - ly);

                lastx = x;
                lasty = y;
                segments.push([lx, ly, x, y, o, sgnx, sgny]);
            },
            segLength = function (s) {
                return Math.sqrt(Math.pow(s[0] - s[2], 2) + Math.pow(s[1] - s[3], 2));
            },
            _cloneArray = function (a) {
                var _a = [];
                _a.push.apply(_a, a);
                return _a;
            },
            writeSegments = function (conn, segments, paintInfo) {
                var current = null, next;
                for (var i = 0; i < segments.length - 1; i++) {

                    current = current || _cloneArray(segments[i]);
                    next = _cloneArray(segments[i + 1]);
                    if (cornerRadius > 0 && current[4] != next[4]) {
                        var radiusToUse = Math.min(cornerRadius, segLength(current), segLength(next));
                        // right angle. adjust current segment's end point, and next segment's start point.
                        current[2] -= current[5] * radiusToUse;
                        current[3] -= current[6] * radiusToUse;
                        next[0] += next[5] * radiusToUse;
                        next[1] += next[6] * radiusToUse;
                        var ac = (current[6] == next[5] && next[5] == 1) ||
                                ((current[6] == next[5] && next[5] === 0) && current[5] != next[6]) ||
                                (current[6] == next[5] && next[5] == -1),
                            sgny = next[1] > current[3] ? 1 : -1,
                            sgnx = next[0] > current[2] ? 1 : -1,
                            sgnEqual = sgny == sgnx,
                            cx = (sgnEqual && ac || (!sgnEqual && !ac)) ? next[0] : current[2],
                            cy = (sgnEqual && ac || (!sgnEqual && !ac)) ? current[3] : next[1];

                        _super.addSegment(conn, "Straight", {
                            x1: current[0], y1: current[1], x2: current[2], y2: current[3]
                        });

                        _super.addSegment(conn, "Arc", {
                            r: radiusToUse,
                            x1: current[2],
                            y1: current[3],
                            x2: next[0],
                            y2: next[1],
                            cx: cx,
                            cy: cy,
                            ac: ac
                        });
                    }
                    else {
                        // dx + dy are used to adjust for line width.
                        var dx = (current[2] == current[0]) ? 0 : (current[2] > current[0]) ? (paintInfo.lw / 2) : -(paintInfo.lw / 2),
                            dy = (current[3] == current[1]) ? 0 : (current[3] > current[1]) ? (paintInfo.lw / 2) : -(paintInfo.lw / 2);
                        _super.addSegment(conn, "Straight", {
                            x1: current[0] - dx, y1: current[1] - dy, x2: current[2] + dx, y2: current[3] + dy
                        });
                    }
                    current = next;
                }
                if (next != null) {
                    // last segment
                    _super.addSegment(conn, "Straight", {
                        x1: next[0], y1: next[1], x2: next[2], y2: next[3]
                    });
                }
            };

        this.setSegments = function (s) {
            userSuppliedSegments = s;
        };

        this.isEditable = function () {
            return true;
        };

        /*
         Function: getOriginalSegments
         Gets the segments before the addition of rounded corners. This is used by the flowchart
         connector editor, since it only wants to concern itself with the original segments.
         */
        this.getOriginalSegments = function () {
            return userSuppliedSegments || segments;
        };

        this._compute = function (paintInfo, params) {

            if (params.clearEdits)
                userSuppliedSegments = null;

            if (userSuppliedSegments != null) {
                writeSegments(this, userSuppliedSegments, paintInfo);
                return;
            }

            segments = [];
            lastx = null;
            lasty = null;
            lastOrientation = null;

            var midx = paintInfo.startStubX + ((paintInfo.endStubX - paintInfo.startStubX) * midpoint),
                midy = paintInfo.startStubY + ((paintInfo.endStubY - paintInfo.startStubY) * midpoint);

            var orientations = { x: [ 0, 1 ], y: [ 1, 0 ] },
                commonStubCalculator = function () {
                    return [ paintInfo.startStubX, paintInfo.startStubY, paintInfo.endStubX, paintInfo.endStubY ];
                },
                stubCalculators = {
                    perpendicular: commonStubCalculator,
                    orthogonal: commonStubCalculator,
                    opposite: function (axis) {
                        var pi = paintInfo,
                            idx = axis == "x" ? 0 : 1,
                            areInProximity = {
                                "x": function () {
                                    return ( (pi.so[idx] == 1 && (
                                        ( (pi.startStubX > pi.endStubX) && (pi.tx > pi.startStubX) ) ||
                                        ( (pi.sx > pi.endStubX) && (pi.tx > pi.sx))))) ||

                                        ( (pi.so[idx] == -1 && (
                                            ( (pi.startStubX < pi.endStubX) && (pi.tx < pi.startStubX) ) ||
                                            ( (pi.sx < pi.endStubX) && (pi.tx < pi.sx)))));
                                },
                                "y": function () {
                                    return ( (pi.so[idx] == 1 && (
                                        ( (pi.startStubY > pi.endStubY) && (pi.ty > pi.startStubY) ) ||
                                        ( (pi.sy > pi.endStubY) && (pi.ty > pi.sy))))) ||

                                        ( (pi.so[idx] == -1 && (
                                            ( (pi.startStubY < pi.endStubY) && (pi.ty < pi.startStubY) ) ||
                                            ( (pi.sy < pi.endStubY) && (pi.ty < pi.sy)))));
                                }
                            };

                        if (!alwaysRespectStubs && areInProximity[axis]()) {
                            return {
                                "x": [(paintInfo.sx + paintInfo.tx) / 2, paintInfo.startStubY, (paintInfo.sx + paintInfo.tx) / 2, paintInfo.endStubY],
                                "y": [paintInfo.startStubX, (paintInfo.sy + paintInfo.ty) / 2, paintInfo.endStubX, (paintInfo.sy + paintInfo.ty) / 2]
                            }[axis];
                        }
                        else {
                            return [ paintInfo.startStubX, paintInfo.startStubY, paintInfo.endStubX, paintInfo.endStubY ];
                        }
                    }
                },
                lineCalculators = {
                    perpendicular: function (axis) {
                        var pi = paintInfo,
                            sis = {
                                x: [
                                    [ [ 1, 2, 3, 4 ], null, [ 2, 1, 4, 3 ] ],
                                    null,
                                    [ [ 4, 3, 2, 1 ], null, [ 3, 4, 1, 2 ] ]
                                ],
                                y: [
                                    [ [ 3, 2, 1, 4 ], null, [ 2, 3, 4, 1 ] ],
                                    null,
                                    [ [ 4, 1, 2, 3 ], null, [ 1, 4, 3, 2 ] ]
                                ]
                            },
                            stubs = {
                                x: [ [ pi.startStubX, pi.endStubX ], null, [ pi.endStubX, pi.startStubX ] ],
                                y: [ [ pi.startStubY, pi.endStubY ], null, [ pi.endStubY, pi.startStubY ] ]
                            },
                            midLines = {
                                x: [ [ midx, pi.startStubY ], [ midx, pi.endStubY ] ],
                                y: [ [ pi.startStubX, midy ], [ pi.endStubX, midy ] ]
                            },
                            linesToEnd = {
                                x: [ [ pi.endStubX, pi.startStubY ] ],
                                y: [ [ pi.startStubX, pi.endStubY ] ]
                            },
                            startToEnd = {
                                x: [ [ pi.startStubX, pi.endStubY ], [ pi.endStubX, pi.endStubY ] ],
                                y: [ [ pi.endStubX, pi.startStubY ], [ pi.endStubX, pi.endStubY ] ]
                            },
                            startToMidToEnd = {
                                x: [ [ pi.startStubX, midy ], [ pi.endStubX, midy ], [ pi.endStubX, pi.endStubY ] ],
                                y: [ [ midx, pi.startStubY ], [ midx, pi.endStubY ], [ pi.endStubX, pi.endStubY ] ]
                            },
                            otherStubs = {
                                x: [ pi.startStubY, pi.endStubY ],
                                y: [ pi.startStubX, pi.endStubX ]
                            },
                            soIdx = orientations[axis][0], toIdx = orientations[axis][1],
                            _so = pi.so[soIdx] + 1,
                            _to = pi.to[toIdx] + 1,
                            otherFlipped = (pi.to[toIdx] == -1 && (otherStubs[axis][1] < otherStubs[axis][0])) || (pi.to[toIdx] == 1 && (otherStubs[axis][1] > otherStubs[axis][0])),
                            stub1 = stubs[axis][_so][0],
                            stub2 = stubs[axis][_so][1],
                            segmentIndexes = sis[axis][_so][_to];

                        if (pi.segment == segmentIndexes[3] || (pi.segment == segmentIndexes[2] && otherFlipped)) {
                            return midLines[axis];
                        }
                        else if (pi.segment == segmentIndexes[2] && stub2 < stub1) {
                            return linesToEnd[axis];
                        }
                        else if ((pi.segment == segmentIndexes[2] && stub2 >= stub1) || (pi.segment == segmentIndexes[1] && !otherFlipped)) {
                            return startToMidToEnd[axis];
                        }
                        else if (pi.segment == segmentIndexes[0] || (pi.segment == segmentIndexes[1] && otherFlipped)) {
                            return startToEnd[axis];
                        }
                    },
                    orthogonal: function (axis, startStub, otherStartStub, endStub, otherEndStub) {
                        var pi = paintInfo,
                            extent = {
                                "x": pi.so[0] == -1 ? Math.min(startStub, endStub) : Math.max(startStub, endStub),
                                "y": pi.so[1] == -1 ? Math.min(startStub, endStub) : Math.max(startStub, endStub)
                            }[axis];

                        return {
                            "x": [
                                [ extent, otherStartStub ],
                                [ extent, otherEndStub ],
                                [ endStub, otherEndStub ]
                            ],
                            "y": [
                                [ otherStartStub, extent ],
                                [ otherEndStub, extent ],
                                [ otherEndStub, endStub ]
                            ]
                        }[axis];
                    },
                    opposite: function (axis, ss, oss, es) {
                        var pi = paintInfo,
                            otherAxis = {"x": "y", "y": "x"}[axis],
                            dim = {"x": "height", "y": "width"}[axis],
                            comparator = pi["is" + axis.toUpperCase() + "GreaterThanStubTimes2"];

                        if (params.sourceEndpoint.elementId == params.targetEndpoint.elementId) {
                            var _val = oss + ((1 - params.sourceEndpoint.anchor[otherAxis]) * params.sourceInfo[dim]) + _super.maxStub;
                            return {
                                "x": [
                                    [ ss, _val ],
                                    [ es, _val ]
                                ],
                                "y": [
                                    [ _val, ss ],
                                    [ _val, es ]
                                ]
                            }[axis];

                        }
                        else if (!comparator || (pi.so[idx] == 1 && ss > es) || (pi.so[idx] == -1 && ss < es)) {
                            return {
                                "x": [
                                    [ ss, midy ],
                                    [ es, midy ]
                                ],
                                "y": [
                                    [ midx, ss ],
                                    [ midx, es ]
                                ]
                            }[axis];
                        }
                        else if ((pi.so[idx] == 1 && ss < es) || (pi.so[idx] == -1 && ss > es)) {
                            return {
                                "x": [
                                    [ midx, pi.sy ],
                                    [ midx, pi.ty ]
                                ],
                                "y": [
                                    [ pi.sx, midy ],
                                    [ pi.tx, midy ]
                                ]
                            }[axis];
                        }
                    }
                };

            var stubs = stubCalculators[paintInfo.anchorOrientation](paintInfo.sourceAxis),
                idx = paintInfo.sourceAxis == "x" ? 0 : 1,
                oidx = paintInfo.sourceAxis == "x" ? 1 : 0,
                ss = stubs[idx],
                oss = stubs[oidx],
                es = stubs[idx + 2],
                oes = stubs[oidx + 2];

            // add the start stub segment.
            addSegment(segments, stubs[0], stubs[1], paintInfo);

            // compute the rest of the line
            var p = lineCalculators[paintInfo.anchorOrientation](paintInfo.sourceAxis, ss, oss, es, oes);
            if (p) {
                for (var i = 0; i < p.length; i++) {
                    addSegment(segments, p[i][0], p[i][1], paintInfo);
                }
            }

            // line to end stub
            addSegment(segments, stubs[2], stubs[3], paintInfo);

            // end stub to end
            addSegment(segments, paintInfo.tx, paintInfo.ty, paintInfo);

            writeSegments(this, segments, paintInfo);
        };

        this.getPath = function () {
            var _last = null, _lastAxis = null, s = [], segs = userSuppliedSegments || segments;
            for (var i = 0; i < segs.length; i++) {
                var seg = segs[i], axis = seg[4], axisIndex = (axis == "v" ? 3 : 2);
                if (_last != null && _lastAxis === axis) {
                    _last[axisIndex] = seg[axisIndex];
                }
                else {
                    if (seg[0] != seg[2] || seg[1] != seg[3]) {
                        s.push({
                            start: [ seg[0], seg[1] ],
                            end: [ seg[2], seg[3] ]
                        });
                        _last = seg;
                        _lastAxis = seg[4];
                    }
                }
            }
            return s;
        };

        this.setPath = function (path) {
            userSuppliedSegments = [];
            for (var i = 0; i < path.length; i++) {
                var lx = path[i].start[0],
                    ly = path[i].start[1],
                    x = path[i].end[0],
                    y = path[i].end[1],
                    o = lx == x ? "v" : "h",
                    sgnx = sgn(x - lx),
                    sgny = sgn(y - ly);

                userSuppliedSegments.push([lx, ly, x, y, o, sgnx, sgny]);
            }
        };
    };

    _ju.extend(Flowchart, _jp.Connectors.AbstractConnector);
    _jp.registerConnectorType(Flowchart, "Flowchart");
}).call(this);
/*
 * jsPlumb
 * 
 * Title:jsPlumb 2.0.2
 * 
 * Provides a way to visually connect elements on an HTML page, using SVG.
 * 
 * This file contains the state machine connectors.
 *
 * Copyright (c) 2010 - 2015 jsPlumb (hello@jsplumbtoolkit.com)
 * 
 * http://jsplumbtoolkit.com
 * http://github.com/sporritt/jsplumb
 * 
 * Dual licensed under the MIT and GPL2 licenses.
 */
;
(function () {

    "use strict";
    var root = this, _jp = root.jsPlumb, _ju = root.jsPlumbUtil;

    var _segment = function (x1, y1, x2, y2) {
            if (x1 <= x2 && y2 <= y1) return 1;
            else if (x1 <= x2 && y1 <= y2) return 2;
            else if (x2 <= x1 && y2 >= y1) return 3;
            return 4;
        },

    // the control point we will use depends on the faces to which each end of the connection is assigned, specifically whether or not the
    // two faces are parallel or perpendicular.  if they are parallel then the control point lies on the midpoint of the axis in which they
    // are parellel and varies only in the other axis; this variation is proportional to the distance that the anchor points lie from the
    // center of that face.  if the two faces are perpendicular then the control point is at some distance from both the midpoints; the amount and
    // direction are dependent on the orientation of the two elements. 'seg', passed in to this method, tells you which segment the target element
    // lies in with respect to the source: 1 is top right, 2 is bottom right, 3 is bottom left, 4 is top left.
    //
    // sourcePos and targetPos are arrays of info about where on the source and target each anchor is located.  their contents are:
    //
    // 0 - absolute x
    // 1 - absolute y
    // 2 - proportional x in element (0 is left edge, 1 is right edge)
    // 3 - proportional y in element (0 is top edge, 1 is bottom edge)
    //
        _findControlPoint = function (midx, midy, segment, sourceEdge, targetEdge, dx, dy, distance, proximityLimit) {
            // TODO (maybe)
            // - if anchor pos is 0.5, make the control point take into account the relative position of the elements.
            if (distance <= proximityLimit) return [midx, midy];

            if (segment === 1) {
                if (sourceEdge[3] <= 0 && targetEdge[3] >= 1) return [ midx + (sourceEdge[2] < 0.5 ? -1 * dx : dx), midy ];
                else if (sourceEdge[2] >= 1 && targetEdge[2] <= 0) return [ midx, midy + (sourceEdge[3] < 0.5 ? -1 * dy : dy) ];
                else return [ midx + (-1 * dx) , midy + (-1 * dy) ];
            }
            else if (segment === 2) {
                if (sourceEdge[3] >= 1 && targetEdge[3] <= 0) return [ midx + (sourceEdge[2] < 0.5 ? -1 * dx : dx), midy ];
                else if (sourceEdge[2] >= 1 && targetEdge[2] <= 0) return [ midx, midy + (sourceEdge[3] < 0.5 ? -1 * dy : dy) ];
                else return [ midx + dx, midy + (-1 * dy) ];
            }
            else if (segment === 3) {
                if (sourceEdge[3] >= 1 && targetEdge[3] <= 0) return [ midx + (sourceEdge[2] < 0.5 ? -1 * dx : dx), midy ];
                else if (sourceEdge[2] <= 0 && targetEdge[2] >= 1) return [ midx, midy + (sourceEdge[3] < 0.5 ? -1 * dy : dy) ];
                else return [ midx + (-1 * dx) , midy + (-1 * dy) ];
            }
            else if (segment === 4) {
                if (sourceEdge[3] <= 0 && targetEdge[3] >= 1) return [ midx + (sourceEdge[2] < 0.5 ? -1 * dx : dx), midy ];
                else if (sourceEdge[2] <= 0 && targetEdge[2] >= 1) return [ midx, midy + (sourceEdge[3] < 0.5 ? -1 * dy : dy) ];
                else return [ midx + dx , midy + (-1 * dy) ];
            }

        };

    var StateMachine = function (params) {
        params = params || {};
        this.type = "StateMachine";

        var _super = _jp.Connectors.AbstractConnector.apply(this, arguments),
            curviness = params.curviness || 10,
            margin = params.margin || 5,
            proximityLimit = params.proximityLimit || 80,
            clockwise = params.orientation && params.orientation === "clockwise",
            loopbackRadius = params.loopbackRadius || 25,
            showLoopback = params.showLoopback !== false;

        this._compute = function (paintInfo, params) {
            var w = Math.abs(params.sourcePos[0] - params.targetPos[0]),
                h = Math.abs(params.sourcePos[1] - params.targetPos[1]);

            if (!showLoopback || (params.sourceEndpoint.elementId !== params.targetEndpoint.elementId)) {
                var _sx = params.sourcePos[0] < params.targetPos[0] ? 0 : w,
                    _sy = params.sourcePos[1] < params.targetPos[1] ? 0 : h,
                    _tx = params.sourcePos[0] < params.targetPos[0] ? w : 0,
                    _ty = params.sourcePos[1] < params.targetPos[1] ? h : 0;

                // now adjust for the margin
                if (params.sourcePos[2] === 0) _sx -= margin;
                if (params.sourcePos[2] === 1) _sx += margin;
                if (params.sourcePos[3] === 0) _sy -= margin;
                if (params.sourcePos[3] === 1) _sy += margin;
                if (params.targetPos[2] === 0) _tx -= margin;
                if (params.targetPos[2] === 1) _tx += margin;
                if (params.targetPos[3] === 0) _ty -= margin;
                if (params.targetPos[3] === 1) _ty += margin;

                //
                // these connectors are quadratic bezier curves, having a single control point. if both anchors
                // are located at 0.5 on their respective faces, the control point is set to the midpoint and you
                // get a straight line.  this is also the case if the two anchors are within 'proximityLimit', since
                // it seems to make good aesthetic sense to do that. outside of that, the control point is positioned
                // at 'curviness' pixels away along the normal to the straight line connecting the two anchors.
                //
                // there may be two improvements to this.  firstly, we might actually support the notion of avoiding nodes
                // in the UI, or at least making a good effort at doing so.  if a connection would pass underneath some node,
                // for example, we might increase the distance the control point is away from the midpoint in a bid to
                // steer it around that node.  this will work within limits, but i think those limits would also be the likely
                // limits for, once again, aesthetic good sense in the layout of a chart using these connectors.
                //
                // the second possible change is actually two possible changes: firstly, it is possible we should gradually
                // decrease the 'curviness' as the distance between the anchors decreases; start tailing it off to 0 at some
                // point (which should be configurable).  secondly, we might slightly increase the 'curviness' for connectors
                // with respect to how far their anchor is from the center of its respective face. this could either look cool,
                // or stupid, and may indeed work only in a way that is so subtle as to have been a waste of time.
                //

                var _midx = (_sx + _tx) / 2,
                    _midy = (_sy + _ty) / 2,
                    segment = _segment(_sx, _sy, _tx, _ty),
                    distance = Math.sqrt(Math.pow(_tx - _sx, 2) + Math.pow(_ty - _sy, 2)),
                    // calculate the control point.  this code will be where we'll put in a rudimentary element avoidance scheme; it
                    // will work by extending the control point to force the curve to be, um, curvier.
                    _controlPoint = _findControlPoint(_midx,
                        _midy,
                        segment,
                        params.sourcePos,
                        params.targetPos,
                        curviness, curviness,
                        distance,
                        proximityLimit);

                _super.addSegment(this, "Bezier", {
                    x1: _tx, y1: _ty, x2: _sx, y2: _sy,
                    cp1x: _controlPoint[0], cp1y: _controlPoint[1],
                    cp2x: _controlPoint[0], cp2y: _controlPoint[1]
                });
            }
            else {
                // a loopback connector.  draw an arc from one anchor to the other.
                var x1 = params.sourcePos[0], y1 = params.sourcePos[1] - margin,
                    cx = x1, cy = y1 - loopbackRadius,
                // canvas sizing stuff, to ensure the whole painted area is visible.
                    _w = 2 * loopbackRadius,
                    _h = 2 * loopbackRadius,
                    _x = cx - loopbackRadius,
                    _y = cy - loopbackRadius;

                paintInfo.points[0] = _x;
                paintInfo.points[1] = _y;
                paintInfo.points[2] = _w;
                paintInfo.points[3] = _h;

                // ADD AN ARC SEGMENT.
                _super.addSegment(this, "Arc", {
                    loopback: true,
                    x1: (x1 - _x) + 4,
                    y1: y1 - _y,
                    startAngle: 0,
                    endAngle: 2 * Math.PI,
                    r: loopbackRadius,
                    ac: !clockwise,
                    x2: (x1 - _x) - 4,
                    y2: y1 - _y,
                    cx: cx - _x,
                    cy: cy - _y
                });
            }
        };
    };
    _ju.extend(StateMachine, _jp.Connectors.AbstractConnector);
    _jp.registerConnectorType(StateMachine, "StateMachine");
}).call(this);
/*
 * jsPlumb
 * 
 * Title:jsPlumb 2.0.2
 * 
 * Provides a way to visually connect elements on an HTML page, using SVG.
 * 
 * This file contains the code for the Bezier connector type.
 *
 * Copyright (c) 2010 - 2015 jsPlumb (hello@jsplumbtoolkit.com)
 * 
 * http://jsplumbtoolkit.com
 * http://github.com/sporritt/jsplumb
 * 
 * Dual licensed under the MIT and GPL2 licenses.
 */
;
(function () {

    "use strict";
    var root = this, _jp = root.jsPlumb, _ju = root.jsPlumbUtil;

    var Bezier = function (params) {
        params = params || {};

        var _super = _jp.Connectors.AbstractConnector.apply(this, arguments),
            majorAnchor = params.curviness || 150,
            minorAnchor = 10;

        this.type = "Bezier";
        this.getCurviness = function () {
            return majorAnchor;
        };

        this._findControlPoint = function (point, sourceAnchorPosition, targetAnchorPosition, sourceEndpoint, targetEndpoint, soo, too) {
            // determine if the two anchors are perpendicular to each other in their orientation.  we swap the control
            // points around if so (code could be tightened up)
            var perpendicular = soo[0] != too[0] || soo[1] == too[1],
                p = [];

            if (!perpendicular) {
                if (soo[0] === 0) // X
                    p.push(sourceAnchorPosition[0] < targetAnchorPosition[0] ? point[0] + minorAnchor : point[0] - minorAnchor);
                else p.push(point[0] - (majorAnchor * soo[0]));

                if (soo[1] === 0) // Y
                    p.push(sourceAnchorPosition[1] < targetAnchorPosition[1] ? point[1] + minorAnchor : point[1] - minorAnchor);
                else p.push(point[1] + (majorAnchor * too[1]));
            }
            else {
                if (too[0] === 0) // X
                    p.push(targetAnchorPosition[0] < sourceAnchorPosition[0] ? point[0] + minorAnchor : point[0] - minorAnchor);
                else p.push(point[0] + (majorAnchor * too[0]));

                if (too[1] === 0) // Y
                    p.push(targetAnchorPosition[1] < sourceAnchorPosition[1] ? point[1] + minorAnchor : point[1] - minorAnchor);
                else p.push(point[1] + (majorAnchor * soo[1]));
            }

            return p;
        };

        this._compute = function (paintInfo, p) {
            var sp = p.sourcePos,
                tp = p.targetPos,
                _w = Math.abs(sp[0] - tp[0]),
                _h = Math.abs(sp[1] - tp[1]),
                _sx = sp[0] < tp[0] ? _w : 0,
                _sy = sp[1] < tp[1] ? _h : 0,
                _tx = sp[0] < tp[0] ? 0 : _w,
                _ty = sp[1] < tp[1] ? 0 : _h,
                _CP = this._findControlPoint([_sx, _sy], sp, tp, p.sourceEndpoint, p.targetEndpoint, paintInfo.so, paintInfo.to),
                _CP2 = this._findControlPoint([_tx, _ty], tp, sp, p.targetEndpoint, p.sourceEndpoint, paintInfo.to, paintInfo.so);

            _super.addSegment(this, "Bezier", {
                x1: _sx, y1: _sy, x2: _tx, y2: _ty,
                cp1x: _CP[0], cp1y: _CP[1], cp2x: _CP2[0], cp2y: _CP2[1]
            });
        };
    };

    _ju.extend(Bezier, _jp.Connectors.AbstractConnector);
    _jp.registerConnectorType(Bezier, "Bezier");

}).call(this);
/*
 * jsPlumb
 * 
 * Title:jsPlumb 2.0.2
 * 
 * Provides a way to visually connect elements on an HTML page, using SVG.
 * 
 * This file contains the SVG renderers.
 *
 * Copyright (c) 2010 - 2015 jsPlumb (hello@jsplumbtoolkit.com)
 * 
 * http://jsplumbtoolkit.com
 * http://github.com/sporritt/jsplumb
 * 
 * Dual licensed under the MIT and GPL2 licenses.
 */
;
(function () {

// ************************** SVG utility methods ********************************************	

    "use strict";
    var root = this, _jp = root.jsPlumb, _ju = root.jsPlumbUtil;

    var svgAttributeMap = {
            "stroke-linejoin": "stroke-linejoin",
            "stroke-dashoffset": "stroke-dashoffset",
            "stroke-linecap": "stroke-linecap"
        },
        STROKE_DASHARRAY = "stroke-dasharray",
        DASHSTYLE = "dashstyle",
        LINEAR_GRADIENT = "linearGradient",
        RADIAL_GRADIENT = "radialGradient",
        DEFS = "defs",
        FILL = "fill",
        STOP = "stop",
        STROKE = "stroke",
        STROKE_WIDTH = "stroke-width",
        STYLE = "style",
        NONE = "none",
        JSPLUMB_GRADIENT = "jsplumb_gradient_",
        LINE_WIDTH = "lineWidth",
        ns = {
            svg: "http://www.w3.org/2000/svg",
            xhtml: "http://www.w3.org/1999/xhtml"
        },
        _attr = function (node, attributes) {
            for (var i in attributes)
                node.setAttribute(i, "" + attributes[i]);
        },
        _node = function (name, attributes) {
            attributes = attributes || {};
            attributes.version = "1.1";
            attributes.xmlns = ns.xhtml;
            return jsPlumb.createElementNS(ns.svg, name, null, null, attributes);
        },
        _pos = function (d) {
            return "position:absolute;left:" + d[0] + "px;top:" + d[1] + "px";
        },
        _clearGradient = function (parent) {
            var els = parent.querySelectorAll(" defs,linearGradient,radialGradient");
            for (var i = 0; i < els.length; i++)
                els[i].parentNode.removeChild(els[i]);
        },
        _updateGradient = function (parent, node, style, dimensions, uiComponent) {
            var id = JSPLUMB_GRADIENT + uiComponent._jsPlumb.instance.idstamp();
            // first clear out any existing gradient
            _clearGradient(parent);
            // this checks for an 'offset' property in the gradient, and in the absence of it, assumes
            // we want a linear gradient. if it's there, we create a radial gradient.
            // it is possible that a more explicit means of defining the gradient type would be
            // better. relying on 'offset' means that we can never have a radial gradient that uses
            // some default offset, for instance.
            // issue 244 suggested the 'gradientUnits' attribute; without this, straight/flowchart connectors with gradients would
            // not show gradients when the line was perfectly horizontal or vertical.
            var g;
            if (!style.gradient.offset)
                g = _node(LINEAR_GRADIENT, {id: id, gradientUnits: "userSpaceOnUse"});
            else
                g = _node(RADIAL_GRADIENT, { id: id });

            var defs = _node(DEFS);
            parent.appendChild(defs);
            defs.appendChild(g);

            // the svg radial gradient seems to treat stops in the reverse
            // order to how canvas does it.  so we want to keep all the maths the same, but
            // iterate the actual style declarations in reverse order, if the x indexes are not in order.
            for (var i = 0; i < style.gradient.stops.length; i++) {
                var styleToUse = uiComponent.segment == 1 || uiComponent.segment == 2 ? i : style.gradient.stops.length - 1 - i,
                    //stopColor = _ju.convertStyle(style.gradient.stops[styleToUse][1], true),
                    stopColor = style.gradient.stops[styleToUse][1],
                    s = _node(STOP, {"offset": Math.floor(style.gradient.stops[i][0] * 100) + "%", "stop-color": stopColor});

                g.appendChild(s);
            }
            var applyGradientTo = style.strokeStyle ? STROKE : FILL;
            node.setAttribute(applyGradientTo, "url(#" + id + ")");
        },
        _applyStyles = function (parent, node, style, dimensions, uiComponent) {

            node.setAttribute(FILL, style.fillStyle ? style.fillStyle : NONE);
            node.setAttribute(STROKE, style.strokeStyle ? style.strokeStyle : NONE);

            if (style.gradient) {
                _updateGradient(parent, node, style, dimensions, uiComponent);
            }
            else {
                // make sure we clear any existing gradient
                _clearGradient(parent);
                node.setAttribute(STYLE, "");
            }

            if (style.lineWidth) {
                node.setAttribute(STROKE_WIDTH, style.lineWidth);
            }

            // in SVG there is a stroke-dasharray attribute we can set, and its syntax looks like
            // the syntax in VML but is actually kind of nasty: values are given in the pixel
            // coordinate space, whereas in VML they are multiples of the width of the stroked
            // line, which makes a lot more sense.  for that reason, jsPlumb is supporting both
            // the native svg 'stroke-dasharray' attribute, and also the 'dashstyle' concept from
            // VML, which will be the preferred method.  the code below this converts a dashstyle
            // attribute given in terms of stroke width into a pixel representation, by using the
            // stroke's lineWidth.
            if (style[DASHSTYLE] && style[LINE_WIDTH] && !style[STROKE_DASHARRAY]) {
                var sep = style[DASHSTYLE].indexOf(",") == -1 ? " " : ",",
                    parts = style[DASHSTYLE].split(sep),
                    styleToUse = "";
                parts.forEach(function (p) {
                    styleToUse += (Math.floor(p * style.lineWidth) + sep);
                });
                node.setAttribute(STROKE_DASHARRAY, styleToUse);
            }
            else if (style[STROKE_DASHARRAY]) {
                node.setAttribute(STROKE_DASHARRAY, style[STROKE_DASHARRAY]);
            }

            // extra attributes such as join type, dash offset.
            for (var i in svgAttributeMap) {
                if (style[i]) {
                    node.setAttribute(svgAttributeMap[i], style[i]);
                }
            }
        },
        _appendAtIndex = function (svg, path, idx) {
            if (svg.childNodes.length > idx) {
                svg.insertBefore(path, svg.childNodes[idx]);
            }
            else svg.appendChild(path);
        };

    /**
     utility methods for other objects to use.
     */
    _ju.svg = {
        node: _node,
        attr: _attr,
        pos: _pos
    };

    // ************************** / SVG utility methods ********************************************

    /*
     * Base class for SVG components.
     */
    var SvgComponent = function (params) {
        var pointerEventsSpec = params.pointerEventsSpec || "all", renderer = {};

        _jp.jsPlumbUIComponent.apply(this, params.originalArgs);
        this.canvas = null;
        this.path = null;
        this.svg = null;
        this.bgCanvas = null;

        var clazz = params.cssClass + " " + (params.originalArgs[0].cssClass || ""),
            svgParams = {
                "style": "",
                "width": 0,
                "height": 0,
                "pointer-events": pointerEventsSpec,
                "position": "absolute"
            };

        this.svg = _node("svg", svgParams);

        if (params.useDivWrapper) {
            this.canvas = jsPlumb.createElement("div", { position : "absolute" });
            _ju.sizeElement(this.canvas, 0, 0, 1, 1);
            this.canvas.className = clazz;
        }
        else {
            _attr(this.svg, { "class": clazz });
            this.canvas = this.svg;
        }

        params._jsPlumb.appendElement(this.canvas, params.originalArgs[0].parent);
        if (params.useDivWrapper) this.canvas.appendChild(this.svg);

        var displayElements = [ this.canvas ];
        this.getDisplayElements = function () {
            return displayElements;
        };

        this.appendDisplayElement = function (el) {
            displayElements.push(el);
        };

        this.paint = function (style, anchor, extents) {
            if (style != null) {

                var xy = [ this.x, this.y ], wh = [ this.w, this.h ], p;
                if (extents != null) {
                    if (extents.xmin < 0) xy[0] += extents.xmin;
                    if (extents.ymin < 0) xy[1] += extents.ymin;
                    wh[0] = extents.xmax + ((extents.xmin < 0) ? -extents.xmin : 0);
                    wh[1] = extents.ymax + ((extents.ymin < 0) ? -extents.ymin : 0);
                }

                if (params.useDivWrapper) {
                    _ju.sizeElement(this.canvas, xy[0], xy[1], wh[0], wh[1]);
                    xy[0] = 0;
                    xy[1] = 0;
                    p = _pos([ 0, 0 ]);
                }
                else
                    p = _pos([ xy[0], xy[1] ]);

                renderer.paint.apply(this, arguments);

                _attr(this.svg, {
                    "style": p,
                    "width": wh[0] || 0,
                    "height": wh[1] || 0
                });
            }
        };

        return {
            renderer: renderer
        };
    };

    _ju.extend(SvgComponent, _jp.jsPlumbUIComponent, {
        cleanup: function (force) {
            if (force || this.typeId == null) {
                if (this.canvas) this.canvas._jsPlumb = null;
                if (this.svg) this.svg._jsPlumb = null;
                if (this.bgCanvas) this.bgCanvas._jsPlumb = null;

                if (this.canvas && this.canvas.parentNode)
                    this.canvas.parentNode.removeChild(this.canvas);
                if (this.bgCanvas && this.bgCanvas.parentNode)
                    this.canvas.parentNode.removeChild(this.canvas);

                this.svg = null;
                this.canvas = null;
                this.path = null;
                this.group = null;
            }
            else {
                // if not a forced cleanup, just detach from DOM for now.
                if (this.canvas && this.canvas.parentNode) this.canvas.parentNode.removeChild(this.canvas);
                if (this.bgCanvas && this.bgCanvas.parentNode) this.bgCanvas.parentNode.removeChild(this.bgCanvas);
            }
        },
        reattach:function(instance) {
            var c = instance.getContainer();
            if (this.canvas && this.canvas.parentNode == null) c.appendChild(this.canvas);
            if (this.bgCanvas && this.bgCanvas.parentNode == null) c.appendChild(this.bgCanvas);
        },
        setVisible: function (v) {
            if (this.canvas) {
                this.canvas.style.display = v ? "block" : "none";
            }
        }
    });

    /*
     * Base class for SVG connectors.
     */
    _jp.ConnectorRenderers.svg = function (params) {
        var self = this,
            _super = SvgComponent.apply(this, [
                {
                    cssClass: params._jsPlumb.connectorClass,
                    originalArgs: arguments,
                    pointerEventsSpec: "none",
                    _jsPlumb: params._jsPlumb
                }
            ]);

        _super.renderer.paint = function (style, anchor, extents) {

            var segments = self.getSegments(), p = "", offset = [0, 0];
            if (extents.xmin < 0) offset[0] = -extents.xmin;
            if (extents.ymin < 0) offset[1] = -extents.ymin;

            if (segments.length > 0) {

                // create path from segments.
                for (var i = 0; i < segments.length; i++) {
                    p += _jp.Segments.svg.SegmentRenderer.getPath(segments[i]);
                    p += " ";
                }

                var a = {
                        d: p,
                        transform: "translate(" + offset[0] + "," + offset[1] + ")",
                        "pointer-events": params["pointer-events"] || "visibleStroke"
                    },
                    outlineStyle = null,
                    d = [self.x, self.y, self.w, self.h];

                // outline style.  actually means drawing an svg object underneath the main one.
                if (style.outlineColor) {
                    var outlineWidth = style.outlineWidth || 1,
                        outlineStrokeWidth = style.lineWidth + (2 * outlineWidth);
                    outlineStyle = _jp.extend({}, style);
                    delete outlineStyle.gradient;
                    outlineStyle.strokeStyle = style.outlineColor;
                    outlineStyle.lineWidth = outlineStrokeWidth;

                    if (self.bgPath == null) {
                        self.bgPath = _node("path", a);
                        _jp.addClass(self.bgPath, _jp.connectorOutlineClass);
                        _appendAtIndex(self.svg, self.bgPath, 0);
                    }
                    else {
                        _attr(self.bgPath, a);
                    }

                    _applyStyles(self.svg, self.bgPath, outlineStyle, d, self);
                }

                if (self.path == null) {
                    self.path = _node("path", a);
                    _appendAtIndex(self.svg, self.path, style.outlineColor ? 1 : 0);
                }
                else {
                    _attr(self.path, a);
                }

                _applyStyles(self.svg, self.path, style, d, self);
            }
        };
    };
    _ju.extend(_jp.ConnectorRenderers.svg, SvgComponent);

// ******************************* svg segment renderer *****************************************************	

    _jp.Segments.svg = {
        SegmentRenderer: {
            getPath: function (segment) {
                return ({
                    "Straight": function () {
                        var d = segment.getCoordinates();
                        return "M " + d.x1 + " " + d.y1 + " L " + d.x2 + " " + d.y2;
                    },
                    "Bezier": function () {
                        var d = segment.params;
                        return "M " + d.x1 + " " + d.y1 +
                            " C " + d.cp1x + " " + d.cp1y + " " + d.cp2x + " " + d.cp2y + " " + d.x2 + " " + d.y2;
                    },
                    "Arc": function () {
                        var d = segment.params,
                            laf = segment.sweep > Math.PI ? 1 : 0,
                            sf = segment.anticlockwise ? 0 : 1;

                        return "M" + segment.x1 + " " + segment.y1 + " A " + segment.radius + " " + d.r + " 0 " + laf + "," + sf + " " + segment.x2 + " " + segment.y2;
                    }
                })[segment.type]();
            }
        }
    };

// ******************************* /svg segments *****************************************************

    /*
     * Base class for SVG endpoints.
     */
    var SvgEndpoint = _jp.SvgEndpoint = function (params) {
        var _super = SvgComponent.apply(this, [
            {
                cssClass: params._jsPlumb.endpointClass,
                originalArgs: arguments,
                pointerEventsSpec: "all",
                useDivWrapper: true,
                _jsPlumb: params._jsPlumb
            }
        ]);

        _super.renderer.paint = function (style) {
            var s = _jp.extend({}, style);
            if (s.outlineColor) {
                s.strokeWidth = s.outlineWidth;
                s.strokeStyle = s.outlineColor;
            }

            if (this.node == null) {
                this.node = this.makeNode(s);
                this.svg.appendChild(this.node);
            }
            else if (this.updateNode != null) {
                this.updateNode(this.node);
            }
            _applyStyles(this.svg, this.node, s, [ this.x, this.y, this.w, this.h ], this);
            _pos(this.node, [ this.x, this.y ]);
        }.bind(this);

    };
    _ju.extend(SvgEndpoint, SvgComponent);

    /*
     * SVG Dot Endpoint
     */
    _jp.Endpoints.svg.Dot = function () {
        _jp.Endpoints.Dot.apply(this, arguments);
        SvgEndpoint.apply(this, arguments);
        this.makeNode = function (style) {
            return _node("circle", {
                "cx": this.w / 2,
                "cy": this.h / 2,
                "r": this.radius
            });
        };
        this.updateNode = function (node) {
            _attr(node, {
                "cx": this.w / 2,
                "cy": this.h / 2,
                "r": this.radius
            });
        };
    };
    _ju.extend(_jp.Endpoints.svg.Dot, [_jp.Endpoints.Dot, SvgEndpoint]);

    /*
     * SVG Rectangle Endpoint
     */
    _jp.Endpoints.svg.Rectangle = function () {
        _jp.Endpoints.Rectangle.apply(this, arguments);
        SvgEndpoint.apply(this, arguments);
        this.makeNode = function (style) {
            return _node("rect", {
                "width": this.w,
                "height": this.h
            });
        };
        this.updateNode = function (node) {
            _attr(node, {
                "width": this.w,
                "height": this.h
            });
        };
    };
    _ju.extend(_jp.Endpoints.svg.Rectangle, [_jp.Endpoints.Rectangle, SvgEndpoint]);

    /*
     * SVG Image Endpoint is the default image endpoint.
     */
    _jp.Endpoints.svg.Image = _jp.Endpoints.Image;
    /*
     * Blank endpoint in svg renderer is the default Blank endpoint.
     */
    _jp.Endpoints.svg.Blank = _jp.Endpoints.Blank;
    /*
     * Label overlay in svg renderer is the default Label overlay.
     */
    _jp.Overlays.svg.Label = _jp.Overlays.Label;
    /*
     * Custom overlay in svg renderer is the default Custom overlay.
     */
    _jp.Overlays.svg.Custom = _jp.Overlays.Custom;

    var AbstractSvgArrowOverlay = function (superclass, originalArgs) {
        superclass.apply(this, originalArgs);
        _jp.jsPlumbUIComponent.apply(this, originalArgs);
        this.isAppendedAtTopLevel = false;
        var self = this;
        this.path = null;
        this.paint = function (params, containerExtents) {
            // only draws on connections, not endpoints.
            if (params.component.svg && containerExtents) {
                if (this.path == null) {
                    this.path = _node("path", {
                        "pointer-events": "all"
                    });
                    params.component.svg.appendChild(this.path);

                    this.canvas = params.component.svg; // for the sake of completeness; this behaves the same as other overlays
                }
                var clazz = originalArgs && (originalArgs.length == 1) ? (originalArgs[0].cssClass || "") : "",
                    offset = [0, 0];

                if (containerExtents.xmin < 0) offset[0] = -containerExtents.xmin;
                if (containerExtents.ymin < 0) offset[1] = -containerExtents.ymin;

                _attr(this.path, {
                    "d": makePath(params.d),
                    "class": clazz,
                    stroke: params.strokeStyle ? params.strokeStyle : null,
                    fill: params.fillStyle ? params.fillStyle : null,
                    transform: "translate(" + offset[0] + "," + offset[1] + ")"
                });
            }
        };
        var makePath = function (d) {
            return (isNaN(d.cxy.x) || isNaN(d.cxy.y)) ? "" : "M" + d.hxy.x + "," + d.hxy.y +
                " L" + d.tail[0].x + "," + d.tail[0].y +
                " L" + d.cxy.x + "," + d.cxy.y +
                " L" + d.tail[1].x + "," + d.tail[1].y +
                " L" + d.hxy.x + "," + d.hxy.y;
        };
        this.transfer = function(target) {
            if (target.canvas && this.path && this.path.parentNode) {
                this.path.parentNode.removeChild(this.path);
                target.canvas.appendChild(this.path);
            }
        };
    };
    _ju.extend(AbstractSvgArrowOverlay, [_jp.jsPlumbUIComponent, _jp.Overlays.AbstractOverlay], {
        cleanup: function (force) {
            if (this.path != null) {
                if (force)
                    this._jsPlumb.instance.removeElement(this.path);
                else
                    if (this.path.parentNode)
                        this.path.parentNode.removeChild(this.path);
            }
        },
        reattach:function(instance) {
            if (this.path && this.canvas && this.path.parentNode == null)
                this.canvas.appendChild(this.path);
        },
        setVisible: function (v) {
            if (this.path != null) (this.path.style.display = (v ? "block" : "none"));
        }
    });

    _jp.Overlays.svg.Arrow = function () {
        AbstractSvgArrowOverlay.apply(this, [_jp.Overlays.Arrow, arguments]);
    };
    _ju.extend(_jp.Overlays.svg.Arrow, [ _jp.Overlays.Arrow, AbstractSvgArrowOverlay ]);

    _jp.Overlays.svg.PlainArrow = function () {
        AbstractSvgArrowOverlay.apply(this, [_jp.Overlays.PlainArrow, arguments]);
    };
    _ju.extend(_jp.Overlays.svg.PlainArrow, [ _jp.Overlays.PlainArrow, AbstractSvgArrowOverlay ]);

    _jp.Overlays.svg.Diamond = function () {
        AbstractSvgArrowOverlay.apply(this, [_jp.Overlays.Diamond, arguments]);
    };
    _ju.extend(_jp.Overlays.svg.Diamond, [ _jp.Overlays.Diamond, AbstractSvgArrowOverlay ]);

    // a test
    _jp.Overlays.svg.GuideLines = function () {
        var path = null, self = this, p1_1, p1_2;
        _jp.Overlays.GuideLines.apply(this, arguments);
        this.paint = function (params, containerExtents) {
            if (path == null) {
                path = _node("path");
                params.connector.svg.appendChild(path);
                self.attachListeners(path, params.connector);
                self.attachListeners(path, self);

                p1_1 = _node("path");
                params.connector.svg.appendChild(p1_1);
                self.attachListeners(p1_1, params.connector);
                self.attachListeners(p1_1, self);

                p1_2 = _node("path");
                params.connector.svg.appendChild(p1_2);
                self.attachListeners(p1_2, params.connector);
                self.attachListeners(p1_2, self);
            }

            var offset = [0, 0];
            if (containerExtents.xmin < 0) offset[0] = -containerExtents.xmin;
            if (containerExtents.ymin < 0) offset[1] = -containerExtents.ymin;

            _attr(path, {
                "d": makePath(params.head, params.tail),
                stroke: "red",
                fill: null,
                transform: "translate(" + offset[0] + "," + offset[1] + ")"
            });

            _attr(p1_1, {
                "d": makePath(params.tailLine[0], params.tailLine[1]),
                stroke: "blue",
                fill: null,
                transform: "translate(" + offset[0] + "," + offset[1] + ")"
            });

            _attr(p1_2, {
                "d": makePath(params.headLine[0], params.headLine[1]),
                stroke: "green",
                fill: null,
                transform: "translate(" + offset[0] + "," + offset[1] + ")"
            });
        };

        var makePath = function (d1, d2) {
            return "M " + d1.x + "," + d1.y +
                " L" + d2.x + "," + d2.y;
        };
    };
    _ju.extend(_jp.Overlays.svg.GuideLines, _jp.Overlays.GuideLines);
}).call(this);

/*
 * jsPlumb
 * 
 * Title:jsPlumb 2.0.2
 * 
 * Provides a way to visually connect elements on an HTML page, using SVG.
 * 
 * This file contains the 'vanilla' adapter - having no external dependencies other than bundled libs.
 *
 * Copyright (c) 2010 - 2015 jsPlumb (hello@jsplumbtoolkit.com)
 * 
 * http://jsplumbtoolkit.com
 * http://github.com/sporritt/jsplumb
 * 
 * Dual licensed under the MIT and GPL2 licenses.
 */
;
(function () {

    "use strict";
    var root = this, _jp = root.jsPlumb, _ju = root.jsPlumbUtil,
        _jk = root.Katavorio, _jg = root.Biltong;

    var _getDragManager = function (instance, category) {

        category = category || "main";
        var key = "_katavorio_" + category;
        var k = instance[key],
            e = instance.getEventManager();

        if (!k) {
            k = new _jk({
                bind: e.on,
                unbind: e.off,
                getSize: jsPlumb.getSize,
                getPosition: function (el) {
                    // if this is a nested draggable then compute the offset against its own offsetParent, otherwise
                    // compute against the Container's origin. see also the getUIPosition method below.
                    var o = instance.getOffset(el, false, el._katavorioDrag ? el.offsetParent : null);
                    return [o.left, o.top];
                },
                setPosition: function (el, xy) {
                    el.style.left = xy[0] + "px";
                    el.style.top = xy[1] + "px";
                },
                addClass: jsPlumb.addClass,
                removeClass: jsPlumb.removeClass,
                intersects: _jg.intersects,
                indexOf: function(l, i) { return l.indexOf(i); },
                css: {
                    noSelect: instance.dragSelectClass,
                    droppable: "jsplumb-droppable",
                    draggable: "jsplumb-draggable",
                    drag: "jsplumb-drag",
                    selected: "jsplumb-drag-selected",
                    active: "jsplumb-drag-active",
                    hover: "jsplumb-drag-hover"
                }
            });
            instance[key] = k;
            instance.bind("zoom", k.setZoom);
        }
        return k;
    };

    var _animProps = function (o, p) {
        var _one = function (pName) {
            if (p[pName] != null) {
                if (_ju.isString(p[pName])) {
                    var m = p[pName].match(/-=/) ? -1 : 1,
                        v = p[pName].substring(2);
                    return o[pName] + (m * v);
                }
                else return p[pName];
            }
            else
                return o[pName];
        };
        return [ _one("left"), _one("top") ];
    };

    _jp.extend(root.jsPlumbInstance.prototype, {

        animationSupported:true,
        getElement: function (el) {
            if (el == null) return null;
            // here we pluck the first entry if el was a list of entries.
            // this is not my favourite thing to do, but previous versions of
            // jsplumb supported jquery selectors, and it is possible a selector
            // will be passed in here.
            el = typeof el === "string" ? el : el.length != null && el.enctype == null ? el[0] : el;
            return typeof el === "string" ? document.getElementById(el) : el;
        },
        removeElement: function (element) {
            _getDragManager(this).elementRemoved(element);
            this.getEventManager().remove(element);
        },
        //
        // this adapter supports a rudimentary animation function. no easing is supported.  only
        // left/top properties are supported. property delta args are expected to be in the form
        //
        // +=x.xxxx
        //
        // or
        //
        // -=x.xxxx
        //
        doAnimate: function (el, properties, options) {
            options = options || {};
            var o = this.getOffset(el),
                ap = _animProps(o, properties),
                ldist = ap[0] - o.left,
                tdist = ap[1] - o.top,
                d = options.duration || 250,
                step = 15, steps = d / step,
                linc = (step / d) * ldist,
                tinc = (step / d) * tdist,
                idx = 0,
                int = setInterval(function () {
                    jsPlumb.setPosition(el, {
                        left: o.left + (linc * (idx + 1)),
                        top: o.top + (tinc * (idx + 1))
                    });
                    if (options.step != null) options.step(idx, Math.ceil(steps));
                    idx++;
                    if (idx >= steps) {
                        window.clearInterval(int);
                        if (options.complete != null) options.complete();
                    }
                }, step);
        },
        // DRAG/DROP
        destroyDraggable: function (el, category) {
            _getDragManager(this, category).destroyDraggable(el);
        },
        destroyDroppable: function (el, category) {
            _getDragManager(this, category).destroyDroppable(el);
        },
        initDraggable: function (el, options, category) {
            _getDragManager(this, category).draggable(el, options);
        },
        initDroppable: function (el, options, category) {
            _getDragManager(this, category).droppable(el, options);
        },
        isAlreadyDraggable: function (el) {
            return el._katavorioDrag != null;
        },
        isDragSupported: function (el, options) {
            return true;
        },
        isDropSupported: function (el, options) {
            return true;
        },
        isElementDraggable: function (el) {
            el = jsPlumb.getElement(el);
            return el._katavorioDrag && el._katavorioDrag.isEnabled();
        },
        getDragObject: function (eventArgs) {
            return eventArgs[0].drag.getDragElement();
        },
        getDragScope: function (el) {
            return el._katavorioDrag && el._katavorioDrag.scopes.join(" ") || "";
        },
        getDropEvent: function (args) {
            return args[0].e;
        },
        getUIPosition: function (eventArgs, zoom) {
            // here the position reported to us by Katavorio is relative to the element's offsetParent. For top
            // level nodes that is fine, but if we have a nested draggable then its offsetParent is actually
            // not going to be the jsplumb container; it's going to be some child of that element. In that case
            // we want to adjust the UI position to account for the offsetParent's position relative to the Container
            // origin.
            var el = eventArgs[0].el;
            var p = { left:eventArgs[0].pos[0], top:eventArgs[0].pos[1] };
            if (el._katavorioDrag && el.offsetParent !== this.getContainer()) {
                var oc = this.getOffset(el.offsetParent);
                p.left += oc.left;
                p.top += oc.top;
            }
            return p;
        },
        setDragFilter: function (el, filter, _exclude) {
            if (el._katavorioDrag) {
                el._katavorioDrag.setFilter(filter, _exclude);
            }
        },
        setElementDraggable: function (el, draggable) {
            el = jsPlumb.getElement(el);
            if (el._katavorioDrag)
                el._katavorioDrag.setEnabled(draggable);
        },
        setDragScope: function (el, scope) {
            if (el._katavorioDrag)
                el._katavorioDrag.k.setDragScope(el, scope);
        },
        setDropScope:function(el, scope) {
            if (el._katavorioDrop && el._katavorioDrop.length > 0) {
                el._katavorioDrop[0].k.setDropScope(el, scope);
            }
        },
        addToPosse:function(el, spec) {
            var specs = Array.prototype.slice.call(arguments, 1);
            var dm = _getDragManager(this);
            jsPlumb.each(el, function(_el) {
                _el = [ jsPlumb.getElement(_el) ];
                _el.push.apply(_el, specs );
                dm.addToPosse.apply(dm, _el);
            });
        },
        removeFromPosse:function(el, posseId) {
            var specs = Array.prototype.slice.call(arguments, 1);
            var dm = _getDragManager(this);
            jsPlumb.each(el, function(_el) {
                _el = [ jsPlumb.getElement(_el) ];
                _el.push.apply(_el, specs );
                dm.removeFromPosse.apply(dm, _el);
            });
        },
        removeFromAllPosses:function(el) {
            var dm = _getDragManager(this);
            jsPlumb.each(el, function(_el) { dm.removeFromAllPosses(jsPlumb.getElement(_el)); });
        },
        dragEvents: {
            'start': 'start', 'stop': 'stop', 'drag': 'drag', 'step': 'step',
            'over': 'over', 'out': 'out', 'drop': 'drop', 'complete': 'complete',
            'beforeStart':'beforeStart'
        },
        animEvents: {
            'step': "step", 'complete': 'complete'
        },
        stopDrag: function (el) {
            if (el._katavorioDrag)
                el._katavorioDrag.abort();
        },
        addToDragSelection: function (spec) {
            _getDragManager(this).select(spec);
        },
        removeFromDragSelection: function (spec) {
            _getDragManager(this).deselect(spec);
        },
        clearDragSelection: function () {
            _getDragManager(this).deselectAll();
        },
        trigger: function (el, event, originalEvent, payload) {
            this.getEventManager().trigger(el, event, originalEvent, payload);
        },
        doReset:function() {
            // look for katavorio instances and reset each one if found.
            for (var key in this) {
                if (key.indexOf("_katavorio_") === 0) {
                    this[key].reset();
                }
            }
        }
    });

    var ready = function (f) {
        var _do = function () {
            if (/complete|loaded|interactive/.test(document.readyState) && typeof(document.body) != "undefined" && document.body != null)
                f();
            else
                setTimeout(_do, 9);
        };

        _do();
    };
    ready(_jp.init);

}).call(this);
</script>

<dom-module id="nuxeo-workflow-graph" assetpath="nuxeo-workflow-graph/">
  <template>
    <style>
      :host {
        display: block;
      }

      #container {
        position: relative;
        width: 880px;
        height: 720px;
      }

      .workflow_node {
        position: absolute;
        text-align: center;
        font-size: .92em;
        z-index: 100;
      }

      .workflow_simple_task,
      .workflow_multiple_task {
        height: 80px;
        width: 80px;
        color: #006da6;
        padding-top: 1.2em;
        background-color: #f7f8f9;
        border-radius: 0.5em;
        box-sizing: border-box;
      }

      .workflow_simple_task {
        border: 1px solid #3c9ae2;
      }

      .workflow_multiple_task {
        border: 3px double #3c9ae2;
      }

      .workflow_fork_node,
      .workflow_merge_node {
        width: 0;
        height: 0;
        border-bottom: 40px solid #a4c9da;
        border-left: 20px solid transparent;
        border-right: 20px solid transparent;
        line-height: 100%;
      }

      .workflow_merge_node {
        border-top: 40px solid #dededd;
        border-bottom: 0;
        line-height: 0;
      }

      .workflow_start_node,
      .workflow_end_node {
        width: 40px;
        height: 40px;
        background: #92c938;
        border-radius: 40px;
        color: #fff;
        line-height: 40px;
      }

      .workflow_end_node {
        background: #f04545;
      }

      .workflow_subworkflow_task {
        border: 2px solid #3c9ae2;
        /*background: url("icons/subworkflow_bg_node.png") no-repeat scroll right bottom white*/
      }

      .workflow_node_suspended {
        background-color: #3c9ae2;
        font-weight: bold;
        color: #fff;
      }

      .workflow_connection_label {
        background-color: white;
        padding: .15em .25em;
        font: 12px sans-serif;
        color: #3780b9;
        z-index: 120;
        border: 1px dotted rgba(0, 0, 0, 0.2);
        opacity: 0.85;
        filter: alpha(opacity = 85);
        max-width: 170px;
        word-wrap: break-word;
        transform: none !important;
      }

      .jsplumb-endpoint {
        z-index: 110;
      }

      .jsplumb-overlay {
        z-index: 6;
      }
    </style>

    <nuxeo-resource id="graphResource" path="/workflow/[[workflowId]]/graph" response="{{graph}}" headers="{&quot;Content-Type&quot;:&quot;application/json&quot;}"></nuxeo-resource>

    <nuxeo-dialog id="graphDialog" with-backdrop="">
      <paper-dialog-scrollable>
        <div class="graph-container">
          <div id="container"></div>
        </div>
      </paper-dialog-scrollable>
      <div class="buttons">
        <paper-button noink="" class="primary" dialog-dismiss="">[[i18n('command.close')]]</paper-button>
      </div>
    </nuxeo-dialog>
  </template>

  <script>
    Polymer({
      is: 'nuxeo-workflow-graph',
      behaviors: [Nuxeo.I18nBehavior, Polymer.IronResizableBehavior],
      properties: {
        workflowId: {
          type: String
        },

        graph: {
          type: Object
        },

        dynamicAnchors: {
          type: Array,
          value: [0.5, 0.25, 0.75, 0, 1, 0.375, 0.625, 0.125, 0.875]
        },

        connectionColors: {
          type: Array,
          value: ['#92e1aa', '#F7BE81', '#BDBDBD', '#5882FA', '#E1F5A9',
            '#FA5858', '#FFFF00', '#FF0000', '#D8F781']
        },

        sourceEndpointOptions: {
          type: Object,
          value: {
            connector: ['Flowchart', {cornerRadius: 5}],
            paintStyle: {
              fillStyle: '#92e1aa'
            },
            isSource: true,
            isTarget: false,
            uniqueEndpoint: true,
            maxConnections: 1
          }
        },

        targetEndpointOptions: {
          type: Object,
          value: {
            paintStyle: {
              fillStyle: '#003f7d'
            },
            isSource: false,
            isTarget: true,
            reattach: true,
            // without specifying this the targetEndpoint doesn't accept multiple connections
            maxConnections: -1
          }
        },

        _jsPlumbInstance: {
          type: Object
        }
      },

      observers: [
        '_updateGraph(graph)'
      ],

      listeners: {
        'iron-resize': '_resize'
      },

      ready: function() {
        this.scopeSubtree(this.$.container, true);
        this._initialize();
      },

      show: function() {
        this.$.graphResource.execute().then(function() {
          this.$.graphDialog.toggle();
        }.bind(this)).catch(function(error) {
          this.fire('notify', {message: this.i18n('documentPage.route.view.graph.error')});
          throw error;
        });
      },

      _initialize: function() {
        this._jsPlumbInstance = jsPlumb.getInstance({
          DragOptions: {
            cursor: 'pointer',
            zIndex: 2000
          },
          PaintStyle: {
            strokeStyle: '#92e1aa',
            lineWidth: 3,
            outlineWidth: 2,
            outlineColor: 'white',
            joinstyle: 'round'
          },
          Endpoint: ['Dot', {
            radius: 6
          }],
          ConnectionOverlays: [['Arrow', {
            location: 0.8
          }, {
            foldback: 0.9,
            fillStyle: '#92e1aa',
            width: 14
          }]]
        });
        this._jsPlumbInstance.setContainer(this.$.container);
      },

      _transitionOverlay: function(transition) {
        return [
          ['Arrow', {location: 0.8}, {foldback: 0.9, fillStyle: '#92e1aa', width: 14}],
          ['Label', {
            label: '<span title="' + transition.label + '">' + transition.label + '</span>',
            cssClass: 'workflow_connection_label',
            location: 0.6
          }]
        ];
      },

      _nodeClass: function(node) {
        if (node.isStartNode) {
          return 'workflow_start_node';
        } else if (node.isEndNode) {
          return 'workflow_end_node';
        } else if (node.isMerge) {
          return 'workflow_merge_node';
        } else if (node.isMultiTask) {
          return 'workflow_multiple_task';
        } else if (node.hasSubWorkflow) {
          return 'workflow_subworkflow_task';
        } else {
          return 'workflow_simple_task';
        }
      },

      _updateGraph: function(data) {
        if (!data) {
          return;
        }

        // clear when re-rendering
        while (this.$.container.firstChild) {
          this.$.container.removeChild(this.$.container.firstChild);
        }
        this._jsPlumbInstance.reset();

        // XXX: build these in the template
        data.nodes.forEach(function(node) {
          var element = this.create('div', {id: node.id, innerHTML: node.title});
          element.style.left = node.x + 'px';
          element.style.top = node.y + 'px';

          element.classList.add('workflow_node');
          element.classList.add(this._nodeClass(node));
          if (node.state === 'suspended') {
            element.classList.add('workflow_node_suspended');
          }
          this.$.container.appendChild(element);
        }.bind(this));

        // initialize connection source points
        var nodes = [];

        // determine number of source endpoints per node
        var sourceEndpoints = {};
        data.transitions.forEach(function(transition) {
          sourceEndpoints[transition.nodeSourceId] = (sourceEndpoints[transition.nodeSourceId] || 0) + 1;
        });

        // use fixed dynamic anchors, only 9 items supported, after this everything
        // is displayed on the center
        data.transitions.forEach(function(transition) {
          var source = transition.nodeSourceId,
              target = transition.nodeTargetId;

          var anchorIndex = nodes.filter(function(v) { return v === source; }).length;
          if (anchorIndex > 9) {
            anchorIndex = 0;
          }
          nodes.push(source);

          // determine anchors for transition node
          var anchors = this.dynamicAnchors.slice(0, sourceEndpoints[source]).sort();
          // add endpoints
          var endPointSource = this._addSourceEndpoint(Polymer.dom(this.$.container).querySelector('#' + source),
                anchors[anchorIndex]),
              endPointTarget = this._addTargetEndpoint(Polymer.dom(this.$.container).querySelector('#' + target));

          var connection = this._jsPlumbInstance.connect({
            connector: 'Flowchart',
            source: endPointSource,
            target: endPointTarget,
            overlays: this._transitionOverlay(transition),
            paintStyle: {
              lineWidth: 3,
              strokeStyle: this.connectionColors[anchorIndex],
              outlineWidth: 2,
              outlineColor: 'white',
              joinstyle: 'round'
            },
            detachable: false
          });

          // prepare the transition's path
          // ignore paths with only one segment
          var segments = [];
          if (transition.path && transition.path.length > 2) {
            for (var i = 1; i < transition.path.length; i++) {
              segments.push({
                start: [transition.path[i - 1].x, transition.path[i - 1].y],
                end: [transition.path[i].x, transition.path[i].y]
              });
            }
            connection.connector.setPath(segments);
          }
        }.bind(this));
      },

      _addTargetEndpoint: function(target) {
        return this._jsPlumbInstance.addEndpoint(target, {anchor: 'TopCenter'}, this.targetEndpointOptions);
      },

      _addSourceEndpoint: function(source, pos) {
        var anchor = [pos, 1, 0, 1];
        return this._jsPlumbInstance.addEndpoint(source, {anchor: anchor}, this.sourceEndpointOptions);
      },

      _resize: function() {
        this._jsPlumbInstance.repaintEverything();
      }

    });
  </script>

</dom-module>
<dom-module id="nuxeo-document-info-bar" assetpath="nuxeo-document-info-bar/">
  <template>

    <style include="nuxeo-styles iron-flex">
      .bar {
        @apply --layout-horizontal;
        @apply --layout-center;
        @apply --layout-justified;
        padding: 8px;
        margin-bottom: 16px;
        box-shadow: 0 3px 5px rgba(0, 0, 0, 0.04);
        background-color: var(--nuxeo-box);
      }

      .bar.task {
        background: black;
        color: white;
      }

      .item {
        @apply --layout-horizontal;
        @apply --layout-center;
        @apply --layout-flex;
      }

      a.viewGraph {
        text-decoration: underline;
        margin-right: 1em;
      }

      iron-icon {
        margin: 0 .5em;
        width: 1.5em;
      }
    </style>

    <nuxeo-connection id="nxcon" user="{{currentUser}}"></nuxeo-connection>

    <nuxeo-resource id="worfklow" path="/workflow"></nuxeo-resource>
    <nuxeo-resource id="task" path="/task" headers="{&quot;X-NXfetch.task&quot;: &quot;targetDocumentIds,actors&quot;}"></nuxeo-resource>
    <nuxeo-resource id="user" path="/user"></nuxeo-resource>

    <template is="dom-repeat" items="[[workflows]]" as="workflow">
      <nuxeo-workflow-graph id="graph-[[workflow.id]]" workflow-id="[[workflow.id]]"></nuxeo-workflow-graph>
      <div class="bar workflow">
        <div class="item">
          <iron-icon class="icon" icon="icons:perm-data-setting"></iron-icon>
          <template is="dom-if" if="[[!_isCurrentUser(workflow.initiator, currentUser)]]">
            <nuxeo-user-tag user="[[workflow.initiator]]"></nuxeo-user-tag>
          </template>
          <span>[[_labelForInitiatedWf(workflow, currentUser)]]</span>
        </div>
        <a class="viewGraph" on-tap="_toggleGraphDialog">[[i18n('documentPage.route.view.graph')]]</a>
        <template is="dom-if" if="[[_hasPermissionToAbandon(workflow.initiator, currentUser)]]">
          <paper-button class="primary" on-tap="_abandonWorkflow" noink="">[[i18n('documentPage.abandon.workflow')]]</paper-button>
        </template>
      </div>
    </template>

    <template is="dom-repeat" items="[[tasks]]" as="task">
      <div class="bar task">
        <div class="item">
          <iron-icon class="icon" icon="icons:assignment-turned-in"></iron-icon>
          <span>[[i18n('documentPage.to.process')]]
            <nuxeo-date datetime="[[task.dueDate]]"></nuxeo-date>
          </span>
        </div>
        <paper-button class="primary" on-tap="_processTask" noink="">[[i18n('documentPage.process.task')]]</paper-button>
      </div>
    </template>

    <template is="dom-if" if="[[isTrashed(document)]]">
      <div id="trashedInfoBar" class="bar trashed">
        <div class="layout horizontal center flex">
          <iron-icon icon="icons:info"></iron-icon>
          <span>[[i18n('documentPage.trash.info')]]</span>
        </div>
        <template is="dom-if" if="[[!hasPermission(document, 'Write')]]">
          <div>[[i18n('documentPage.trash.noPermissionToRestore')]]</div>
        </template>
        <template is="dom-if" if="[[hasPermission(document, 'Write')]]">
          <nuxeo-untrash-document-button document="[[document]]"></nuxeo-untrash-document-button>
        </template>
        <template is="dom-if" if="[[hasPermission(document, 'Everything')]]">
          <nuxeo-delete-document-button document="[[document]]" hard=""></nuxeo-delete-document-button>
        </template>
      </div>
    </template>

    <template is="dom-if" if="[[isVersion(document)]]">
      <div id="versionInfoBar" class="bar version">
        <div class="layout horizontal center">
          <iron-icon icon="icons:info"></iron-icon>
          <span>[[i18n('versions.info', document.properties.uid:major_version, document.properties.uid:minor_version)]]</span>
        </div>
        <nuxeo-restore-version-button document="[[document]]"></nuxeo-restore-version-button>
      </div>
    </template>

    <template is="dom-if" if="[[isPublication(document)]]">
      <nuxeo-publication-info-bar document="[[document]]"></nuxeo-publication-info-bar>
    </template>

  </template>

  <script>
    Polymer({
      is: 'nuxeo-document-info-bar',
      behaviors: [Nuxeo.LayoutBehavior],
      properties: {
        document: {
          type: Object
        },
        tasks: {
          type: Array,
          computed: '_tasks(document)'
        },
        workflows: {
          type: Array,
          computed: '_workflows(document)'
        },
        _wfTasks: Array
      },

      _tasks: function(doc) {
        return doc && doc.contextParameters && doc.contextParameters.pendingTasks
          ? doc.contextParameters.pendingTasks : [];
      },

      _workflows: function(doc) {
        return doc && doc.contextParameters && doc.contextParameters.runningWorkflows
          ? doc.contextParameters.runningWorkflows : [];
      },

      _processTask: function(e) {
        this.fire('workflowTaskProcess', { task: e.model.task });
      },

      ready: function() {
        this.$.nxcon.connect().then(function(user) {
          this.currentUser = user;
        }.bind(this))
      },

      _isCurrentUser: function(userId) {
        return this.currentUser && this.currentUser.id === userId;
      },

      _labelForInitiatedWf: function(workflow) {
        if (this._isCurrentUser(workflow.initiator)) {
          return this.i18n('documentPage.initiated.workflow.currentUser', this.i18n(workflow.title));
        } else {
          return this.i18n('documentPage.initiated.workflow', this.i18n(workflow.title));
        }
      },

      _abandonWorkflow: function(e) {
        if (confirm(this.i18n('documentPage.abandon.workflow.confirm'))) {
          this.$.worfklow.path = '/workflow/' + e.model.workflow.id;
          this.$.worfklow.remove().then(function() {
            this.fire('workflowAbandoned', { workflow: e.model.workflow });
          }.bind(this));
        }
      },

      /**
       * Checks if current user has permission to abandon a workflow.
       */
      _hasPermissionToAbandon: function(initiator) {
        return this._isCurrentUser(initiator) || (this.currentUser && this.currentUser.isAdministrator);
      },

      _toggleGraphDialog: function(e) {
        this.$$('#graph-' + e.model.workflow.id).show();
      }

    });
  </script>
</dom-module>
<dom-module id="nuxeo-document-versions-list" assetpath="nuxeo-document-versions/">
  <template>
    <style include="paper-material-styles">
      :host {
        display: inline-block;
        background: var(--nuxeo-box);
        @apply --paper-material-elevation-1;
      }

      #list-actions {
        @apply --layout-vertical;
        @apply --layout-center;
        @apply --buttons-bar;
        padding: 8px;
      }
    </style>

    <div id="list-items">
      <slot name="items"></slot>
    </div>

    <div id="list-actions">
      <slot name="actions"></slot>
    </div>

  </template>

  <script>
    Polymer({
      is: 'nuxeo-document-versions-list',

      behaviors: [
        Polymer.IronOverlayBehavior
      ],

      ready: function() {
        this.horizontalAlign = 'left';
        this.verticalAlign = 'auto';
      }

    });
  </script>
</dom-module>
<dom-module id="nuxeo-dropzone" assetpath="nuxeo-dropzone/">
  <template>
    <style include="nuxeo-styles">
      :host {
        display: block;
      }

      label {
        margin-bottom: 8px;
      }

      label.dragging {
        color: var(--paper-input-container-focus-color);
      }

      a, a:active, a:visited, a:focus {
        color: var(--nuxeo-secondary-color, #0066ff);
        text-decoration: underline;
      }

      #dropzone {
        overflow: auto;
        height: 100%;
      }

      #container {
        @apply --layout-vertical;
        @apply --layout-center;
        @apply --layout-flex;
        @apply --layout-center-justified;
        border-radius: 2px;
        border: 1px dashed var(--paper-input-container-color);
        min-height: 64px;
        height: calc(100% - 2px);
      }

      #container.dragging {
        border: 1px dashed var(--paper-input-container-focus-color);
        background: rgba(0, 0, 0, 0.01);
      }

      #container .actions {
        text-align: center;
        @apply --layout-horizontal;
        @apply --layout-wrap;
      }

      #details {
        border: 1px solid var(--nuxeo-border, rgba(0,0,0,0.15));
        padding: 16px;
        margin-bottom: 8px;
      }

      .file {
        @apply --layout-horizontal;
        @apply --layout-center;
      }

      .file .info {
        @apply --layout-vertical;
        @apply --layout-flex;
      }

      .file .info .name {
        font-weight: 500;
      }

      .file .info .size {
        opacity: .5;
        margin: 4px 0;
      }

      .file .info .progress {
        width: 100%;
        padding: 8px 0;
      }

      .file .actions {
        margin-left: 16px;
      }

      .actions > * {
        margin-left: 8px;
      }
    </style>

    <nuxeo-connection id="nx"></nuxeo-connection>
    <nuxeo-document id="doc" doc-id="[[document.uid]]" enrichers="[[enrichers]]"></nuxeo-document>

    <template is="dom-if" if="[[label]]">
      <label id="label">[[label]]</label>
    </template>

    <input hidden="" id="input" type="file" on-change="_uploadInputFiles">

    <div id="details" hidden$="[[!hasFiles]]">
      <template is="dom-repeat" items="[[files]]" as="file">
        <div class="file">
          <div class="info">
            <div class="name">[[file.name]]</div>
            <div class="size">[[formatSize(file.size)]]</div>
            <template is="dom-if" if="[[uploading]]">
              <paper-progress class="progress" indeterminate="[[!hasProgress()]]" value="[[file.progress]]"></paper-progress>
            </template>
          </div>
          <div class="actions" hidden$="[[!_areActionsVisible(hasFiles, updateDocument, uploading)]]">
            <paper-icon-button noink="" icon="nuxeo:delete" on-tap="_deleteFile"></paper-icon-button>
          </div>
        </div>
      </template>
    </div>

    <div id="dropzone" hidden$="[[!_isDropzoneVisible(hasFiles, updateDocument, blobList)]]">
      <div id="container">
        <a href="javascript:undefined" on-tap="open">[[i18n(message)]]</a>
        <div class="actions">
          <nuxeo-slot slot="FILE_UPLOAD_ACTIONS"></nuxeo-slot>
        </div>
      </div>
    </div>

  </template>

  <script>
    Polymer({
      is: 'nuxeo-dropzone',
      behaviors: [Nuxeo.UploaderBehavior, Nuxeo.FormatBehavior],
      properties: {
        /**
         * Input Document.
         */
        document: {
          type: Object,
          notify: true
        },
        /**
         * The label for this element.
         */
        label: {
          type: String
        },
        /**
         * Dropzone clickable link translated text or key to be translated.
         * By default it will show: 'Upload main file'.
         */
        message: {
          type: String,
          value: 'dropzone.add'
        },
        /**
         * This flag determines whether the dropzone allows multiple files or not.
         */
        blobList: {
          type: Boolean,
          value: false
        },
        /**
         * Path to which the file(s) should be uploaded.
         * For example `xpath="files:files"`.
         * By default it will consider `file:content`.
         */
        xpath: {
          type: String,
          value: 'file:content'
        },
        /**
         * This flag determines whether the file should be immediately uploaded or not.
         */
        updateDocument: {
          type: Boolean,
          value: false,
          reflectToAttribute: true
        },
        /**
         * Message to show when file is uploaded successfully.
         * It expects translated text or a key to be translated.
         * By default it will show: 'File uploaded'.
         */
        uploadedMessage: {
          type: String,
          value: 'dropzone.uploaded'
        },
        /**
         * Flag that indicates if there are already uploaded files on the dropzone.
         */
        hasFiles: {
          type: Boolean,
          readOnly: true,
          value: false,
          notify: true,
        },
        /**
         * A string containing an xpath expression, connected by dot (.) characters instead of slashes (/).
         */
        _parsedXpath: {
          type: String,
          computed: '_computeParsedXpath(xpath)'
        },
        /**
         * Content enrichers to be passed on to `nuxeo-document` resource.
         * Can be an object with entity type as keys or list or string (which defaults to `document` entity type).
         */
        enrichers: {
          type: Object,
          value: function() {
            return this._computeEnrichers();
          }
        }
      },

      listeners: {
        'batchFinished': 'importBatch',
        'nx-blob-picked': '_blobPicked'
      },

      observers: [
        '_reset(document)',
        '_filesChanged(files.splices)'
      ],

      attached: function() {
        this.connection = this.$.nx;
        this.setupDropZone(this.$.dropzone);
      },

      detached: function() {
        this.connection = null;
        this.teardownDropZone();
      },

      open: function() {
        this.$$('input').click();
      },

      _computeParsedXpath: function(xpath) {
        return this.formatPropertyXpath(xpath);
      },

      importBatch: function(data) {
        data.stopPropagation();
        if (this.blobList) {
          if (!this.get('document.properties.' + this._parsedXpath)) {
            this.set('document.properties.' + this._parsedXpath, []);
          }
          this.files.forEach(function(file, index) {
            var uploadedFile = {
              'upload-batch': data.detail.batchId,
              'upload-fileId': index.toString()
            };
            this.push('document.properties.' + this._parsedXpath,
              // Handle special case when using files:files
              this.xpath === 'files:files' ? { file: uploadedFile } : uploadedFile);
          }.bind(this));
        } else {
          this.set('document.properties.' + this._parsedXpath, {
            'upload-batch': data.detail.batchId,
            'upload-fileId': '0'
          });
        }
        this._handleBlobUploaded();
      },

      _blobPicked: function(e) {
        this.set('files', e.detail.blobs);
        if (this.blobList) {
          if (!this.get('document.properties.' + this._parsedXpath)) {
            this.set('document.properties.' + this._parsedXpath, []);
          }
          this.files.forEach(function(file) {
            var uploadedFile = {
              'providerId': file.providerId,
              'user': file.user,
              'fileId': file.fileId
            };
            this.push('document.properties.' + this._parsedXpath,
              // Handle special case when using files:files
              this.xpath === 'files:files' ? { file: uploadedFile } : uploadedFile);
          }.bind(this));
        } else {
          var file = e.detail.blobs[0];
          this.set('document.properties.' + this._parsedXpath, {
            'providerId': file.providerId,
            'user': file.user,
            'fileId': file.fileId
          });
        }
        this._handleBlobUploaded();
      },

      _handleBlobUploaded: function() {
        if (this.updateDocument) {
          var props = {};
          this._createNestedObjectRecursive(
            props, this._parsedXpath.split('.'),
            this.get('document.properties.' + this._parsedXpath)
          );
          this.$.doc.data = {
            "entity-type": "document",
            "repository": this.document.repository,
            "uid": this.document.uid,
            "properties": props
          };
          this.$.doc.put().then(function(response) {
            this.document = response;
            this.fire('notify', { message: this.i18n(this.uploadedMessage) });
            this.fire('document-updated');
          }.bind(this));
        } else {
          this.fire('notify', { message: this.i18n(this.uploadedMessage) });
        }
      },

      _deleteFile: function(e) {
        if (!this.updateDocument && this.blobList && Array.isArray(this.get('document.properties.' + this._parsedXpath))) {
          this.splice('document.properties.' + this._parsedXpath, e.model.itemsIndex, 1);
          this.splice('files', e.model.itemsIndex, 1);
        } else {
          this._reset();
          this.set('document.properties.' + this._parsedXpath, '');
        }
      },

      _reset: function(document) {
        if (document === undefined) {
          this.cancelBatch();
        }
        this.$.input.value = '';
        this.files = [];
      },

      _uploadInputFiles: function(e) {
        this._upload(e.target.files);
      },

      _filesChanged: function() {
        this._setHasFiles(this.files.length > 0);
      },

      _upload: function(files) {
        if (files && files.length > 0) {
          this.uploadFiles(files);
        }
      },

      _dragover: function(e) {
        e.preventDefault();
        this.toggleClass('dragging', true, this.$.label);
        this.toggleClass('dragging', true, this.$.container);
      },

      _dragleave: function() {
        this.toggleClass('dragging', false, this.$.label);
        this.toggleClass('dragging', false, this.$.container);
      },

      _drop: function(e) {
        e.preventDefault();
        this.toggleClass('dragging', false, this.$.label);
        this.toggleClass('dragging', false, this.$.container);
        this._upload(e.dataTransfer.files);
      },

      _isDropzoneVisible: function() {
        // Area to drop files should stay visible when the element is attached to a blob list property
        // and `updateDocument` is false (e.g when using the element on a form: creation or edition of documents).
        // This will allow the user to manage the list of files.
        return (!this.updateDocument && this.blobList) || !this.hasFiles;
      },

      _areActionsVisible: function() {
        return !this.updateDocument && this.hasFiles && !this.uploading;
      },

      _computeEnrichers: function() {
        return {
          document: ['preview'],
          blob: (Nuxeo.UI && Nuxeo.UI.config && Nuxeo.UI.config.enrichers && Nuxeo.UI.config.enrichers.blob)
            || ['appLinks']
        };
      },

      /**
       * Recursive method to create nested objects when they don't exist in a parent object.
       * It does not change any other existing objects or inner objects, only the ones referred in 'path'.
       * @param obj Parent Object where inner nested objects should be created.
       * @param path Array containing the inner object keys.
       * @param value Object that should be set to last nested object.
       * Usage Example:
       *
       *  - Creating document properties using xpath:
       *
       *    const xpath = 'my:custom/field/subfield/x'
       *    _createNestedObjectRecursive(this.document.properties, xpath.split('/'), 'should set this value');
       *
       */
      _createNestedObjectRecursive: function(obj, path, value) {
        if (path.length === 0) {
          return;
        }
        if ((!Object.prototype.hasOwnProperty.call(obj, path[0]) && !obj[path[0]]) || typeof obj[path[0]] !== 'object') {
          obj[path[0]] = path.length === 1 && value ? value : {};
        }
        return this._createNestedObjectRecursive(obj[path[0]], path.slice(1), value);
      },

    });
  </script>

</dom-module>
<dom-module id="nuxeo-document-create-version" assetpath="nuxeo-document-versions/">
  <template>

    <style>
      iron-icon:hover {
        fill: var(--nuxeo-link-hover-color);
      }

      .dialog .content {
        @apply --layout-vertical;
        box-shadow: none;
      }

      nuxeo-tag {
        cursor: pointer;
        @apply --nx-button-primary;
      }

      nuxeo-tag:hover {
        @apply --nx-button-primary-hover;
      }

      nuxeo-tag[disabled] {
        @apply --nuxeo-tag;
        cursor: auto;
        font-weight: normal;
      }

      .buttons {
        @apply --layout-horizontal;
        @apply --layout-justified;
        @apply --buttons-bar;
      }

      paper-radio-group {
        margin: 16px;
      }

      paper-radio-button {
        display: block;
      }

      paper-radio-button .version {
        background-color: var(--nuxeo-primary-color);
        color: var(--nuxeo-button-primary-text);
        padding: 4px 8px;
        margin-right: 8px;
        font-weight: 500;
        border-radius: 2px;
      }

      paper-button {
        margin: 0;
        padding: 8px 16px;
      }
    </style>

    <nuxeo-document id="doc" headers="[[headers]]" doc-id="[[document.uid]]" data="{{document}}" response="{{document}}">
    </nuxeo-document>

    <nuxeo-operation id="opCreateVersion" op="Document.CreateVersion" input="[[document.uid]]" headers="[[headers]]" response="{{version}}" sync-indexing=""></nuxeo-operation>

    <nuxeo-tag class="create" disabled$="[[!_isAvailable(document)]]" on-tap="_toggleDialog" uppercase="">[[label]]</nuxeo-tag>

    <nuxeo-dialog id="dialog" class="dialog" with-backdrop="" on-iron-overlay-opened="_dialogOpened" on-iron-overlay-closed="_dialogClosed">
      <h2>[[i18n('documentCreateVersion.title',
        document.properties.dc:title, document.properties.uid:major_version, document.properties.uid:minor_version)]]
      </h2>
      <div class="content">
        <paper-radio-group selected="{{versionType}}">
          <paper-radio-button name="minor">
            <span id="nextMinor" class="version">[[_nextMinor(document)]]</span>
            <span>[[i18n('documentCreateVersion.minor')]]</span>
          </paper-radio-button>
          <paper-radio-button name="major">
            <span id="nextMajor" class="version">[[_nextMajor(document)]]</span>
            <span>[[i18n('documentCreateVersion.major')]]</span>
          </paper-radio-button>
        </paper-radio-group>
      </div>
      <div class="buttons">
        <paper-button noink="" dialog-dismiss="">[[i18n('documentCreateVersion.dismiss')]]</paper-button>
        <paper-button noink="" dialog-confirm="" class="primary" on-tap="_create">
          [[i18n('documentCreateVersion.confirm')]]
        </paper-button>
      </div>
    </nuxeo-dialog>

  </template>

  <script>
    Polymer({
      is: 'nuxeo-document-create-version',
      behaviors: [Nuxeo.I18nBehavior, Nuxeo.FiltersBehavior],
      properties: {
        label: String,
        document: Object,
        version: Object,
        headers: {
          type: Object,
          computed: '_computeHeaders(versionType)'
        },
        versionType: {
          type: String,
          value: 'major'
        },
        response: Object
      },

      ready: function() {
        if (!this.label) {
          this.label = this.i18n('versions.create');
        }
      },

      _dialogOpened: function(e) {
        e.target.parentNode.insertBefore(e.target.backdropElement, e.target);
      },

      _dialogClosed: function() {
        this.fire('dialog-closed');
      },

      _computeHeaders: function(versionType) {
        return {
          'X-Versioning-Option': versionType
        };
      },

      _isAvailable: function(doc) {
        return !this.isVersion(doc) && this.hasFacet(doc, 'Versionable') && this.hasPermission(doc, 'Write');
      },

      _nextMinor: function(doc) {
        return (doc) ? doc.properties['uid:major_version'] + '.' + (doc.properties['uid:minor_version'] + 1) : '';
      },

      _nextMajor: function(doc) {
        return (doc) ? (doc.properties['uid:major_version'] + 1) + '.0' : '';
      },

      _toggleDialog: function() {
        if (this._isAvailable(this.document)) {
          this.$.dialog.open();
        }
      },

      _create: function() {
        if (this._isAvailable(this.document)) {
          this.$.opCreateVersion.params = {increment: this.versionType, saveDocument: true};
          this.$.opCreateVersion.execute().then(function () {
            this.fire('document-updated');
          }.bind(this));
        }
      }

    });
  </script>

</dom-module>
<dom-module id="nuxeo-document-versions" assetpath="nuxeo-document-versions/">

  <template>
    <style>
      :host {
        display: inline-block;
        min-width: 60px;
      }

      .toggle {
        padding: 0;
        cursor: pointer;
      }

      .toggle-text {
        display: inline-block;
        padding: 4px 0 4px 8px;
      }

      .toggle-icon {
        width: 20px;
        height: 20px;
      }

      .version {
        @apply --layout-vertical;
        @apply --layout-start;
        padding: 8px;
        cursor: pointer;
        border-top: 1px solid var(--divider-color);
      }

      .version:hover {
        @apply --nuxeo-block-hover;
      }

      .version .row {
        @apply --layout-horizontal;
        @apply --layout-start;
        margin: 0;
        padding: 0;
      }

      .version .row * {
        display: inline-block;
        text-align: left;
      }

      .version .modified {
        font-size: .8rem;
        margin-top: 4px;
        opacity: .3;
      }

      .version .latest {
        margin: 8px 0;
      }

      iron-scroll-threshold {
        display: none;
      }

      #list-items {
        max-height: 50vh;
        overflow-y: auto;
      }
    </style>

    <nuxeo-operation id="opGetLatest" op="Proxy.GetSourceDocument" input="[[document.uid]]" response="{{latest}}">
    </nuxeo-operation>

    <nuxeo-page-provider id="provider" query="[[query]]" page-size="[[pageSize]]" page="{{page}}" sort="{&quot;uid:major_version&quot;: &quot;desc&quot;, &quot;uid:minor_version&quot;: &quot;desc&quot;}" schemas="dublincore,common,uid">
    </nuxeo-page-provider>

    <nuxeo-document-create-version document="[[document]]" hidden$="[[hasVersions(document)]]" label="[[_labelCreate(document)]]">
    </nuxeo-document-create-version>

    <div hidden$="[[!hasVersions(document)]]">
      <nuxeo-tag class="toggle" on-tap="_showList">
        <div class="toggle-text">[[_labelTitle(document)]][[_labelCheckedOut(document)]]</div>
        <iron-icon class="toggle-icon" icon="icons:arrow-drop-down"></iron-icon>
      </nuxeo-tag>
      <nuxeo-document-versions-list id="list">
        <div id="list-items" slot="items">
          <template is="dom-if" if="[[document.isVersion]]">
            <div class="version" on-tap="_showLatest">
              <div id="version-latest" class="row title latest">[[_labelLatest(latest)]]</div>
            </div>
          </template>
          <template is="dom-repeat" items="[[versions]]" as="item">
            <div name="version-item" class="version" on-tap="_showVersion">
              <div id="version-id-[[index]]" class="row title">[[_labelTitle(item)]]</div>
              <div class="row modified">[[_labelModified(item)]]</div>
            </div>
          </template>
        </div>
        <nuxeo-document-create-version slot="actions" document="[[document]]" hidden$="[[!_isCheckedOut(document)]]" on-dialog-closed="_hideList">
        </nuxeo-document-create-version>
      </nuxeo-document-versions-list>
      <iron-scroll-threshold id="scrollThreshold" scroll-target="list-items" lower-threshold="500" on-lower-threshold="_loadMore">
      </iron-scroll-threshold>
    </div>

    <template is="dom-if" if="[[document.isVersion]]">
      <nuxeo-tooltip for="version-latest" position="right">[[latest.title]]</nuxeo-tooltip>
    </template>
    <template is="dom-repeat" items="[[versions]]" as="item">
      <nuxeo-tooltip for="version-id-[[index]]" position="right">[[item.title]]</nuxeo-tooltip>
    </template>

  </template>

  <script>
    Polymer({
      is: 'nuxeo-document-versions',
      behaviors: [Nuxeo.RoutingBehavior, Nuxeo.FormatBehavior, Nuxeo.FiltersBehavior],
      properties: {
        document: Object,
        latest: Object,
        versions: {
          type: Array,
          value: [],
          notify: true
        },
        query: String,
        page: {
          type: Number,
          value: 0
        },
        pageSize: {
          type: Number,
          value: 100
        }
      },

      observers: [
        '_update(document.*)'
      ],

      _update: function() {
        if (this.document) {
          if (this.document.isVersion) {
            this.$.opGetLatest.execute().then(function() {
              this._query(this.latest.uid);
            }.bind(this));
          } else {
            this._query(this.document.uid);
          }
        }
      },

      _isCheckedOut: function(doc) {
        return doc && doc.isCheckedOut;
      },

      _query: function(id) {
        this.query = 'SELECT * FROM Document WHERE ecm:versionVersionableId = "' + id + '" AND ecm:isVersion = 1';
        this.page = 0;
        this._loadMore();
      },

      _loadMore: function() {
        this.$.scrollThreshold.clearTriggers();
        if (this.query && (this.$.provider.isNextPageAvailable || this.page === 0)) {
          this.page = this.page + 1;
          this.$.provider.fetch().then(function(results) {
            if (this.page === 1) {
              this.set('versions', []);
            }
            if (results) {
              results.entries.forEach(function(doc) {
                this.push('versions', doc);
              }.bind(this));
            }
          }.bind(this));
        }
      },

      _showList: function() {
        this.$.list.open();
      },

      _hideList: function() {
        this.$.list.close();
      },

      _showLatest: function() {
        this._hideList();
        this.navigateTo('browse', this.document.path);
      },

      _showVersion: function(e) {
        this._hideList();
        this.navigateTo('document', e.model.item.uid);
      },

      _labelCreate: function(doc) {
        var permission = !this.isVersion(doc) && this.hasFacet(doc, 'Versionable') && this.hasPermission(doc, 'Write');
        return this.i18n(permission ? 'versions.create' : 'versions.unversioned');
      },

      _labelLatest: function(doc) {
        if (doc) {
          var number = this.i18n('versions.version',
              doc.properties['uid:major_version'], doc.properties['uid:minor_version']) +
            ((doc.isCheckedOut) ? '+ ' : ' ');
          var label = (doc.isCheckedOut) ?
            this.i18n('versions.unversionedChanges') :
            this.i18n('versions.latest');
          return number + label;
        }
        this._hideList();
        return '';
      },

      _labelTitle: function(doc) {
        if (doc) {
          return this.i18n('versions.version',
            doc.properties['uid:major_version'], doc.properties['uid:minor_version']);
        }
        return '';
      },

      _labelCheckedOut: function(doc) {
        return (doc && doc.isCheckedOut) ? '+' : '';
      },

      _labelModified: function(doc) {
        return this.i18n('versions.modified',
          moment().to(doc.properties['dc:modified']), doc.properties['dc:creator']);
      },

      _date: function(date) {
        return moment(date).format('DD/MM/YYYY HH:mm');
      }

    });
  </script>

</dom-module>
<dom-module id="nuxeo-document-info" assetpath="nuxeo-document-info/">
  <template>

    <style>
      [hidden] {
        display: none !important;
      }

      .item {
        @apply --layout-horizontal;
        line-height: 2.2rem;
      }

      .item label {
        width: 90px;
        min-width: 90px;
        font-size: 12px;
      }

    </style>

    <div class="item" name="process" hidden$="[[!_showProcess]]">
      <label>[[i18n('documentInfo.process')]]</label>
      <div><nuxeo-tag uppercase="">[[i18n('documentInfo.process.running')]]</nuxeo-tag></div>
    </div>
    <div class="item">
      <label>[[i18n('documentInfo.state')]]</label>
      <div><nuxeo-tag uppercase="">[[formatLifecycleState(document.state)]]</nuxeo-tag></div>
    </div>
    <template is="dom-if" if="[[hasFacet(document, 'Versionable')]]">
      <div class="item">
        <label>[[i18n('documentInfo.version')]]</label>
        <template is="dom-if" if="[[!isProxy(document)]]">
          <nuxeo-document-versions document="[[document]]"></nuxeo-document-versions>
        </template>
        <template is="dom-if" if="[[isProxy(document)]]">
          <div><nuxeo-tag uppercase="">[[formatVersion(document)]]</nuxeo-tag></div>
        </template>
      </div>
    </template>
    <template is="dom-if" if="[[_showPub(document)]]">
      <div class="item">
        <label>[[i18n('documentInfo.publications')]]</label>
        <div>
          <a href$="[[_urlForPub(document)]]">
            [[document.contextParameters.publications.resultsCount]]
          </a>
        </div>
      </div>
    </template>
    <div class="item">
      <label>[[i18n('documentInfo.lastModified')]]</label>
      <nuxeo-date datetime="[[document.properties.dc:modified]]"></nuxeo-date>
    </div>
    <div class="item">
      <label>[[i18n('documentInfo.created')]]</label>
      <nuxeo-date datetime="[[document.properties.dc:created]]"></nuxeo-date>
    </div>
    <div class="item">
      <label>[[i18n('documentInfo.by')]]</label>
      <nuxeo-user-tag user="[[document.properties.dc:creator]]"></nuxeo-user-tag>
    </div>
    <div class="item">
      <label>[[i18n('documentInfo.contributors')]]</label>
      <nuxeo-tags type="user" items="[[document.properties.dc:contributors]]"></nuxeo-tags>
    </div>

  </template>
</dom-module>

<script>
  Polymer({
    is: 'nuxeo-document-info',
    behaviors: [Nuxeo.LayoutBehavior],
    properties: {
      document: {
        type: Object,
        observer: '_documentChanged'
      },
      _showProcess: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      }
    },

    _showPub: function(doc) {
      return doc && doc.contextParameters &&
        doc.contextParameters.publications && doc.contextParameters.publications.resultsCount > 0;
    },

    _documentChanged: function() {
      this._showProcess = this.document && this.document.contextParameters &&
        this.document.contextParameters.runningWorkflows && this.document.contextParameters.runningWorkflows.length > 0;
    },

    _urlForPub: function() {
      if (this.document) {
        return this.urlFor('browse', this.document.path, 'publication');
      }
    }
  });
</script>
<dom-module id="nuxeo-document-collections" assetpath="nuxeo-collections/">
  <template>
    <style include="nuxeo-styles">
      :host {
        display: block;
      }

      .item {
        @apply --layout-horizontal;
        @apply --layout-center;
      }

      iron-icon {
        /* Similiar look and feel as select2 */
        height: 13px;
        width: 13px;
        opacity: 0.6;
      }

      iron-icon:hover {
        cursor: pointer;
        opacity: 1;
      }

      .ellipsis {
        text-overflow: ellipsis;
        overflow: hidden;
        white-space: nowrap;
        display: block;
      }

    </style>

    <nuxeo-operation op="Collection.RemoveFromCollection" input="[[document.uid]]" id="op">
    </nuxeo-operation>

    <template is="dom-repeat" items="[[document.contextParameters.collections]]">
      <nuxeo-tag>
       <div class="item">
         <a class="title ellipsis" href$="[[urlFor('browse', item.path)]]">[[item.title]]</a>
         <iron-icon icon="nuxeo:cross" name="remove" on-tap="remove" data-uid$="[[item.uid]]"></iron-icon>
       </div>
     </nuxeo-tag>
    </template>

  </template>
  <script>
    Polymer({
      is: 'nuxeo-document-collections',

      behaviors: [Nuxeo.RoutingBehavior],

      properties: {
        document: Object
      },

      remove: function(evt) {
        var op = this.$.op;
        op.params = {
          'collection': evt.currentTarget.dataset.uid
        };
        op.execute().then(function() {
          this.fire('removed-from-collection', {doc: this.document, collectionId: evt.target.dataset.uid});
        }.bind(this));
      }

    });
  </script>
</dom-module>
<dom-module id="nuxeo-document-activity" assetpath="nuxeo-document-activity/">
  <template>
    <style>
      .row {
        @apply --layout-horizontal;
      }

      .value {
        margin: 0 4px 7px;
      }

      .datetime {
        opacity: .5;
        margin-left: 3px;
      }
    </style>

    <template is="dom-repeat" items="[[activities]]">
      <div class="row">
        <nuxeo-user-tag user="[[item.principalName]]"></nuxeo-user-tag>
        <div class="value">
          <span>[[_activity(item)]]</span>
          <nuxeo-date class="datetime" datetime="[[item.eventDate]]" format="relative"></nuxeo-date>
        </div>
      </div>
    </template>
  </template>

  <script>
    Polymer({
      is: 'nuxeo-document-activity',

      behaviors: [Nuxeo.I18nBehavior, Nuxeo.RoutingBehavior],

      properties: {
        document: {
          type: Object,
          observer: '_documentChanged'
        },

        activities: {
          type: Array,
          value: []
        }
      },

      _activity: function(event) {
        return this.i18n('activity.' + event.eventId);
      },

      _documentChanged: function() {
        if (this.document && this.document.contextParameters && this.document.contextParameters.audit) {
          this.activities = this._gatherDuplicatedActivities(this.document.contextParameters.audit);
        }
      },

      /**
       * Returns a copy of the given array with "repeated" gathered
       */
      _gatherDuplicatedActivities: function(original) {
        var activities = original.slice();
        for (var i = 0; i < activities.length - 1; i++) {
          for (var j = i + 1;  j < activities.length; j++) {
            if (this._areGatherableActivities(activities[i], activities[j])) {
              activities.splice(j,1);
              j--;  //After remove duplicated element, decrease j to keep same index

            }
          }
        }
        return activities;
      },

      /**
       * Checks if two given activities are "gatherable".
       * Activities are gatharable if they are both "download", have the same author
       * and have less than 24 hours between them.
       */
      _areGatherableActivities: function(a, b){
        var delta = new Date(a.eventDate) - new Date(b.eventDate);
        delta = delta / 1000 / 60 / 60 ; //Converts ms to hours
        return a.eventId === b.eventId
            && a.eventId === 'download'
            && a.principalName === b.principalName
            && delta < 24;
      }
    });
  </script>
</dom-module>
<dom-module id="nuxeo-document-comment" assetpath="nuxeo-document-comments/">
  <template>
    <style include="nuxeo-styles">
      :host {
        display: block;
        margin-top: 5px;
      }

      #body:hover paper-icon-button {
        opacity: 0.5;
        transition: opacity 100ms;
      }

      .author {
        font-weight: bold;
        margin-right: 5px;
      }

      .horizontal {
        @apply --layout-horizontal;
      }

      .info {
        margin-left: 10px;
        @apply --layout-vertical;
        @apply --layout-flex;
      }

      .link {
        cursor: pointer;
      }

      .main-option {
        height: 1.5em;
        width: 1.5em;
        cursor: pointer;
      }

      .more-content {
        color: var(--nuxeo-secondary-color, #1f28bf);
      }

      .no-selection {
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
      }

      .opaque {
        opacity: 0.5;
      }

      .separator {
        margin: 0 5px;
      }

      .smaller {
        font-size: 0.86em;
      }

      .text {
        display: inline;
      }

      .text span {
        white-space: pre-wrap;
      }

      paper-menu-button {
        --paper-menu-button: {
          padding: 0;
        };
      }

      paper-listbox {
        --paper-listbox: {
          padding: 0;
        };
      }

      paper-icon-button {
        opacity: 0;
        --paper-icon-button: {
          padding: 0;
        };
      }

      paper-icon-item {
        --paper-icon-item: {
          padding: 5px 5px;
          display: flex;
          cursor: pointer;
        };

        --paper-item-min-height: 24px;

        --paper-item-icon: {
          width: 1.75em;
          margin-right: 10px;
        };

        --paper-item-selected-weight: normal;

        --paper-item-focused-before: {
          background-color: transparent;
        }
      }

    </style>

    <nuxeo-connection id="nxcon" user="{{currentUser}}"></nuxeo-connection>

    <nuxeo-dialog id="dialog" with-backdrop="">
      <h2>[[i18n('comments.deletion.dialog.heading')]]</h2>
      <div>[[_computeConfirmationLabel(comment.numberOfReplies)]]</div>
      <div class="buttons">
        <paper-button name="dismiss" dialog-dismiss="">[[i18n('comments.deletion.dialog.buttons.cancel')]]</paper-button>
        <paper-button name="confirm" dialog-confirm="" on-click="_deleteComment">[[i18n('comments.deletion.dialog.buttons.delete')]]</paper-button>
      </div>
    </nuxeo-dialog>

    <div class="horizontal">
      <nuxeo-user-avatar user="[[comment.author]]" height="[[_computeAvatarDimensions(level)]]" width="[[_computeAvatarDimensions(level)]]" border-radius="50" font-size="[[_computeAvatarFontSize(level)]]">
      </nuxeo-user-avatar>
      <div class="info">
        <div id="body">
          <div class="horizontal">
            <span class="author">[[comment.author]]</span>
            <span class="smaller opaque">[[_computeDateLabel(comment, comment.creationDate, comment.modificationDate, i18n)]]</span>
            <template is="dom-if" if="[[_areExtendedOptionsAvailable(comment.author, currentUser)]]">
              <paper-menu-button id="options" no-animations="" close-on-activate="">
                <paper-icon-button class="main-option" icon="more-vert" slot="dropdown-trigger" alt="menu">
                </paper-icon-button>
                <paper-listbox slot="dropdown-content">
                  <paper-icon-item name="edit" class="smaller no-selection" on-tap="_editComment">
                    <iron-icon icon="nuxeo:edit" slot="item-icon"></iron-icon>
                    <span>[[i18n('comments.options.edit')]]</span>
                  </paper-icon-item>
                  <paper-icon-item name="delete" class="smaller no-selection" on-tap="_toggleDeletionConfirmation">
                    <iron-icon icon="nuxeo:delete" slot="item-icon"></iron-icon>
                    <span>[[i18n('comments.options.delete')]]</span>
                  </paper-icon-item>
                </paper-listbox>
              </paper-menu-button>
            </template>
          </div>
          <div class="text">
            <span inner-h-t-m-l="[[_computeTextToDisplay(comment.text, maxChars, truncated)]]"></span>
            <template is="dom-if" if="[[truncated]]">
              <span class="smaller opaque link" on-tap="_showFullComment">[[i18n('comments.showAll')]]</span>
            </template>
            <template is="dom-if" if="[[!truncated]]">
              <iron-icon name="reply" class="main-option opaque" icon="reply" on-tap="_reply" hidden$="[[!_isRootElement(level)]]"></iron-icon>
            </template>
          </div>
          <template is="dom-if" if="[[_isSummaryVisible(comment.expanded, comment.numberOfReplies)]]">
            <div id="summary" class="horizontal smaller">
              <span class="more-content link no-selection" on-tap="_expand">[[i18n('comments.numberOfReplies', comment.numberOfReplies)]]</span>
              <span class="separator opaque"></span>
              <span class="opaque">[[_computeDateLabel(comment, 'lastReplyDate', comment.lastReplyDate, i18n)]]</span>
            </div>
          </template>
        </div>

        <template is="dom-if" if="[[comment.expanded]]">
          <nuxeo-document-comment-thread id="thread" uid="[[comment.id]]" level="[[_computeSubLevel(level)]]">
          </nuxeo-document-comment-thread>
        </template>
      </div>
    </div>

  </template>

  <script>
    Polymer({
      is: 'nuxeo-document-comment',

      behaviors: [Nuxeo.FormatBehavior],

      properties: {
        comment: {
          type: Object,
        },

        level: {
          type: Number,
          value: 1,
        },

        truncated: {
          type: Boolean,
          computed: '_computeTruncatedFlag(comment.showFull, comment.text,  maxChars)'
        },

        maxChars: {
          type: Number,
          readOnly: true,
          value: 256,
        },
      },

      connectedCallback : function() {
        this.addEventListener('number-of-replies', this._handleRepliesChange);
      },

      disconnectedCallback: function() {
        this.removeEventListener('number-of-replies', this._handleRepliesChange);
      },

      _deleteComment: function() {
        this.fire('delete-comment', {commentId: this.comment.id});
      },

      _editComment: function() {
        this.fire('edit-comment', {commentId: this.comment.id});
      },

      _expand: function () {
        this.set('comment.expanded', true);
      },

      _handleRepliesChange: function(event) {
        var numberOfReplies = event.detail.total;
        if(numberOfReplies === 0) {
          this.set('comment.expanded', false);
        }
        this.set('comment.numberOfReplies', numberOfReplies);
        event.stopPropagation();
      },

      _showFullComment: function() {
        this.set('comment.showFull', true);
      },

      _reply: function() {
        if (!this.comment.expanded) {
          this._expand();
        }
        Polymer.RenderStatus.afterNextRender(this, function() {
          this.$$('#thread').focusInput();
        });
      },

      _toggleDeletionConfirmation: function() {
        this.$.dialog.toggle();
      },

      _computeAvatarDimensions: function(level) {
        return this._isRootElement(level) ? 24 : 20;
      },

      _computeAvatarFontSize: function(level) {
        return this._isRootElement(level) ? 13 : 11;
      },

      _computeConfirmationLabel: function (replies) {
        return this.i18n('comments.deletion.dialog.message.' + (replies > 0 ? 'withReplies' : 'withoutReplies'));
      },

      _computeDateLabel: function (item, option) {
        if (item) {
          var date = this.formatDate(item.creationDate, 'relative');
          if(option === 'lastReplyDate') {
            date = this.formatDate(item.lastReplyDate, 'relative');
            return this.i18n('comments.lastReply', date);
          } else if (item.modificationDate) {
            return this.i18n('comments.edited', date)
          }
          return date;
        }
      },

      _computeSubLevel: function (level) {
        return level + 1;
      },

      _computeTextToDisplay: function(text, maxChars, truncated) {
        var parsedText = text;
        if(truncated){
          parsedText = text.substring(0, maxChars - 1) + '';
        }
        return parsedText;
      },

      _computeTruncatedFlag: function(showFull, text, limit) {
        return !showFull && text.length > limit;
      },

      /** Visibility Methods **/

      _areExtendedOptionsAvailable: function (author, currentUser) {
        return currentUser && (currentUser.properties.username === author || currentUser.isAdministrator);
      },

      _isRootElement: function (level) {
        return level === 1;
      },

      _isSummaryVisible: function (expanded, total) {
        return !expanded && total > 0;
      },

    });
  </script>
</dom-module>
<dom-module id="nuxeo-document-comment-thread" assetpath="nuxeo-document-comments/">
  <template>
    <style include="nuxeo-styles">
      :host {
        display: block;
      }

      .main-option {
        height: 1.5em;
        width: 1.5em;
        cursor: pointer;
        opacity: 0.5;
      }

      .more-content {
        color: var(--nuxeo-secondary-color, #1f28bf);
        cursor: pointer;
        font-size: 0.86em;

        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
      }

      .reply-area {
        margin: 5px 0;

        @apply --layout-horizontal;
        @apply --layout-end;
      }

      paper-textarea {
        width: 100%;
        --paper-input-container-input: {
          font-size: 1em;
          line-height: var(--nuxeo-comment-line-height, 20px);
        };

        --paper-input-container-color: var(--secondary-text-color, #939caa);

        --iron-autogrow-textarea-placeholder: {
          color: var(--secondary-text-color, #939caa);
          font-size: 0.86em;
        };
      }

    </style>

    <nuxeo-connection id="nxcon" user="{{currentUser}}"></nuxeo-connection>
    <nuxeo-resource id="commentRequest"></nuxeo-resource>

    <array-selector id="selector" items="{{comments}}" selected="{{selectedComment}}"></array-selector>

    <template is="dom-if" if="[[_moreAvailable(comments.length, total, allCommentsLoaded)]]">
      <span class="more-content" on-tap="_loadMore">[[_computeTextLabel(level, 'loadAll', total, i18n)]]</span>
    </template>
    <template id="commentList" is="dom-repeat" items="[[comments]]" as="comment">
      <nuxeo-document-comment comment="{{comment}}" level="[[level]]">
      </nuxeo-document-comment>
    </template>

    <template is="dom-if" if="[[_allowReplies(level)]]">
      <div class="reply-area">
        <paper-textarea id="replyContainer" placeholder="[[_computeTextLabel(level, 'writePlaceholder', null, i18n)]]" value="{{reply}}" max-rows="[[_computeMaxRows()]]" no-label-float="" on-keydown="_checkForEnter">
        </paper-textarea>
        <template is="dom-if" if="[[!_isBlank(reply)]]">
          <iron-icon id="submit" name="submit" class="main-option" icon="check" on-tap="_submitReply"></iron-icon>
          <nuxeo-tooltip for="submit">[[i18n('comments.submit.tooltip')]]</nuxeo-tooltip>
          <iron-icon name="clear" class="main-option" icon="clear" on-tap="_clearReply"></iron-icon>
        </template>
      </div>
    </template>

  </template>

  <script>
    Polymer({
      is: 'nuxeo-document-comment-thread',

      behaviors: [Nuxeo.FormatBehavior],

      properties: {
        uid: {
          type: String,
          observer: '_refresh',
        },

        comments: {
          type: Array,
          value: function() {
            return [];
          }
        },

        level: {
          type: Number,
          value: 1,
        },

        reply: {
          type: String,
          value: '',
        },

        pageSize: {
          type: Number,
          readOnly: true,
          value: 10,
        },

        allCommentsLoaded: {
          type: Boolean,
          readOnly: true,
          value: false,
        },

        total: {
          type: Number,
          readOnly: true,
          value: 0,
        },
      },

      connectedCallback : function() {
        this.addEventListener('delete-comment', this._handleDeleteEvent);
        this.addEventListener('edit-comment', this._handleEditEvent);
        this.addEventListener('comments-changed', this._handleCommentsChange);
      },

      disconnectedCallback: function() {
        this.removeEventListener('delete-comment', this._handleDeleteEvent);
        this.removeEventListener('edit-comment', this._handleEditEvent);
        this.removeEventListener('comments-changed', this._handleCommentsChange);
      },

      focusInput: function() {
        this.$$('#replyContainer').focus();
      },

      _checkForEnter: function(e) {
        if (e.keyCode === 13 && e.ctrlKey) {
          if(!this._isBlank(this.reply)) {
            this._submitReply();
          }
        }
      },

      _clearReply: function() {
        this.$.selector.clearSelection();
        this.set('reply', '');
      },

      _clearRequest: function() {
        this.$.commentRequest.data = {};
        this.$.commentRequest.headers = {};
        this.$.commentRequest.params = {};
      },

      _fetchComments: function(loadAll) {
        this._clearRequest();
        this.$.commentRequest.path = this._computeResourcePath();
        this.$.commentRequest.params = {
          pageSize: loadAll ? 0 : this.pageSize,
          currentPageIndex: 0,
        };
        this.$.commentRequest.headers = {
          'X-NXfetch.comment': 'repliesSummary'
        };
        this.$.commentRequest.get()
          .then(function (response) {
            /* Reconciliation of local and server comments */
            var olderComment = this.comments.length > 0 ? this.comments[0] : null;
            var newComments = response.entries;
            while (newComments.length > 0 && !!olderComment
            && (newComments[0].creationDate > olderComment.creationDate || newComments[0].id === olderComment.id)) {
              newComments.shift();
            }
            response.entries.forEach(function (entry) {
              this.unshift('comments', entry);
            }.bind(this));
            this._setTotal(response.totalSize);
            this._setAllCommentsLoaded(!!loadAll);
          }.bind(this))
          .catch(function (error) {
            if (error.status === 404) {
              this.fire('notify', {message: this._computeTextLabel(this.level, 'notFound')});
            } else {
              this.fire('notify', {message: this._computeTextLabel(this.level, 'fetch.error')});
              throw error;
            }
          }.bind(this));
      },

      _getCommentIndexById: function(commentId) {
        return this.comments.findIndex(function (entry) {
          return entry.id === commentId;
        });
      },

      _handleCommentsChange: function(event) {
        if (event.detail.path === 'comments.length') {
          this.fire('number-of-replies', {total: this.comments.length});
        }
      },

      _handleDeleteEvent: function(event) {
        var index = this._getCommentIndexById(event.detail.commentId);
        if (index !== -1) {
          this._clearRequest();
          this.$.commentRequest.path = this._computeResourcePath(this.comments[index].id);
          this.$.commentRequest.remove()
            .then(function () {
              this.splice('comments', index, 1);
              this._setTotal(this.total - 1);
            }.bind(this))
            .catch(function (error) {
              if (error.status === 404) {
                this.fire('notify', {message: this._computeTextLabel(this.level, 'notFound')});
              } else {
                this.fire('notify', {message: this._computeTextLabel(this.level, 'deletion.error')});
                throw error;
              }
            }.bind(this));
          event.stopPropagation();
        }
      },

      _handleEditEvent: function(event) {
        var index = this._getCommentIndexById(event.detail.commentId);
        if (index !== -1) {
          var comment = this.comments[index];
          this.$.commentList.itemForElement(comment);
          this.$.selector.select(comment);
          this.set('reply', comment.text);
          this.$$('#replyContainer').focus();
        }
        event.stopPropagation();
      },

      _loadMore: function() {
        this._fetchComments(true);
      },

      _refresh: function() {
        this._fetchComments(this.allCommentsLoaded);
      },

      _submitReply: function(e) {
        if (e) {
          e.preventDefault();
        }
        this._clearRequest();
        this.$.commentRequest.path = this._computeResourcePath(this.selectedComment ? this.selectedComment.id : null);
        this.$.commentRequest.data = {
          'entity-type': 'comment',
          parentId: this.uid,
          author: this.selectedComment ? this.selectedComment.author : this.currentUser.properties.username,
          text: this.reply.trim()
        };

        if (this.selectedComment) {
          this.$.commentRequest.put()
            .then(function (response){
              var index = this._getCommentIndexById(this.selectedComment.id);
              if (index !== -1) {
                this.set('comments.' + index + '.modificationDate', response.modificationDate);
                this.set('comments.' + index + '.text', response.text);
              }
              this._clearReply();
            }.bind(this))
            .catch(function (error){
              if (error.status === 404) {
                this.fire('notify', {message: this._computeTextLabel(this.level, 'notFound')});
              } else {
                this.fire('notify', {message: this._computeTextLabel(this.level, 'edition.error')});
                throw error;
              }
            }.bind(this));
        } else {
          this.$.commentRequest.post()
            .then(function (response) {
              this._clearReply();
              this.push('comments', response);
              this._setTotal(this.total + 1);
            }.bind(this))
            .catch(function (error) {
              if (error.status === 404) {
                this.fire('notify', {message: this._computeTextLabel(this.level, 'notFound')});
              } else {
                this.fire('notify', {message: this._computeTextLabel(this.level, 'creation.error')});
                throw error;
              }
            }.bind(this));
        }
      },

      _computeMaxRows: function() {
        var lineHeight = parseFloat(this.getComputedStyleValue('--nuxeo-comment-line-height'));
        var maxHeight = parseFloat(this.getComputedStyleValue('--nuxeo-comment-max-height'));
        return Math.round( (isNaN(maxHeight) ? 80 : maxHeight) / (isNaN(lineHeight) ? 20 : lineHeight) );
      },

      _computeResourcePath: function(commentId) {
        return "/id/" + this.uid + "/@comment/" + (commentId ? commentId : '');
      },

      _computeSubLevel: function(level) {
        return level + 1;
      },

      _computeTextLabel: function(level, option, placeholder) {
        return level === 1 ? this.i18n('comments.' + option + '.comment', placeholder)
          : this.i18n('comments.' + option + '.reply', placeholder);
      },

      /** Visibility Methods **/
      _allowReplies: function(level) {
        return level <= 2;
      },

      _isBlank: function(reply) {
        return !reply || typeof reply !== 'string' || reply.trim().length === 0;
      },

      _moreAvailable: function(length, total, allCommentsLoaded) {
        return length < total && !allCommentsLoaded;
      },

    });
  </script>
</dom-module>
<dom-module id="nuxeo-document-blob" assetpath="nuxeo-document-blob/">
  <template>

    <style include="nuxeo-styles">
      :host {
        display: block;
      }

      .row {
        @apply --layout-horizontal;
        @apply --layout-center;
      }

      .row .info {
        @apply --layout-vertical;
        @apply --layout-flex;
        overflow: hidden;
      }

      .row .actions {
        @apply --layout-horizontal;
        @apply --layout-center;
      }

      .row .info a {
        overflow: hidden;
        display: block;
        text-overflow: ellipsis;
      }

      .detail {
        opacity: .5;
      }

      .actions ::content paper-icon-button {
        width: 36px;
        height: 36px;
      }

      nuxeo-actions-menu {
        height: 100%;
        max-width: var(--nuxeo-document-blob-actions-menu-max-width, 160px);
      }
    </style>

    <nuxeo-connection user="{{user}}"></nuxeo-connection>

    <template is="dom-if" if="[[blob]]">
      <div class="row">
        <div class="info">
          <div><a href="[[blob.data]]" title="[[blob.name]]">[[blob.name]]</a></div>
          <div class="detail">[[formatSize(blob.length)]]</div>
        </div>
        <div class="actions">
          <nuxeo-actions-menu>
            <nuxeo-slot slot="BLOB_ACTIONS" model="[[actionContext]]"></nuxeo-slot>
          </nuxeo-actions-menu>
        </div>
      </div>
    </template>

  </template>

</dom-module>

<script>
  Polymer({
    is: 'nuxeo-document-blob',
    behaviors: [Nuxeo.I18nBehavior, Nuxeo.FormatBehavior],
    properties: {
      user: Object,
      document: Object,
      xpath: {
        type: String,
        value: 'file:content'
      },
      blob: Object,
      actionContext: Object
    },

    observers: [
      '_update(user, document, xpath)'
    ],

    _update: function(user, document, xpath) {
      this.blob = document && this._deepFind(document.properties, xpath);
      this.actionContext = {user: this.user, document: this.document, blob: this.blob, xpath: this.xpath};
    },

    _deepFind: function(obj, props) {
      for (var i = 0, path = props.split('/'), len = path.length; i < len; i++) {
        if (!obj || obj === []) {
          break;
        }
        obj = obj[path[i]];
      }
      return obj;
    }

  });
</script>
<dom-module id="nuxeo-document-view" assetpath="document/">
  <template>
    <nuxeo-document-layout document="[[document]]" layout="view"></nuxeo-document-layout>
  </template>
  <script>
    Polymer({
      is: 'nuxeo-document-view',
      properties: {
        document: Object
      }
    });
  </script>
</dom-module>
<dom-module id="nuxeo-document-metadata" assetpath="document/">
  <template>
    <style include="nuxeo-styles">
      :host {
        display: block;
      }
    </style>

    <nuxeo-document-layout document="[[document]]" layout="metadata"></nuxeo-document-layout>

  </template>

  <script>
    Polymer({
      is: 'nuxeo-document-metadata',
      properties: {
        document: Object
      }
    });
  </script>
</dom-module>
<dom-module id="nuxeo-document-page" assetpath="document/">
  <template>
    <style include="nuxeo-styles">
      #details {
        width: 28px;
        height: 28px;
        padding: 5px;
        opacity: 0.3;
        margin: 6px 0;
      }

      :host([opened]) #details {
        opacity: 1;
        margin-left: 6px;
      }

      #documentViewsItems {
        @apply --layout-horizontal;
        --paper-listbox-background-color: transparent;
      }

      #documentViewsItems > [name='comments'] {
        margin: 0;
      }

      .scrollerHeader {
        @apply --layout-horizontal;
      }

      :host([opened]) .scrollerHeader {
        box-shadow: 0 3px 5px rgba(0,0,0,0.04) !important;
        border-radius: 0;
        background-color: var(--nuxeo-box) !important;
      }

      .page {
        @apply --layout-horizontal;
      }

      .main {
        @apply --layout-vertical;
        @apply --layout-flex-2;
        padding-right: 8px;
        overflow: hidden;
      }

      :host([opened]) .main {
        padding-right: 16px;
      }

      .side {
        @apply --layout-vertical;
        position: relative;
        margin-bottom: var(--nuxeo-card-margin-bottom, 16px);
        min-height: 60vh;
      }

      :host([opened]) .side {
        @apply --layout-flex;
      }

      .scroller {
        @apply --nuxeo-card;
        margin-bottom: 0;
        overflow: auto;
        display: none;
        left: 0;
        top: 36px;
        right: 0;
        bottom: 0;
        position: absolute;
      }

      :host([opened]) .scroller {
        display: block;
      }

      .section {
        margin-bottom: 32px;
      }

      .section:last-of-type {
        margin-bottom: 64px;
      }

      nuxeo-document-view {
        --nuxeo-document-content-margin-bottom: var(--nuxeo-card-margin-bottom);
      }

      @media (max-width: 1024px) {
        #details {
          opacity: 1;
          margin-left: 6px;
          cursor: default;
        }

        .scrollerHeader {
          box-shadow: 0 3px 5px rgba(0,0,0,0.04) !important;
          font-family: var(--nuxeo-app-font);
          border-radius: 0;
          background-color: var(--nuxeo-box) !important;
        }

        .page {
          @apply --layout-vertical;
        }

        .main,
        :host([opened]) .main {
          padding: 0;
          max-width: initial;
          margin-right: 0;
        }

        .side {
          padding: 0;
          max-width: initial;
          min-height: initial;
          display: block;
          margin-bottom: 16px;
        }

        .scroller {
          top: 0;
          position: relative;
          display: block;
        }
      }
    </style>

    <nuxeo-document-info-bar document="[[document]]"></nuxeo-document-info-bar>

    <div class="page">

      <div class="main">
        <nuxeo-document-view document="[[document]]"></nuxeo-document-view>
      </div>

      <div class="side">
        <div class="scrollerHeader">
          <paper-icon-button id="details" noink="" icon="nuxeo:details" on-tap="_toggleOpened"></paper-icon-button>
          <nuxeo-tooltip for="details">[[i18n('documentPage.details.opened')]]</nuxeo-tooltip>
        </div>
        <div class="scroller">
          <div class="section">
            <nuxeo-document-info document="[[document]]"></nuxeo-document-info>
          </div>

          <div class="section">
            <nuxeo-document-metadata document="[[document]]"></nuxeo-document-metadata>
          </div>

          <div class="section" hidden$="[[!_hasCollections(document)]]">
            <h3>[[i18n('documentPage.collections')]]</h3>
            <nuxeo-document-collections document="[[document]]"></nuxeo-document-collections>
          </div>

          <template is="dom-if" if="[[hasFacet(document, 'NXTag')]]">
            <div class="section">
              <h3>[[i18n('documentPage.tags')]]</h3>
              <nuxeo-tag-suggestion document="[[document]]" allow-new-tags="" placeholder="[[i18n('documentPage.tags.placeholder')]]" readonly="[[!isTaggable(document)]]">
              </nuxeo-tag-suggestion>
            </div>
          </template>

          <div class="section">
            <paper-listbox id="documentViewsItems" selected="{{selectedTab}}" attr-for-selected="name">
              <nuxeo-page-item name="comments" label="[[i18n('documentPage.comments')]]"></nuxeo-page-item>
              <nuxeo-page-item name="activity" label="[[i18n('documentPage.activity')]]"></nuxeo-page-item>
            </paper-listbox>
            <iron-pages selected="[[selectedTab]]" attr-for-selected="name" selected-item="{{page}}">
              <nuxeo-document-comment-thread name="comments" uid="[[document.uid]]"></nuxeo-document-comment-thread>
              <nuxeo-document-activity name="activity" document="[[document]]"></nuxeo-document-activity>
            </iron-pages>
          </div>
        </div>
      </div>
    </div>

  </template>
  <script>
    Polymer({
      is: 'nuxeo-document-page',
      behaviors: [Nuxeo.LayoutBehavior],
      properties: {
        document: {
          type: Object
        },
        selectedTab: {
          type: String,
          value: 'comments',
          notify: true
        },
        opened: {
          type: Boolean,
          value: false,
          notify: true,
          reflectToAttribute: true,
          observer: '_openedChanged',
        }
      },

      _openedChanged: function() {
        Polymer.Async.animationFrame.run(function() {
          // notify that there was a resize
          this.dispatchEvent(new CustomEvent('resize', {
            bubbles: false,
            composed: true,
          }));
        });
      },

      _toggleOpened: function() {
        this.opened = !this.opened;
      },

      _isMutable: function(doc) {
        return !this.hasFacet(doc, 'Immutable') && doc.type !== 'Root' && !this.isTrashed(doc);
      },

      _hasCollections: function(doc) {
        return this.hasCollections(doc);
      }
    });
  </script>

</dom-module>
<dom-module id="nuxeo-collapsible-document-page" assetpath="document/">
  <template>
    <style include="nuxeo-styles">
      .page {
        @apply --layout-vertical;
      }

      .details {
        @apply --layout-horizontal;
        @apply --layout-wrap;
        @apply --layout-justified;
      }

      .details .section {
        @apply --layout-flex;
        margin: 16px;
        min-width: 256px;
        max-width: 320px;
      }

      paper-icon-button {
        @apply --nuxeo-action;
      }

      paper-icon-button:hover {
        @apply --nuxeo-action-hover;
      }

      nuxeo-document-view {
        --nuxeo-document-content-min-height: calc(100vh - 237px - var(--nuxeo-app-top));
      }
    </style>

    <nuxeo-document-info-bar document="[[document]]"></nuxeo-document-info-bar>

    <div class="page">
      <nuxeo-card id="detailsCard" heading="[[i18n('documentPage.details')]]" collapsible="">
        <div class="details">
          <div class="section">
            <h3>[[i18n('documentPage.info')]]</h3>
            <nuxeo-document-info document="[[document]]"></nuxeo-document-info>
          </div>

          <div class="section">
            <h3>[[i18n('documentPage.metadata')]]</h3>
            <nuxeo-document-metadata document="[[document]]"></nuxeo-document-metadata>
          </div>

          <div class="section" hidden$="[[!_hasCollections(document)]]">
            <h3>[[i18n('documentPage.collections')]]</h3>
            <nuxeo-document-collections document="[[document]]"></nuxeo-document-collections>
          </div>

          <template is="dom-if" if="[[hasFacet(document, 'NXTag')]]">
            <div class="section">
              <h3>[[i18n('documentPage.tags')]]</h3>
              <nuxeo-tag-suggestion document="[[document]]" allow-new-tags="" placeholder="[[i18n('documentPage.tags.placeholder')]]" readonly="[[!hasPermission(document, 'Write')]]">&gt;
              </nuxeo-tag-suggestion>
            </div>
          </template>

          <div class="section">
            <h3>[[i18n('documentPage.activity')]]</h3>
            <nuxeo-document-activity document="[[document]]"></nuxeo-document-activity>
          </div>
        </div>
      </nuxeo-card>

      <div class="main">
        <nuxeo-document-view document="[[document]]"></nuxeo-document-view>
      </div>
    </div>

  </template>
  <script>
    Polymer({
      is: 'nuxeo-collapsible-document-page',
      behaviors: [Nuxeo.LayoutBehavior],
      properties: {
        document: {
          type: Object
        }
      },

      _hasCollections: function (doc) {
        return this.hasCollections(doc);
      }
    });
  </script>
</dom-module>
<dom-module id="nuxeo-document-edit" assetpath="document/">
  <template>
    <nuxeo-document-form-layout document="{{document}}" layout="edit" headers="[[headers]]"></nuxeo-document-form-layout>
  </template>
  <script>
    Polymer({
      is: 'nuxeo-document-edit',
      properties: {
        document: {
          type: Object,
          notify: true
        },

        headers: {
          type: Object
        }
      }
    });
  </script>
</dom-module>
<dom-module id="nuxeo-vocabulary-management" assetpath="directory/">
  <template>
    <style>
      :host {
        display: block;
      }

      nuxeo-data-table {
        min-height: calc(100vh - 280px);
      }

      .top.actions {
        @apply --layout-horizontal;
        @apply --layout-center;
        @apply --layout-end-justified;
        margin: 1em 0 1em 0;
      }

      nuxeo-select {
        max-width: 223px;
      }

      nuxeo-dialog {
        min-width: 480px;
      }

      @media (max-width: 1024px) {
        nuxeo-dialog {
          min-width: 0;
          width: 90%;
        }
      }

     nuxeo-dialog .buttons {
        @apply --layout-horizontal;
        @apply --layout-justified;
        margin-top: 16px;
        background-color: var(--nuxeo-dialog-buttons-bar, white);
      }
    </style>

    <nuxeo-resource id="directory" path="/directory" params="{&quot;pageSize&quot;: 0}"></nuxeo-resource>
    <nuxeo-resource id="schema"></nuxeo-resource>

    <nuxeo-page>
      <div slot="header">
        <span>[[i18n('vocabularyManagement.heading')]]</span>
      </div>

      <div>
        <nuxeo-card>
          <nuxeo-select label="[[i18n('vocabularyManagement.vocabulary')]]" placeholder="[[i18n('vocabularyManagement.select')]]" selected="{{selectedVocabulary}}" attr-for-selected="name">
            <template is="dom-repeat" items="[[vocabularies]]" as="vocabulary">
              <paper-item name$="[[vocabulary.name]]">[[vocabulary.name]]</paper-item>
            </template>
          </nuxeo-select>
        </nuxeo-card>

        <template is="dom-if" if="[[_isVocabularySelected(selectedVocabulary)]]">
          <div class="top actions">
            <paper-button id="addEntry" class="primary" on-tap="_createEntry">
              <span>+ [[i18n('vocabularyManagement.addEntry')]]</span>
            </paper-button>
          </div>
          <nuxeo-data-table id="table" empty-label="[[i18n('vocabularyManagement.noEntry')]]" empty-label-when-filtered="[[i18n('vocabularyManagement.noEntryWhenFiltered')]]">
            <template is="dom-repeat" items="[[colDef]]" as="col">
              <nuxeo-data-table-column name="[[i18n(col.name)]]" key="[[col.key]]">
                <template>
                  <template is="dom-if" if="[[!_entryActions(column.key)]]">
                    [[_value(index, column.key)]]
                  </template>
                  <template is="dom-if" if="[[_entryActions(column.key)]]">
                    <paper-icon-button id="edit-button-[[index]]" icon="nuxeo:edit" on-tap="_editEntry"></paper-icon-button>
                    <nuxeo-tooltip for="edit-button-[[index]]">[[i18n('vocabularyManagement.editEntry')]]</nuxeo-tooltip>
                    <paper-icon-button id="delete-button-[[index]]" name="delete" icon="nuxeo:delete" on-tap="_deleteEntry"></paper-icon-button>
                    <nuxeo-tooltip for="delete-button-[[index]]">[[i18n('vocabularyManagement.deleteEntry')]]</nuxeo-tooltip>
                  </template>
                </template>
              </nuxeo-data-table-column>
            </template>
          </nuxeo-data-table>
        </template>
      </div>
    </nuxeo-page>

    <nuxeo-dialog id="vocabularyEditDialog" with-backdrop="">
      <h2>[[i18n('vocabularyManagement.popup.editEntry')]]</h2>
      <iron-form id="form">
        <form>
          <nuxeo-layout id="layout" href="[[_layoutHref(_selectedSchema)]]" model="[[_layoutModel(_selectedEntry)]]" error="[[i18n('documentVocabularyManagement.layoutNotFound', _selectedSchema)]]" on-element-changed="_elementChanged">
          </nuxeo-layout>
        </form>
      </iron-form>
      <div class="buttons">
        <paper-button name="cancel" noink="" dialog-dismiss="">[[i18n('command.cancel')]]</paper-button>
        <paper-button name="save" noink="" class="primary" on-tap="_save">[[i18n('command.save')]]</paper-button>
      </div>
    </nuxeo-dialog>

  </template>

  <script>
    (function() {
      var schemaDataCache = {};
      Polymer({
        is: 'nuxeo-vocabulary-management',
        behaviors: [Nuxeo.I18nBehavior],
        properties: {
          vocabularies: Array,
          selectedVocabulary: String,
          entries: {
            type: Array,
            value: []
          },
          colDef: {
            type: Object,
            notify: true
          },
          visible: {
            type: Boolean,
            observer: '_visibleChanged'
          },
          _selectedEntry: {
            type: Object
          },
          _selectedSchema: {
            type: String,
            computed: '_schemaFor(selectedVocabulary)'
          }
        },

        observers: [
          '_refresh(selectedVocabulary)'
        ],

        _visibleChanged: function() {
          if (this.visible && !this.vocabularies) {
            this.$.directory.get().then(function(response) {
              this.vocabularies = response.entries;
            }.bind(this));
          }
        },

        /**
         * Returns the href for the current layout element
         */
        _layoutHref: function(schema) {
          var lowerCaseSchema = schema.toLowerCase();
          return this.resolveUrl(lowerCaseSchema + '/nuxeo-' + lowerCaseSchema + '-edit-layout.html');
        },

        _layoutModel: function() {
          return {
            entry: this._selectedEntry,
            directory: this.selectedVocabulary,
            parentDirectory: this._getParentDirectoryFor(this._selectedEntry),
            entries: this.entries,
            new: this._new
          };
        },

        _schemaFor: function() {
          if (!this._isVocabularySelected()) {
            return;
          }
          var schema = '';
          for (var i in this.vocabularies) {
            if (this.vocabularies[i].name === this.selectedVocabulary) {
              schema = this.vocabularies[i].schema;
              break;
            }
          }
          if (!schema || schema.length === 0) {
            return 'vocabulary';
          }
          return schema;
        },

        _getParentDirectoryFor: function(entry) {
          var parent = '';
          for (var i in this.vocabularies) {
            if (this.vocabularies[i].name === entry.directoryName) {
              parent = this.vocabularies[i].parent;
              break;
            }
          }
          return parent;
        },

        _entryActions: function(o) {
          return o  === 'actions';
        },

        _refresh: function() {
          if (this._isVocabularySelected()) {
            this.$.directory.path = '/directory/' + this.selectedVocabulary;
            this.entries = [];
            this.colDef = [];
            this.$.directory.get().then(function(resp) {
              var tmp = [];
              if (resp.entries.length > 0) {
                tmp = Object.keys(resp.entries[0].properties).map(function(key) {
                  return {key: key, name: 'vocabularyManagement.edit.' + key, pos: this._computeColPos(key)};
                }.bind(this));
              }
              tmp.push({key: 'actions', name: 'vocabularyManagement.edit.actions', pos: 1000, actions: true});
              tmp.sort(function(a, b) {
                return a.pos - b.pos;
              });
              this.colDef = tmp;
              this.entries = resp.entries;

              var table = this.$$('#table');
              table.items = [];
              table.items = this.entries;
            }.bind(this));
          }
        },

        _value: function(index, prop) {
          var entry = this.entries[index];
          if (entry && entry.properties && prop) {
            if (prop === 'obsolete') {
              return entry.properties[prop] > 0 ? this.i18n('label.yes') : this.i18n('label.no');
            }
            return entry.properties[prop];
          } else {
            return 'N/A';
          }
        },

        _computeColPos: function(key) {
          if (key === 'parent') {
            return 1;
          } else if (key === 'id') {
            return 2;
          } else if (key === 'obsolete') {
            return 98;
          } else if (key === 'ordering') {
            return 99;
          } else {
            return 50;
          }
        },

        _deleteEntry: function(e) {
          if (confirm(this.i18n('vocabularyManagement.confirmDelete'))) {
            var item = e.target.parentNode.item;
            this.$.directory.path = '/directory/' + item.directoryName + '/' + item.properties.id;
            this.$.directory.remove().then(function() {
              this._refresh();
              this.fire('notify', {message: this.i18n('vocabularyManagement.successfullyDeleted')});
            }.bind(this), function(err) {
              if (err.status === 401) {
                this.fire('notify', {message: this.i18n('label.error').toUpperCase() + ': ' +
                    this.i18n('vocabularyManagement.cannotDelete.referencedEntry')});
              } else {
                this.fire('notify', {message: this.i18n('label.error').toUpperCase() + ': ' +
                    this.i18n('vocabularyManagement.cannotDelete.error')});
              }
            }.bind(this));
          }
        },

        _editEntry: function(e) {
          this._new = false;
          this._selectedEntry = e.target.parentNode.item;
          this.$.vocabularyEditDialog.toggle();
        },

        _elementChanged: function() {
          if (this.$.vocabularyEditDialog.opened) {
            this.async(this.$.vocabularyEditDialog.notifyResize.bind(this.$.vocabularyEditDialog));
          }
        },

        _save: function() {
          if (!this.$.layout.validate()) {
            return;
          }
          this.$.directory.data = this._selectedEntry;
          if (this._new) {
            this.$.directory.path = '/directory/' + this._selectedEntry.directoryName;
            this.$.directory.post().then(function() {
              this.$.vocabularyEditDialog.toggle();
              this.fire('notify', {message: this.i18n('vocabularyManagement.successfullyCreated')});
              this._refresh();
            }.bind(this),
              function(err) {
                this.fire('notify', {message: this.i18n('label.error').toUpperCase() + ': ' +
                    (err.message && err.message.length > 0 ? err.message :
                      this.i18n('vocabularyManagement.cannotCreate'))});
              }.bind(this));
          } else {
            this.$.directory.path = '/directory/' + this._selectedEntry.directoryName +
              '/' + this._selectedEntry.properties.id;
            this.$.directory.put().then(function() {
              this.$.vocabularyEditDialog.toggle();
              this.fire('notify', {message: this.i18n('vocabularyManagement.successfullyEdited')});
              this._refresh();
            }.bind(this),
              function(err) {
                this.fire('notify', {message: this.i18n('label.error').toUpperCase() + ': ' +
                    (err.message && err.message.length > 0 ? err.message :
                      this.i18n('vocabularyManagement.cannotEdit'))});
              }.bind(this));
          }
        },

        _isVocabularySelected: function() {
          return this.selectedVocabulary && this.selectedVocabulary.length > 0;
        },

        _createEntry: function() {
          var emptyEntry = {
            'entity-type': 'directoryEntry',
            directoryName: this.selectedVocabulary,
            id: undefined,
            properties: {}
          };
          this._getSchemaFields().then(function(response) {
            response.forEach(function(field) {
              emptyEntry.properties[field] = undefined;
            });
            this._new = true;
            this._selectedEntry = emptyEntry;
            this.$.vocabularyEditDialog.toggle();
          }.bind(this));
        },

        _getSchemaFields: function() {
          var schema = this._selectedSchema;
          if (schemaDataCache[schema]) {
            return Promise.resolve(schemaDataCache[schema]);
          } else if (this.entries.length > 0) {
            var fields = Object.keys(this.entries[0].properties);
            schemaDataCache[schema] = fields;
            return Promise.resolve(fields);
          } else {
            this.$.schema.path = '/config/schemas/' + schema;
            return this.$.schema.get()
              .then(function(response) {
                var fields = Object.keys(response.fields);
                schemaDataCache[schema] = fields;
                return fields;
              }).catch(function(error) {
                this.fire('notify', {message: this.i18n('vocabularyManagement.cannotGetSchema')});
                if (error.status !== 404) {
                  throw error;
                }
              });
          }
        }

      });
    })();
  </script>
</dom-module>
<dom-module id="nuxeo-saved-search-actions" assetpath="search/">
  <template>

    <style include="iron-flex">
      paper-item {
        @apply --layout-horizontal;
        @apply --layout-center;
        cursor: pointer;
      }
      iron-icon {
        margin-right: 16px;
      }
      paper-menu-button[hidden] {
        display: none !important;
      }
    </style>

    <nuxeo-document auto="" doc-id="[[searchId]]" enrichers="permissions" response="{{searchDoc}}"></nuxeo-document>
    <div class="horizontal layout center">
      <paper-button on-tap="_saveSearchAs" hidden$="[[!_showSaveAs(searchDoc, isSavedSearch, _dirty)]]">
        <iron-icon icon="nuxeo:filter-edit"></iron-icon>[[i18n('app.saveNewSearch')]]
      </paper-button>
      <paper-button on-tap="_saveSearch" hidden$="[[!_showSave(searchDoc, isSavedSearch, _dirty)]]">
        <iron-icon icon="nuxeo:filter-add"></iron-icon>[[i18n('app.savedSearch')]]
      </paper-button>
      <paper-menu-button no-animations="" horizontal-align="right" vertical-offset="40" hidden$="[[!_showOtherSearchActions(searchDoc, isSavedSearch, _dirty)]]">
        <paper-icon-button icon="icons:more-vert" slot="dropdown-trigger" alt="menu"></paper-icon-button>
        <paper-listbox slot="dropdown-content">
          <paper-item on-tap="_renameSearch">
            <iron-icon icon="nuxeo:edit"></iron-icon>[[i18n('app.renameSearch')]]
          </paper-item>
          <paper-item on-tap="_shareSearch">
            <iron-icon icon="nuxeo:share"></iron-icon>[[i18n('app.shareSearch')]]
          </paper-item>
          <paper-item on-tap="_deleteSearch">
            <iron-icon icon="nuxeo:delete"></iron-icon>[[i18n('app.deleteSearch')]]
          </paper-item>
        </paper-listbox>
      </paper-menu-button>
    </div>

  </template>
  <script>
    Polymer({
      is: 'nuxeo-saved-search-actions',
      behaviors: [Nuxeo.I18nBehavior, Nuxeo.FiltersBehavior],
      properties: {
        searchId: String,
        searchDoc: Object,
        searchForm: {
          type: Object,
          observer: '_searchFormChanged'
        },
        _dirty: Boolean
      },

      _searchFormChanged: function() {
        this._dirty = this.searchForm && this.searchForm.dirty;
        if (this.searchForm) {
          this.searchForm.addEventListener('dirty-changed', function() {
            this._dirty = this.searchForm.dirty;
          }.bind(this));
          this.searchForm.addEventListener('selected-search-changed', function() {
            if (this.searchForm.selectedSearch) {
              this.searchId = this.searchForm.selectedSearch.id;
              this.isSavedSearch = !!this.searchId;
            }
          }.bind(this));

          if (this.searchForm.selectedSearch) {
            this.searchId = this.searchForm.selectedSearch.id;
          }
        }
        this.isSavedSearch = !!this.searchId;
      },


      _saveSearch: function() {
        this.searchForm.save();
      },

      _saveSearchAs: function() {
        this.searchForm.saveAs();
      },

      _renameSearch: function() {
        this.searchForm.rename();
      },

      _shareSearch: function() {
        this.searchForm.share();
      },

      _deleteSearch: function() {
        this.searchForm.delete();
      },

      _showSaveAs: function() {
        return this.isSavedSearch || (!this.isSavedSearch && this.searchForm && this._dirty);
      },

      _showSave: function() {
        return this.isSavedSearch && this._dirty && this._hasPermissions();
      },

      _showOtherSearchActions: function() {
        return this.isSavedSearch && this._hasPermissions();
      },

      _hasPermissions: function() {
        return this.searchDoc ? (this.searchDoc.contextParameters.permissions.indexOf('Write') > -1 ||
                this.searchDoc.contextParameters.permissions.indexOf('Everything') > -1) : false;
      }
    });
  </script>
</dom-module>
<dom-module id="nuxeo-search-results-layout" assetpath="search/">
  <template>

    <nuxeo-layout id="results" href="[[_resultsHref(searchName)]]" model="[[_resultsModel(searchName,nxProvider)]]" error="[[i18n('searchResults.layoutNotFound', searchName)]]" on-element-changed="_formChanged"></nuxeo-layout>

  </template>

  <script>
    Polymer({
      is: 'nuxeo-search-results-layout',

      behaviors: [Nuxeo.I18nBehavior],

      properties: {
        /**
         * The name of the search layout.
         **/
        searchName: String,
        /**
         * The `nuxeo-page-provider` instance used to perform the search.
         **/
        nxProvider: HTMLElement,
        /**
         * An object propagating key/values served by enclosing slot contents.
         */
        model: {
          type: Object,
          value: function() { return {}; }
        },
        /**
         * The `nuxeo-results` element bound to this element.
         */
        results: {
          type: Object,
          notify: true
        },
      },

      get element() {
        return this.$.results && this.$.results.element;
      },

      fetch: function() {
        if (this.results) {
          this.results.fetch();
        } else {
          return Promise.resolve();
        }
      },

      reset: function() {
        if (this.results) {
          this.results.reset();
        }
      },

      _resultsHref: function() {
        var name = ['nuxeo', this.searchName.toLowerCase(), 'search-results'].join('-');
        return this.resolveUrl([this.searchName.toLowerCase(), name + '.html'].join('/'));
      },

      _resultsModel: function () {
        return { nxProvider: this.nxProvider, name: this.searchName };
      },

      _formChanged: function (e) {
        this.results = e.detail.value && this._grabResults([e.detail.value]);
      },

      _grabResults: function(els) {
        if (!Array.isArray(els) || els.length === 0) {
          return;
        }
        // let's find the results element on the local and light dom of the current elements
        var i, el;
        for (i = 0; i < els.length; i++) {
          el = els[i];
          var results = Polymer.dom(el).querySelector('nuxeo-results');
          if (!results && el.root) {
            results = Polymer.dom(el.root).querySelector('nuxeo-results');
          }
          if (results) {
            return results;
          }
        }
        // none found; let's do the same for the children of the current elements
        var children = [];
        for (i = 0; i < els.length; i++) {
          el = els[i];
          if (el.root) {
            children = [].concat.apply(children, children.concat(Polymer.dom(el.root).querySelectorAll('*')));
          }
        }
        return this._grabResults(children);
      }

    });
  </script>

</dom-module>
<dom-module id="nuxeo-results-view" assetpath="search/">
  <template>
    <style include="nuxeo-styles iron-flex iron-flex-alignment">
      .ellipsis {
        text-overflow: ellipsis;
        overflow: hidden;
        white-space: nowrap;
        display: block;
      }

      .capitalize {
        text-transform: capitalize;
      }

      .form {
        @apply --paper-card;
        padding: 0;
      }

      .header, #collapse {
        padding: 16px;
      }

      .buttons {
        @apply --buttons-bar;
      }

      .hidden {
        visibility: hidden;
      }

      .count {
        @apply --layout-horizontal;
        @apply --layout-center;
        @apply --layout-center-justified;
        background: var(--nuxeo-badge-background);
        color: white;
        border-radius: 50%;
        width: 24px;
        height: 24px;
        margin-left: 1em;
      }

      .filter {
        text-transform: uppercase;
      }

      .buttons {
        @apply --layout-horizontal;
      }
    </style>

    <nuxeo-page-provider id="provider" provider="[[provider]]" page-size="[[pageSize]]" aggregations="{{aggregations}}" enrichers="[[enrichers]]" params="[[_params]]" quick-filters="{{quickFilters}}" schemas="[[schemas]]" loading="{{loading}}" headers="[[headers]]" fetch-aggregates="" skip-aggregates$="[[skipAggregates]]" on-error="_onError">
    </nuxeo-page-provider>

    <template is="dom-if" if="[[showFilters]]">
      <div class="form">
        <div class="header horizontal layout center">
          <a href="javascript:undefined" class="horizontal layout center" on-tap="toggleExpand">
            <span><iron-icon icon="[[_expandIcon(opened)]]" toggle=""></iron-icon></span>
            <span class="filter">[[i18n('resultsView.filters.heading')]]</span>
          </a>
          <div class$="count [[_hideCounter]]">
            <span>[[_getFilterCount(_params.*)]]</span>
          </div>
          <div class="horizontal layout flex center end-justified">
            <paper-button noink="" on-tap="_clear" class$="[[_hideCounter]]">
              [[i18n('command.clear')]]
            </paper-button>
          </div>
        </div>
        <iron-collapse id="collapse" opened="{{opened}}">
          <nuxeo-search-form-layout id="form" provider="[[provider]]" search-name="[[searchName]]" aggregations="[[aggregations]]" params="[[_params]]" on-search-form-layout-changed="_formChanged"></nuxeo-search-form-layout>
          <paper-spinner-lite active="[[loading]]"></paper-spinner-lite>
        </iron-collapse>
        <div class="buttons" hidden$="[[!opened]]">
          <paper-button noink="" class="primary search" on-tap="_search" hidden$="[[auto]]">
            [[i18n('command.search')]]
          </paper-button>
          <div class="horizontal layout flex end-justified">
            <paper-button noink="" class="clear" on-tap="_clear">
              [[i18n('command.clear')]]
            </paper-button>
          </div>
        </div>
      </div>
    </template>

    <template is="dom-if" if="[[visible]]">
      <nuxeo-search-results-layout id="results" search-name="[[searchName]]" nx-provider="[[_nxProvider]]" on-navigate="_navigateFromSearch" on-results-changed="_resultsChanged"></nuxeo-search-results-layout>
    </template>

  </template>

  <script>
    Polymer({
      is: 'nuxeo-results-view',

      behaviors: [Nuxeo.I18nBehavior],

      properties: {
        /**
         * The id of the `nuxeo-page-provider` instance used to perform the search.
         */
        provider: {
          type: String
        },
        /**
         * The number of results per page.
         */
        pageSize: {
          type: Number,
          value: 40
        },
        /**
         * The query parameters passed on to `provider`.
         */
        params: {
          type: Object,
          observer: '_paramsChanged',
          value: {}
        },
        /**
         * List of content enrichers passed on to `provider`.
         * Already set by default are thumbnail, permissions and highlight.
         */
        enrichers: {
          type: String,
          value: 'thumbnail, permissions, highlight'
        },
        /**
         * The headers passed on to `provider`.
         * Already set by default are 'X-NXfetch.document': 'properties' and 'X-NXtranslate.directoryEntry': 'label'.
         */
        headers: {
          type: String,
          value: {'X-NXfetch.document': 'properties', 'X-NXtranslate.directoryEntry': 'label'}
        },
        /**
         * List of comma separated values of the document schemas to be returned.
         * All document schemas are returned by default.
         */
        schemas: {
          type: String
        },
        /**
         * If `true`, requests from `provider` are in flight.
         */
        loading: {
          type: Boolean,
          reflectToAttribute: true,
          value: false
        },
        /**
         * The name of the search layout.
         */
        searchName: String,
        /**
         * The aggregations returned by `provider`.
         */
        aggregations: {
          type: Object,
          observer: '_aggregationsChanged',
          notify: true
        },
        /**
         * Name of the quick filters to be displayed in case you don't want to display all of them.
         * Expected format : ['quickfilter1','quickfilter2'].
         */
        quickFilters: {
          type: Array,
          notify: true
        },
        /**
         * If `true`, the current element is visible.
         */
        visible: {
          type: Boolean,
          value: false
        },
        /**
         * If `true`, automatically execute the search when either `provider` or `params` changes.
         */
        auto: {
          type: Boolean,
          value: false
        },
        /**
         * If `true`, display the top filtering panel.
         */
        showFilters: {
          type: Boolean,
          value: false
        },
        /**
         * If `true`, opens the collapsible top filtering panel.
         */
        opened: {
          type: Boolean,
          value: false
        },
        /**
         * An external search form (containing its own page provider) will be used, instead of the embeded one.
         * In case this is set, the following properties should be ignored, as the behavior they affect will be
         * controlled by the search form: `provider`, `pageSize`, `params`, `schemas`, `enrichers`, `headers`,
         * `loading`, `aggregations`, `quickFilters` and `auto`.
         */
        searchForm: {
          type: Object,
          value: null,
          observer: '_searchFormChanged'
        },

        /**
         * If `true`, aggregates from page provider definition will not be computed.
         */
        skipAggregates: Boolean,

        _params: Object,
        _paramsCount: Number,
        _nxProvider: HTMLElement,
        _hideCounter: {
          type: String,
          computed: '_computeHideCounter(opened, _params.*)',
          value: 'hidden'
        }
      },

      ready: function() {
        if (!this._nxProvider) {
          this._nxProvider = this.$.provider;
        }
      },

      get form() {
        var form = this.$$('#form');
        return form && form.element;
      },

      get results() {
        return this.$$('#results');
      },

      toggleExpand: function() {
        this.$$('#collapse').toggle();
      },

      _expandIcon: function(opened) {
        return 'hardware:keyboard-arrow-' + (opened ? 'down' : 'right');
      },

      _getFilterCount: function() {
        if (this._params) {
          // subtract the number of original parameters (this._paramsCount)
          return Object.keys(this._params).length - this._paramsCount - ('highlight' in this._params ? 1 : 0);
        } else {
          return 0;
        }
      },

      _computeHideCounter: function(opened) {
        var count = this._getFilterCount();
        return opened || count === 0 ? 'hidden' : '';
      },

      _paramsChanged: function() {
        if (this.params) {
          // if the supplied params are a string, parse them; otherwise clone the object
          this._params = JSON.parse(typeof this.params === 'string' ? this.params : JSON.stringify(this.params));
          // cache the number of this.params to avoid having to parse json again if this.params is a string
          this._paramsCount = Object.keys(this._params).length;
        } else {
          this._params = {};
          this._paramsCount = 0;
        }
      },

      _search: function() {
        if (this.results) {
          this.results.reset();
          this.results.fetch();
        }
      },

      _aggregationsChanged: function() {
        if (this.form) {
          this.form.aggregations = this.aggregations;
        }
      },

      _onError: function(e) {
        this.fire('notify', e.detail.error);
        e.stopPropagation();
      },

      _clear: function() {
        if (this.form && this.form.clear !== undefined && typeof this.form.clear === 'function') {
          this.form.clear();
        }
        this._paramsChanged();
        if (!this.auto) {
          this.aggregations = {};
        }
        if (!this.auto && this.visible) {
          this._search();
        }
      },

      _formChanged: function(e) {
        this._clear();
        var form = e.detail.value;
        // setup data binding
        form.addEventListener('params-changed', function(e) {
          // e.detail.path is params.prop_name eg: params.ecm_fulltext
          if (e.detail.path) {
            var param = e.detail.path.split('.')[1];
            this.notifyPath('_params.' + param, e.detail.value);
            if (this.visible && this.auto) {
              this._search();
            }
          }
        }.bind(this));
        this.skipAggregates = form.skipAggregates;
        form.addEventListener('skip-aggregates-changed', function(e) {
          this.notifyPath('skipAggregates', e.detail.value);
        }.bind(this));
        form.addEventListener('trigger-search', this._search.bind(this));
        this._search();
      },

      _resultsChanged: function() {
        var results = this.results;
        if (this.searchForm && results) {
          this.searchForm.results = results.results;
        }
      },

      _searchFormChanged: function(searchForm) {
        if (searchForm) {
          this._nxProvider = searchForm.nxProvider;
          this.provider = this._nxProvider.provider;
          this.searchName = searchForm.searchName;
          var results = this.results;
          if (results) {
            searchForm.results = results.results;
          }
        }
      },

      _navigateFromSearch: function(e) {
        if (this.searchForm) {
          this.searchForm.displayQueue(e.detail.index);
        }
      }

    });
  </script>

</dom-module>
<dom-module id="nuxeo-document-task-assignment-popup" assetpath="workflow/">
  <template>
    <style include="nuxeo-styles">
      :host {
        display: block;
      }
    </style>

    <nuxeo-resource id="taskAssignment" path="/task/[[task.id]]/[[action]]" params="[[params]]"></nuxeo-resource>

    <nuxeo-dialog id="assignmentDialog" with-backdrop="" no-auto-focus="">
      <h2>[[i18n(task.name)]]</h2>
      <paper-dialog-scrollable>
        <iron-form id="assignmentForm">
          <form>
            <nuxeo-user-suggestion name="userGroup" label="[[i18n('tasks.assignment.userOrGroup')]]" value="{{actors}}" multiple="true" required="true" placeholder="[[i18n('tasks.assignment.placeholder')]]">
            </nuxeo-user-suggestion>
            <nuxeo-textarea id="commentText" label="[[i18n('tasks.assignment.comment')]]" placeholder="[[i18n('tasks.assignment.placeholder')]]" value="[[comment]]" max-rows="4">
            </nuxeo-textarea>
          </form>
        </iron-form>
      </paper-dialog-scrollable>
      <div class="buttons">
        <paper-button id="cancel" noink="" dialog-dismiss="">[[i18n('command.close')]]</paper-button>
        <paper-button id="confirm" noink="" class="primary" on-click="_processAssignment">[[_getActionLabel(action, i18n)]]</paper-button>
      </div>
    </nuxeo-dialog>

  </template>

  <script>
    Polymer({
      is: 'nuxeo-document-task-assignment-popup',
      behaviors: [Nuxeo.I18nBehavior],
      properties: {
        task: {
          type: Object
        },

        action: {
          type: String
        }
      },

      openPopup: function() {
        this._resetPopup();
        this.$.assignmentDialog.open();
      },

      _getActionLabel: function(action, i18n) {
        return i18n('tasks.' + action);
      },

      _processAssignment: function() {
        if (this.$.assignmentForm.validate()) {
          this.params['comment'] = this.comment;
          this.params[this.action === 'delegate' ? 'delegatedActors' : 'actors'] = this.actors;

          this.$.taskAssignment.put().then(function(task) {
            this.$.assignmentDialog.close();
            this.fire('workflowTaskAssignment', { task: task });
          }.bind(this));
        }
      },

      _resetPopup: function() {
        this.actors = [];
        this.comment = null;
        this.params = {};

        this.$.assignmentForm.reset();
      }

    });
  </script>

</dom-module>
<dom-module id="nuxeo-document-task" assetpath="workflow/">
  <template>
    <style include="nuxeo-styles">
      :host {
        display: block;
      }

      nuxeo-workflow-graph {
        position: relative;
      }

      #task-body {
        @apply --layout-vertical;
      }

      .heading {
        @apply --layout-horizontal;
        @apply --layout-justified;
      }

      .vertical {
        @apply --layout-vertical;
      }

      .horizontal {
        @apply --layout-horizontal;
      }

      h3 {
        margin-bottom: 0;
      }

      .options {
        @apply --layout-horizontal;
        @apply --layout-start;
        @apply --layout-end-justified;
        @apply --layout-flex;
      }

      .spaced {
        margin: 16px 0;
      }

      .date {
        color: var(--nuxeo-warn-text, #fb6107);
      }

      .view-graph {
        color: var(--nuxeo-primary-color, #0066ff);
        font-weight: bolder;
      }
    </style>

    <nuxeo-resource id="taskRequest" path="/task/[[task.id]]/[[action]]" data="{{taskData}}"></nuxeo-resource>

    <div id="task-body">

      <iron-pages selected="[[_selectedTab]]" attr-for-selected="name">
        <div name="resolution">
          <nuxeo-workflow-graph id="graph" workflow-id="[[task.workflowInstanceId]]"></nuxeo-workflow-graph>
          <nuxeo-document-task-assignment-popup id="assignmentDialog" task="[[task]]" action="[[action]]"></nuxeo-document-task-assignment-popup>

          <div class="heading">
            <div class="vertical">
              <h3>[[i18n(task.name)]]</h3>
              <a href="javascript:undefined" on-tap="_toggleGraphDialog" class="view-graph">[[i18n('tasks.viewGraph')]]</a>
            </div>
            <div class="options">
              <paper-button id="reassignBtn" noink="" dialog-confirm="" on-tap="_toggleAssignmentDialog" data-args="reassign" hidden$="[[!task.taskInfo.allowTaskReassignment]]">[[i18n('tasks.reassign')]]</paper-button>
              <paper-button id="delegateBtn" noink="" dialog-confirm="" on-tap="_toggleAssignmentDialog" data-args="delegate">[[i18n('tasks.delegate')]]</paper-button>
            </div>
          </div>
          <div class="horizontal spaced">
            <span>[[i18n(tasks.directive)]]</span>
          </div>
          <div id="assignedActors" class="vertical spaced">
            <span>[[i18n('tasks.actors.assigned')]]</span>
            <nuxeo-tags type="user" items="[[task.actors]]"></nuxeo-tags>
          </div>
          <template is="dom-if" if="[[_delegatedActorsExist(task.delegatedActors)]]">
            <div id="delegatedActors" class="vertical spaced">
              <span>[[i18n('tasks.actors.delegated')]]</span>
              <nuxeo-tags type="user" items="[[task.delegatedActors]]"></nuxeo-tags>
            </div>
          </template>
          <div class="vertical spaced">
            <label>[[i18n('documentTask.dueDate')]]</label>
            <div class="date">
              <nuxeo-date datetime="[[task.dueDate]]" format="relative"></nuxeo-date>
            </div>
          </div>

          <iron-form id="task-container">
            <form>
              <nuxeo-layout id="layout" href="[[_layoutHref(task)]]" model="[[_layoutModel(task)]]" error="[[i18n('documentView.layoutNotFound', task.nodeName)]]"></nuxeo-layout>
            </form>
          </iron-form>

          <div class="horizontal">
            <div class="options">
              <template is="dom-repeat" items="[[task.taskInfo.taskActions]]">
                <paper-button noink="" dialog-confirm="" class="primary" name$="[[item.name]]" on-tap="_processTask">[[i18n(item.label)]]</paper-button>
              </template>
            </div>
          </div>

        </div>
      </iron-pages>
    </div>
  </template>

  <script>
    Polymer({
      is: 'nuxeo-document-task',
      behaviors: [Nuxeo.RoutingBehavior, Nuxeo.FormatBehavior],
      properties: {
        task: {
          type: Object
        },

        action: {
          type: String
        },

        _selectedTab: {
          type: String,
          value: 'resolution'
        }
      },

      /**
       * Returns the name for the current layout element
       */
      _layoutHref: function(task) {
        if (task) {
          var layout = ['nuxeo', task.nodeName.toLowerCase(), 'layout'].join('-');
          return this.resolveUrl(task.workflowModelName.toLowerCase() + '/' + layout + '.html');
        }
      },

      _layoutModel: function(task) {
        if (task) {
          return { document: task.targetDocumentIds[0], task: task };
        }
      },

      validate: function() {
        var form = this.$['task-container'];

        // run our custom validation function first to allow setting custom native validity
        return this.$.layout.validate() && this._doNativeValidation(form) && form.validate();
      },

      _processTask: function(e) {
        var validate = e.model.item.validate;
        if (!validate || this.validate()) {
          this.action = e.model.item.name;
          this.taskData = {
            'entity-type': 'task',
            id: this.$.layout.element.task.id,
            variables: this.$.layout.element.task.variables
          };
          this.$.taskRequest.put().then(function(task) {
            this.fire('workflowTaskProcessed', { task: task });
          }.bind(this));
        }
      },

      _toggleGraphDialog: function() {
        this.$.graph.show();
      },

      _toggleAssignmentDialog: function(e) {
        this.action = e.target.dataset.args;
        this.$.assignmentDialog.openPopup();
      },

      _delegatedActorsExist: function(delegatedActors) {
        return !!delegatedActors && delegatedActors.length > 0;
      },

      // trigger native browser invalid-form UI
      _doNativeValidation: function(form) {
        var fakeSubmit = document.createElement('input');
        fakeSubmit.setAttribute('type', 'submit');
        fakeSubmit.style.display = 'none';
        form._form.appendChild(fakeSubmit);
        fakeSubmit.click();
        form._form.removeChild(fakeSubmit);
        return form._form.checkValidity();
      }

    });
  </script>

</dom-module>
<dom-module id="nuxeo-document-task-review-result" assetpath="workflow/">
  <template>
    <style>
      :host {
        display: block;
      }
    </style>
  </template>

  <script>
    Polymer({
      is: 'nuxeo-document-task-review-result',
      properties: {
        result: {
          type: String,
          observer: '_observeResult'
        }
      },

      _observeResult: function() {
        this.root.innerHTML = this.result;
      }
    });
  </script>

</dom-module>
<dom-module id="nuxeo-analytics" assetpath="nuxeo-admin/">
  <template>
    <style>
      .flex {
        @apply --layout-flex;
      }
      paper-listbox {
        @apply --layout-horizontal;
        --paper-listbox-background-color: transparent;
        padding: 0;
      }
    </style>

    <nuxeo-page>
      <div slot="header">
        <span class="flex">[[i18n('analytics.heading')]]</span>
      </div>
      <div slot="tabs">
        <paper-listbox selected="{{selected}}" attr-for-selected="name">
          <nuxeo-slot slot="ANALYTICS_ITEMS"></nuxeo-slot>
        </paper-listbox>
      </div>
      <div>
        <template is="dom-if" if="[[visible]]">
          <iron-pages selected="[[selected]]" attr-for-selected="name" selected-attribute="visible">
            <nuxeo-slot slot="ANALYTICS_PAGES"></nuxeo-slot>
          </iron-pages>
        </template>
      </div>
    </nuxeo-page>

  </template>
  <script>
    Polymer({
      is: 'nuxeo-analytics',
      behaviors: [Nuxeo.I18nBehavior],
      properties: {
        visible: Boolean,
        selected: String
      }
    });
  </script>
</dom-module>
<dom-module id="paper-slider" assetpath="bower_components/paper-slider/">
  <template strip-whitespace="">
    <style>
      :host {
        @apply --layout;
        @apply --layout-justified;
        @apply --layout-center;
        width: 200px;
        cursor: default;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
        --paper-progress-active-color: var(--paper-slider-active-color, var(--google-blue-700));
        --paper-progress-secondary-color: var(--paper-slider-secondary-color, var(--google-blue-300));
        --paper-progress-disabled-active-color: var(--paper-slider-disabled-active-color, var(--paper-grey-400));
        --paper-progress-disabled-secondary-color: var(--paper-slider-disabled-secondary-color, var(--paper-grey-400));
        --calculated-paper-slider-height: var(--paper-slider-height, 2px);
      }

      /* focus shows the ripple */
      :host(:focus) {
        outline: none;
      }

      /**
       * NOTE(keanulee): Though :host-context is not universally supported, some pages
       * still rely on paper-slider being flipped when dir="rtl" is set on body. For full
       * compatibility, dir="rtl" must be explicitly set on paper-slider.
       */
      :dir(rtl) #sliderContainer {
        -webkit-transform: scaleX(-1);
        transform: scaleX(-1);
      }

      /**
       * NOTE(keanulee): This is separate from the rule above because :host-context may
       * not be recognized.
       */
      :host([dir="rtl"]) #sliderContainer {
        -webkit-transform: scaleX(-1);
        transform: scaleX(-1);
      }

      /**
       * NOTE(keanulee): Needed to override the :host-context rule (where supported)
       * to support LTR sliders in RTL pages.
       */
      :host([dir="ltr"]) #sliderContainer {
        -webkit-transform: scaleX(1);
        transform: scaleX(1);
      }

      #sliderContainer {
        position: relative;
        width: 100%;
        height: calc(30px + var(--calculated-paper-slider-height));
        margin-left: calc(15px + var(--calculated-paper-slider-height)/2);
        margin-right: calc(15px + var(--calculated-paper-slider-height)/2);
      }

      #sliderContainer:focus {
        outline: 0;
      }

      #sliderContainer.editable {
        margin-top: 12px;
        margin-bottom: 12px;
      }

      .bar-container {
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        overflow: hidden;
      }

      .ring > .bar-container {
        left: calc(5px + var(--calculated-paper-slider-height)/2);
        transition: left 0.18s ease;
      }

      .ring.expand.dragging > .bar-container {
        transition: none;
      }

      .ring.expand:not(.pin) > .bar-container {
        left: calc(8px + var(--calculated-paper-slider-height)/2);
      }

      #sliderBar {
        padding: 15px 0;
        width: 100%;
        background-color: var(--paper-slider-bar-color, transparent);
        --paper-progress-container-color: var(--paper-slider-container-color, var(--paper-grey-400));
        --paper-progress-height: var(--calculated-paper-slider-height);
      }

      .slider-markers {
        position: absolute;
        /* slider-knob is 30px + the slider-height so that the markers should start at a offset of 15px*/
        top: 15px;
        height: var(--calculated-paper-slider-height);
        left: 0;
        right: -1px;
        box-sizing: border-box;
        pointer-events: none;
        @apply --layout-horizontal;
      }

      .slider-marker {
        @apply --layout-flex;
      }
      .slider-markers::after,
      .slider-marker::after {
        content: "";
        display: block;
        margin-left: -1px;
        width: 2px;
        height: var(--calculated-paper-slider-height);
        border-radius: 50%;
        background-color: var(--paper-slider-markers-color, #000);
      }

      .slider-knob {
        position: absolute;
        left: 0;
        top: 0;
        margin-left: calc(-15px - var(--calculated-paper-slider-height)/2);
        width: calc(30px + var(--calculated-paper-slider-height));
        height: calc(30px + var(--calculated-paper-slider-height));
      }

      .transiting > .slider-knob {
        transition: left 0.08s ease;
      }

      .slider-knob:focus {
        outline: none;
      }

      .slider-knob.dragging {
        transition: none;
      }

      .snaps > .slider-knob.dragging {
        transition: -webkit-transform 0.08s ease;
        transition: transform 0.08s ease;
      }

      .slider-knob-inner {
        margin: 10px;
        width: calc(100% - 20px);
        height: calc(100% - 20px);
        background-color: var(--paper-slider-knob-color, var(--google-blue-700));
        border: 2px solid var(--paper-slider-knob-color, var(--google-blue-700));
        border-radius: 50%;

        -moz-box-sizing: border-box;
        box-sizing: border-box;

        transition-property: -webkit-transform, background-color, border;
        transition-property: transform, background-color, border;
        transition-duration: 0.18s;
        transition-timing-function: ease;
      }

      .expand:not(.pin) > .slider-knob > .slider-knob-inner {
        -webkit-transform: scale(1.5);
        transform: scale(1.5);
      }

      .ring > .slider-knob > .slider-knob-inner {
        background-color: var(--paper-slider-knob-start-color, transparent);
        border: 2px solid var(--paper-slider-knob-start-border-color, var(--paper-grey-400));
      }

      .slider-knob-inner::before {
        background-color: var(--paper-slider-pin-color, var(--google-blue-700));
      }

      .pin > .slider-knob > .slider-knob-inner::before {
        content: "";
        position: absolute;
        top: 0;
        left: 50%;
        margin-left: -13px;
        width: 26px;
        height: 26px;
        border-radius: 50% 50% 50% 0;

        -webkit-transform: rotate(-45deg) scale(0) translate(0);
        transform: rotate(-45deg) scale(0) translate(0);
      }

      .slider-knob-inner::before,
      .slider-knob-inner::after {
        transition: -webkit-transform .18s ease, background-color .18s ease;
        transition: transform .18s ease, background-color .18s ease;
      }

      .pin.ring > .slider-knob > .slider-knob-inner::before {
        background-color: var(--paper-slider-pin-start-color, var(--paper-grey-400));
      }

      .pin.expand > .slider-knob > .slider-knob-inner::before {
        -webkit-transform: rotate(-45deg) scale(1) translate(17px, -17px);
        transform: rotate(-45deg) scale(1) translate(17px, -17px);
      }

      .pin > .slider-knob > .slider-knob-inner::after {
        content: attr(value);
        position: absolute;
        top: 0;
        left: 50%;
        margin-left: -16px;
        width: 32px;
        height: 26px;
        text-align: center;
        color: var(--paper-slider-font-color, #fff);
        font-size: 10px;

        -webkit-transform: scale(0) translate(0);
        transform: scale(0) translate(0);
      }

      .pin.expand > .slider-knob > .slider-knob-inner::after {
        -webkit-transform: scale(1) translate(0, -17px);
        transform: scale(1) translate(0, -17px);
      }

      /* paper-input */
      .slider-input {
        width: 50px;
        overflow: hidden;
        --paper-input-container-input: {
          text-align: center;
          @apply --paper-slider-input-container-input;
        };
        @apply --paper-slider-input;
      }

      /* disabled state */
      #sliderContainer.disabled {
        pointer-events: none;
      }

      .disabled > .slider-knob > .slider-knob-inner {
        background-color: var(--paper-slider-disabled-knob-color, var(--paper-grey-400));
        border: 2px solid var(--paper-slider-disabled-knob-color, var(--paper-grey-400));
        -webkit-transform: scale3d(0.75, 0.75, 1);
        transform: scale3d(0.75, 0.75, 1);
      }

      .disabled.ring > .slider-knob > .slider-knob-inner {
        background-color: var(--paper-slider-knob-start-color, transparent);
        border: 2px solid var(--paper-slider-knob-start-border-color, var(--paper-grey-400));
      }

      paper-ripple {
        color: var(--paper-slider-knob-color, var(--google-blue-700));
      }
    </style>

    <div id="sliderContainer" class$="[[_getClassNames(disabled, pin, snaps, immediateValue, min, expand, dragging, transiting, editable)]]">
      <div class="bar-container">
        <paper-progress disabled$="[[disabled]]" id="sliderBar" aria-hidden="true" min="[[min]]" max="[[max]]" step="[[step]]" value="[[immediateValue]]" secondary-progress="[[secondaryProgress]]" on-down="_bardown" on-up="_resetKnob" on-track="_bartrack" on-tap="_barclick">
        </paper-progress>
      </div>

      <template is="dom-if" if="[[snaps]]">
        <div class="slider-markers">
          <template is="dom-repeat" items="[[markers]]">
            <div class="slider-marker"></div>
          </template>
        </div>
      </template>

      <div id="sliderKnob" class="slider-knob" on-down="_knobdown" on-up="_resetKnob" on-track="_onTrack" on-transitionend="_knobTransitionEnd">
          <div class="slider-knob-inner" value$="[[immediateValue]]"></div>
      </div>
    </div>

    <template is="dom-if" if="[[editable]]">
      <paper-input id="input" type="number" step="[[step]]" min="[[min]]" max="[[max]]" class="slider-input" disabled$="[[disabled]]" value="[[immediateValue]]" on-change="_changeValue" on-keydown="_inputKeyDown" no-label-float="">
      </paper-input>
    </template>
  </template>

  <script>
    Polymer({
      is: 'paper-slider',

      behaviors: [
        Polymer.IronA11yKeysBehavior,
        Polymer.IronFormElementBehavior,
        Polymer.PaperInkyFocusBehavior,
        Polymer.IronRangeBehavior
      ],

      properties: {

        value: {type: Number, value: 0},

        /**
         * If true, the slider thumb snaps to tick marks evenly spaced based
         * on the `step` property value.
         */
        snaps: {type: Boolean, value: false, notify: true},

        /**
         * If true, a pin with numeric value label is shown when the slider thumb
         * is pressed. Use for settings for which users need to know the exact
         * value of the setting.
         */
        pin: {type: Boolean, value: false, notify: true},

        /**
         * The number that represents the current secondary progress.
         */
        secondaryProgress: {
          type: Number,
          value: 0,
          notify: true,
          observer: '_secondaryProgressChanged'
        },

        /**
         * If true, an input is shown and user can use it to set the slider value.
         */
        editable: {type: Boolean, value: false},

        /**
         * The immediate value of the slider.  This value is updated while the user
         * is dragging the slider.
         */
        immediateValue: {type: Number, value: 0, readOnly: true, notify: true},

        /**
         * The maximum number of markers
         */
        maxMarkers: {type: Number, value: 0, notify: true},

        /**
         * If true, the knob is expanded
         */
        expand: {type: Boolean, value: false, readOnly: true},

        /**
         * If true, a touchmove on the slider bar doesn't drag the slider thunb.
         * Tapping on the slider bar still updates the slider's position
         */
        ignoreBarTouch: {type: Boolean, value: false},

        /**
         * True when the user is dragging the slider.
         */
        dragging: {type: Boolean, value: false, readOnly: true, notify: true},

        transiting: {type: Boolean, value: false, readOnly: true},

        markers: {
          type: Array,
          readOnly: true,
          value: function() {
            return [];
          }
        },
      },

      observers: [
        '_updateKnob(value, min, max, snaps, step)',
        '_valueChanged(value)',
        '_immediateValueChanged(immediateValue)',
        '_updateMarkers(maxMarkers, min, max, snaps)'
      ],

      hostAttributes: {role: 'slider', tabindex: 0},

      keyBindings: {
        'left': '_leftKey',
        'right': '_rightKey',
        'down pagedown home': '_decrementKey',
        'up pageup end': '_incrementKey'
      },

      ready: function() {
        if (this.ignoreBarTouch) {
          Polymer.Gestures.setTouchAction(this.$.sliderBar, 'auto');
        }
      },

      /**
       * Increases value by `step` but not above `max`.
       * @method increment
       */
      increment: function() {
        this.value = this._clampValue(this.value + this.step);
      },

      /**
       * Decreases value by `step` but not below `min`.
       * @method decrement
       */
      decrement: function() {
        this.value = this._clampValue(this.value - this.step);
      },

      _updateKnob: function(value, min, max, snaps, step) {
        this.setAttribute('aria-valuemin', min);
        this.setAttribute('aria-valuemax', max);
        this.setAttribute('aria-valuenow', value);

        this._positionKnob(this._calcRatio(value) * 100);
      },

      _valueChanged: function() {
        this.fire('value-change', {composed: true});
      },

      _immediateValueChanged: function() {
        if (this.dragging) {
          this.fire('immediate-value-change', {composed: true});
        } else {
          this.value = this.immediateValue;
        }
      },

      _secondaryProgressChanged: function() {
        this.secondaryProgress = this._clampValue(this.secondaryProgress);
      },

      _expandKnob: function() {
        this._setExpand(true);
      },

      _resetKnob: function() {
        this.cancelDebouncer('expandKnob');
        this._setExpand(false);
      },

      _positionKnob: function(ratio) {
        this._setImmediateValue(this._calcStep(this._calcKnobPosition(ratio)));
        this._setRatio(this._calcRatio(this.immediateValue) * 100);

        this.$.sliderKnob.style.left = this.ratio + '%';
        if (this.dragging) {
          this._knobstartx = (this.ratio * this._w) / 100;
          this.translate3d(0, 0, 0, this.$.sliderKnob);
        }
      },

      _calcKnobPosition: function(ratio) {
        return (this.max - this.min) * ratio / 100 + this.min;
      },

      _onTrack: function(event) {
        event.stopPropagation();
        switch (event.detail.state) {
          case 'start':
            this._trackStart(event);
            break;
          case 'track':
            this._trackX(event);
            break;
          case 'end':
            this._trackEnd();
            break;
        }
      },

      _trackStart: function(event) {
        this._setTransiting(false);
        this._w = this.$.sliderBar.offsetWidth;
        this._x = this.ratio * this._w / 100;
        this._startx = this._x;
        this._knobstartx = this._startx;
        this._minx = -this._startx;
        this._maxx = this._w - this._startx;
        this.$.sliderKnob.classList.add('dragging');
        this._setDragging(true);
      },

      _trackX: function(event) {
        if (!this.dragging) {
          this._trackStart(event);
        }

        var direction = this._isRTL ? -1 : 1;
        var dx =
            Math.min(this._maxx, Math.max(this._minx, event.detail.dx * direction));
        this._x = this._startx + dx;

        var immediateValue =
            this._calcStep(this._calcKnobPosition(this._x / this._w * 100));
        this._setImmediateValue(immediateValue);

        // update knob's position
        var translateX =
            ((this._calcRatio(this.immediateValue) * this._w) - this._knobstartx);
        this.translate3d(translateX + 'px', 0, 0, this.$.sliderKnob);
      },

      _trackEnd: function() {
        var s = this.$.sliderKnob.style;

        this.$.sliderKnob.classList.remove('dragging');
        this._setDragging(false);
        this._resetKnob();
        this.value = this.immediateValue;

        s.transform = s.webkitTransform = '';

        this.fire('change', {composed: true});
      },

      _knobdown: function(event) {
        this._expandKnob();

        // cancel selection
        event.preventDefault();

        // set the focus manually because we will called prevent default
        this.focus();
      },

      _bartrack: function(event) {
        if (this._allowBarEvent(event)) {
          this._onTrack(event);
        }
      },

      _barclick: function(event) {
        this._w = this.$.sliderBar.offsetWidth;
        var rect = this.$.sliderBar.getBoundingClientRect();
        var ratio = (event.detail.x - rect.left) / this._w * 100;
        if (this._isRTL) {
          ratio = 100 - ratio;
        }
        var prevRatio = this.ratio;

        this._setTransiting(true);
        this._positionKnob(ratio);

        // if the ratio doesn't change, sliderKnob's animation won't start
        // and `_knobTransitionEnd` won't be called
        // Therefore, we need to manually update the `transiting` state
        if (prevRatio === this.ratio) {
          this._setTransiting(false);
        }

        this.async(function() {
          this.fire('change', {composed: true});
        });

        // cancel selection
        event.preventDefault();

        // set the focus manually because we will called prevent default
        this.focus();
      },

      _bardown: function(event) {
        if (this._allowBarEvent(event)) {
          this.debounce('expandKnob', this._expandKnob, 60);
          this._barclick(event);
        }
      },

      _knobTransitionEnd: function(event) {
        if (event.target === this.$.sliderKnob) {
          this._setTransiting(false);
        }
      },

      _updateMarkers: function(maxMarkers, min, max, snaps) {
        if (!snaps) {
          this._setMarkers([]);
        }
        var steps = Math.round((max - min) / this.step);
        if (steps > maxMarkers) {
          steps = maxMarkers;
        }
        if (steps < 0 || !isFinite(steps)) {
          steps = 0;
        }
        this._setMarkers(new Array(steps));
      },

      _mergeClasses: function(classes) {
        return Object.keys(classes)
            .filter(function(className) {
              return classes[className];
            })
            .join(' ');
      },

      _getClassNames: function() {
        return this._mergeClasses({
          disabled: this.disabled,
          pin: this.pin,
          snaps: this.snaps,
          ring: this.immediateValue <= this.min,
          expand: this.expand,
          dragging: this.dragging,
          transiting: this.transiting,
          editable: this.editable
        });
      },

      _allowBarEvent: function(event) {
        return (
            !this.ignoreBarTouch ||
            (event.detail.sourceEvent instanceof MouseEvent))
      },

      get _isRTL() {
        if (this.__isRTL === undefined) {
          this.__isRTL = window.getComputedStyle(this)['direction'] === 'rtl';
        }
        return this.__isRTL;
      },

      _leftKey: function(event) {
        if (this._isRTL)
          this._incrementKey(event);
        else
          this._decrementKey(event);
      },

      _rightKey: function(event) {
        if (this._isRTL)
          this._decrementKey(event);
        else
          this._incrementKey(event);
      },

      _incrementKey: function(event) {
        if (!this.disabled) {
          if (event.detail.key === 'end') {
            this.value = this.max;
          } else {
            this.increment();
          }
          this.fire('change');
          event.preventDefault();
        }
      },

      _decrementKey: function(event) {
        if (!this.disabled) {
          if (event.detail.key === 'home') {
            this.value = this.min;
          } else {
            this.decrement();
          }
          this.fire('change');
          event.preventDefault();
        }
      },

      _changeValue: function(event) {
        this.value = event.target.value;
        this.fire('change', {composed: true});
      },

      _inputKeyDown: function(event) {
        event.stopPropagation();
      },

      // create the element ripple inside the `sliderKnob`
      _createRipple: function() {
        this._rippleContainer = this.$.sliderKnob;
        return Polymer.PaperInkyFocusBehaviorImpl._createRipple.call(this);
      },

      // Hide the ripple when user is not interacting with keyboard.
      // This behavior is different from other ripple-y controls, but is
      // according to spec:
      // https://www.google.com/design/spec/components/sliders.html
      _focusedChanged: function(receivedFocusFromKeyboard) {
        if (receivedFocusFromKeyboard) {
          this.ensureRipple();
        }
        if (this.hasRipple()) {
          // note, ripple must be un-hidden prior to setting `holdDown`
          if (receivedFocusFromKeyboard) {
            this._ripple.style.display = '';
          } else {
            this._ripple.style.display = 'none';
          }
          this._ripple.holdDown = receivedFocusFromKeyboard;
        }
      }
    });

    /**
     * Fired when the slider's value changes.
     *
     * @event value-change
     */

    /**
     * Fired when the slider's immediateValue changes. Only occurs while the
     * user is dragging.
     *
     * To detect changes to immediateValue that happen for any input (i.e.
     * dragging, tapping, clicking, etc.) listen for immediate-value-changed
     * instead.
     *
     * @event immediate-value-change
     */

    /**
     * Fired when the slider's value changes due to user interaction.
     *
     * Changes to the slider's value due to changes in an underlying
     * bound variable will not trigger this event.
     *
     * @event change
     */
  </script>
</dom-module>
<script>
  var Nuxeo = Nuxeo || {};

  /**
   * @polymerBehavior Nuxeo.ChartDataBehavior
   */
  Nuxeo.ChartDataBehavior = {
    _labels: function(data) {
      return data.map(function(entry) {
        if (Array.isArray(entry.value)) {
          return entry.value.map(this._labels.bind(this));
        } else {
          return entry.key;
        }
      });
    },
    _series: function(data) {
      return data.map(function(obj) {
        return obj.key;
      });
    },
    _values: function(data) {
      return [data.map(function(entry) {
        if (Array.isArray(entry.value)) {
          return entry.value.map(this._values.bind(this));
        } else {
          return entry.value;
        }
      })];
    },
    _extendEndDate: function(date) {
      if (date && moment) {
        return this._formatDate(moment(date).add(1, 'days').subtract(1, 'ms').toJSON());
      }
      return date;
    },

    _formatDate: function(date) {
      return moment(date).format('YYYY-MM-DD');
    }
  };
</script>
<script>
  /*
   The MIT License (MIT)

   Copyright (c) 2014 Jonathan Ong me@jongleberry.com

   Permission is hereby granted, free of charge, to any person obtaining a copy
   of this software and associated documentation files (the "Software"), to deal
   in the Software without restriction, including without limitation the rights
   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   copies of the Software, and to permit persons to whom the Software is
   furnished to do so, subject to the following conditions:

   The above copyright notice and this permission notice shall be included in
   all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   THE SOFTWARE.

   https://github.com/jshttp/mime-db
   */

  var Nuxeo = Nuxeo || {};
  Nuxeo.mimeTypes = {
    'application/1d-interleaved-parityfec': {
      'source': 'iana'
    },
    'application/3gpdash-qoe-report+xml': {
      'source': 'iana'
    },
    'application/3gpp-ims+xml': {
      'source': 'iana'
    },
    'application/a2l': {
      'source': 'iana'
    },
    'application/activemessage': {
      'source': 'iana'
    },
    'application/alto-costmap+json': {
      'source': 'iana'
    },
    'application/alto-costmapfilter+json': {
      'source': 'iana',
      'compressible': true
    },
    'application/alto-directory+json': {
      'source': 'iana',
      'compressible': true
    },
    'application/alto-endpointcost+json': {
      'source': 'iana',
      'compressible': true
    },
    'application/alto-endpointcostparams+json': {
      'source': 'iana',
      'compressible': true
    },
    'application/alto-endpointprop+json': {
      'source': 'iana',
      'compressible': true
    },
    'application/alto-endpointpropparams+json': {
      'source': 'iana',
      'compressible': true
    },
    'application/alto-error+json': {
      'source': 'iana',
      'compressible': true
    },
    'application/alto-networkmap+json': {
      'source': 'iana',
      'compressible': true
    },
    'application/alto-networkmapfilter+json': {
      'source': 'iana',
      'compressible': true
    },
    'application/aml': {
      'source': 'iana'
    },
    'application/andrew-inset': {
      'source': 'iana',
      'extensions': ['ez']
    },
    'application/applefile': {
      'source': 'iana'
    },
    'application/applixware': {
      'source': 'apache',
      'extensions': ['aw']
    },
    'application/atf': {
      'source': 'iana'
    },
    'application/atfx': {
      'source': 'iana'
    },
    'application/atom+xml': {
      'source': 'iana',
      'compressible': true,
      'extensions': ['atom']
    },
    'application/atomcat+xml': {
      'source': 'iana',
      'extensions': ['atomcat']
    },
    'application/atomdeleted+xml': {
      'source': 'iana'
    },
    'application/atomicmail': {
      'source': 'iana'
    },
    'application/atomsvc+xml': {
      'source': 'iana',
      'extensions': ['atomsvc']
    },
    'application/atxml': {
      'source': 'iana'
    },
    'application/auth-policy+xml': {
      'source': 'iana'
    },
    'application/bacnet-xdd+zip': {
      'source': 'iana'
    },
    'application/batch-smtp': {
      'source': 'iana'
    },
    'application/bdoc': {
      'compressible': false,
      'extensions': ['bdoc']
    },
    'application/beep+xml': {
      'source': 'iana'
    },
    'application/calendar+json': {
      'source': 'iana',
      'compressible': true
    },
    'application/calendar+xml': {
      'source': 'iana'
    },
    'application/call-completion': {
      'source': 'iana'
    },
    'application/cals-1840': {
      'source': 'iana'
    },
    'application/cbor': {
      'source': 'iana'
    },
    'application/ccmp+xml': {
      'source': 'iana'
    },
    'application/ccxml+xml': {
      'source': 'iana',
      'extensions': ['ccxml']
    },
    'application/cdfx+xml': {
      'source': 'iana'
    },
    'application/cdmi-capability': {
      'source': 'iana',
      'extensions': ['cdmia']
    },
    'application/cdmi-container': {
      'source': 'iana',
      'extensions': ['cdmic']
    },
    'application/cdmi-domain': {
      'source': 'iana',
      'extensions': ['cdmid']
    },
    'application/cdmi-object': {
      'source': 'iana',
      'extensions': ['cdmio']
    },
    'application/cdmi-queue': {
      'source': 'iana',
      'extensions': ['cdmiq']
    },
    'application/cdni': {
      'source': 'iana'
    },
    'application/cea': {
      'source': 'iana'
    },
    'application/cea-2018+xml': {
      'source': 'iana'
    },
    'application/cellml+xml': {
      'source': 'iana'
    },
    'application/cfw': {
      'source': 'iana'
    },
    'application/cms': {
      'source': 'iana'
    },
    'application/cnrp+xml': {
      'source': 'iana'
    },
    'application/coap-group+json': {
      'source': 'iana',
      'compressible': true
    },
    'application/commonground': {
      'source': 'iana'
    },
    'application/conference-info+xml': {
      'source': 'iana'
    },
    'application/cpl+xml': {
      'source': 'iana'
    },
    'application/csrattrs': {
      'source': 'iana'
    },
    'application/csta+xml': {
      'source': 'iana'
    },
    'application/cstadata+xml': {
      'source': 'iana'
    },
    'application/csvm+json': {
      'source': 'iana',
      'compressible': true
    },
    'application/cu-seeme': {
      'source': 'apache',
      'extensions': ['cu']
    },
    'application/cybercash': {
      'source': 'iana'
    },
    'application/dart': {
      'compressible': true
    },
    'application/dash+xml': {
      'source': 'iana',
      'extensions': ['mpd']
    },
    'application/dashdelta': {
      'source': 'iana'
    },
    'application/davmount+xml': {
      'source': 'iana',
      'extensions': ['davmount']
    },
    'application/dca-rft': {
      'source': 'iana'
    },
    'application/dcd': {
      'source': 'iana'
    },
    'application/dec-dx': {
      'source': 'iana'
    },
    'application/dialog-info+xml': {
      'source': 'iana'
    },
    'application/dicom': {
      'source': 'iana'
    },
    'application/dii': {
      'source': 'iana'
    },
    'application/dit': {
      'source': 'iana'
    },
    'application/dns': {
      'source': 'iana'
    },
    'application/docbook+xml': {
      'source': 'apache',
      'extensions': ['dbk']
    },
    'application/dskpp+xml': {
      'source': 'iana'
    },
    'application/dssc+der': {
      'source': 'iana',
      'extensions': ['dssc']
    },
    'application/dssc+xml': {
      'source': 'iana',
      'extensions': ['xdssc']
    },
    'application/dvcs': {
      'source': 'iana'
    },
    'application/ecmascript': {
      'source': 'iana',
      'compressible': true,
      'extensions': ['ecma']
    },
    'application/edi-consent': {
      'source': 'iana'
    },
    'application/edi-x12': {
      'source': 'iana',
      'compressible': false
    },
    'application/edifact': {
      'source': 'iana',
      'compressible': false
    },
    'application/efi': {
      'source': 'iana'
    },
    'application/emergencycalldata.comment+xml': {
      'source': 'iana'
    },
    'application/emergencycalldata.deviceinfo+xml': {
      'source': 'iana'
    },
    'application/emergencycalldata.providerinfo+xml': {
      'source': 'iana'
    },
    'application/emergencycalldata.serviceinfo+xml': {
      'source': 'iana'
    },
    'application/emergencycalldata.subscriberinfo+xml': {
      'source': 'iana'
    },
    'application/emma+xml': {
      'source': 'iana',
      'extensions': ['emma']
    },
    'application/emotionml+xml': {
      'source': 'iana'
    },
    'application/encaprtp': {
      'source': 'iana'
    },
    'application/epp+xml': {
      'source': 'iana'
    },
    'application/epub+zip': {
      'source': 'iana',
      'extensions': ['epub']
    },
    'application/eshop': {
      'source': 'iana'
    },
    'application/exi': {
      'source': 'iana',
      'extensions': ['exi']
    },
    'application/fastinfoset': {
      'source': 'iana'
    },
    'application/fastsoap': {
      'source': 'iana'
    },
    'application/fdt+xml': {
      'source': 'iana'
    },
    'application/fits': {
      'source': 'iana'
    },
    'application/font-sfnt': {
      'source': 'iana'
    },
    'application/font-tdpfr': {
      'source': 'iana',
      'extensions': ['pfr']
    },
    'application/font-woff': {
      'source': 'iana',
      'compressible': false,
      'extensions': ['woff']
    },
    'application/font-woff2': {
      'compressible': false,
      'extensions': ['woff2']
    },
    'application/framework-attributes+xml': {
      'source': 'iana'
    },
    'application/gml+xml': {
      'source': 'apache',
      'extensions': ['gml']
    },
    'application/gpx+xml': {
      'source': 'apache',
      'extensions': ['gpx']
    },
    'application/gxf': {
      'source': 'apache',
      'extensions': ['gxf']
    },
    'application/gzip': {
      'name': 'GZIP',
      'source': 'iana',
      'compressible': false
    },
    'application/h224': {
      'source': 'iana'
    },
    'application/held+xml': {
      'source': 'iana'
    },
    'application/http': {
      'source': 'iana'
    },
    'application/hyperstudio': {
      'source': 'iana',
      'extensions': ['stk']
    },
    'application/ibe-key-request+xml': {
      'source': 'iana'
    },
    'application/ibe-pkg-reply+xml': {
      'source': 'iana'
    },
    'application/ibe-pp-data': {
      'source': 'iana'
    },
    'application/iges': {
      'source': 'iana'
    },
    'application/im-iscomposing+xml': {
      'source': 'iana'
    },
    'application/index': {
      'source': 'iana'
    },
    'application/index.cmd': {
      'source': 'iana'
    },
    'application/index.obj': {
      'source': 'iana'
    },
    'application/index.response': {
      'source': 'iana'
    },
    'application/index.vnd': {
      'source': 'iana'
    },
    'application/inkml+xml': {
      'source': 'iana',
      'extensions': ['ink', 'inkml']
    },
    'application/iotp': {
      'source': 'iana'
    },
    'application/ipfix': {
      'source': 'iana',
      'extensions': ['ipfix']
    },
    'application/ipp': {
      'source': 'iana'
    },
    'application/isup': {
      'source': 'iana'
    },
    'application/its+xml': {
      'source': 'iana'
    },
    'application/java-archive': {
      'name': 'JAR',
      'source': 'apache',
      'compressible': false,
      'extensions': ['jar', 'war', 'ear']
    },
    'application/java-serialized-object': {
      'source': 'apache',
      'compressible': false,
      'extensions': ['ser']
    },
    'application/java-vm': {
      'name': 'CLASS',
      'source': 'apache',
      'compressible': false,
      'extensions': ['class']
    },
    'application/javascript': {
      'name': 'JavaScript',
      'source': 'iana',
      'charset': 'UTF-8',
      'compressible': true,
      'extensions': ['js']
    },
    'application/jose': {
      'source': 'iana'
    },
    'application/jose+json': {
      'name': 'JSON',
      'source': 'iana',
      'compressible': true
    },
    'application/jrd+json': {
      'source': 'iana',
      'compressible': true
    },
    'application/json': {
      'source': 'iana',
      'charset': 'UTF-8',
      'compressible': true,
      'extensions': ['json', 'map']
    },
    'application/json-patch+json': {
      'source': 'iana',
      'compressible': true
    },
    'application/json-seq': {
      'source': 'iana'
    },
    'application/json5': {
      'extensions': ['json5']
    },
    'application/jsonml+json': {
      'source': 'apache',
      'compressible': true,
      'extensions': ['jsonml']
    },
    'application/jwk+json': {
      'source': 'iana',
      'compressible': true
    },
    'application/jwk-set+json': {
      'source': 'iana',
      'compressible': true
    },
    'application/jwt': {
      'source': 'iana'
    },
    'application/kpml-request+xml': {
      'source': 'iana'
    },
    'application/kpml-response+xml': {
      'source': 'iana'
    },
    'application/ld+json': {
      'source': 'iana',
      'compressible': true,
      'extensions': ['jsonld']
    },
    'application/link-format': {
      'source': 'iana'
    },
    'application/load-control+xml': {
      'source': 'iana'
    },
    'application/lost+xml': {
      'source': 'iana',
      'extensions': ['lostxml']
    },
    'application/lostsync+xml': {
      'source': 'iana'
    },
    'application/lxf': {
      'source': 'iana'
    },
    'application/mac-binhex40': {
      'source': 'iana',
      'extensions': ['hqx']
    },
    'application/mac-compactpro': {
      'source': 'apache',
      'extensions': ['cpt']
    },
    'application/macwriteii': {
      'source': 'iana'
    },
    'application/mads+xml': {
      'source': 'iana',
      'extensions': ['mads']
    },
    'application/manifest+json': {
      'charset': 'UTF-8',
      'compressible': true,
      'extensions': ['webmanifest']
    },
    'application/marc': {
      'source': 'iana',
      'extensions': ['mrc']
    },
    'application/marcxml+xml': {
      'source': 'iana',
      'extensions': ['mrcx']
    },
    'application/mathematica': {
      'source': 'iana',
      'extensions': ['ma', 'nb', 'mb']
    },
    'application/mathml+xml': {
      'source': 'iana',
      'extensions': ['mathml']
    },
    'application/mathml-content+xml': {
      'source': 'iana'
    },
    'application/mathml-presentation+xml': {
      'source': 'iana'
    },
    'application/mbms-associated-procedure-description+xml': {
      'source': 'iana'
    },
    'application/mbms-deregister+xml': {
      'source': 'iana'
    },
    'application/mbms-envelope+xml': {
      'source': 'iana'
    },
    'application/mbms-msk+xml': {
      'source': 'iana'
    },
    'application/mbms-msk-response+xml': {
      'source': 'iana'
    },
    'application/mbms-protection-description+xml': {
      'source': 'iana'
    },
    'application/mbms-reception-report+xml': {
      'source': 'iana'
    },
    'application/mbms-register+xml': {
      'source': 'iana'
    },
    'application/mbms-register-response+xml': {
      'source': 'iana'
    },
    'application/mbms-schedule+xml': {
      'source': 'iana'
    },
    'application/mbms-user-service-description+xml': {
      'source': 'iana'
    },
    'application/mbox': {
      'source': 'iana',
      'extensions': ['mbox']
    },
    'application/media-policy-dataset+xml': {
      'source': 'iana'
    },
    'application/media_control+xml': {
      'source': 'iana'
    },
    'application/mediaservercontrol+xml': {
      'source': 'iana',
      'extensions': ['mscml']
    },
    'application/merge-patch+json': {
      'source': 'iana',
      'compressible': true
    },
    'application/metalink+xml': {
      'source': 'apache',
      'extensions': ['metalink']
    },
    'application/metalink4+xml': {
      'source': 'iana',
      'extensions': ['meta4']
    },
    'application/mets+xml': {
      'source': 'iana',
      'extensions': ['mets']
    },
    'application/mf4': {
      'source': 'iana'
    },
    'application/mikey': {
      'source': 'iana'
    },
    'application/mods+xml': {
      'source': 'iana',
      'extensions': ['mods']
    },
    'application/moss-keys': {
      'source': 'iana'
    },
    'application/moss-signature': {
      'source': 'iana'
    },
    'application/mosskey-data': {
      'source': 'iana'
    },
    'application/mosskey-request': {
      'source': 'iana'
    },
    'application/mp21': {
      'source': 'iana',
      'extensions': ['m21', 'mp21']
    },
    'application/mp4': {
      'source': 'iana',
      'extensions': ['mp4s', 'm4p']
    },
    'application/mpeg4-generic': {
      'source': 'iana'
    },
    'application/mpeg4-iod': {
      'source': 'iana'
    },
    'application/mpeg4-iod-xmt': {
      'source': 'iana'
    },
    'application/mrb-consumer+xml': {
      'source': 'iana'
    },
    'application/mrb-publish+xml': {
      'source': 'iana'
    },
    'application/msc-ivr+xml': {
      'source': 'iana'
    },
    'application/msc-mixer+xml': {
      'source': 'iana'
    },
    'application/msword': {
      'name': 'Word',
      'source': 'iana',
      'compressible': false,
      'extensions': ['doc', 'dot']
    },
    'application/mxf': {
      'source': 'iana',
      'extensions': ['mxf']
    },
    'application/nasdata': {
      'source': 'iana'
    },
    'application/news-checkgroups': {
      'source': 'iana'
    },
    'application/news-groupinfo': {
      'source': 'iana'
    },
    'application/news-transmission': {
      'source': 'iana'
    },
    'application/nlsml+xml': {
      'source': 'iana'
    },
    'application/nss': {
      'source': 'iana'
    },
    'application/ocsp-request': {
      'source': 'iana'
    },
    'application/ocsp-response': {
      'source': 'iana'
    },
    'application/octet-stream': {
      'name': 'Binary',
      'source': 'iana',
      'compressible': false,
      'extensions': ['bin', 'dms', 'lrf', 'mar', 'so', 'dist', 'distz', 'pkg', 'bpk', 'dump', 'elc', 'deploy', 'exe',
        'dll', 'deb', 'dmg', 'iso', 'img', 'msi', 'msp', 'msm', 'buffer']
    },
    'application/oda': {
      'source': 'iana',
      'extensions': ['oda']
    },
    'application/odx': {
      'source': 'iana'
    },
    'application/oebps-package+xml': {
      'source': 'iana',
      'extensions': ['opf']
    },
    'application/ogg': {
      'source': 'iana',
      'compressible': false,
      'extensions': ['ogx']
    },
    'application/omdoc+xml': {
      'source': 'apache',
      'extensions': ['omdoc']
    },
    'application/onenote': {
      'name': 'One Note',
      'source': 'apache',
      'extensions': ['onetoc', 'onetoc2', 'onetmp', 'onepkg']
    },
    'application/oxps': {
      'source': 'iana',
      'extensions': ['oxps']
    },
    'application/p2p-overlay+xml': {
      'source': 'iana'
    },
    'application/parityfec': {
      'source': 'iana'
    },
    'application/patch-ops-error+xml': {
      'source': 'iana',
      'extensions': ['xer']
    },
    'application/pdf': {
      'name': 'PDF',
      'source': 'iana',
      'compressible': false,
      'extensions': ['pdf']
    },
    'application/pdx': {
      'source': 'iana'
    },
    'application/pgp-encrypted': {
      'source': 'iana',
      'compressible': false,
      'extensions': ['pgp']
    },
    'application/pgp-keys': {
      'source': 'iana'
    },
    'application/pgp-signature': {
      'source': 'iana',
      'extensions': ['asc', 'sig']
    },
    'application/pics-rules': {
      'source': 'apache',
      'extensions': ['prf']
    },
    'application/pidf+xml': {
      'source': 'iana'
    },
    'application/pidf-diff+xml': {
      'source': 'iana'
    },
    'application/pkcs10': {
      'source': 'iana',
      'extensions': ['p10']
    },
    'application/pkcs12': {
      'source': 'iana'
    },
    'application/pkcs7-mime': {
      'source': 'iana',
      'extensions': ['p7m', 'p7c']
    },
    'application/pkcs7-signature': {
      'source': 'iana',
      'extensions': ['p7s']
    },
    'application/pkcs8': {
      'source': 'iana',
      'extensions': ['p8']
    },
    'application/pkix-attr-cert': {
      'source': 'iana',
      'extensions': ['ac']
    },
    'application/pkix-cert': {
      'source': 'iana',
      'extensions': ['cer']
    },
    'application/pkix-crl': {
      'source': 'iana',
      'extensions': ['crl']
    },
    'application/pkix-pkipath': {
      'source': 'iana',
      'extensions': ['pkipath']
    },
    'application/pkixcmp': {
      'source': 'iana',
      'extensions': ['pki']
    },
    'application/pls+xml': {
      'source': 'iana',
      'extensions': ['pls']
    },
    'application/poc-settings+xml': {
      'source': 'iana'
    },
    'application/postscript': {
      'source': 'iana',
      'compressible': true,
      'extensions': ['ai', 'eps', 'ps']
    },
    'application/ppsp-tracker+json': {
      'source': 'iana',
      'compressible': true
    },
    'application/problem+json': {
      'source': 'iana',
      'compressible': true
    },
    'application/problem+xml': {
      'source': 'iana'
    },
    'application/provenance+xml': {
      'source': 'iana'
    },
    'application/prs.alvestrand.titrax-sheet': {
      'source': 'iana'
    },
    'application/prs.cww': {
      'source': 'iana',
      'extensions': ['cww']
    },
    'application/prs.hpub+zip': {
      'source': 'iana'
    },
    'application/prs.nprend': {
      'source': 'iana'
    },
    'application/prs.plucker': {
      'source': 'iana'
    },
    'application/prs.rdf-xml-crypt': {
      'source': 'iana'
    },
    'application/prs.xsf+xml': {
      'source': 'iana'
    },
    'application/pskc+xml': {
      'source': 'iana',
      'extensions': ['pskcxml']
    },
    'application/qsig': {
      'source': 'iana'
    },
    'application/raptorfec': {
      'source': 'iana'
    },
    'application/rdap+json': {
      'source': 'iana',
      'compressible': true
    },
    'application/rdf+xml': {
      'source': 'iana',
      'compressible': true,
      'extensions': ['rdf']
    },
    'application/reginfo+xml': {
      'source': 'iana',
      'extensions': ['rif']
    },
    'application/relax-ng-compact-syntax': {
      'source': 'iana',
      'extensions': ['rnc']
    },
    'application/remote-printing': {
      'source': 'iana'
    },
    'application/reputon+json': {
      'source': 'iana',
      'compressible': true
    },
    'application/resource-lists+xml': {
      'source': 'iana',
      'extensions': ['rl']
    },
    'application/resource-lists-diff+xml': {
      'source': 'iana',
      'extensions': ['rld']
    },
    'application/rfc+xml': {
      'source': 'iana'
    },
    'application/riscos': {
      'source': 'iana'
    },
    'application/rlmi+xml': {
      'source': 'iana'
    },
    'application/rls-services+xml': {
      'source': 'iana',
      'extensions': ['rs']
    },
    'application/rpki-ghostbusters': {
      'source': 'iana',
      'extensions': ['gbr']
    },
    'application/rpki-manifest': {
      'source': 'iana',
      'extensions': ['mft']
    },
    'application/rpki-roa': {
      'source': 'iana',
      'extensions': ['roa']
    },
    'application/rpki-updown': {
      'source': 'iana'
    },
    'application/rsd+xml': {
      'source': 'apache',
      'extensions': ['rsd']
    },
    'application/rss+xml': {
      'name': 'RSS',
      'source': 'apache',
      'compressible': true,
      'extensions': ['rss']
    },
    'application/rtf': {
      'name': 'RTF',
      'source': 'iana',
      'compressible': true,
      'extensions': ['rtf']
    },
    'application/rtploopback': {
      'source': 'iana'
    },
    'application/rtx': {
      'source': 'iana'
    },
    'application/samlassertion+xml': {
      'source': 'iana'
    },
    'application/samlmetadata+xml': {
      'source': 'iana'
    },
    'application/sbml+xml': {
      'source': 'iana',
      'extensions': ['sbml']
    },
    'application/scaip+xml': {
      'source': 'iana'
    },
    'application/scim+json': {
      'source': 'iana',
      'compressible': true
    },
    'application/scvp-cv-request': {
      'source': 'iana',
      'extensions': ['scq']
    },
    'application/scvp-cv-response': {
      'source': 'iana',
      'extensions': ['scs']
    },
    'application/scvp-vp-request': {
      'source': 'iana',
      'extensions': ['spq']
    },
    'application/scvp-vp-response': {
      'source': 'iana',
      'extensions': ['spp']
    },
    'application/sdp': {
      'source': 'iana',
      'extensions': ['sdp']
    },
    'application/sep+xml': {
      'source': 'iana'
    },
    'application/sep-exi': {
      'source': 'iana'
    },
    'application/session-info': {
      'source': 'iana'
    },
    'application/set-payment': {
      'source': 'iana'
    },
    'application/set-payment-initiation': {
      'source': 'iana',
      'extensions': ['setpay']
    },
    'application/set-registration': {
      'source': 'iana'
    },
    'application/set-registration-initiation': {
      'source': 'iana',
      'extensions': ['setreg']
    },
    'application/sgml': {
      'source': 'iana'
    },
    'application/sgml-open-catalog': {
      'source': 'iana'
    },
    'application/shf+xml': {
      'source': 'iana',
      'extensions': ['shf']
    },
    'application/sieve': {
      'source': 'iana'
    },
    'application/simple-filter+xml': {
      'source': 'iana'
    },
    'application/simple-message-summary': {
      'source': 'iana'
    },
    'application/simplesymbolcontainer': {
      'source': 'iana'
    },
    'application/slate': {
      'source': 'iana'
    },
    'application/smil': {
      'source': 'iana'
    },
    'application/smil+xml': {
      'source': 'iana',
      'extensions': ['smi', 'smil']
    },
    'application/smpte336m': {
      'source': 'iana'
    },
    'application/soap+fastinfoset': {
      'source': 'iana'
    },
    'application/soap+xml': {
      'source': 'iana',
      'compressible': true
    },
    'application/sparql-query': {
      'source': 'iana',
      'extensions': ['rq']
    },
    'application/sparql-results+xml': {
      'source': 'iana',
      'extensions': ['srx']
    },
    'application/spirits-event+xml': {
      'source': 'iana'
    },
    'application/sql': {
      'source': 'iana'
    },
    'application/srgs': {
      'source': 'iana',
      'extensions': ['gram']
    },
    'application/srgs+xml': {
      'source': 'iana',
      'extensions': ['grxml']
    },
    'application/sru+xml': {
      'source': 'iana',
      'extensions': ['sru']
    },
    'application/ssdl+xml': {
      'source': 'apache',
      'extensions': ['ssdl']
    },
    'application/ssml+xml': {
      'source': 'iana',
      'extensions': ['ssml']
    },
    'application/tamp-apex-update': {
      'source': 'iana'
    },
    'application/tamp-apex-update-confirm': {
      'source': 'iana'
    },
    'application/tamp-community-update': {
      'source': 'iana'
    },
    'application/tamp-community-update-confirm': {
      'source': 'iana'
    },
    'application/tamp-error': {
      'source': 'iana'
    },
    'application/tamp-sequence-adjust': {
      'source': 'iana'
    },
    'application/tamp-sequence-adjust-confirm': {
      'source': 'iana'
    },
    'application/tamp-status-query': {
      'source': 'iana'
    },
    'application/tamp-status-response': {
      'source': 'iana'
    },
    'application/tamp-update': {
      'source': 'iana'
    },
    'application/tamp-update-confirm': {
      'source': 'iana'
    },
    'application/tar': {
      'compressible': true
    },
    'application/tei+xml': {
      'source': 'iana',
      'extensions': ['tei', 'teicorpus']
    },
    'application/thraud+xml': {
      'source': 'iana',
      'extensions': ['tfi']
    },
    'application/timestamp-query': {
      'source': 'iana'
    },
    'application/timestamp-reply': {
      'source': 'iana'
    },
    'application/timestamped-data': {
      'source': 'iana',
      'extensions': ['tsd']
    },
    'application/ttml+xml': {
      'source': 'iana'
    },
    'application/tve-trigger': {
      'source': 'iana'
    },
    'application/ulpfec': {
      'source': 'iana'
    },
    'application/urc-grpsheet+xml': {
      'source': 'iana'
    },
    'application/urc-ressheet+xml': {
      'source': 'iana'
    },
    'application/urc-targetdesc+xml': {
      'source': 'iana'
    },
    'application/urc-uisocketdesc+xml': {
      'source': 'iana'
    },
    'application/vcard+json': {
      'source': 'iana',
      'compressible': true
    },
    'application/vcard+xml': {
      'source': 'iana'
    },
    'application/vemmi': {
      'source': 'iana'
    },
    'application/vividence.scriptfile': {
      'source': 'apache'
    },
    'application/vnd.3gpp-prose+xml': {
      'source': 'iana'
    },
    'application/vnd.3gpp-prose-pc3ch+xml': {
      'source': 'iana'
    },
    'application/vnd.3gpp.access-transfer-events+xml': {
      'source': 'iana'
    },
    'application/vnd.3gpp.bsf+xml': {
      'source': 'iana'
    },
    'application/vnd.3gpp.mid-call+xml': {
      'source': 'iana'
    },
    'application/vnd.3gpp.pic-bw-large': {
      'source': 'iana',
      'extensions': ['plb']
    },
    'application/vnd.3gpp.pic-bw-small': {
      'source': 'iana',
      'extensions': ['psb']
    },
    'application/vnd.3gpp.pic-bw-var': {
      'source': 'iana',
      'extensions': ['pvb']
    },
    'application/vnd.3gpp.sms': {
      'source': 'iana'
    },
    'application/vnd.3gpp.sms+xml': {
      'source': 'iana'
    },
    'application/vnd.3gpp.srvcc-ext+xml': {
      'source': 'iana'
    },
    'application/vnd.3gpp.srvcc-info+xml': {
      'source': 'iana'
    },
    'application/vnd.3gpp.state-and-event-info+xml': {
      'source': 'iana'
    },
    'application/vnd.3gpp.ussd+xml': {
      'source': 'iana'
    },
    'application/vnd.3gpp2.bcmcsinfo+xml': {
      'source': 'iana'
    },
    'application/vnd.3gpp2.sms': {
      'source': 'iana'
    },
    'application/vnd.3gpp2.tcap': {
      'source': 'iana',
      'extensions': ['tcap']
    },
    'application/vnd.3lightssoftware.imagescal': {
      'source': 'iana'
    },
    'application/vnd.3m.post-it-notes': {
      'source': 'iana',
      'extensions': ['pwn']
    },
    'application/vnd.accpac.simply.aso': {
      'source': 'iana',
      'extensions': ['aso']
    },
    'application/vnd.accpac.simply.imp': {
      'source': 'iana',
      'extensions': ['imp']
    },
    'application/vnd.acucobol': {
      'source': 'iana',
      'extensions': ['acu']
    },
    'application/vnd.acucorp': {
      'source': 'iana',
      'extensions': ['atc', 'acutc']
    },
    'application/vnd.adobe.air-application-installer-package+zip': {
      'source': 'apache',
      'extensions': ['air']
    },
    'application/vnd.adobe.flash.movie': {
      'source': 'iana'
    },
    'application/vnd.adobe.formscentral.fcdt': {
      'source': 'iana',
      'extensions': ['fcdt']
    },
    'application/vnd.adobe.fxp': {
      'source': 'iana',
      'extensions': ['fxp', 'fxpl']
    },
    'application/vnd.adobe.partial-upload': {
      'source': 'iana'
    },
    'application/vnd.adobe.xdp+xml': {
      'source': 'iana',
      'extensions': ['xdp']
    },
    'application/vnd.adobe.xfdf': {
      'source': 'iana',
      'extensions': ['xfdf']
    },
    'application/vnd.aether.imp': {
      'source': 'iana'
    },
    'application/vnd.ah-barcode': {
      'source': 'iana'
    },
    'application/vnd.ahead.space': {
      'source': 'iana',
      'extensions': ['ahead']
    },
    'application/vnd.airzip.filesecure.azf': {
      'source': 'iana',
      'extensions': ['azf']
    },
    'application/vnd.airzip.filesecure.azs': {
      'source': 'iana',
      'extensions': ['azs']
    },
    'application/vnd.amazon.ebook': {
      'source': 'apache',
      'extensions': ['azw']
    },
    'application/vnd.americandynamics.acc': {
      'source': 'iana',
      'extensions': ['acc']
    },
    'application/vnd.amiga.ami': {
      'source': 'iana',
      'extensions': ['ami']
    },
    'application/vnd.amundsen.maze+xml': {
      'source': 'iana'
    },
    'application/vnd.android.package-archive': {
      'name': 'APK',
      'source': 'apache',
      'compressible': false,
      'extensions': ['apk']
    },
    'application/vnd.anki': {
      'source': 'iana'
    },
    'application/vnd.anser-web-certificate-issue-initiation': {
      'source': 'iana',
      'extensions': ['cii']
    },
    'application/vnd.anser-web-funds-transfer-initiation': {
      'source': 'apache',
      'extensions': ['fti']
    },
    'application/vnd.antix.game-component': {
      'source': 'iana',
      'extensions': ['atx']
    },
    'application/vnd.apache.thrift.binary': {
      'source': 'iana'
    },
    'application/vnd.apache.thrift.compact': {
      'source': 'iana'
    },
    'application/vnd.apache.thrift.json': {
      'source': 'iana'
    },
    'application/vnd.api+json': {
      'source': 'iana',
      'compressible': true
    },
    'application/vnd.apple.installer+xml': {
      'source': 'iana',
      'extensions': ['mpkg']
    },
    'application/vnd.apple.mpegurl': {
      'source': 'iana',
      'extensions': ['m3u8']
    },
    'application/vnd.apple.pkpass': {
      'compressible': false,
      'extensions': ['pkpass']
    },
    'application/vnd.arastra.swi': {
      'source': 'iana'
    },
    'application/vnd.aristanetworks.swi': {
      'source': 'iana',
      'extensions': ['swi']
    },
    'application/vnd.artsquare': {
      'source': 'iana'
    },
    'application/vnd.astraea-software.iota': {
      'source': 'iana',
      'extensions': ['iota']
    },
    'application/vnd.audiograph': {
      'source': 'iana',
      'extensions': ['aep']
    },
    'application/vnd.autopackage': {
      'source': 'iana'
    },
    'application/vnd.avistar+xml': {
      'source': 'iana'
    },
    'application/vnd.balsamiq.bmml+xml': {
      'source': 'iana'
    },
    'application/vnd.balsamiq.bmpr': {
      'source': 'iana'
    },
    'application/vnd.bekitzur-stech+json': {
      'source': 'iana',
      'compressible': true
    },
    'application/vnd.biopax.rdf+xml': {
      'source': 'iana'
    },
    'application/vnd.blueice.multipass': {
      'source': 'iana',
      'extensions': ['mpm']
    },
    'application/vnd.bluetooth.ep.oob': {
      'source': 'iana'
    },
    'application/vnd.bluetooth.le.oob': {
      'source': 'iana'
    },
    'application/vnd.bmi': {
      'source': 'iana',
      'extensions': ['bmi']
    },
    'application/vnd.businessobjects': {
      'source': 'iana',
      'extensions': ['rep']
    },
    'application/vnd.cab-jscript': {
      'source': 'iana'
    },
    'application/vnd.canon-cpdl': {
      'source': 'iana'
    },
    'application/vnd.canon-lips': {
      'source': 'iana'
    },
    'application/vnd.cendio.thinlinc.clientconf': {
      'source': 'iana'
    },
    'application/vnd.century-systems.tcp_stream': {
      'source': 'iana'
    },
    'application/vnd.chemdraw+xml': {
      'source': 'iana',
      'extensions': ['cdxml']
    },
    'application/vnd.chipnuts.karaoke-mmd': {
      'source': 'iana',
      'extensions': ['mmd']
    },
    'application/vnd.cinderella': {
      'source': 'iana',
      'extensions': ['cdy']
    },
    'application/vnd.cirpack.isdn-ext': {
      'source': 'iana'
    },
    'application/vnd.citationstyles.style+xml': {
      'source': 'iana'
    },
    'application/vnd.claymore': {
      'source': 'iana',
      'extensions': ['cla']
    },
    'application/vnd.cloanto.rp9': {
      'source': 'iana',
      'extensions': ['rp9']
    },
    'application/vnd.clonk.c4group': {
      'source': 'iana',
      'extensions': ['c4g', 'c4d', 'c4f', 'c4p', 'c4u']
    },
    'application/vnd.cluetrust.cartomobile-config': {
      'source': 'iana',
      'extensions': ['c11amc']
    },
    'application/vnd.cluetrust.cartomobile-config-pkg': {
      'source': 'iana',
      'extensions': ['c11amz']
    },
    'application/vnd.coffeescript': {
      'source': 'iana'
    },
    'application/vnd.collection+json': {
      'source': 'iana',
      'compressible': true
    },
    'application/vnd.collection.doc+json': {
      'source': 'iana',
      'compressible': true
    },
    'application/vnd.collection.next+json': {
      'source': 'iana',
      'compressible': true
    },
    'application/vnd.commerce-battelle': {
      'source': 'iana'
    },
    'application/vnd.commonspace': {
      'source': 'iana',
      'extensions': ['csp']
    },
    'application/vnd.contact.cmsg': {
      'source': 'iana',
      'extensions': ['cdbcmsg']
    },
    'application/vnd.coreos.ignition+json': {
      'source': 'iana',
      'compressible': true
    },
    'application/vnd.cosmocaller': {
      'source': 'iana',
      'extensions': ['cmc']
    },
    'application/vnd.crick.clicker': {
      'source': 'iana',
      'extensions': ['clkx']
    },
    'application/vnd.crick.clicker.keyboard': {
      'source': 'iana',
      'extensions': ['clkk']
    },
    'application/vnd.crick.clicker.palette': {
      'source': 'iana',
      'extensions': ['clkp']
    },
    'application/vnd.crick.clicker.template': {
      'source': 'iana',
      'extensions': ['clkt']
    },
    'application/vnd.crick.clicker.wordbank': {
      'source': 'iana',
      'extensions': ['clkw']
    },
    'application/vnd.criticaltools.wbs+xml': {
      'source': 'iana',
      'extensions': ['wbs']
    },
    'application/vnd.ctc-posml': {
      'source': 'iana',
      'extensions': ['pml']
    },
    'application/vnd.ctct.ws+xml': {
      'source': 'iana'
    },
    'application/vnd.cups-pdf': {
      'source': 'iana'
    },
    'application/vnd.cups-postscript': {
      'source': 'iana'
    },
    'application/vnd.cups-ppd': {
      'source': 'iana',
      'extensions': ['ppd']
    },
    'application/vnd.cups-raster': {
      'source': 'iana'
    },
    'application/vnd.cups-raw': {
      'source': 'iana'
    },
    'application/vnd.curl': {
      'source': 'iana'
    },
    'application/vnd.curl.car': {
      'source': 'apache',
      'extensions': ['car']
    },
    'application/vnd.curl.pcurl': {
      'source': 'apache',
      'extensions': ['pcurl']
    },
    'application/vnd.cyan.dean.root+xml': {
      'source': 'iana'
    },
    'application/vnd.cybank': {
      'source': 'iana'
    },
    'application/vnd.dart': {
      'source': 'iana',
      'compressible': true,
      'extensions': ['dart']
    },
    'application/vnd.data-vision.rdz': {
      'source': 'iana',
      'extensions': ['rdz']
    },
    'application/vnd.debian.binary-package': {
      'source': 'iana'
    },
    'application/vnd.dece.data': {
      'source': 'iana',
      'extensions': ['uvf', 'uvvf', 'uvd', 'uvvd']
    },
    'application/vnd.dece.ttml+xml': {
      'source': 'iana',
      'extensions': ['uvt', 'uvvt']
    },
    'application/vnd.dece.unspecified': {
      'source': 'iana',
      'extensions': ['uvx', 'uvvx']
    },
    'application/vnd.dece.zip': {
      'source': 'iana',
      'extensions': ['uvz', 'uvvz']
    },
    'application/vnd.denovo.fcselayout-link': {
      'source': 'iana',
      'extensions': ['fe_launch']
    },
    'application/vnd.desmume-movie': {
      'source': 'iana'
    },
    'application/vnd.desmume.movie': {
      'source': 'apache'
    },
    'application/vnd.dir-bi.plate-dl-nosuffix': {
      'source': 'iana'
    },
    'application/vnd.dm.delegation+xml': {
      'source': 'iana'
    },
    'application/vnd.dna': {
      'source': 'iana',
      'extensions': ['dna']
    },
    'application/vnd.document+json': {
      'source': 'iana',
      'compressible': true
    },
    'application/vnd.dolby.mlp': {
      'source': 'apache',
      'extensions': ['mlp']
    },
    'application/vnd.dolby.mobile.1': {
      'source': 'iana'
    },
    'application/vnd.dolby.mobile.2': {
      'source': 'iana'
    },
    'application/vnd.doremir.scorecloud-binary-document': {
      'source': 'iana'
    },
    'application/vnd.dpgraph': {
      'source': 'iana',
      'extensions': ['dpg']
    },
    'application/vnd.dreamfactory': {
      'source': 'iana',
      'extensions': ['dfac']
    },
    'application/vnd.drive+json': {
      'source': 'iana',
      'compressible': true
    },
    'application/vnd.ds-keypoint': {
      'source': 'apache',
      'extensions': ['kpxx']
    },
    'application/vnd.dtg.local': {
      'source': 'iana'
    },
    'application/vnd.dtg.local.flash': {
      'source': 'iana'
    },
    'application/vnd.dtg.local.html': {
      'source': 'iana'
    },
    'application/vnd.dvb.ait': {
      'source': 'iana',
      'extensions': ['ait']
    },
    'application/vnd.dvb.dvbj': {
      'source': 'iana'
    },
    'application/vnd.dvb.esgcontainer': {
      'source': 'iana'
    },
    'application/vnd.dvb.ipdcdftnotifaccess': {
      'source': 'iana'
    },
    'application/vnd.dvb.ipdcesgaccess': {
      'source': 'iana'
    },
    'application/vnd.dvb.ipdcesgaccess2': {
      'source': 'iana'
    },
    'application/vnd.dvb.ipdcesgpdd': {
      'source': 'iana'
    },
    'application/vnd.dvb.ipdcroaming': {
      'source': 'iana'
    },
    'application/vnd.dvb.iptv.alfec-base': {
      'source': 'iana'
    },
    'application/vnd.dvb.iptv.alfec-enhancement': {
      'source': 'iana'
    },
    'application/vnd.dvb.notif-aggregate-root+xml': {
      'source': 'iana'
    },
    'application/vnd.dvb.notif-container+xml': {
      'source': 'iana'
    },
    'application/vnd.dvb.notif-generic+xml': {
      'source': 'iana'
    },
    'application/vnd.dvb.notif-ia-msglist+xml': {
      'source': 'iana'
    },
    'application/vnd.dvb.notif-ia-registration-request+xml': {
      'source': 'iana'
    },
    'application/vnd.dvb.notif-ia-registration-response+xml': {
      'source': 'iana'
    },
    'application/vnd.dvb.notif-init+xml': {
      'source': 'iana'
    },
    'application/vnd.dvb.pfr': {
      'source': 'iana'
    },
    'application/vnd.dvb.service': {
      'source': 'iana',
      'extensions': ['svc']
    },
    'application/vnd.dxr': {
      'source': 'iana'
    },
    'application/vnd.dynageo': {
      'source': 'iana',
      'extensions': ['geo']
    },
    'application/vnd.dzr': {
      'source': 'iana'
    },
    'application/vnd.easykaraoke.cdgdownload': {
      'source': 'iana'
    },
    'application/vnd.ecdis-update': {
      'source': 'iana'
    },
    'application/vnd.ecowin.chart': {
      'source': 'iana',
      'extensions': ['mag']
    },
    'application/vnd.ecowin.filerequest': {
      'source': 'iana'
    },
    'application/vnd.ecowin.fileupdate': {
      'source': 'iana'
    },
    'application/vnd.ecowin.series': {
      'source': 'iana'
    },
    'application/vnd.ecowin.seriesrequest': {
      'source': 'iana'
    },
    'application/vnd.ecowin.seriesupdate': {
      'source': 'iana'
    },
    'application/vnd.emclient.accessrequest+xml': {
      'source': 'iana'
    },
    'application/vnd.enliven': {
      'source': 'iana',
      'extensions': ['nml']
    },
    'application/vnd.enphase.envoy': {
      'source': 'iana'
    },
    'application/vnd.eprints.data+xml': {
      'source': 'iana'
    },
    'application/vnd.epson.esf': {
      'source': 'iana',
      'extensions': ['esf']
    },
    'application/vnd.epson.msf': {
      'source': 'iana',
      'extensions': ['msf']
    },
    'application/vnd.epson.quickanime': {
      'source': 'iana',
      'extensions': ['qam']
    },
    'application/vnd.epson.salt': {
      'source': 'iana',
      'extensions': ['slt']
    },
    'application/vnd.epson.ssf': {
      'source': 'iana',
      'extensions': ['ssf']
    },
    'application/vnd.ericsson.quickcall': {
      'source': 'iana'
    },
    'application/vnd.eszigno3+xml': {
      'source': 'iana',
      'extensions': ['es3', 'et3']
    },
    'application/vnd.etsi.aoc+xml': {
      'source': 'iana'
    },
    'application/vnd.etsi.asic-e+zip': {
      'source': 'iana'
    },
    'application/vnd.etsi.asic-s+zip': {
      'source': 'iana'
    },
    'application/vnd.etsi.cug+xml': {
      'source': 'iana'
    },
    'application/vnd.etsi.iptvcommand+xml': {
      'source': 'iana'
    },
    'application/vnd.etsi.iptvdiscovery+xml': {
      'source': 'iana'
    },
    'application/vnd.etsi.iptvprofile+xml': {
      'source': 'iana'
    },
    'application/vnd.etsi.iptvsad-bc+xml': {
      'source': 'iana'
    },
    'application/vnd.etsi.iptvsad-cod+xml': {
      'source': 'iana'
    },
    'application/vnd.etsi.iptvsad-npvr+xml': {
      'source': 'iana'
    },
    'application/vnd.etsi.iptvservice+xml': {
      'source': 'iana'
    },
    'application/vnd.etsi.iptvsync+xml': {
      'source': 'iana'
    },
    'application/vnd.etsi.iptvueprofile+xml': {
      'source': 'iana'
    },
    'application/vnd.etsi.mcid+xml': {
      'source': 'iana'
    },
    'application/vnd.etsi.mheg5': {
      'source': 'iana'
    },
    'application/vnd.etsi.overload-control-policy-dataset+xml': {
      'source': 'iana'
    },
    'application/vnd.etsi.pstn+xml': {
      'source': 'iana'
    },
    'application/vnd.etsi.sci+xml': {
      'source': 'iana'
    },
    'application/vnd.etsi.simservs+xml': {
      'source': 'iana'
    },
    'application/vnd.etsi.timestamp-token': {
      'source': 'iana'
    },
    'application/vnd.etsi.tsl+xml': {
      'source': 'iana'
    },
    'application/vnd.etsi.tsl.der': {
      'source': 'iana'
    },
    'application/vnd.eudora.data': {
      'source': 'iana'
    },
    'application/vnd.ezpix-album': {
      'source': 'iana',
      'extensions': ['ez2']
    },
    'application/vnd.ezpix-package': {
      'source': 'iana',
      'extensions': ['ez3']
    },
    'application/vnd.f-secure.mobile': {
      'source': 'iana'
    },
    'application/vnd.fastcopy-disk-image': {
      'source': 'iana'
    },
    'application/vnd.fdf': {
      'source': 'iana',
      'extensions': ['fdf']
    },
    'application/vnd.fdsn.mseed': {
      'source': 'iana',
      'extensions': ['mseed']
    },
    'application/vnd.fdsn.seed': {
      'source': 'iana',
      'extensions': ['seed', 'dataless']
    },
    'application/vnd.ffsns': {
      'source': 'iana'
    },
    'application/vnd.filmit.zfc': {
      'source': 'iana'
    },
    'application/vnd.fints': {
      'source': 'iana'
    },
    'application/vnd.firemonkeys.cloudcell': {
      'source': 'iana'
    },
    'application/vnd.flographit': {
      'source': 'iana',
      'extensions': ['gph']
    },
    'application/vnd.fluxtime.clip': {
      'source': 'iana',
      'extensions': ['ftc']
    },
    'application/vnd.font-fontforge-sfd': {
      'source': 'iana'
    },
    'application/vnd.framemaker': {
      'source': 'iana',
      'extensions': ['fm', 'frame', 'maker', 'book']
    },
    'application/vnd.frogans.fnc': {
      'source': 'iana',
      'extensions': ['fnc']
    },
    'application/vnd.frogans.ltf': {
      'source': 'iana',
      'extensions': ['ltf']
    },
    'application/vnd.fsc.weblaunch': {
      'source': 'iana',
      'extensions': ['fsc']
    },
    'application/vnd.fujitsu.oasys': {
      'source': 'iana',
      'extensions': ['oas']
    },
    'application/vnd.fujitsu.oasys2': {
      'source': 'iana',
      'extensions': ['oa2']
    },
    'application/vnd.fujitsu.oasys3': {
      'source': 'iana',
      'extensions': ['oa3']
    },
    'application/vnd.fujitsu.oasysgp': {
      'source': 'iana',
      'extensions': ['fg5']
    },
    'application/vnd.fujitsu.oasysprs': {
      'source': 'iana',
      'extensions': ['bh2']
    },
    'application/vnd.fujixerox.art-ex': {
      'source': 'iana'
    },
    'application/vnd.fujixerox.art4': {
      'source': 'iana'
    },
    'application/vnd.fujixerox.ddd': {
      'source': 'iana',
      'extensions': ['ddd']
    },
    'application/vnd.fujixerox.docuworks': {
      'source': 'iana',
      'extensions': ['xdw']
    },
    'application/vnd.fujixerox.docuworks.binder': {
      'source': 'iana',
      'extensions': ['xbd']
    },
    'application/vnd.fujixerox.docuworks.container': {
      'source': 'iana'
    },
    'application/vnd.fujixerox.hbpl': {
      'source': 'iana'
    },
    'application/vnd.fut-misnet': {
      'source': 'iana'
    },
    'application/vnd.fuzzysheet': {
      'source': 'iana',
      'extensions': ['fzs']
    },
    'application/vnd.genomatix.tuxedo': {
      'source': 'iana',
      'extensions': ['txd']
    },
    'application/vnd.geo+json': {
      'source': 'iana',
      'compressible': true
    },
    'application/vnd.geocube+xml': {
      'source': 'iana'
    },
    'application/vnd.geogebra.file': {
      'source': 'iana',
      'extensions': ['ggb']
    },
    'application/vnd.geogebra.tool': {
      'source': 'iana',
      'extensions': ['ggt']
    },
    'application/vnd.geometry-explorer': {
      'source': 'iana',
      'extensions': ['gex', 'gre']
    },
    'application/vnd.geonext': {
      'source': 'iana',
      'extensions': ['gxt']
    },
    'application/vnd.geoplan': {
      'source': 'iana',
      'extensions': ['g2w']
    },
    'application/vnd.geospace': {
      'source': 'iana',
      'extensions': ['g3w']
    },
    'application/vnd.gerber': {
      'source': 'iana'
    },
    'application/vnd.globalplatform.card-content-mgt': {
      'source': 'iana'
    },
    'application/vnd.globalplatform.card-content-mgt-response': {
      'source': 'iana'
    },
    'application/vnd.gmx': {
      'source': 'iana',
      'extensions': ['gmx']
    },
    'application/vnd.google-apps.document': {
      'name': 'Google Docs',
      'compressible': false,
      'extensions': ['gdoc']
    },
    'application/vnd.google-apps.presentation': {
      'name': 'Google Presentation',
      'compressible': false,
      'extensions': ['gslides']
    },
    'application/vnd.google-apps.spreadsheet': {
      'name': 'Google Spreadsheet',
      'compressible': false,
      'extensions': ['gsheet']
    },
    'application/vnd.google-earth.kml+xml': {
      'name': 'Google Earth (kml)',
      'source': 'iana',
      'compressible': true,
      'extensions': ['kml']
    },
    'application/vnd.google-earth.kmz': {
      'name': 'Google Earth (kmz)',
      'source': 'iana',
      'compressible': false,
      'extensions': ['kmz']
    },
    'application/vnd.google-apps.folder': {
      'name': 'Google Drive folder',
      'extensions': ['g?']
    },
    'application/vnd.google-apps.file': {
      'name': 'Google Drive file',
      'extensions': ['g?']
    },
    'application/vnd.google-apps.form': {
      'name': 'Google Form',
      'extensions': ['g?']
    },
    'application/vnd.google-apps.fusiontable': {
      'name': 'Google Fusion Tables',
      'extensions': ['g?']
    },
    'application/vnd.google-apps.sites': {
      'name': 'Google Sites',
      'extensions': ['g?']
    },
    'application/vnd.gov.sk.e-form+xml': {
      'source': 'iana'
    },
    'application/vnd.gov.sk.e-form+zip': {
      'source': 'iana'
    },
    'application/vnd.gov.sk.xmldatacontainer+xml': {
      'source': 'iana'
    },
    'application/vnd.grafeq': {
      'source': 'iana',
      'extensions': ['gqf', 'gqs']
    },
    'application/vnd.gridmp': {
      'source': 'iana'
    },
    'application/vnd.groove-account': {
      'source': 'iana',
      'extensions': ['gac']
    },
    'application/vnd.groove-help': {
      'source': 'iana',
      'extensions': ['ghf']
    },
    'application/vnd.groove-identity-message': {
      'source': 'iana',
      'extensions': ['gim']
    },
    'application/vnd.groove-injector': {
      'source': 'iana',
      'extensions': ['grv']
    },
    'application/vnd.groove-tool-message': {
      'source': 'iana',
      'extensions': ['gtm']
    },
    'application/vnd.groove-tool-template': {
      'source': 'iana',
      'extensions': ['tpl']
    },
    'application/vnd.groove-vcard': {
      'source': 'iana',
      'extensions': ['vcg']
    },
    'application/vnd.hal+json': {
      'source': 'iana',
      'compressible': true
    },
    'application/vnd.hal+xml': {
      'source': 'iana',
      'extensions': ['hal']
    },
    'application/vnd.handheld-entertainment+xml': {
      'source': 'iana',
      'extensions': ['zmm']
    },
    'application/vnd.hbci': {
      'source': 'iana',
      'extensions': ['hbci']
    },
    'application/vnd.hcl-bireports': {
      'source': 'iana'
    },
    'application/vnd.hdt': {
      'source': 'iana'
    },
    'application/vnd.heroku+json': {
      'source': 'iana',
      'compressible': true
    },
    'application/vnd.hhe.lesson-player': {
      'source': 'iana',
      'extensions': ['les']
    },
    'application/vnd.hp-hpgl': {
      'source': 'iana',
      'extensions': ['hpgl']
    },
    'application/vnd.hp-hpid': {
      'source': 'iana',
      'extensions': ['hpid']
    },
    'application/vnd.hp-hps': {
      'source': 'iana',
      'extensions': ['hps']
    },
    'application/vnd.hp-jlyt': {
      'source': 'iana',
      'extensions': ['jlt']
    },
    'application/vnd.hp-pcl': {
      'source': 'iana',
      'extensions': ['pcl']
    },
    'application/vnd.hp-pclxl': {
      'source': 'iana',
      'extensions': ['pclxl']
    },
    'application/vnd.httphone': {
      'source': 'iana'
    },
    'application/vnd.hydrostatix.sof-data': {
      'source': 'iana',
      'extensions': ['sfd-hdstx']
    },
    'application/vnd.hyperdrive+json': {
      'source': 'iana',
      'compressible': true
    },
    'application/vnd.hzn-3d-crossword': {
      'source': 'iana'
    },
    'application/vnd.ibm.afplinedata': {
      'source': 'iana'
    },
    'application/vnd.ibm.electronic-media': {
      'source': 'iana'
    },
    'application/vnd.ibm.minipay': {
      'source': 'iana',
      'extensions': ['mpy']
    },
    'application/vnd.ibm.modcap': {
      'source': 'iana',
      'extensions': ['afp', 'listafp', 'list3820']
    },
    'application/vnd.ibm.rights-management': {
      'source': 'iana',
      'extensions': ['irm']
    },
    'application/vnd.ibm.secure-container': {
      'source': 'iana',
      'extensions': ['sc']
    },
    'application/vnd.iccprofile': {
      'source': 'iana',
      'extensions': ['icc', 'icm']
    },
    'application/vnd.ieee.1905': {
      'source': 'iana'
    },
    'application/vnd.igloader': {
      'source': 'iana',
      'extensions': ['igl']
    },
    'application/vnd.immervision-ivp': {
      'source': 'iana',
      'extensions': ['ivp']
    },
    'application/vnd.immervision-ivu': {
      'source': 'iana',
      'extensions': ['ivu']
    },
    'application/vnd.ims.imsccv1p1': {
      'source': 'iana'
    },
    'application/vnd.ims.imsccv1p2': {
      'source': 'iana'
    },
    'application/vnd.ims.imsccv1p3': {
      'source': 'iana'
    },
    'application/vnd.ims.lis.v2.result+json': {
      'source': 'iana',
      'compressible': true
    },
    'application/vnd.ims.lti.v2.toolconsumerprofile+json': {
      'source': 'iana',
      'compressible': true
    },
    'application/vnd.ims.lti.v2.toolproxy+json': {
      'source': 'iana',
      'compressible': true
    },
    'application/vnd.ims.lti.v2.toolproxy.id+json': {
      'source': 'iana',
      'compressible': true
    },
    'application/vnd.ims.lti.v2.toolsettings+json': {
      'source': 'iana',
      'compressible': true
    },
    'application/vnd.ims.lti.v2.toolsettings.simple+json': {
      'source': 'iana',
      'compressible': true
    },
    'application/vnd.informedcontrol.rms+xml': {
      'source': 'iana'
    },
    'application/vnd.informix-visionary': {
      'source': 'iana'
    },
    'application/vnd.infotech.project': {
      'source': 'iana'
    },
    'application/vnd.infotech.project+xml': {
      'source': 'iana'
    },
    'application/vnd.innopath.wamp.notification': {
      'source': 'iana'
    },
    'application/vnd.insors.igm': {
      'source': 'iana',
      'extensions': ['igm']
    },
    'application/vnd.intercon.formnet': {
      'source': 'iana',
      'extensions': ['xpw', 'xpx']
    },
    'application/vnd.intergeo': {
      'source': 'iana',
      'extensions': ['i2g']
    },
    'application/vnd.intertrust.digibox': {
      'source': 'iana'
    },
    'application/vnd.intertrust.nncp': {
      'source': 'iana'
    },
    'application/vnd.intu.qbo': {
      'source': 'iana',
      'extensions': ['qbo']
    },
    'application/vnd.intu.qfx': {
      'source': 'iana',
      'extensions': ['qfx']
    },
    'application/vnd.iptc.g2.catalogitem+xml': {
      'source': 'iana'
    },
    'application/vnd.iptc.g2.conceptitem+xml': {
      'source': 'iana'
    },
    'application/vnd.iptc.g2.knowledgeitem+xml': {
      'source': 'iana'
    },
    'application/vnd.iptc.g2.newsitem+xml': {
      'source': 'iana'
    },
    'application/vnd.iptc.g2.newsmessage+xml': {
      'source': 'iana'
    },
    'application/vnd.iptc.g2.packageitem+xml': {
      'source': 'iana'
    },
    'application/vnd.iptc.g2.planningitem+xml': {
      'source': 'iana'
    },
    'application/vnd.ipunplugged.rcprofile': {
      'source': 'iana',
      'extensions': ['rcprofile']
    },
    'application/vnd.irepository.package+xml': {
      'source': 'iana',
      'extensions': ['irp']
    },
    'application/vnd.is-xpr': {
      'source': 'iana',
      'extensions': ['xpr']
    },
    'application/vnd.isac.fcs': {
      'source': 'iana',
      'extensions': ['fcs']
    },
    'application/vnd.jam': {
      'source': 'iana',
      'extensions': ['jam']
    },
    'application/vnd.japannet-directory-service': {
      'source': 'iana'
    },
    'application/vnd.japannet-jpnstore-wakeup': {
      'source': 'iana'
    },
    'application/vnd.japannet-payment-wakeup': {
      'source': 'iana'
    },
    'application/vnd.japannet-registration': {
      'source': 'iana'
    },
    'application/vnd.japannet-registration-wakeup': {
      'source': 'iana'
    },
    'application/vnd.japannet-setstore-wakeup': {
      'source': 'iana'
    },
    'application/vnd.japannet-verification': {
      'source': 'iana'
    },
    'application/vnd.japannet-verification-wakeup': {
      'source': 'iana'
    },
    'application/vnd.jcp.javame.midlet-rms': {
      'source': 'iana',
      'extensions': ['rms']
    },
    'application/vnd.jisp': {
      'source': 'iana',
      'extensions': ['jisp']
    },
    'application/vnd.joost.joda-archive': {
      'source': 'iana',
      'extensions': ['joda']
    },
    'application/vnd.jsk.isdn-ngn': {
      'source': 'iana'
    },
    'application/vnd.kahootz': {
      'source': 'iana',
      'extensions': ['ktz', 'ktr']
    },
    'application/vnd.kde.karbon': {
      'source': 'iana',
      'extensions': ['karbon']
    },
    'application/vnd.kde.kchart': {
      'source': 'iana',
      'extensions': ['chrt']
    },
    'application/vnd.kde.kformula': {
      'source': 'iana',
      'extensions': ['kfo']
    },
    'application/vnd.kde.kivio': {
      'source': 'iana',
      'extensions': ['flw']
    },
    'application/vnd.kde.kontour': {
      'source': 'iana',
      'extensions': ['kon']
    },
    'application/vnd.kde.kpresenter': {
      'source': 'iana',
      'extensions': ['kpr', 'kpt']
    },
    'application/vnd.kde.kspread': {
      'source': 'iana',
      'extensions': ['ksp']
    },
    'application/vnd.kde.kword': {
      'source': 'iana',
      'extensions': ['kwd', 'kwt']
    },
    'application/vnd.kenameaapp': {
      'source': 'iana',
      'extensions': ['htke']
    },
    'application/vnd.kidspiration': {
      'source': 'iana',
      'extensions': ['kia']
    },
    'application/vnd.kinar': {
      'source': 'iana',
      'extensions': ['kne', 'knp']
    },
    'application/vnd.koan': {
      'source': 'iana',
      'extensions': ['skp', 'skd', 'skt', 'skm']
    },
    'application/vnd.kodak-descriptor': {
      'source': 'iana',
      'extensions': ['sse']
    },
    'application/vnd.las.las+xml': {
      'source': 'iana',
      'extensions': ['lasxml']
    },
    'application/vnd.liberty-request+xml': {
      'source': 'iana'
    },
    'application/vnd.llamagraphics.life-balance.desktop': {
      'source': 'iana',
      'extensions': ['lbd']
    },
    'application/vnd.llamagraphics.life-balance.exchange+xml': {
      'source': 'iana',
      'extensions': ['lbe']
    },
    'application/vnd.lotus-1-2-3': {
      'source': 'iana',
      'extensions': ['123']
    },
    'application/vnd.lotus-approach': {
      'source': 'iana',
      'extensions': ['apr']
    },
    'application/vnd.lotus-freelance': {
      'source': 'iana',
      'extensions': ['pre']
    },
    'application/vnd.lotus-notes': {
      'source': 'iana',
      'extensions': ['nsf']
    },
    'application/vnd.lotus-organizer': {
      'source': 'iana',
      'extensions': ['org']
    },
    'application/vnd.lotus-screencam': {
      'source': 'iana',
      'extensions': ['scm']
    },
    'application/vnd.lotus-wordpro': {
      'source': 'iana',
      'extensions': ['lwp']
    },
    'application/vnd.macports.portpkg': {
      'source': 'iana',
      'extensions': ['portpkg']
    },
    'application/vnd.mapbox-vector-tile': {
      'source': 'iana'
    },
    'application/vnd.marlin.drm.actiontoken+xml': {
      'source': 'iana'
    },
    'application/vnd.marlin.drm.conftoken+xml': {
      'source': 'iana'
    },
    'application/vnd.marlin.drm.license+xml': {
      'source': 'iana'
    },
    'application/vnd.marlin.drm.mdcf': {
      'source': 'iana'
    },
    'application/vnd.mason+json': {
      'source': 'iana',
      'compressible': true
    },
    'application/vnd.maxmind.maxmind-db': {
      'source': 'iana'
    },
    'application/vnd.mcd': {
      'source': 'iana',
      'extensions': ['mcd']
    },
    'application/vnd.medcalcdata': {
      'source': 'iana',
      'extensions': ['mc1']
    },
    'application/vnd.mediastation.cdkey': {
      'source': 'iana',
      'extensions': ['cdkey']
    },
    'application/vnd.meridian-slingshot': {
      'source': 'iana'
    },
    'application/vnd.mfer': {
      'source': 'iana',
      'extensions': ['mwf']
    },
    'application/vnd.mfmp': {
      'source': 'iana',
      'extensions': ['mfm']
    },
    'application/vnd.micro+json': {
      'source': 'iana',
      'compressible': true
    },
    'application/vnd.micrografx.flo': {
      'source': 'iana',
      'extensions': ['flo']
    },
    'application/vnd.micrografx.igx': {
      'source': 'iana',
      'extensions': ['igx']
    },
    'application/vnd.microsoft.portable-executable': {
      'source': 'iana'
    },
    'application/vnd.miele+json': {
      'source': 'iana',
      'compressible': true
    },
    'application/vnd.mif': {
      'source': 'iana',
      'extensions': ['mif']
    },
    'application/vnd.minisoft-hp3000-save': {
      'source': 'iana'
    },
    'application/vnd.mitsubishi.misty-guard.trustweb': {
      'source': 'iana'
    },
    'application/vnd.mobius.daf': {
      'source': 'iana',
      'extensions': ['daf']
    },
    'application/vnd.mobius.dis': {
      'source': 'iana',
      'extensions': ['dis']
    },
    'application/vnd.mobius.mbk': {
      'source': 'iana',
      'extensions': ['mbk']
    },
    'application/vnd.mobius.mqy': {
      'source': 'iana',
      'extensions': ['mqy']
    },
    'application/vnd.mobius.msl': {
      'source': 'iana',
      'extensions': ['msl']
    },
    'application/vnd.mobius.plc': {
      'source': 'iana',
      'extensions': ['plc']
    },
    'application/vnd.mobius.txf': {
      'source': 'iana',
      'extensions': ['txf']
    },
    'application/vnd.mophun.application': {
      'source': 'iana',
      'extensions': ['mpn']
    },
    'application/vnd.mophun.certificate': {
      'source': 'iana',
      'extensions': ['mpc']
    },
    'application/vnd.motorola.flexsuite': {
      'source': 'iana'
    },
    'application/vnd.motorola.flexsuite.adsi': {
      'source': 'iana'
    },
    'application/vnd.motorola.flexsuite.fis': {
      'source': 'iana'
    },
    'application/vnd.motorola.flexsuite.gotap': {
      'source': 'iana'
    },
    'application/vnd.motorola.flexsuite.kmr': {
      'source': 'iana'
    },
    'application/vnd.motorola.flexsuite.ttc': {
      'source': 'iana'
    },
    'application/vnd.motorola.flexsuite.wem': {
      'source': 'iana'
    },
    'application/vnd.motorola.iprm': {
      'source': 'iana'
    },
    'application/vnd.mozilla.xul+xml': {
      'source': 'iana',
      'compressible': true,
      'extensions': ['xul']
    },
    'application/vnd.ms-3mfdocument': {
      'source': 'iana'
    },
    'application/vnd.ms-artgalry': {
      'source': 'iana',
      'extensions': ['cil']
    },
    'application/vnd.ms-asf': {
      'source': 'iana'
    },
    'application/vnd.ms-cab-compressed': {
      'source': 'iana',
      'extensions': ['cab']
    },
    'application/vnd.ms-color.iccprofile': {
      'source': 'apache'
    },
    'application/vnd.ms-excel': {
      'source': 'iana',
      'compressible': false,
      'extensions': ['xls', 'xlm', 'xla', 'xlc', 'xlt', 'xlw']
    },
    'application/vnd.ms-excel.addin.macroenabled.12': {
      'source': 'iana',
      'extensions': ['xlam']
    },
    'application/vnd.ms-excel.sheet.binary.macroenabled.12': {
      'source': 'iana',
      'extensions': ['xlsb']
    },
    'application/vnd.ms-excel.sheet.macroenabled.12': {
      'source': 'iana',
      'extensions': ['xlsm']
    },
    'application/vnd.ms-excel.template.macroenabled.12': {
      'source': 'iana',
      'extensions': ['xltm']
    },
    'application/vnd.ms-fontobject': {
      'source': 'iana',
      'compressible': true,
      'extensions': ['eot']
    },
    'application/vnd.ms-htmlhelp': {
      'source': 'iana',
      'extensions': ['chm']
    },
    'application/vnd.ms-ims': {
      'source': 'iana',
      'extensions': ['ims']
    },
    'application/vnd.ms-lrm': {
      'source': 'iana',
      'extensions': ['lrm']
    },
    'application/vnd.ms-office.activex+xml': {
      'source': 'iana'
    },
    'application/vnd.ms-officetheme': {
      'source': 'iana',
      'extensions': ['thmx']
    },
    'application/vnd.ms-opentype': {
      'source': 'apache',
      'compressible': true
    },
    'application/vnd.ms-package.obfuscated-opentype': {
      'source': 'apache'
    },
    'application/vnd.ms-pki.seccat': {
      'source': 'apache',
      'extensions': ['cat']
    },
    'application/vnd.ms-pki.stl': {
      'source': 'apache',
      'extensions': ['stl']
    },
    'application/vnd.ms-playready.initiator+xml': {
      'source': 'iana'
    },
    'application/vnd.ms-powerpoint': {
      'source': 'iana',
      'compressible': false,
      'extensions': ['ppt', 'pps', 'pot']
    },
    'application/vnd.ms-powerpoint.addin.macroenabled.12': {
      'source': 'iana',
      'extensions': ['ppam']
    },
    'application/vnd.ms-powerpoint.presentation.macroenabled.12': {
      'source': 'iana',
      'extensions': ['pptm']
    },
    'application/vnd.ms-powerpoint.slide.macroenabled.12': {
      'source': 'iana',
      'extensions': ['sldm']
    },
    'application/vnd.ms-powerpoint.slideshow.macroenabled.12': {
      'source': 'iana',
      'extensions': ['ppsm']
    },
    'application/vnd.ms-powerpoint.template.macroenabled.12': {
      'source': 'iana',
      'extensions': ['potm']
    },
    'application/vnd.ms-printdevicecapabilities+xml': {
      'source': 'iana'
    },
    'application/vnd.ms-printing.printticket+xml': {
      'source': 'apache'
    },
    'application/vnd.ms-printschematicket+xml': {
      'source': 'iana'
    },
    'application/vnd.ms-project': {
      'source': 'iana',
      'extensions': ['mpp', 'mpt']
    },
    'application/vnd.ms-tnef': {
      'source': 'iana'
    },
    'application/vnd.ms-windows.devicepairing': {
      'source': 'iana'
    },
    'application/vnd.ms-windows.nwprinting.oob': {
      'source': 'iana'
    },
    'application/vnd.ms-windows.printerpairing': {
      'source': 'iana'
    },
    'application/vnd.ms-windows.wsd.oob': {
      'source': 'iana'
    },
    'application/vnd.ms-wmdrm.lic-chlg-req': {
      'source': 'iana'
    },
    'application/vnd.ms-wmdrm.lic-resp': {
      'source': 'iana'
    },
    'application/vnd.ms-wmdrm.meter-chlg-req': {
      'source': 'iana'
    },
    'application/vnd.ms-wmdrm.meter-resp': {
      'source': 'iana'
    },
    'application/vnd.ms-word.document.macroenabled.12': {
      'source': 'iana',
      'extensions': ['docm']
    },
    'application/vnd.ms-word.template.macroenabled.12': {
      'source': 'iana',
      'extensions': ['dotm']
    },
    'application/vnd.ms-works': {
      'source': 'iana',
      'extensions': ['wps', 'wks', 'wcm', 'wdb']
    },
    'application/vnd.ms-wpl': {
      'source': 'iana',
      'extensions': ['wpl']
    },
    'application/vnd.ms-xpsdocument': {
      'source': 'iana',
      'compressible': false,
      'extensions': ['xps']
    },
    'application/vnd.msa-disk-image': {
      'source': 'iana'
    },
    'application/vnd.mseq': {
      'source': 'iana',
      'extensions': ['mseq']
    },
    'application/vnd.msign': {
      'source': 'iana'
    },
    'application/vnd.multiad.creator': {
      'source': 'iana'
    },
    'application/vnd.multiad.creator.cif': {
      'source': 'iana'
    },
    'application/vnd.music-niff': {
      'source': 'iana'
    },
    'application/vnd.musician': {
      'source': 'iana',
      'extensions': ['mus']
    },
    'application/vnd.muvee.style': {
      'source': 'iana',
      'extensions': ['msty']
    },
    'application/vnd.mynfc': {
      'source': 'iana',
      'extensions': ['taglet']
    },
    'application/vnd.ncd.control': {
      'source': 'iana'
    },
    'application/vnd.ncd.reference': {
      'source': 'iana'
    },
    'application/vnd.nervana': {
      'source': 'iana'
    },
    'application/vnd.netfpx': {
      'source': 'iana'
    },
    'application/vnd.neurolanguage.nlu': {
      'source': 'iana',
      'extensions': ['nlu']
    },
    'application/vnd.nintendo.nitro.rom': {
      'source': 'iana'
    },
    'application/vnd.nintendo.snes.rom': {
      'source': 'iana'
    },
    'application/vnd.nitf': {
      'source': 'iana',
      'extensions': ['ntf', 'nitf']
    },
    'application/vnd.noblenet-directory': {
      'source': 'iana',
      'extensions': ['nnd']
    },
    'application/vnd.noblenet-sealer': {
      'source': 'iana',
      'extensions': ['nns']
    },
    'application/vnd.noblenet-web': {
      'source': 'iana',
      'extensions': ['nnw']
    },
    'application/vnd.nokia.catalogs': {
      'source': 'iana'
    },
    'application/vnd.nokia.conml+wbxml': {
      'source': 'iana'
    },
    'application/vnd.nokia.conml+xml': {
      'source': 'iana'
    },
    'application/vnd.nokia.iptv.config+xml': {
      'source': 'iana'
    },
    'application/vnd.nokia.isds-radio-presets': {
      'source': 'iana'
    },
    'application/vnd.nokia.landmark+wbxml': {
      'source': 'iana'
    },
    'application/vnd.nokia.landmark+xml': {
      'source': 'iana'
    },
    'application/vnd.nokia.landmarkcollection+xml': {
      'source': 'iana'
    },
    'application/vnd.nokia.n-gage.ac+xml': {
      'source': 'iana'
    },
    'application/vnd.nokia.n-gage.data': {
      'source': 'iana',
      'extensions': ['ngdat']
    },
    'application/vnd.nokia.n-gage.symbian.install': {
      'source': 'iana',
      'extensions': ['n-gage']
    },
    'application/vnd.nokia.ncd': {
      'source': 'iana'
    },
    'application/vnd.nokia.pcd+wbxml': {
      'source': 'iana'
    },
    'application/vnd.nokia.pcd+xml': {
      'source': 'iana'
    },
    'application/vnd.nokia.radio-preset': {
      'source': 'iana',
      'extensions': ['rpst']
    },
    'application/vnd.nokia.radio-presets': {
      'source': 'iana',
      'extensions': ['rpss']
    },
    'application/vnd.novadigm.edm': {
      'source': 'iana',
      'extensions': ['edm']
    },
    'application/vnd.novadigm.edx': {
      'source': 'iana',
      'extensions': ['edx']
    },
    'application/vnd.novadigm.ext': {
      'source': 'iana',
      'extensions': ['ext']
    },
    'application/vnd.ntt-local.content-share': {
      'source': 'iana'
    },
    'application/vnd.ntt-local.file-transfer': {
      'source': 'iana'
    },
    'application/vnd.ntt-local.ogw_remote-access': {
      'source': 'iana'
    },
    'application/vnd.ntt-local.sip-ta_remote': {
      'source': 'iana'
    },
    'application/vnd.ntt-local.sip-ta_tcp_stream': {
      'source': 'iana'
    },
    'application/vnd.oasis.opendocument.chart': {
      'name': 'OpenDocument Chart',
      'source': 'iana',
      'extensions': ['odc']
    },
    'application/vnd.oasis.opendocument.chart-template': {
      'name': 'OpenDocument Chart Template',
      'source': 'iana',
      'extensions': ['otc']
    },
    'application/vnd.oasis.opendocument.database': {
      'name': 'OpenDocument Database',
      'source': 'iana',
      'extensions': ['odb']
    },
    'application/vnd.oasis.opendocument.formula': {
      'name': 'OpenDocument Formula',
      'source': 'iana',
      'extensions': ['odf']
    },
    'application/vnd.oasis.opendocument.formula-template': {
      'name': 'OpenDocument Formula Template',
      'source': 'iana',
      'extensions': ['odft']
    },
    'application/vnd.oasis.opendocument.graphics': {
      'name': 'OpenDocument Graphics',
      'source': 'iana',
      'compressible': false,
      'extensions': ['odg']
    },
    'application/vnd.oasis.opendocument.graphics-template': {
      'name': 'OpenDocument Graphics Template',
      'source': 'iana',
      'extensions': ['otg']
    },
    'application/vnd.oasis.opendocument.image': {
      'name': 'OpenDocument Image',
      'source': 'iana',
      'extensions': ['odi']
    },
    'application/vnd.oasis.opendocument.image-template': {
      'name': 'OpenDocument Image Template',
      'source': 'iana',
      'extensions': ['oti']
    },
    'application/vnd.oasis.opendocument.presentation': {
      'name': 'OpenDocument Presentation',
      'source': 'iana',
      'compressible': false,
      'extensions': ['odp']
    },
    'application/vnd.oasis.opendocument.presentation-template': {
      'name': 'OpenDocument Presentation Template',
      'source': 'iana',
      'extensions': ['otp']
    },
    'application/vnd.oasis.opendocument.spreadsheet': {
      'name': 'OpenDocument Spreadsheet',
      'source': 'iana',
      'compressible': false,
      'extensions': ['ods']
    },
    'application/vnd.oasis.opendocument.spreadsheet-template': {
      'name': 'OpenDocument Spreadsheet Template',
      'source': 'iana',
      'extensions': ['ots']
    },
    'application/vnd.oasis.opendocument.text': {
      'name': 'OpenDocument Text',
      'source': 'iana',
      'compressible': false,
      'extensions': ['odt']
    },
    'application/vnd.oasis.opendocument.text-master': {
      'name': 'OpenDocument Text Master',
      'source': 'iana',
      'extensions': ['odm']
    },
    'application/vnd.oasis.opendocument.text-template': {
      'name': 'OpenDocument Text Template',
      'source': 'iana',
      'extensions': ['ott']
    },
    'application/vnd.oasis.opendocument.text-web': {
      'name': 'OpenDocument Text Web',
      'source': 'iana',
      'extensions': ['oth']
    },
    'application/vnd.obn': {
      'source': 'iana'
    },
    'application/vnd.oftn.l10n+json': {
      'source': 'iana',
      'compressible': true
    },
    'application/vnd.oipf.contentaccessdownload+xml': {
      'source': 'iana'
    },
    'application/vnd.oipf.contentaccessstreaming+xml': {
      'source': 'iana'
    },
    'application/vnd.oipf.cspg-hexbinary': {
      'source': 'iana'
    },
    'application/vnd.oipf.dae.svg+xml': {
      'source': 'iana'
    },
    'application/vnd.oipf.dae.xhtml+xml': {
      'source': 'iana'
    },
    'application/vnd.oipf.mippvcontrolmessage+xml': {
      'source': 'iana'
    },
    'application/vnd.oipf.pae.gem': {
      'source': 'iana'
    },
    'application/vnd.oipf.spdiscovery+xml': {
      'source': 'iana'
    },
    'application/vnd.oipf.spdlist+xml': {
      'source': 'iana'
    },
    'application/vnd.oipf.ueprofile+xml': {
      'source': 'iana'
    },
    'application/vnd.oipf.userprofile+xml': {
      'source': 'iana'
    },
    'application/vnd.olpc-sugar': {
      'source': 'iana',
      'extensions': ['xo']
    },
    'application/vnd.oma-scws-config': {
      'source': 'iana'
    },
    'application/vnd.oma-scws-http-request': {
      'source': 'iana'
    },
    'application/vnd.oma-scws-http-response': {
      'source': 'iana'
    },
    'application/vnd.oma.bcast.associated-procedure-parameter+xml': {
      'source': 'iana'
    },
    'application/vnd.oma.bcast.drm-trigger+xml': {
      'source': 'iana'
    },
    'application/vnd.oma.bcast.imd+xml': {
      'source': 'iana'
    },
    'application/vnd.oma.bcast.ltkm': {
      'source': 'iana'
    },
    'application/vnd.oma.bcast.notification+xml': {
      'source': 'iana'
    },
    'application/vnd.oma.bcast.provisioningtrigger': {
      'source': 'iana'
    },
    'application/vnd.oma.bcast.sgboot': {
      'source': 'iana'
    },
    'application/vnd.oma.bcast.sgdd+xml': {
      'source': 'iana'
    },
    'application/vnd.oma.bcast.sgdu': {
      'source': 'iana'
    },
    'application/vnd.oma.bcast.simple-symbol-container': {
      'source': 'iana'
    },
    'application/vnd.oma.bcast.smartcard-trigger+xml': {
      'source': 'iana'
    },
    'application/vnd.oma.bcast.sprov+xml': {
      'source': 'iana'
    },
    'application/vnd.oma.bcast.stkm': {
      'source': 'iana'
    },
    'application/vnd.oma.cab-address-book+xml': {
      'source': 'iana'
    },
    'application/vnd.oma.cab-feature-handler+xml': {
      'source': 'iana'
    },
    'application/vnd.oma.cab-pcc+xml': {
      'source': 'iana'
    },
    'application/vnd.oma.cab-subs-invite+xml': {
      'source': 'iana'
    },
    'application/vnd.oma.cab-user-prefs+xml': {
      'source': 'iana'
    },
    'application/vnd.oma.dcd': {
      'source': 'iana'
    },
    'application/vnd.oma.dcdc': {
      'source': 'iana'
    },
    'application/vnd.oma.dd2+xml': {
      'source': 'iana',
      'extensions': ['dd2']
    },
    'application/vnd.oma.drm.risd+xml': {
      'source': 'iana'
    },
    'application/vnd.oma.group-usage-list+xml': {
      'source': 'iana'
    },
    'application/vnd.oma.pal+xml': {
      'source': 'iana'
    },
    'application/vnd.oma.poc.detailed-progress-report+xml': {
      'source': 'iana'
    },
    'application/vnd.oma.poc.final-report+xml': {
      'source': 'iana'
    },
    'application/vnd.oma.poc.groups+xml': {
      'source': 'iana'
    },
    'application/vnd.oma.poc.invocation-descriptor+xml': {
      'source': 'iana'
    },
    'application/vnd.oma.poc.optimized-progress-report+xml': {
      'source': 'iana'
    },
    'application/vnd.oma.push': {
      'source': 'iana'
    },
    'application/vnd.oma.scidm.messages+xml': {
      'source': 'iana'
    },
    'application/vnd.oma.xcap-directory+xml': {
      'source': 'iana'
    },
    'application/vnd.omads-email+xml': {
      'source': 'iana'
    },
    'application/vnd.omads-file+xml': {
      'source': 'iana'
    },
    'application/vnd.omads-folder+xml': {
      'source': 'iana'
    },
    'application/vnd.omaloc-supl-init': {
      'source': 'iana'
    },
    'application/vnd.onepager': {
      'source': 'iana'
    },
    'application/vnd.openblox.game+xml': {
      'source': 'iana'
    },
    'application/vnd.openblox.game-binary': {
      'source': 'iana'
    },
    'application/vnd.openeye.oeb': {
      'source': 'iana'
    },
    'application/vnd.openofficeorg.extension': {
      'source': 'apache',
      'extensions': ['oxt']
    },
    'application/vnd.openxmlformats-officedocument.custom-properties+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.customxmlproperties+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.drawing+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.drawingml.chart+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.extended-properties+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.presentationml-template': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.presentationml.comments+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.presentationml.presentation': {
      'name': 'PowerPoint',
      'source': 'iana',
      'compressible': false,
      'extensions': ['pptx']
    },
    'application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.presentationml.presprops+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.presentationml.slide': {
      'source': 'iana',
      'extensions': ['sldx']
    },
    'application/vnd.openxmlformats-officedocument.presentationml.slide+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.presentationml.slideshow': {
      'source': 'iana',
      'extensions': ['ppsx']
    },
    'application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.presentationml.tags+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.presentationml.template': {
      'source': 'apache',
      'extensions': ['potx']
    },
    'application/vnd.openxmlformats-officedocument.presentationml.template.main+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml-template': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': {
      'name': 'Excel (xlsx)',
      'source': 'iana',
      'compressible': false,
      'extensions': ['xlsx']
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.template': {
      'source': 'apache',
      'extensions': ['xltx']
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.theme+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.themeoverride+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.vmldrawing': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.wordprocessingml-template': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document': {
      'name': 'Word',
      'source': 'iana',
      'compressible': false,
      'extensions': ['docx']
    },
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.wordprocessingml.template': {
      'name': 'Word Template',
      'source': 'apache',
      'extensions': ['dotx']
    },
    'application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-package.core-properties+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml': {
      'source': 'iana'
    },
    'application/vnd.openxmlformats-package.relationships+xml': {
      'source': 'iana'
    },
    'application/vnd.oracle.resource+json': {
      'source': 'iana',
      'compressible': true
    },
    'application/vnd.orange.indata': {
      'source': 'iana'
    },
    'application/vnd.osa.netdeploy': {
      'source': 'iana'
    },
    'application/vnd.osgeo.mapguide.package': {
      'source': 'iana',
      'extensions': ['mgp']
    },
    'application/vnd.osgi.bundle': {
      'source': 'iana'
    },
    'application/vnd.osgi.dp': {
      'source': 'iana',
      'extensions': ['dp']
    },
    'application/vnd.osgi.subsystem': {
      'source': 'iana',
      'extensions': ['esa']
    },
    'application/vnd.otps.ct-kip+xml': {
      'source': 'iana'
    },
    'application/vnd.oxli.countgraph': {
      'source': 'iana'
    },
    'application/vnd.pagerduty+json': {
      'source': 'iana',
      'compressible': true
    },
    'application/vnd.palm': {
      'source': 'iana',
      'extensions': ['pdb', 'pqa', 'oprc']
    },
    'application/vnd.panoply': {
      'source': 'iana'
    },
    'application/vnd.paos+xml': {
      'source': 'iana'
    },
    'application/vnd.paos.xml': {
      'source': 'apache'
    },
    'application/vnd.pawaafile': {
      'source': 'iana',
      'extensions': ['paw']
    },
    'application/vnd.pcos': {
      'source': 'iana'
    },
    'application/vnd.pg.format': {
      'source': 'iana',
      'extensions': ['str']
    },
    'application/vnd.pg.osasli': {
      'source': 'iana',
      'extensions': ['ei6']
    },
    'application/vnd.piaccess.application-licence': {
      'source': 'iana'
    },
    'application/vnd.picsel': {
      'source': 'iana',
      'extensions': ['efif']
    },
    'application/vnd.pmi.widget': {
      'source': 'iana',
      'extensions': ['wg']
    },
    'application/vnd.poc.group-advertisement+xml': {
      'source': 'iana'
    },
    'application/vnd.pocketlearn': {
      'source': 'iana',
      'extensions': ['plf']
    },
    'application/vnd.powerbuilder6': {
      'source': 'iana',
      'extensions': ['pbd']
    },
    'application/vnd.powerbuilder6-s': {
      'source': 'iana'
    },
    'application/vnd.powerbuilder7': {
      'source': 'iana'
    },
    'application/vnd.powerbuilder7-s': {
      'source': 'iana'
    },
    'application/vnd.powerbuilder75': {
      'source': 'iana'
    },
    'application/vnd.powerbuilder75-s': {
      'source': 'iana'
    },
    'application/vnd.preminet': {
      'source': 'iana'
    },
    'application/vnd.previewsystems.box': {
      'source': 'iana',
      'extensions': ['box']
    },
    'application/vnd.proteus.magazine': {
      'source': 'iana',
      'extensions': ['mgz']
    },
    'application/vnd.publishare-delta-tree': {
      'source': 'iana',
      'extensions': ['qps']
    },
    'application/vnd.pvi.ptid1': {
      'source': 'iana',
      'extensions': ['ptid']
    },
    'application/vnd.pwg-multiplexed': {
      'source': 'iana'
    },
    'application/vnd.pwg-xhtml-print+xml': {
      'source': 'iana'
    },
    'application/vnd.qualcomm.brew-app-res': {
      'source': 'iana'
    },
    'application/vnd.quark.quarkxpress': {
      'source': 'iana',
      'extensions': ['qxd', 'qxt', 'qwd', 'qwt', 'qxl', 'qxb']
    },
    'application/vnd.quobject-quoxdocument': {
      'source': 'iana'
    },
    'application/vnd.radisys.moml+xml': {
      'source': 'iana'
    },
    'application/vnd.radisys.msml+xml': {
      'source': 'iana'
    },
    'application/vnd.radisys.msml-audit+xml': {
      'source': 'iana'
    },
    'application/vnd.radisys.msml-audit-conf+xml': {
      'source': 'iana'
    },
    'application/vnd.radisys.msml-audit-conn+xml': {
      'source': 'iana'
    },
    'application/vnd.radisys.msml-audit-dialog+xml': {
      'source': 'iana'
    },
    'application/vnd.radisys.msml-audit-stream+xml': {
      'source': 'iana'
    },
    'application/vnd.radisys.msml-conf+xml': {
      'source': 'iana'
    },
    'application/vnd.radisys.msml-dialog+xml': {
      'source': 'iana'
    },
    'application/vnd.radisys.msml-dialog-base+xml': {
      'source': 'iana'
    },
    'application/vnd.radisys.msml-dialog-fax-detect+xml': {
      'source': 'iana'
    },
    'application/vnd.radisys.msml-dialog-fax-sendrecv+xml': {
      'source': 'iana'
    },
    'application/vnd.radisys.msml-dialog-group+xml': {
      'source': 'iana'
    },
    'application/vnd.radisys.msml-dialog-speech+xml': {
      'source': 'iana'
    },
    'application/vnd.radisys.msml-dialog-transform+xml': {
      'source': 'iana'
    },
    'application/vnd.rainstor.data': {
      'source': 'iana'
    },
    'application/vnd.rapid': {
      'source': 'iana'
    },
    'application/vnd.realvnc.bed': {
      'source': 'iana',
      'extensions': ['bed']
    },
    'application/vnd.recordare.musicxml': {
      'source': 'iana',
      'extensions': ['mxl']
    },
    'application/vnd.recordare.musicxml+xml': {
      'source': 'iana',
      'extensions': ['musicxml']
    },
    'application/vnd.renlearn.rlprint': {
      'source': 'iana'
    },
    'application/vnd.rig.cryptonote': {
      'source': 'iana',
      'extensions': ['cryptonote']
    },
    'application/vnd.rim.cod': {
      'source': 'apache',
      'extensions': ['cod']
    },
    'application/vnd.rn-realmedia': {
      'source': 'apache',
      'extensions': ['rm']
    },
    'application/vnd.rn-realmedia-vbr': {
      'source': 'apache',
      'extensions': ['rmvb']
    },
    'application/vnd.route66.link66+xml': {
      'source': 'iana',
      'extensions': ['link66']
    },
    'application/vnd.rs-274x': {
      'source': 'iana'
    },
    'application/vnd.ruckus.download': {
      'source': 'iana'
    },
    'application/vnd.s3sms': {
      'source': 'iana'
    },
    'application/vnd.sailingtracker.track': {
      'source': 'iana',
      'extensions': ['st']
    },
    'application/vnd.sbm.cid': {
      'source': 'iana'
    },
    'application/vnd.sbm.mid2': {
      'source': 'iana'
    },
    'application/vnd.scribus': {
      'source': 'iana'
    },
    'application/vnd.sealed.3df': {
      'source': 'iana'
    },
    'application/vnd.sealed.csf': {
      'source': 'iana'
    },
    'application/vnd.sealed.doc': {
      'source': 'iana'
    },
    'application/vnd.sealed.eml': {
      'source': 'iana'
    },
    'application/vnd.sealed.mht': {
      'source': 'iana'
    },
    'application/vnd.sealed.net': {
      'source': 'iana'
    },
    'application/vnd.sealed.ppt': {
      'source': 'iana'
    },
    'application/vnd.sealed.tiff': {
      'source': 'iana'
    },
    'application/vnd.sealed.xls': {
      'source': 'iana'
    },
    'application/vnd.sealedmedia.softseal.html': {
      'source': 'iana'
    },
    'application/vnd.sealedmedia.softseal.pdf': {
      'source': 'iana'
    },
    'application/vnd.seemail': {
      'source': 'iana',
      'extensions': ['see']
    },
    'application/vnd.sema': {
      'source': 'iana',
      'extensions': ['sema']
    },
    'application/vnd.semd': {
      'source': 'iana',
      'extensions': ['semd']
    },
    'application/vnd.semf': {
      'source': 'iana',
      'extensions': ['semf']
    },
    'application/vnd.shana.informed.formdata': {
      'source': 'iana',
      'extensions': ['ifm']
    },
    'application/vnd.shana.informed.formtemplate': {
      'source': 'iana',
      'extensions': ['itp']
    },
    'application/vnd.shana.informed.interchange': {
      'source': 'iana',
      'extensions': ['iif']
    },
    'application/vnd.shana.informed.package': {
      'source': 'iana',
      'extensions': ['ipk']
    },
    'application/vnd.simtech-mindmapper': {
      'source': 'iana',
      'extensions': ['twd', 'twds']
    },
    'application/vnd.siren+json': {
      'source': 'iana',
      'compressible': true
    },
    'application/vnd.smaf': {
      'source': 'iana',
      'extensions': ['mmf']
    },
    'application/vnd.smart.notebook': {
      'source': 'iana'
    },
    'application/vnd.smart.teacher': {
      'source': 'iana',
      'extensions': ['teacher']
    },
    'application/vnd.software602.filler.form+xml': {
      'source': 'iana'
    },
    'application/vnd.software602.filler.form-xml-zip': {
      'source': 'iana'
    },
    'application/vnd.solent.sdkm+xml': {
      'source': 'iana',
      'extensions': ['sdkm', 'sdkd']
    },
    'application/vnd.spotfire.dxp': {
      'source': 'iana',
      'extensions': ['dxp']
    },
    'application/vnd.spotfire.sfs': {
      'source': 'iana',
      'extensions': ['sfs']
    },
    'application/vnd.sss-cod': {
      'source': 'iana'
    },
    'application/vnd.sss-dtf': {
      'source': 'iana'
    },
    'application/vnd.sss-ntf': {
      'source': 'iana'
    },
    'application/vnd.stardivision.calc': {
      'source': 'apache',
      'extensions': ['sdc']
    },
    'application/vnd.stardivision.draw': {
      'source': 'apache',
      'extensions': ['sda']
    },
    'application/vnd.stardivision.impress': {
      'source': 'apache',
      'extensions': ['sdd']
    },
    'application/vnd.stardivision.math': {
      'source': 'apache',
      'extensions': ['smf']
    },
    'application/vnd.stardivision.writer': {
      'source': 'apache',
      'extensions': ['sdw', 'vor']
    },
    'application/vnd.stardivision.writer-global': {
      'source': 'apache',
      'extensions': ['sgl']
    },
    'application/vnd.stepmania.package': {
      'source': 'iana',
      'extensions': ['smzip']
    },
    'application/vnd.stepmania.stepchart': {
      'source': 'iana',
      'extensions': ['sm']
    },
    'application/vnd.street-stream': {
      'source': 'iana'
    },
    'application/vnd.sun.wadl+xml': {
      'source': 'iana'
    },
    'application/vnd.sun.xml.calc': {
      'source': 'apache',
      'extensions': ['sxc']
    },
    'application/vnd.sun.xml.calc.template': {
      'source': 'apache',
      'extensions': ['stc']
    },
    'application/vnd.sun.xml.draw': {
      'source': 'apache',
      'extensions': ['sxd']
    },
    'application/vnd.sun.xml.draw.template': {
      'source': 'apache',
      'extensions': ['std']
    },
    'application/vnd.sun.xml.impress': {
      'source': 'apache',
      'extensions': ['sxi']
    },
    'application/vnd.sun.xml.impress.template': {
      'source': 'apache',
      'extensions': ['sti']
    },
    'application/vnd.sun.xml.math': {
      'source': 'apache',
      'extensions': ['sxm']
    },
    'application/vnd.sun.xml.writer': {
      'source': 'apache',
      'extensions': ['sxw']
    },
    'application/vnd.sun.xml.writer.global': {
      'source': 'apache',
      'extensions': ['sxg']
    },
    'application/vnd.sun.xml.writer.template': {
      'source': 'apache',
      'extensions': ['stw']
    },
    'application/vnd.sus-calendar': {
      'source': 'iana',
      'extensions': ['sus', 'susp']
    },
    'application/vnd.svd': {
      'source': 'iana',
      'extensions': ['svd']
    },
    'application/vnd.swiftview-ics': {
      'source': 'iana'
    },
    'application/vnd.symbian.install': {
      'source': 'apache',
      'extensions': ['sis', 'sisx']
    },
    'application/vnd.syncml+xml': {
      'source': 'iana',
      'extensions': ['xsm']
    },
    'application/vnd.syncml.dm+wbxml': {
      'source': 'iana',
      'extensions': ['bdm']
    },
    'application/vnd.syncml.dm+xml': {
      'source': 'iana',
      'extensions': ['xdm']
    },
    'application/vnd.syncml.dm.notification': {
      'source': 'iana'
    },
    'application/vnd.syncml.dmddf+wbxml': {
      'source': 'iana'
    },
    'application/vnd.syncml.dmddf+xml': {
      'source': 'iana'
    },
    'application/vnd.syncml.dmtnds+wbxml': {
      'source': 'iana'
    },
    'application/vnd.syncml.dmtnds+xml': {
      'source': 'iana'
    },
    'application/vnd.syncml.ds.notification': {
      'source': 'iana'
    },
    'application/vnd.tao.intent-module-archive': {
      'source': 'iana',
      'extensions': ['tao']
    },
    'application/vnd.tcpdump.pcap': {
      'source': 'iana',
      'extensions': ['pcap', 'cap', 'dmp']
    },
    'application/vnd.tmd.mediaflex.api+xml': {
      'source': 'iana'
    },
    'application/vnd.tml': {
      'source': 'iana'
    },
    'application/vnd.tmobile-livetv': {
      'source': 'iana',
      'extensions': ['tmo']
    },
    'application/vnd.trid.tpt': {
      'source': 'iana',
      'extensions': ['tpt']
    },
    'application/vnd.triscape.mxs': {
      'source': 'iana',
      'extensions': ['mxs']
    },
    'application/vnd.trueapp': {
      'source': 'iana',
      'extensions': ['tra']
    },
    'application/vnd.truedoc': {
      'source': 'iana'
    },
    'application/vnd.ubisoft.webplayer': {
      'source': 'iana'
    },
    'application/vnd.ufdl': {
      'source': 'iana',
      'extensions': ['ufd', 'ufdl']
    },
    'application/vnd.uiq.theme': {
      'source': 'iana',
      'extensions': ['utz']
    },
    'application/vnd.umajin': {
      'source': 'iana',
      'extensions': ['umj']
    },
    'application/vnd.unity': {
      'source': 'iana',
      'extensions': ['unityweb']
    },
    'application/vnd.uoml+xml': {
      'source': 'iana',
      'extensions': ['uoml']
    },
    'application/vnd.uplanet.alert': {
      'source': 'iana'
    },
    'application/vnd.uplanet.alert-wbxml': {
      'source': 'iana'
    },
    'application/vnd.uplanet.bearer-choice': {
      'source': 'iana'
    },
    'application/vnd.uplanet.bearer-choice-wbxml': {
      'source': 'iana'
    },
    'application/vnd.uplanet.cacheop': {
      'source': 'iana'
    },
    'application/vnd.uplanet.cacheop-wbxml': {
      'source': 'iana'
    },
    'application/vnd.uplanet.channel': {
      'source': 'iana'
    },
    'application/vnd.uplanet.channel-wbxml': {
      'source': 'iana'
    },
    'application/vnd.uplanet.list': {
      'source': 'iana'
    },
    'application/vnd.uplanet.list-wbxml': {
      'source': 'iana'
    },
    'application/vnd.uplanet.listcmd': {
      'source': 'iana'
    },
    'application/vnd.uplanet.listcmd-wbxml': {
      'source': 'iana'
    },
    'application/vnd.uplanet.signal': {
      'source': 'iana'
    },
    'application/vnd.uri-map': {
      'source': 'iana'
    },
    'application/vnd.valve.source.material': {
      'source': 'iana'
    },
    'application/vnd.vcx': {
      'source': 'iana',
      'extensions': ['vcx']
    },
    'application/vnd.vd-study': {
      'source': 'iana'
    },
    'application/vnd.vectorworks': {
      'source': 'iana'
    },
    'application/vnd.vel+json': {
      'source': 'iana',
      'compressible': true
    },
    'application/vnd.verimatrix.vcas': {
      'source': 'iana'
    },
    'application/vnd.vidsoft.vidconference': {
      'source': 'iana'
    },
    'application/vnd.visio': {
      'source': 'iana',
      'extensions': ['vsd', 'vst', 'vss', 'vsw']
    },
    'application/vnd.visionary': {
      'source': 'iana',
      'extensions': ['vis']
    },
    'application/vnd.vividence.scriptfile': {
      'source': 'iana'
    },
    'application/vnd.vsf': {
      'source': 'iana',
      'extensions': ['vsf']
    },
    'application/vnd.wap.sic': {
      'source': 'iana'
    },
    'application/vnd.wap.slc': {
      'source': 'iana'
    },
    'application/vnd.wap.wbxml': {
      'source': 'iana',
      'extensions': ['wbxml']
    },
    'application/vnd.wap.wmlc': {
      'source': 'iana',
      'extensions': ['wmlc']
    },
    'application/vnd.wap.wmlscriptc': {
      'source': 'iana',
      'extensions': ['wmlsc']
    },
    'application/vnd.webturbo': {
      'source': 'iana',
      'extensions': ['wtb']
    },
    'application/vnd.wfa.p2p': {
      'source': 'iana'
    },
    'application/vnd.wfa.wsc': {
      'source': 'iana'
    },
    'application/vnd.windows.devicepairing': {
      'source': 'iana'
    },
    'application/vnd.wmc': {
      'source': 'iana'
    },
    'application/vnd.wmf.bootstrap': {
      'source': 'iana'
    },
    'application/vnd.wolfram.mathematica': {
      'source': 'iana'
    },
    'application/vnd.wolfram.mathematica.package': {
      'source': 'iana'
    },
    'application/vnd.wolfram.player': {
      'source': 'iana',
      'extensions': ['nbp']
    },
    'application/vnd.wordperfect': {
      'source': 'iana',
      'extensions': ['wpd']
    },
    'application/vnd.wqd': {
      'source': 'iana',
      'extensions': ['wqd']
    },
    'application/vnd.wrq-hp3000-labelled': {
      'source': 'iana'
    },
    'application/vnd.wt.stf': {
      'source': 'iana',
      'extensions': ['stf']
    },
    'application/vnd.wv.csp+wbxml': {
      'source': 'iana'
    },
    'application/vnd.wv.csp+xml': {
      'source': 'iana'
    },
    'application/vnd.wv.ssp+xml': {
      'source': 'iana'
    },
    'application/vnd.xacml+json': {
      'source': 'iana',
      'compressible': true
    },
    'application/vnd.xara': {
      'source': 'iana',
      'extensions': ['xar']
    },
    'application/vnd.xfdl': {
      'source': 'iana',
      'extensions': ['xfdl']
    },
    'application/vnd.xfdl.webform': {
      'source': 'iana'
    },
    'application/vnd.xmi+xml': {
      'source': 'iana'
    },
    'application/vnd.xmpie.cpkg': {
      'source': 'iana'
    },
    'application/vnd.xmpie.dpkg': {
      'source': 'iana'
    },
    'application/vnd.xmpie.plan': {
      'source': 'iana'
    },
    'application/vnd.xmpie.ppkg': {
      'source': 'iana'
    },
    'application/vnd.xmpie.xlim': {
      'source': 'iana'
    },
    'application/vnd.yamaha.hv-dic': {
      'source': 'iana',
      'extensions': ['hvd']
    },
    'application/vnd.yamaha.hv-script': {
      'source': 'iana',
      'extensions': ['hvs']
    },
    'application/vnd.yamaha.hv-voice': {
      'source': 'iana',
      'extensions': ['hvp']
    },
    'application/vnd.yamaha.openscoreformat': {
      'source': 'iana',
      'extensions': ['osf']
    },
    'application/vnd.yamaha.openscoreformat.osfpvg+xml': {
      'source': 'iana',
      'extensions': ['osfpvg']
    },
    'application/vnd.yamaha.remote-setup': {
      'source': 'iana'
    },
    'application/vnd.yamaha.smaf-audio': {
      'source': 'iana',
      'extensions': ['saf']
    },
    'application/vnd.yamaha.smaf-phrase': {
      'source': 'iana',
      'extensions': ['spf']
    },
    'application/vnd.yamaha.through-ngn': {
      'source': 'iana'
    },
    'application/vnd.yamaha.tunnel-udpencap': {
      'source': 'iana'
    },
    'application/vnd.yaoweme': {
      'source': 'iana'
    },
    'application/vnd.yellowriver-custom-menu': {
      'source': 'iana',
      'extensions': ['cmp']
    },
    'application/vnd.zul': {
      'source': 'iana',
      'extensions': ['zir', 'zirz']
    },
    'application/vnd.zzazz.deck+xml': {
      'source': 'iana',
      'extensions': ['zaz']
    },
    'application/voicexml+xml': {
      'source': 'iana',
      'extensions': ['vxml']
    },
    'application/vq-rtcpxr': {
      'source': 'iana'
    },
    'application/watcherinfo+xml': {
      'source': 'iana'
    },
    'application/whoispp-query': {
      'source': 'iana'
    },
    'application/whoispp-response': {
      'source': 'iana'
    },
    'application/widget': {
      'source': 'iana',
      'extensions': ['wgt']
    },
    'application/winhlp': {
      'source': 'apache',
      'extensions': ['hlp']
    },
    'application/wita': {
      'source': 'iana'
    },
    'application/wordperfect5.1': {
      'source': 'iana'
    },
    'application/wsdl+xml': {
      'source': 'iana',
      'extensions': ['wsdl']
    },
    'application/wspolicy+xml': {
      'source': 'iana',
      'extensions': ['wspolicy']
    },
    'application/x-7z-compressed': {
      'source': 'apache',
      'compressible': false,
      'extensions': ['7z']
    },
    'application/x-abiword': {
      'source': 'apache',
      'extensions': ['abw']
    },
    'application/x-ace-compressed': {
      'source': 'apache',
      'extensions': ['ace']
    },
    'application/x-amf': {
      'source': 'apache'
    },
    'application/x-apple-diskimage': {
      'source': 'apache',
      'extensions': ['dmg']
    },
    'application/x-authorware-bin': {
      'source': 'apache',
      'extensions': ['aab', 'x32', 'u32', 'vox']
    },
    'application/x-authorware-map': {
      'source': 'apache',
      'extensions': ['aam']
    },
    'application/x-authorware-seg': {
      'source': 'apache',
      'extensions': ['aas']
    },
    'application/x-bcpio': {
      'source': 'apache',
      'extensions': ['bcpio']
    },
    'application/x-bdoc': {
      'compressible': false,
      'extensions': ['bdoc']
    },
    'application/x-bittorrent': {
      'source': 'apache',
      'extensions': ['torrent']
    },
    'application/x-blorb': {
      'source': 'apache',
      'extensions': ['blb', 'blorb']
    },
    'application/x-bzip': {
      'source': 'apache',
      'compressible': false,
      'extensions': ['bz']
    },
    'application/x-bzip2': {
      'source': 'apache',
      'compressible': false,
      'extensions': ['bz2', 'boz']
    },
    'application/x-cbr': {
      'source': 'apache',
      'extensions': ['cbr', 'cba', 'cbt', 'cbz', 'cb7']
    },
    'application/x-cdlink': {
      'source': 'apache',
      'extensions': ['vcd']
    },
    'application/x-cfs-compressed': {
      'source': 'apache',
      'extensions': ['cfs']
    },
    'application/x-chat': {
      'source': 'apache',
      'extensions': ['chat']
    },
    'application/x-chess-pgn': {
      'source': 'apache',
      'extensions': ['pgn']
    },
    'application/x-chrome-extension': {
      'extensions': ['crx']
    },
    'application/x-cocoa': {
      'source': 'nginx',
      'extensions': ['cco']
    },
    'application/x-compress': {
      'source': 'apache'
    },
    'application/x-conference': {
      'source': 'apache',
      'extensions': ['nsc']
    },
    'application/x-cpio': {
      'source': 'apache',
      'extensions': ['cpio']
    },
    'application/x-csh': {
      'source': 'apache',
      'extensions': ['csh']
    },
    'application/x-deb': {
      'compressible': false
    },
    'application/x-debian-package': {
      'source': 'apache',
      'extensions': ['deb', 'udeb']
    },
    'application/x-dgc-compressed': {
      'source': 'apache',
      'extensions': ['dgc']
    },
    'application/x-director': {
      'source': 'apache',
      'extensions': ['dir', 'dcr', 'dxr', 'cst', 'cct', 'cxt', 'w3d', 'fgd', 'swa']
    },
    'application/x-doom': {
      'source': 'apache',
      'extensions': ['wad']
    },
    'application/x-dtbncx+xml': {
      'source': 'apache',
      'extensions': ['ncx']
    },
    'application/x-dtbook+xml': {
      'source': 'apache',
      'extensions': ['dtb']
    },
    'application/x-dtbresource+xml': {
      'source': 'apache',
      'extensions': ['res']
    },
    'application/x-dvi': {
      'source': 'apache',
      'compressible': false,
      'extensions': ['dvi']
    },
    'application/x-envoy': {
      'source': 'apache',
      'extensions': ['evy']
    },
    'application/x-eva': {
      'source': 'apache',
      'extensions': ['eva']
    },
    'application/x-font-bdf': {
      'source': 'apache',
      'extensions': ['bdf']
    },
    'application/x-font-dos': {
      'source': 'apache'
    },
    'application/x-font-framemaker': {
      'source': 'apache'
    },
    'application/x-font-ghostscript': {
      'source': 'apache',
      'extensions': ['gsf']
    },
    'application/x-font-libgrx': {
      'source': 'apache'
    },
    'application/x-font-linux-psf': {
      'source': 'apache',
      'extensions': ['psf']
    },
    'application/x-font-otf': {
      'source': 'apache',
      'compressible': true,
      'extensions': ['otf']
    },
    'application/x-font-pcf': {
      'source': 'apache',
      'extensions': ['pcf']
    },
    'application/x-font-snf': {
      'source': 'apache',
      'extensions': ['snf']
    },
    'application/x-font-speedo': {
      'source': 'apache'
    },
    'application/x-font-sunos-news': {
      'source': 'apache'
    },
    'application/x-font-ttf': {
      'source': 'apache',
      'compressible': true,
      'extensions': ['ttf', 'ttc']
    },
    'application/x-font-type1': {
      'source': 'apache',
      'extensions': ['pfa', 'pfb', 'pfm', 'afm']
    },
    'application/x-font-vfont': {
      'source': 'apache'
    },
    'application/x-freearc': {
      'source': 'apache',
      'extensions': ['arc']
    },
    'application/x-futuresplash': {
      'source': 'apache',
      'extensions': ['spl']
    },
    'application/x-gca-compressed': {
      'source': 'apache',
      'extensions': ['gca']
    },
    'application/x-glulx': {
      'source': 'apache',
      'extensions': ['ulx']
    },
    'application/x-gnumeric': {
      'source': 'apache',
      'extensions': ['gnumeric']
    },
    'application/x-gramps-xml': {
      'source': 'apache',
      'extensions': ['gramps']
    },
    'application/x-gtar': {
      'source': 'apache',
      'extensions': ['gtar']
    },
    'application/x-gzip': {
      'source': 'apache'
    },
    'application/x-hdf': {
      'source': 'apache',
      'extensions': ['hdf']
    },
    'application/x-httpd-php': {
      'compressible': true,
      'extensions': ['php']
    },
    'application/x-install-instructions': {
      'source': 'apache',
      'extensions': ['install']
    },
    'application/x-iso9660-image': {
      'source': 'apache',
      'extensions': ['iso']
    },
    'application/x-java-archive-diff': {
      'source': 'nginx',
      'extensions': ['jardiff']
    },
    'application/x-java-jnlp-file': {
      'source': 'apache',
      'compressible': false,
      'extensions': ['jnlp']
    },
    'application/x-javascript': {
      'compressible': true
    },
    'application/x-latex': {
      'source': 'apache',
      'compressible': false,
      'extensions': ['latex']
    },
    'application/x-lua-bytecode': {
      'extensions': ['luac']
    },
    'application/x-lzh-compressed': {
      'source': 'apache',
      'extensions': ['lzh', 'lha']
    },
    'application/x-makeself': {
      'source': 'nginx',
      'extensions': ['run']
    },
    'application/x-mie': {
      'source': 'apache',
      'extensions': ['mie']
    },
    'application/x-mobipocket-ebook': {
      'source': 'apache',
      'extensions': ['prc', 'mobi']
    },
    'application/x-mpegurl': {
      'compressible': false
    },
    'application/x-ms-application': {
      'source': 'apache',
      'extensions': ['application']
    },
    'application/x-ms-shortcut': {
      'source': 'apache',
      'extensions': ['lnk']
    },
    'application/x-ms-wmd': {
      'source': 'apache',
      'extensions': ['wmd']
    },
    'application/x-ms-wmz': {
      'source': 'apache',
      'extensions': ['wmz']
    },
    'application/x-ms-xbap': {
      'source': 'apache',
      'extensions': ['xbap']
    },
    'application/x-msaccess': {
      'source': 'apache',
      'extensions': ['mdb']
    },
    'application/x-msbinder': {
      'source': 'apache',
      'extensions': ['obd']
    },
    'application/x-mscardfile': {
      'source': 'apache',
      'extensions': ['crd']
    },
    'application/x-msclip': {
      'source': 'apache',
      'extensions': ['clp']
    },
    'application/x-msdos-program': {
      'extensions': ['exe']
    },
    'application/x-msdownload': {
      'source': 'apache',
      'extensions': ['exe', 'dll', 'com', 'bat', 'msi']
    },
    'application/x-msmediaview': {
      'source': 'apache',
      'extensions': ['mvb', 'm13', 'm14']
    },
    'application/x-msmetafile': {
      'source': 'apache',
      'extensions': ['wmf', 'wmz', 'emf', 'emz']
    },
    'application/x-msmoney': {
      'source': 'apache',
      'extensions': ['mny']
    },
    'application/x-mspublisher': {
      'source': 'apache',
      'extensions': ['pub']
    },
    'application/x-msschedule': {
      'source': 'apache',
      'extensions': ['scd']
    },
    'application/x-msterminal': {
      'source': 'apache',
      'extensions': ['trm']
    },
    'application/x-mswrite': {
      'source': 'apache',
      'extensions': ['wri']
    },
    'application/x-netcdf': {
      'source': 'apache',
      'extensions': ['nc', 'cdf']
    },
    'application/x-ns-proxy-autoconfig': {
      'compressible': true,
      'extensions': ['pac']
    },
    'application/x-nzb': {
      'source': 'apache',
      'extensions': ['nzb']
    },
    'application/x-perl': {
      'source': 'nginx',
      'extensions': ['pl', 'pm']
    },
    'application/x-pilot': {
      'source': 'nginx',
      'extensions': ['prc', 'pdb']
    },
    'application/x-pkcs12': {
      'source': 'apache',
      'compressible': false,
      'extensions': ['p12', 'pfx']
    },
    'application/x-pkcs7-certificates': {
      'source': 'apache',
      'extensions': ['p7b', 'spc']
    },
    'application/x-pkcs7-certreqresp': {
      'source': 'apache',
      'extensions': ['p7r']
    },
    'application/x-rar-compressed': {
      'source': 'apache',
      'compressible': false,
      'extensions': ['rar']
    },
    'application/x-redhat-package-manager': {
      'source': 'nginx',
      'extensions': ['rpm']
    },
    'application/x-research-info-systems': {
      'source': 'apache',
      'extensions': ['ris']
    },
    'application/x-sea': {
      'source': 'nginx',
      'extensions': ['sea']
    },
    'application/x-sh': {
      'source': 'apache',
      'compressible': true,
      'extensions': ['sh']
    },
    'application/x-shar': {
      'source': 'apache',
      'extensions': ['shar']
    },
    'application/x-shockwave-flash': {
      'source': 'apache',
      'compressible': false,
      'extensions': ['swf']
    },
    'application/x-silverlight-app': {
      'source': 'apache',
      'extensions': ['xap']
    },
    'application/x-sql': {
      'source': 'apache',
      'extensions': ['sql']
    },
    'application/x-stuffit': {
      'source': 'apache',
      'compressible': false,
      'extensions': ['sit']
    },
    'application/x-stuffitx': {
      'source': 'apache',
      'extensions': ['sitx']
    },
    'application/x-subrip': {
      'source': 'apache',
      'extensions': ['srt']
    },
    'application/x-sv4cpio': {
      'source': 'apache',
      'extensions': ['sv4cpio']
    },
    'application/x-sv4crc': {
      'source': 'apache',
      'extensions': ['sv4crc']
    },
    'application/x-t3vm-image': {
      'source': 'apache',
      'extensions': ['t3']
    },
    'application/x-tads': {
      'source': 'apache',
      'extensions': ['gam']
    },
    'application/x-tar': {
      'source': 'apache',
      'compressible': true,
      'extensions': ['tar']
    },
    'application/x-tcl': {
      'source': 'apache',
      'extensions': ['tcl', 'tk']
    },
    'application/x-tex': {
      'source': 'apache',
      'extensions': ['tex']
    },
    'application/x-tex-tfm': {
      'source': 'apache',
      'extensions': ['tfm']
    },
    'application/x-texinfo': {
      'source': 'apache',
      'extensions': ['texinfo', 'texi']
    },
    'application/x-tgif': {
      'source': 'apache',
      'extensions': ['obj']
    },
    'application/x-ustar': {
      'source': 'apache',
      'extensions': ['ustar']
    },
    'application/x-wais-source': {
      'source': 'apache',
      'extensions': ['src']
    },
    'application/x-web-app-manifest+json': {
      'compressible': true,
      'extensions': ['webapp']
    },
    'application/x-www-form-urlencoded': {
      'source': 'iana',
      'compressible': true
    },
    'application/x-x509-ca-cert': {
      'source': 'apache',
      'extensions': ['der', 'crt', 'pem']
    },
    'application/x-xfig': {
      'source': 'apache',
      'extensions': ['fig']
    },
    'application/x-xliff+xml': {
      'source': 'apache',
      'extensions': ['xlf']
    },
    'application/x-xpinstall': {
      'source': 'apache',
      'compressible': false,
      'extensions': ['xpi']
    },
    'application/x-xz': {
      'source': 'apache',
      'extensions': ['xz']
    },
    'application/x-zmachine': {
      'source': 'apache',
      'extensions': ['z1', 'z2', 'z3', 'z4', 'z5', 'z6', 'z7', 'z8']
    },
    'application/x400-bp': {
      'source': 'iana'
    },
    'application/xacml+xml': {
      'source': 'iana'
    },
    'application/xaml+xml': {
      'source': 'apache',
      'extensions': ['xaml']
    },
    'application/xcap-att+xml': {
      'source': 'iana'
    },
    'application/xcap-caps+xml': {
      'source': 'iana'
    },
    'application/xcap-diff+xml': {
      'source': 'iana',
      'extensions': ['xdf']
    },
    'application/xcap-el+xml': {
      'source': 'iana'
    },
    'application/xcap-error+xml': {
      'source': 'iana'
    },
    'application/xcap-ns+xml': {
      'source': 'iana'
    },
    'application/xcon-conference-info+xml': {
      'source': 'iana'
    },
    'application/xcon-conference-info-diff+xml': {
      'source': 'iana'
    },
    'application/xenc+xml': {
      'source': 'iana',
      'extensions': ['xenc']
    },
    'application/xhtml+xml': {
      'source': 'iana',
      'compressible': true,
      'extensions': ['xhtml', 'xht']
    },
    'application/xhtml-voice+xml': {
      'source': 'apache'
    },
    'application/xml': {
      'name': 'XML',
      'source': 'iana',
      'compressible': true,
      'extensions': ['xml', 'xsl', 'xsd', 'rng']
    },
    'application/xml-dtd': {
      'source': 'iana',
      'compressible': true,
      'extensions': ['dtd']
    },
    'application/xml-external-parsed-entity': {
      'source': 'iana'
    },
    'application/xml-patch+xml': {
      'source': 'iana'
    },
    'application/xmpp+xml': {
      'source': 'iana'
    },
    'application/xop+xml': {
      'source': 'iana',
      'compressible': true,
      'extensions': ['xop']
    },
    'application/xproc+xml': {
      'source': 'apache',
      'extensions': ['xpl']
    },
    'application/xslt+xml': {
      'source': 'iana',
      'extensions': ['xslt']
    },
    'application/xspf+xml': {
      'source': 'apache',
      'extensions': ['xspf']
    },
    'application/xv+xml': {
      'source': 'iana',
      'extensions': ['mxml', 'xhvml', 'xvml', 'xvm']
    },
    'application/yang': {
      'source': 'iana',
      'extensions': ['yang']
    },
    'application/yin+xml': {
      'source': 'iana',
      'extensions': ['yin']
    },
    'application/zip': {
      'source': 'iana',
      'compressible': false,
      'extensions': ['zip']
    },
    'application/zlib': {
      'source': 'iana'
    },
    'audio/1d-interleaved-parityfec': {
      'source': 'iana'
    },
    'audio/32kadpcm': {
      'source': 'iana'
    },
    'audio/3gpp': {
      'source': 'iana',
      'compressible': false,
      'extensions': ['3gpp']
    },
    'audio/3gpp2': {
      'source': 'iana'
    },
    'audio/ac3': {
      'source': 'iana'
    },
    'audio/adpcm': {
      'source': 'apache',
      'extensions': ['adp']
    },
    'audio/amr': {
      'source': 'iana'
    },
    'audio/amr-wb': {
      'source': 'iana'
    },
    'audio/amr-wb+': {
      'source': 'iana'
    },
    'audio/aptx': {
      'source': 'iana'
    },
    'audio/asc': {
      'source': 'iana'
    },
    'audio/atrac-advanced-lossless': {
      'source': 'iana'
    },
    'audio/atrac-x': {
      'source': 'iana'
    },
    'audio/atrac3': {
      'source': 'iana'
    },
    'audio/basic': {
      'source': 'iana',
      'compressible': false,
      'extensions': ['au', 'snd']
    },
    'audio/bv16': {
      'source': 'iana'
    },
    'audio/bv32': {
      'source': 'iana'
    },
    'audio/clearmode': {
      'source': 'iana'
    },
    'audio/cn': {
      'source': 'iana'
    },
    'audio/dat12': {
      'source': 'iana'
    },
    'audio/dls': {
      'source': 'iana'
    },
    'audio/dsr-es201108': {
      'source': 'iana'
    },
    'audio/dsr-es202050': {
      'source': 'iana'
    },
    'audio/dsr-es202211': {
      'source': 'iana'
    },
    'audio/dsr-es202212': {
      'source': 'iana'
    },
    'audio/dv': {
      'source': 'iana'
    },
    'audio/dvi4': {
      'source': 'iana'
    },
    'audio/eac3': {
      'source': 'iana'
    },
    'audio/encaprtp': {
      'source': 'iana'
    },
    'audio/evrc': {
      'source': 'iana'
    },
    'audio/evrc-qcp': {
      'source': 'iana'
    },
    'audio/evrc0': {
      'source': 'iana'
    },
    'audio/evrc1': {
      'source': 'iana'
    },
    'audio/evrcb': {
      'source': 'iana'
    },
    'audio/evrcb0': {
      'source': 'iana'
    },
    'audio/evrcb1': {
      'source': 'iana'
    },
    'audio/evrcnw': {
      'source': 'iana'
    },
    'audio/evrcnw0': {
      'source': 'iana'
    },
    'audio/evrcnw1': {
      'source': 'iana'
    },
    'audio/evrcwb': {
      'source': 'iana'
    },
    'audio/evrcwb0': {
      'source': 'iana'
    },
    'audio/evrcwb1': {
      'source': 'iana'
    },
    'audio/evs': {
      'source': 'iana'
    },
    'audio/fwdred': {
      'source': 'iana'
    },
    'audio/g711-0': {
      'source': 'iana'
    },
    'audio/g719': {
      'source': 'iana'
    },
    'audio/g722': {
      'source': 'iana'
    },
    'audio/g7221': {
      'source': 'iana'
    },
    'audio/g723': {
      'source': 'iana'
    },
    'audio/g726-16': {
      'source': 'iana'
    },
    'audio/g726-24': {
      'source': 'iana'
    },
    'audio/g726-32': {
      'source': 'iana'
    },
    'audio/g726-40': {
      'source': 'iana'
    },
    'audio/g728': {
      'source': 'iana'
    },
    'audio/g729': {
      'source': 'iana'
    },
    'audio/g7291': {
      'source': 'iana'
    },
    'audio/g729d': {
      'source': 'iana'
    },
    'audio/g729e': {
      'source': 'iana'
    },
    'audio/gsm': {
      'source': 'iana'
    },
    'audio/gsm-efr': {
      'source': 'iana'
    },
    'audio/gsm-hr-08': {
      'source': 'iana'
    },
    'audio/ilbc': {
      'source': 'iana'
    },
    'audio/ip-mr_v2.5': {
      'source': 'iana'
    },
    'audio/isac': {
      'source': 'apache'
    },
    'audio/l16': {
      'source': 'iana'
    },
    'audio/l20': {
      'source': 'iana'
    },
    'audio/l24': {
      'source': 'iana',
      'compressible': false
    },
    'audio/l8': {
      'source': 'iana'
    },
    'audio/lpc': {
      'source': 'iana'
    },
    'audio/midi': {
      'source': 'apache',
      'extensions': ['mid', 'midi', 'kar', 'rmi']
    },
    'audio/mobile-xmf': {
      'source': 'iana'
    },
    'audio/mp4': {
      'source': 'iana',
      'compressible': false,
      'extensions': ['m4a', 'mp4a']
    },
    'audio/mp4a-latm': {
      'source': 'iana'
    },
    'audio/mpa': {
      'source': 'iana'
    },
    'audio/mpa-robust': {
      'source': 'iana'
    },
    'audio/mpeg': {
      'source': 'iana',
      'compressible': false,
      'extensions': ['mpga', 'mp2', 'mp2a', 'mp3', 'm2a', 'm3a']
    },
    'audio/mpeg4-generic': {
      'source': 'iana'
    },
    'audio/musepack': {
      'source': 'apache'
    },
    'audio/ogg': {
      'source': 'iana',
      'compressible': false,
      'extensions': ['oga', 'ogg', 'spx']
    },
    'audio/opus': {
      'source': 'iana'
    },
    'audio/parityfec': {
      'source': 'iana'
    },
    'audio/pcma': {
      'source': 'iana'
    },
    'audio/pcma-wb': {
      'source': 'iana'
    },
    'audio/pcmu': {
      'source': 'iana'
    },
    'audio/pcmu-wb': {
      'source': 'iana'
    },
    'audio/prs.sid': {
      'source': 'iana'
    },
    'audio/qcelp': {
      'source': 'iana'
    },
    'audio/raptorfec': {
      'source': 'iana'
    },
    'audio/red': {
      'source': 'iana'
    },
    'audio/rtp-enc-aescm128': {
      'source': 'iana'
    },
    'audio/rtp-midi': {
      'source': 'iana'
    },
    'audio/rtploopback': {
      'source': 'iana'
    },
    'audio/rtx': {
      'source': 'iana'
    },
    'audio/s3m': {
      'source': 'apache',
      'extensions': ['s3m']
    },
    'audio/silk': {
      'source': 'apache',
      'extensions': ['sil']
    },
    'audio/smv': {
      'source': 'iana'
    },
    'audio/smv-qcp': {
      'source': 'iana'
    },
    'audio/smv0': {
      'source': 'iana'
    },
    'audio/sp-midi': {
      'source': 'iana'
    },
    'audio/speex': {
      'source': 'iana'
    },
    'audio/t140c': {
      'source': 'iana'
    },
    'audio/t38': {
      'source': 'iana'
    },
    'audio/telephone-event': {
      'source': 'iana'
    },
    'audio/tone': {
      'source': 'iana'
    },
    'audio/uemclip': {
      'source': 'iana'
    },
    'audio/ulpfec': {
      'source': 'iana'
    },
    'audio/vdvi': {
      'source': 'iana'
    },
    'audio/vmr-wb': {
      'source': 'iana'
    },
    'audio/vnd.3gpp.iufp': {
      'source': 'iana'
    },
    'audio/vnd.4sb': {
      'source': 'iana'
    },
    'audio/vnd.audiokoz': {
      'source': 'iana'
    },
    'audio/vnd.celp': {
      'source': 'iana'
    },
    'audio/vnd.cisco.nse': {
      'source': 'iana'
    },
    'audio/vnd.cmles.radio-events': {
      'source': 'iana'
    },
    'audio/vnd.cns.anp1': {
      'source': 'iana'
    },
    'audio/vnd.cns.inf1': {
      'source': 'iana'
    },
    'audio/vnd.dece.audio': {
      'source': 'iana',
      'extensions': ['uva', 'uvva']
    },
    'audio/vnd.digital-winds': {
      'source': 'iana',
      'extensions': ['eol']
    },
    'audio/vnd.dlna.adts': {
      'source': 'iana'
    },
    'audio/vnd.dolby.heaac.1': {
      'source': 'iana'
    },
    'audio/vnd.dolby.heaac.2': {
      'source': 'iana'
    },
    'audio/vnd.dolby.mlp': {
      'source': 'iana'
    },
    'audio/vnd.dolby.mps': {
      'source': 'iana'
    },
    'audio/vnd.dolby.pl2': {
      'source': 'iana'
    },
    'audio/vnd.dolby.pl2x': {
      'source': 'iana'
    },
    'audio/vnd.dolby.pl2z': {
      'source': 'iana'
    },
    'audio/vnd.dolby.pulse.1': {
      'source': 'iana'
    },
    'audio/vnd.dra': {
      'source': 'iana',
      'extensions': ['dra']
    },
    'audio/vnd.dts': {
      'source': 'iana',
      'extensions': ['dts']
    },
    'audio/vnd.dts.hd': {
      'source': 'iana',
      'extensions': ['dtshd']
    },
    'audio/vnd.dvb.file': {
      'source': 'iana'
    },
    'audio/vnd.everad.plj': {
      'source': 'iana'
    },
    'audio/vnd.hns.audio': {
      'source': 'iana'
    },
    'audio/vnd.lucent.voice': {
      'source': 'iana',
      'extensions': ['lvp']
    },
    'audio/vnd.ms-playready.media.pya': {
      'source': 'iana',
      'extensions': ['pya']
    },
    'audio/vnd.nokia.mobile-xmf': {
      'source': 'iana'
    },
    'audio/vnd.nortel.vbk': {
      'source': 'iana'
    },
    'audio/vnd.nuera.ecelp4800': {
      'source': 'iana',
      'extensions': ['ecelp4800']
    },
    'audio/vnd.nuera.ecelp7470': {
      'source': 'iana',
      'extensions': ['ecelp7470']
    },
    'audio/vnd.nuera.ecelp9600': {
      'source': 'iana',
      'extensions': ['ecelp9600']
    },
    'audio/vnd.octel.sbc': {
      'source': 'iana'
    },
    'audio/vnd.qcelp': {
      'source': 'iana'
    },
    'audio/vnd.rhetorex.32kadpcm': {
      'source': 'iana'
    },
    'audio/vnd.rip': {
      'source': 'iana',
      'extensions': ['rip']
    },
    'audio/vnd.rn-realaudio': {
      'compressible': false
    },
    'audio/vnd.sealedmedia.softseal.mpeg': {
      'source': 'iana'
    },
    'audio/vnd.vmx.cvsd': {
      'source': 'iana'
    },
    'audio/vnd.wave': {
      'compressible': false
    },
    'audio/vorbis': {
      'source': 'iana',
      'compressible': false
    },
    'audio/vorbis-config': {
      'source': 'iana'
    },
    'audio/wav': {
      'compressible': false,
      'extensions': ['wav']
    },
    'audio/wave': {
      'compressible': false,
      'extensions': ['wav']
    },
    'audio/webm': {
      'source': 'apache',
      'compressible': false,
      'extensions': ['weba']
    },
    'audio/x-aac': {
      'source': 'apache',
      'compressible': false,
      'extensions': ['aac']
    },
    'audio/x-aiff': {
      'source': 'apache',
      'extensions': ['aif', 'aiff', 'aifc']
    },
    'audio/x-caf': {
      'source': 'apache',
      'compressible': false,
      'extensions': ['caf']
    },
    'audio/x-flac': {
      'source': 'apache',
      'extensions': ['flac']
    },
    'audio/x-m4a': {
      'source': 'nginx',
      'extensions': ['m4a']
    },
    'audio/x-matroska': {
      'source': 'apache',
      'extensions': ['mka']
    },
    'audio/x-mpegurl': {
      'source': 'apache',
      'extensions': ['m3u']
    },
    'audio/x-ms-wax': {
      'source': 'apache',
      'extensions': ['wax']
    },
    'audio/x-ms-wma': {
      'source': 'apache',
      'extensions': ['wma']
    },
    'audio/x-pn-realaudio': {
      'source': 'apache',
      'extensions': ['ram', 'ra']
    },
    'audio/x-pn-realaudio-plugin': {
      'source': 'apache',
      'extensions': ['rmp']
    },
    'audio/x-realaudio': {
      'source': 'nginx',
      'extensions': ['ra']
    },
    'audio/x-tta': {
      'source': 'apache'
    },
    'audio/x-wav': {
      'source': 'apache',
      'extensions': ['wav']
    },
    'audio/xm': {
      'source': 'apache',
      'extensions': ['xm']
    },
    'chemical/x-cdx': {
      'source': 'apache',
      'extensions': ['cdx']
    },
    'chemical/x-cif': {
      'source': 'apache',
      'extensions': ['cif']
    },
    'chemical/x-cmdf': {
      'source': 'apache',
      'extensions': ['cmdf']
    },
    'chemical/x-cml': {
      'source': 'apache',
      'extensions': ['cml']
    },
    'chemical/x-csml': {
      'source': 'apache',
      'extensions': ['csml']
    },
    'chemical/x-pdb': {
      'source': 'apache'
    },
    'chemical/x-xyz': {
      'source': 'apache',
      'extensions': ['xyz']
    },
    'font/opentype': {
      'compressible': true,
      'extensions': ['otf']
    },
    'image/bmp': {
      'name': 'BMP',
      'source': 'apache',
      'compressible': true,
      'extensions': ['bmp']
    },
    'image/cgm': {
      'source': 'iana',
      'extensions': ['cgm']
    },
    'image/fits': {
      'source': 'iana'
    },
    'image/g3fax': {
      'source': 'iana',
      'extensions': ['g3']
    },
    'image/gif': {
      'name': 'GIF',
      'source': 'iana',
      'compressible': false,
      'extensions': ['gif']
    },
    'image/ief': {
      'source': 'iana',
      'extensions': ['ief']
    },
    'image/jp2': {
      'source': 'iana'
    },
    'image/jpeg': {
      'name': 'JPG',
      'source': 'iana',
      'compressible': false,
      'extensions': ['jpeg', 'jpg', 'jpe']
    },
    'image/jpm': {
      'source': 'iana'
    },
    'image/jpx': {
      'source': 'iana'
    },
    'image/ktx': {
      'source': 'iana',
      'extensions': ['ktx']
    },
    'image/naplps': {
      'source': 'iana'
    },
    'image/pjpeg': {
      'compressible': false
    },
    'image/png': {
      'name': 'PNG',
      'source': 'iana',
      'compressible': false,
      'extensions': ['png']
    },
    'image/prs.btif': {
      'source': 'iana',
      'extensions': ['btif']
    },
    'image/prs.pti': {
      'source': 'iana'
    },
    'image/pwg-raster': {
      'source': 'iana'
    },
    'image/sgi': {
      'source': 'apache',
      'extensions': ['sgi']
    },
    'image/svg+xml': {
      'source': 'iana',
      'compressible': true,
      'extensions': ['svg', 'svgz']
    },
    'image/t38': {
      'source': 'iana'
    },
    'image/tiff': {
      'name': 'TIFF',
      'source': 'iana',
      'compressible': false,
      'extensions': ['tiff', 'tif']
    },
    'image/tiff-fx': {
      'source': 'iana'
    },
    'image/vnd.adobe.photoshop': {
      'source': 'iana',
      'compressible': true,
      'extensions': ['psd']
    },
    'image/vnd.airzip.accelerator.azv': {
      'source': 'iana'
    },
    'image/vnd.cns.inf2': {
      'source': 'iana'
    },
    'image/vnd.dece.graphic': {
      'source': 'iana',
      'extensions': ['uvi', 'uvvi', 'uvg', 'uvvg']
    },
    'image/vnd.djvu': {
      'source': 'iana',
      'extensions': ['djvu', 'djv']
    },
    'image/vnd.dvb.subtitle': {
      'source': 'iana',
      'extensions': ['sub']
    },
    'image/vnd.dwg': {
      'source': 'iana',
      'extensions': ['dwg']
    },
    'image/vnd.dxf': {
      'source': 'iana',
      'extensions': ['dxf']
    },
    'image/vnd.fastbidsheet': {
      'source': 'iana',
      'extensions': ['fbs']
    },
    'image/vnd.fpx': {
      'source': 'iana',
      'extensions': ['fpx']
    },
    'image/vnd.fst': {
      'source': 'iana',
      'extensions': ['fst']
    },
    'image/vnd.fujixerox.edmics-mmr': {
      'source': 'iana',
      'extensions': ['mmr']
    },
    'image/vnd.fujixerox.edmics-rlc': {
      'source': 'iana',
      'extensions': ['rlc']
    },
    'image/vnd.globalgraphics.pgb': {
      'source': 'iana'
    },
    'image/vnd.microsoft.icon': {
      'source': 'iana'
    },
    'image/vnd.mix': {
      'source': 'iana'
    },
    'image/vnd.mozilla.apng': {
      'source': 'iana'
    },
    'image/vnd.ms-modi': {
      'source': 'iana',
      'extensions': ['mdi']
    },
    'image/vnd.ms-photo': {
      'source': 'apache',
      'extensions': ['wdp']
    },
    'image/vnd.net-fpx': {
      'source': 'iana',
      'extensions': ['npx']
    },
    'image/vnd.radiance': {
      'source': 'iana'
    },
    'image/vnd.sealed.png': {
      'source': 'iana'
    },
    'image/vnd.sealedmedia.softseal.gif': {
      'source': 'iana'
    },
    'image/vnd.sealedmedia.softseal.jpg': {
      'source': 'iana'
    },
    'image/vnd.svf': {
      'source': 'iana'
    },
    'image/vnd.tencent.tap': {
      'source': 'iana'
    },
    'image/vnd.valve.source.texture': {
      'source': 'iana'
    },
    'image/vnd.wap.wbmp': {
      'source': 'iana',
      'extensions': ['wbmp']
    },
    'image/vnd.xiff': {
      'source': 'iana',
      'extensions': ['xif']
    },
    'image/vnd.zbrush.pcx': {
      'source': 'iana'
    },
    'image/webp': {
      'source': 'apache',
      'extensions': ['webp']
    },
    'image/x-3ds': {
      'source': 'apache',
      'extensions': ['3ds']
    },
    'image/x-cmu-raster': {
      'source': 'apache',
      'extensions': ['ras']
    },
    'image/x-cmx': {
      'source': 'apache',
      'extensions': ['cmx']
    },
    'image/x-freehand': {
      'source': 'apache',
      'extensions': ['fh', 'fhc', 'fh4', 'fh5', 'fh7']
    },
    'image/x-icon': {
      'source': 'apache',
      'compressible': true,
      'extensions': ['ico']
    },
    'image/x-jng': {
      'source': 'nginx',
      'extensions': ['jng']
    },
    'image/x-mrsid-image': {
      'source': 'apache',
      'extensions': ['sid']
    },
    'image/x-ms-bmp': {
      'source': 'nginx',
      'compressible': true,
      'extensions': ['bmp']
    },
    'image/x-pcx': {
      'source': 'apache',
      'extensions': ['pcx']
    },
    'image/x-pict': {
      'source': 'apache',
      'extensions': ['pic', 'pct']
    },
    'image/x-portable-anymap': {
      'source': 'apache',
      'extensions': ['pnm']
    },
    'image/x-portable-bitmap': {
      'source': 'apache',
      'extensions': ['pbm']
    },
    'image/x-portable-graymap': {
      'source': 'apache',
      'extensions': ['pgm']
    },
    'image/x-portable-pixmap': {
      'source': 'apache',
      'extensions': ['ppm']
    },
    'image/x-rgb': {
      'source': 'apache',
      'extensions': ['rgb']
    },
    'image/x-tga': {
      'source': 'apache',
      'extensions': ['tga']
    },
    'image/x-xbitmap': {
      'source': 'apache',
      'extensions': ['xbm']
    },
    'image/x-xcf': {
      'compressible': false
    },
    'image/x-xpixmap': {
      'source': 'apache',
      'extensions': ['xpm']
    },
    'image/x-xwindowdump': {
      'source': 'apache',
      'extensions': ['xwd']
    },
    'message/cpim': {
      'source': 'iana'
    },
    'message/delivery-status': {
      'source': 'iana'
    },
    'message/disposition-notification': {
      'source': 'iana'
    },
    'message/external-body': {
      'source': 'iana'
    },
    'message/feedback-report': {
      'source': 'iana'
    },
    'message/global': {
      'source': 'iana'
    },
    'message/global-delivery-status': {
      'source': 'iana'
    },
    'message/global-disposition-notification': {
      'source': 'iana'
    },
    'message/global-headers': {
      'source': 'iana'
    },
    'message/http': {
      'source': 'iana',
      'compressible': false
    },
    'message/imdn+xml': {
      'source': 'iana',
      'compressible': true
    },
    'message/news': {
      'source': 'iana'
    },
    'message/partial': {
      'source': 'iana',
      'compressible': false
    },
    'message/rfc822': {
      'source': 'iana',
      'compressible': true,
      'extensions': ['eml', 'mime']
    },
    'message/s-http': {
      'source': 'iana'
    },
    'message/sip': {
      'source': 'iana'
    },
    'message/sipfrag': {
      'source': 'iana'
    },
    'message/tracking-status': {
      'source': 'iana'
    },
    'message/vnd.si.simp': {
      'source': 'iana'
    },
    'message/vnd.wfa.wsc': {
      'source': 'iana'
    },
    'model/iges': {
      'source': 'iana',
      'compressible': false,
      'extensions': ['igs', 'iges']
    },
    'model/mesh': {
      'source': 'iana',
      'compressible': false,
      'extensions': ['msh', 'mesh', 'silo']
    },
    'model/vnd.collada+xml': {
      'source': 'iana',
      'extensions': ['dae']
    },
    'model/vnd.dwf': {
      'source': 'iana',
      'extensions': ['dwf']
    },
    'model/vnd.flatland.3dml': {
      'source': 'iana'
    },
    'model/vnd.gdl': {
      'source': 'iana',
      'extensions': ['gdl']
    },
    'model/vnd.gs-gdl': {
      'source': 'apache'
    },
    'model/vnd.gs.gdl': {
      'source': 'iana'
    },
    'model/vnd.gtw': {
      'source': 'iana',
      'extensions': ['gtw']
    },
    'model/vnd.moml+xml': {
      'source': 'iana'
    },
    'model/vnd.mts': {
      'source': 'iana',
      'extensions': ['mts']
    },
    'model/vnd.opengex': {
      'source': 'iana'
    },
    'model/vnd.parasolid.transmit.binary': {
      'source': 'iana'
    },
    'model/vnd.parasolid.transmit.text': {
      'source': 'iana'
    },
    'model/vnd.rosette.annotated-data-model': {
      'source': 'iana'
    },
    'model/vnd.valve.source.compiled-map': {
      'source': 'iana'
    },
    'model/vnd.vtu': {
      'source': 'iana',
      'extensions': ['vtu']
    },
    'model/vrml': {
      'source': 'iana',
      'compressible': false,
      'extensions': ['wrl', 'vrml']
    },
    'model/x3d+binary': {
      'source': 'apache',
      'compressible': false,
      'extensions': ['x3db', 'x3dbz']
    },
    'model/x3d+fastinfoset': {
      'source': 'iana'
    },
    'model/x3d+vrml': {
      'source': 'apache',
      'compressible': false,
      'extensions': ['x3dv', 'x3dvz']
    },
    'model/x3d+xml': {
      'source': 'iana',
      'compressible': true,
      'extensions': ['x3d', 'x3dz']
    },
    'model/x3d-vrml': {
      'source': 'iana'
    },
    'multipart/alternative': {
      'source': 'iana',
      'compressible': false
    },
    'multipart/appledouble': {
      'source': 'iana'
    },
    'multipart/byteranges': {
      'source': 'iana'
    },
    'multipart/digest': {
      'source': 'iana'
    },
    'multipart/encrypted': {
      'source': 'iana',
      'compressible': false
    },
    'multipart/form-data': {
      'source': 'iana',
      'compressible': false
    },
    'multipart/header-set': {
      'source': 'iana'
    },
    'multipart/mixed': {
      'source': 'iana',
      'compressible': false
    },
    'multipart/parallel': {
      'source': 'iana'
    },
    'multipart/related': {
      'source': 'iana',
      'compressible': false
    },
    'multipart/report': {
      'source': 'iana'
    },
    'multipart/signed': {
      'source': 'iana',
      'compressible': false
    },
    'multipart/voice-message': {
      'source': 'iana'
    },
    'multipart/x-mixed-replace': {
      'source': 'iana'
    },
    'text/1d-interleaved-parityfec': {
      'source': 'iana'
    },
    'text/cache-manifest': {
      'source': 'iana',
      'compressible': true,
      'extensions': ['appcache', 'manifest']
    },
    'text/calendar': {
      'source': 'iana',
      'extensions': ['ics', 'ifb']
    },
    'text/calender': {
      'compressible': true
    },
    'text/cmd': {
      'compressible': true
    },
    'text/coffeescript': {
      'extensions': ['coffee', 'litcoffee']
    },
    'text/css': {
      'name': 'CSS',
      'source': 'iana',
      'compressible': true,
      'extensions': ['css']
    },
    'text/csv': {
      'name': 'CSV',
      'source': 'iana',
      'compressible': true,
      'extensions': ['csv']
    },
    'text/csv-schema': {
      'source': 'iana'
    },
    'text/directory': {
      'source': 'iana'
    },
    'text/dns': {
      'source': 'iana'
    },
    'text/ecmascript': {
      'source': 'iana'
    },
    'text/encaprtp': {
      'source': 'iana'
    },
    'text/enriched': {
      'source': 'iana'
    },
    'text/fwdred': {
      'source': 'iana'
    },
    'text/grammar-ref-list': {
      'source': 'iana'
    },
    'text/hjson': {
      'extensions': ['hjson']
    },
    'text/html': {
      'name': 'HTML',
      'source': 'iana',
      'compressible': true,
      'extensions': ['html', 'htm', 'shtml']
    },
    'text/jade': {
      'extensions': ['jade']
    },
    'text/javascript': {
      'source': 'iana',
      'compressible': true
    },
    'text/jcr-cnd': {
      'source': 'iana'
    },
    'text/jsx': {
      'compressible': true,
      'extensions': ['jsx']
    },
    'text/less': {
      'extensions': ['less']
    },
    'text/markdown': {
      'source': 'iana'
    },
    'text/mathml': {
      'source': 'nginx',
      'extensions': ['mml']
    },
    'text/mizar': {
      'source': 'iana'
    },
    'text/n3': {
      'source': 'iana',
      'compressible': true,
      'extensions': ['n3']
    },
    'text/parameters': {
      'source': 'iana'
    },
    'text/parityfec': {
      'source': 'iana'
    },
    'text/plain': {
      'name': 'Plain Text',
      'source': 'iana',
      'compressible': true,
      'extensions': ['txt', 'text', 'conf', 'def', 'list', 'log', 'in', 'ini']
    },
    'text/provenance-notation': {
      'source': 'iana'
    },
    'text/prs.fallenstein.rst': {
      'source': 'iana'
    },
    'text/prs.lines.tag': {
      'source': 'iana',
      'extensions': ['dsc']
    },
    'text/prs.prop.logic': {
      'source': 'iana'
    },
    'text/raptorfec': {
      'source': 'iana'
    },
    'text/red': {
      'source': 'iana'
    },
    'text/rfc822-headers': {
      'source': 'iana'
    },
    'text/richtext': {
      'source': 'iana',
      'compressible': true,
      'extensions': ['rtx']
    },
    'text/rtf': {
      'source': 'iana',
      'compressible': true,
      'extensions': ['rtf']
    },
    'text/rtp-enc-aescm128': {
      'source': 'iana'
    },
    'text/rtploopback': {
      'source': 'iana'
    },
    'text/rtx': {
      'source': 'iana'
    },
    'text/sgml': {
      'source': 'iana',
      'extensions': ['sgml', 'sgm']
    },
    'text/slim': {
      'extensions': ['slim', 'slm']
    },
    'text/stylus': {
      'extensions': ['stylus', 'styl']
    },
    'text/t140': {
      'source': 'iana'
    },
    'text/tab-separated-values': {
      'source': 'iana',
      'compressible': true,
      'extensions': ['tsv']
    },
    'text/troff': {
      'source': 'iana',
      'extensions': ['t', 'tr', 'roff', 'man', 'me', 'ms']
    },
    'text/turtle': {
      'source': 'iana',
      'extensions': ['ttl']
    },
    'text/ulpfec': {
      'source': 'iana'
    },
    'text/uri-list': {
      'source': 'iana',
      'compressible': true,
      'extensions': ['uri', 'uris', 'urls']
    },
    'text/vcard': {
      'source': 'iana',
      'compressible': true,
      'extensions': ['vcard']
    },
    'text/vnd.a': {
      'source': 'iana'
    },
    'text/vnd.abc': {
      'source': 'iana'
    },
    'text/vnd.curl': {
      'source': 'iana',
      'extensions': ['curl']
    },
    'text/vnd.curl.dcurl': {
      'source': 'apache',
      'extensions': ['dcurl']
    },
    'text/vnd.curl.mcurl': {
      'source': 'apache',
      'extensions': ['mcurl']
    },
    'text/vnd.curl.scurl': {
      'source': 'apache',
      'extensions': ['scurl']
    },
    'text/vnd.debian.copyright': {
      'source': 'iana'
    },
    'text/vnd.dmclientscript': {
      'source': 'iana'
    },
    'text/vnd.dvb.subtitle': {
      'source': 'iana',
      'extensions': ['sub']
    },
    'text/vnd.esmertec.theme-descriptor': {
      'source': 'iana'
    },
    'text/vnd.fly': {
      'source': 'iana',
      'extensions': ['fly']
    },
    'text/vnd.fmi.flexstor': {
      'source': 'iana',
      'extensions': ['flx']
    },
    'text/vnd.graphviz': {
      'source': 'iana',
      'extensions': ['gv']
    },
    'text/vnd.in3d.3dml': {
      'source': 'iana',
      'extensions': ['3dml']
    },
    'text/vnd.in3d.spot': {
      'source': 'iana',
      'extensions': ['spot']
    },
    'text/vnd.iptc.newsml': {
      'source': 'iana'
    },
    'text/vnd.iptc.nitf': {
      'source': 'iana'
    },
    'text/vnd.latex-z': {
      'source': 'iana'
    },
    'text/vnd.motorola.reflex': {
      'source': 'iana'
    },
    'text/vnd.ms-mediapackage': {
      'source': 'iana'
    },
    'text/vnd.net2phone.commcenter.command': {
      'source': 'iana'
    },
    'text/vnd.radisys.msml-basic-layout': {
      'source': 'iana'
    },
    'text/vnd.si.uricatalogue': {
      'source': 'iana'
    },
    'text/vnd.sun.j2me.app-descriptor': {
      'source': 'iana',
      'extensions': ['jad']
    },
    'text/vnd.trolltech.linguist': {
      'source': 'iana'
    },
    'text/vnd.wap.si': {
      'source': 'iana'
    },
    'text/vnd.wap.sl': {
      'source': 'iana'
    },
    'text/vnd.wap.wml': {
      'source': 'iana',
      'extensions': ['wml']
    },
    'text/vnd.wap.wmlscript': {
      'source': 'iana',
      'extensions': ['wmls']
    },
    'text/vtt': {
      'charset': 'UTF-8',
      'compressible': true,
      'extensions': ['vtt']
    },
    'text/x-asm': {
      'source': 'apache',
      'extensions': ['s', 'asm']
    },
    'text/x-c': {
      'source': 'apache',
      'extensions': ['c', 'cc', 'cxx', 'cpp', 'h', 'hh', 'dic']
    },
    'text/x-component': {
      'source': 'nginx',
      'extensions': ['htc']
    },
    'text/x-fortran': {
      'source': 'apache',
      'extensions': ['f', 'for', 'f77', 'f90']
    },
    'text/x-gwt-rpc': {
      'compressible': true
    },
    'text/x-handlebars-template': {
      'extensions': ['hbs']
    },
    'text/x-java-source': {
      'source': 'apache',
      'extensions': ['java']
    },
    'text/x-jquery-tmpl': {
      'compressible': true
    },
    'text/x-lua': {
      'extensions': ['lua']
    },
    'text/x-markdown': {
      'compressible': true,
      'extensions': ['markdown', 'md', 'mkd']
    },
    'text/x-nfo': {
      'source': 'apache',
      'extensions': ['nfo']
    },
    'text/x-opml': {
      'source': 'apache',
      'extensions': ['opml']
    },
    'text/x-pascal': {
      'source': 'apache',
      'extensions': ['p', 'pas']
    },
    'text/x-processing': {
      'compressible': true,
      'extensions': ['pde']
    },
    'text/x-sass': {
      'extensions': ['sass']
    },
    'text/x-scss': {
      'extensions': ['scss']
    },
    'text/x-setext': {
      'source': 'apache',
      'extensions': ['etx']
    },
    'text/x-sfv': {
      'source': 'apache',
      'extensions': ['sfv']
    },
    'text/x-suse-ymp': {
      'compressible': true,
      'extensions': ['ymp']
    },
    'text/x-uuencode': {
      'source': 'apache',
      'extensions': ['uu']
    },
    'text/x-vcalendar': {
      'source': 'apache',
      'extensions': ['vcs']
    },
    'text/x-vcard': {
      'source': 'apache',
      'extensions': ['vcf']
    },
    'text/xml': {
      'source': 'iana',
      'compressible': true,
      'extensions': ['xml']
    },
    'text/xml-external-parsed-entity': {
      'source': 'iana'
    },
    'text/yaml': {
      'extensions': ['yaml', 'yml']
    },
    'video/1d-interleaved-parityfec': {
      'source': 'apache'
    },
    'video/3gpp': {
      'source': 'apache',
      'extensions': ['3gp', '3gpp']
    },
    'video/3gpp-tt': {
      'source': 'apache'
    },
    'video/3gpp2': {
      'source': 'apache',
      'extensions': ['3g2']
    },
    'video/bmpeg': {
      'source': 'apache'
    },
    'video/bt656': {
      'source': 'apache'
    },
    'video/celb': {
      'source': 'apache'
    },
    'video/dv': {
      'source': 'apache'
    },
    'video/encaprtp': {
      'source': 'apache'
    },
    'video/h261': {
      'source': 'apache',
      'extensions': ['h261']
    },
    'video/h263': {
      'source': 'apache',
      'extensions': ['h263']
    },
    'video/h263-1998': {
      'source': 'apache'
    },
    'video/h263-2000': {
      'source': 'apache'
    },
    'video/h264': {
      'source': 'apache',
      'extensions': ['h264']
    },
    'video/h264-rcdo': {
      'source': 'apache'
    },
    'video/h264-svc': {
      'source': 'apache'
    },
    'video/h265': {
      'source': 'apache'
    },
    'video/iso.segment': {
      'source': 'apache'
    },
    'video/jpeg': {
      'source': 'apache',
      'extensions': ['jpgv']
    },
    'video/jpeg2000': {
      'source': 'apache'
    },
    'video/jpm': {
      'source': 'apache',
      'extensions': ['jpm', 'jpgm']
    },
    'video/mj2': {
      'source': 'apache',
      'extensions': ['mj2', 'mjp2']
    },
    'video/mp1s': {
      'source': 'apache'
    },
    'video/mp2p': {
      'source': 'apache'
    },
    'video/mp2t': {
      'source': 'apache',
      'extensions': ['ts']
    },
    'video/mp4': {
      'name': 'MP4',
      'source': 'apache',
      'compressible': false,
      'extensions': ['mp4', 'mp4v', 'mpg4']
    },
    'video/mp4v-es': {
      'source': 'apache'
    },
    'video/mpeg': {
      'name': 'MPG',
      'source': 'apache',
      'compressible': false,
      'extensions': ['mpeg', 'mpg', 'mpe', 'm1v', 'm2v']
    },
    'video/mpeg4-generic': {
      'source': 'apache'
    },
    'video/mpv': {
      'source': 'apache'
    },
    'video/nv': {
      'source': 'apache'
    },
    'video/ogg': {
      'source': 'apache',
      'compressible': false,
      'extensions': ['ogv']
    },
    'video/parityfec': {
      'source': 'apache'
    },
    'video/pointer': {
      'source': 'apache'
    },
    'video/quicktime': {
      'name': 'Apple Quicktime',
      'source': 'apache',
      'compressible': false,
      'extensions': ['qt', 'mov']
    },
    'video/raptorfec': {
      'source': 'apache'
    },
    'video/raw': {
      'source': 'apache'
    },
    'video/rtp-enc-aescm128': {
      'source': 'apache'
    },
    'video/rtploopback': {
      'source': 'apache'
    },
    'video/rtx': {
      'source': 'apache'
    },
    'video/smpte292m': {
      'source': 'apache'
    },
    'video/ulpfec': {
      'source': 'apache'
    },
    'video/vc1': {
      'source': 'apache'
    },
    'video/vnd.cctv': {
      'source': 'apache'
    },
    'video/vnd.dece.hd': {
      'source': 'apache',
      'extensions': ['uvh', 'uvvh']
    },
    'video/vnd.dece.mobile': {
      'source': 'apache',
      'extensions': ['uvm', 'uvvm']
    },
    'video/vnd.dece.mp4': {
      'source': 'apache'
    },
    'video/vnd.dece.pd': {
      'source': 'apache',
      'extensions': ['uvp', 'uvvp']
    },
    'video/vnd.dece.sd': {
      'source': 'apache',
      'extensions': ['uvs', 'uvvs']
    },
    'video/vnd.dece.video': {
      'source': 'apache',
      'extensions': ['uvv', 'uvvv']
    },
    'video/vnd.directv.mpeg': {
      'source': 'apache'
    },
    'video/vnd.directv.mpeg-tts': {
      'source': 'apache'
    },
    'video/vnd.dlna.mpeg-tts': {
      'source': 'apache'
    },
    'video/vnd.dvb.file': {
      'source': 'apache',
      'extensions': ['dvb']
    },
    'video/vnd.fvt': {
      'source': 'apache',
      'extensions': ['fvt']
    },
    'video/vnd.hns.video': {
      'source': 'apache'
    },
    'video/vnd.iptvforum.1dparityfec-1010': {
      'source': 'apache'
    },
    'video/vnd.iptvforum.1dparityfec-2005': {
      'source': 'apache'
    },
    'video/vnd.iptvforum.2dparityfec-1010': {
      'source': 'apache'
    },
    'video/vnd.iptvforum.2dparityfec-2005': {
      'source': 'apache'
    },
    'video/vnd.iptvforum.ttsavc': {
      'source': 'apache'
    },
    'video/vnd.iptvforum.ttsmpeg2': {
      'source': 'apache'
    },
    'video/vnd.motorola.video': {
      'source': 'apache'
    },
    'video/vnd.motorola.videop': {
      'source': 'apache'
    },
    'video/vnd.mpegurl': {
      'source': 'apache',
      'extensions': ['mxu', 'm4u']
    },
    'video/vnd.ms-playready.media.pyv': {
      'source': 'apache',
      'extensions': ['pyv']
    },
    'video/vnd.nokia.interleaved-multimedia': {
      'source': 'apache'
    },
    'video/vnd.nokia.videovoip': {
      'source': 'apache'
    },
    'video/vnd.objectvideo': {
      'source': 'apache'
    },
    'video/vnd.radgamettools.bink': {
      'source': 'apache'
    },
    'video/vnd.radgamettools.smacker': {
      'source': 'apache'
    },
    'video/vnd.sealed.mpeg1': {
      'source': 'apache'
    },
    'video/vnd.sealed.mpeg4': {
      'source': 'apache'
    },
    'video/vnd.sealed.swf': {
      'source': 'apache'
    },
    'video/vnd.sealedmedia.softseal.mov': {
      'source': 'apache'
    },
    'video/vnd.uvvu.mp4': {
      'source': 'apache',
      'extensions': ['uvu', 'uvvu']
    },
    'video/vnd.vivo': {
      'source': 'apache',
      'extensions': ['viv']
    },
    'video/vp8': {
      'source': 'apache'
    },
    'video/webm': {
      'name': 'WEBM',
      'source': 'apache',
      'compressible': false,
      'extensions': ['webm']
    },
    'video/x-f4v': {
      'source': 'apache',
      'extensions': ['f4v']
    },
    'video/x-fli': {
      'source': 'apache',
      'extensions': ['fli']
    },
    'video/x-flv': {
      'source': 'apache',
      'compressible': false,
      'extensions': ['flv']
    },
    'video/x-m4v': {
      'source': 'apache',
      'extensions': ['m4v']
    },
    'video/x-matroska': {
      'source': 'apache',
      'compressible': false,
      'extensions': ['mkv', 'mk3d', 'mks']
    },
    'video/x-mng': {
      'source': 'apache',
      'extensions': ['mng']
    },
    'video/x-ms-asf': {
      'source': 'apache',
      'extensions': ['asf', 'asx']
    },
    'video/x-ms-vob': {
      'source': 'apache',
      'extensions': ['vob']
    },
    'video/x-ms-wm': {
      'source': 'apache',
      'extensions': ['wm']
    },
    'video/x-ms-wmv': {
      'source': 'apache',
      'compressible': false,
      'extensions': ['wmv']
    },
    'video/x-ms-wmx': {
      'source': 'apache',
      'extensions': ['wmx']
    },
    'video/x-ms-wvx': {
      'source': 'apache',
      'extensions': ['wvx']
    },
    'video/x-msvideo': {
      'name': 'AVI',
      'source': 'apache',
      'extensions': ['avi']
    },
    'video/x-sgi-movie': {
      'source': 'apache',
      'extensions': ['movie']
    },
    'video/x-smv': {
      'source': 'apache',
      'extensions': ['smv']
    },
    'x-conference/x-cooltalk': {
      'source': 'apache',
      'extensions': ['ice']
    },
    'x-shader/x-fragment': {
      'compressible': true
    },
    'x-shader/x-vertex': {
      'compressible': true
    }
  };
</script>
<dom-module id="nuxeo-distribution-analytics" assetpath="nuxeo-admin/">
  <template>
    <style include="iron-flex">
      :host {
        display: block;
      }

      .suggestion-wrapper {
        border-radius: 2px;
        border: 1px solid var(--nuxeo-border);
        padding: 0 8px;
      }

      .suggestion-wrapper iron-icon {
        color: var(--dark-primary-color);
        margin-right: 8px;
      }

      paper-slider {
        width: 100%;
      }

      nuxeo-path-suggestion {
        --nuxeo-path-suggestion-results: {
           z-index: 2;
         };
         --paper-input-container-underline: {
           display: none;
         };
         --paper-input-container-underline-focus: {
           display: none;
         };
      }

    </style>

    <div class="flex-layout">

      <nuxeo-card>
        <div class="suggestion-wrapper horizontal layout center">
          <iron-icon icon="icons:folder"></iron-icon>
          <div class="flex">
            <nuxeo-path-suggestion id="pathSuggester" value="{{path}}"></nuxeo-path-suggestion>
          </div>
        </div>

        <nuxeo-document-distribution-chart id="chart" index="_all" path="[[path]]" mode="count" include-version="" include-hidden="" include-deleted="">
        </nuxeo-document-distribution-chart>

        <div class="horizontal layout center">
          <div>
            <iron-icon icon="icons:track-changes"></iron-icon>
          </div>
          <div class="flex">
            <paper-slider id="ratings" pin="" snaps="" max="20" max-markers="20" step="1" value="{{depth}}"></paper-slider>
          </div>
        </div>
      </nuxeo-card>

    </div>

  </template>
  <script>
    Polymer({
      is: 'nuxeo-distribution-analytics',
      behaviors: [Nuxeo.I18nBehavior],
      properties: {
        index: {
          type: String,
          value: '_all'
        },
        path: {
          type: String
        },
        depth: {
          type: Number,
          value: 7
        }
      },

      observers: [
        '_observeDocPath(path, depth)'
      ],

      _observeDocPath: function() {
        if (this.path && this.path.length && this.path.endsWith('/') &&
          (this.path !== this.$.chart.path || this.depth !== this.$.chart.maxDepth)) {
          this.$.chart.maxDepth = this.depth;
          this.$.chart.path = this.path;
          this.$.chart.execute();
        }
      }
    });
  </script>
</dom-module>
<dom-module id="nuxeo-repository-analytics" assetpath="nuxeo-admin/">
  <template>
    <style include="iron-flex iron-flex-alignment">
      :host {
        display: block;
      }

      nuxeo-date-picker {
        padding: 0 8px;
      }

      .flex-layout {
        display: flex;
        flex-wrap: wrap;
        margin: 0 -1em;
        padding: 0 8px;
      }

      .flex-layout nuxeo-card {
        flex: 1 0 calc(33% - 2em);
        margin: 0 8px 16px;
        text-align: center;
      }

      .message {
        color: #c6c6c6;
      }

      nuxeo-data-table {
        height: 550px;
      }

      iron-icon {
        color: #0f9d58;
        --iron-icon-width: 144px;
        --iron-icon-height: 144px;
        margin-top: 50px;
      }

      chart-line, chart-pie {
        margin: 25px auto 0 auto;
        width: 100% !important;
        min-width: 30em;
        display: block;
        font-size: .8rem;
      }

      @media (max-width: 1024px) {
        .flex-layout nuxeo-card {
          flex: 1 0 calc(100% - 2em);
        }
      }

    </style>

    <nuxeo-card class="dates">
      <div class="horizontal flex end-justified layout">
        <nuxeo-date-picker value="{{startDate}}" label="[[i18n('analytics.after')]]"></nuxeo-date-picker>
        <nuxeo-date-picker value="{{endDate}}" label="[[i18n('analytics.before')]]"></nuxeo-date-picker>
      </div>
    </nuxeo-card>

    <div class="flex-layout">

      <nuxeo-audit-data event-id="download" where="{&quot;extended.downloadReason&quot;: &quot;download&quot;}" grouped-by="docUUID" group-limit="10" start-date="[[startDate]]" end-date="[[_extendEndDate(endDate)]]" data="{{downloads}}">
      </nuxeo-audit-data>

      <nuxeo-page-provider auto="" page-size="10" query="[[_downloadsQuery(downloads)]]" schemas="dublincore, common" current-page="{{downloadedDocs}}">
      </nuxeo-page-provider>

      <nuxeo-card heading="[[i18n('repositoryAnalytics.topDownloads.heading')]]">
        <template is="dom-if" if="[[!_isEmpty(downloads)]]">
          <nuxeo-data-table items="[[downloadedDocs]]">
            <nuxeo-data-table-column name="[[i18n('repositoryAnalytics.topDownloads.file')]]">
              <template>[[item.title]]</template>
            </nuxeo-data-table-column>
            <nuxeo-data-table-column name="[[i18n('repositoryAnalytics.topDownloads.downloads')]]">
              <template>[[_numberOfDownloads(item)]]</template>
            </nuxeo-data-table-column>
          </nuxeo-data-table>
        </template>
        <template is="dom-if" if="[[_isEmpty(downloads)]]">
          <div class="message">[[i18n('repositoryAnalytics.noResults')]]</div>
        </template>
      </nuxeo-card>

      <nuxeo-repository-data start-date="[[startDate]]" end-date="[[_extendEndDate(endDate)]]" metrics="cardinality(ecm:uuid)" data="{{totalCount}}" index="[[index]]">
      </nuxeo-repository-data>

      <nuxeo-card heading="[[i18n('repositoryAnalytics.documents.heading')]]">
        <iron-icon icon="icons:description"></iron-icon>
        <h1>[[totalCount]]</h1>
      </nuxeo-card>

      <nuxeo-repository-data start-date="[[startDate]]" end-date="[[_extendEndDate(endDate)]]" grouped-by="ecm:primaryType" group-limit="10" data="{{typeCount}}" index="[[index]]">
      </nuxeo-repository-data>

      <nuxeo-card heading="[[i18n('repositoryAnalytics.documentTypes.heading')]]">
        <chart-pie values="[[_values(typeCount)]]" labels="[[_labels(typeCount)]]" options="{ &quot;legend&quot;: { &quot;display&quot;: true, &quot;position&quot;: &quot;bottom&quot;, &quot;labels&quot;: { &quot;boxWidth&quot;: 12 } }, &quot;animation&quot;: false }">
        </chart-pie>
      </nuxeo-card>

      <nuxeo-repository-data start-date="[[startDate]]" end-date="[[_extendEndDate(endDate)]]" grouped-by="dc:creator" group-limit="10" data="{{topCreators}}" index="[[index]]">
      </nuxeo-repository-data>

      <nuxeo-card heading="[[i18n('repositoryAnalytics.topNCreators.heading', '10')]]">
        <chart-pie values="[[_values(topCreators)]]" labels="[[_labels(topCreators)]]" options="{ &quot;legend&quot;: { &quot;display&quot;: true, &quot;position&quot;: &quot;bottom&quot;, &quot;labels&quot;: { &quot;boxWidth&quot;: 12 } }, &quot;animation&quot;: false }">
        </chart-pie>
      </nuxeo-card>

      <nuxeo-repository-data start-date="[[_formatDate(startDate)]]" end-date="[[_extendEndDate(endDate)]]" with-date-intervals="week" date-field="dc:created" data="{{docsCreatedPerWeek}}" index="[[index]]">
      </nuxeo-repository-data>

      <nuxeo-card heading="[[i18n('repositoryAnalytics.documentsCreatedPerWeek.heading')]]">
        <chart-line labels="[[_labels(docsCreatedPerWeek)]]" values="[[_values(docsCreatedPerWeek)]]" options="{ &quot;legend&quot;: { &quot;display&quot;: false }, &quot;animation&quot;: false }">
        </chart-line>
      </nuxeo-card>

      <nuxeo-repository-data start-date="[[_formatDate(startDate)]]" end-date="[[_extendEndDate(endDate)]]" with-date-intervals="week" date-field="dc:modified" data="{{docsModifiedPerWeek}}" index="[[index]]">
      </nuxeo-repository-data>

      <nuxeo-card heading="[[i18n('repositoryAnalytics.documentsModifiedPerWeek.heading')]]">
        <chart-line labels="[[_labels(docsModifiedPerWeek)]]" values="[[_values(docsModifiedPerWeek)]]" options="{ &quot;legend&quot;: { &quot;display&quot;: false }, &quot;animation&quot;: false }">
        </chart-line>
      </nuxeo-card>

      <nuxeo-repository-data start-date="[[startDate]]" end-date="[[_extendEndDate(endDate)]]" grouped-by="file:content.mime-type" data="{{filesByMimeType}}" index="[[index]]">
      </nuxeo-repository-data>

      <nuxeo-card heading="[[i18n('repositoryAnalytics.filesByMimeType.heading')]]">
        <chart-pie values="[[_values(filesByMimeType)]]" labels="[[_types(filesByMimeType)]]" options="{ &quot;legend&quot;: { &quot;display&quot;: true, &quot;position&quot;: &quot;bottom&quot;, &quot;labels&quot;: { &quot;boxWidth&quot;: 12 } }, &quot;animation&quot;: false }">
        </chart-pie>
      </nuxeo-card>

    </div>

  </template>
  <script>
    Polymer({
      is: 'nuxeo-repository-analytics',
      behaviors: [Nuxeo.ChartDataBehavior, Nuxeo.I18nBehavior],
      properties: {
        index: {
          type: String,
          value: '_all'
        },
        startDate: String,
        endDate: String
      },

      ready: function() {
        this.startDate = moment().subtract(1, 'month').format('YYYY-MM-DD');
        this.endDate = moment().format('YYYY-MM-DD');
      },

      _types: function(data) {
        return data.map(function(obj) {
          var mimeType = Nuxeo.mimeTypes[obj.key];
          if (mimeType) {
            if (mimeType.name) {
              return mimeType.name;
            } else if (mimeType.extensions && mimeType.extensions.length > 0) {
              return mimeType.extensions[0].toUpperCase();
            } else {
              return obj.key;
            }
          } else {
            return obj.key;
          }
        });
      },

      // builds page provider query to get info about downloaded docs
      _downloadsQuery: function(entries) {
        if (entries.length > 0) {
          var values = entries.map(function(entry) {
            return '\'' + entry.key + '\'';
          }).join(',');
          return 'SELECT * FROM Document WHERE ecm:uuid IN (' + values + ')';
        }
      },

      _numberOfDownloads: function(doc) {
        return this.downloads.find(function(entry) {
          return entry.key === doc.uid;
        }).value;
      },

      _isEmpty: function(array) {
        return !array || array.length === 0;
      }

    });
  </script>
</dom-module>
<dom-module id="nuxeo-search-analytics" assetpath="nuxeo-admin/">
  <template>
    <style include="iron-flex iron-flex-alignment">
      :host {
        display: block;
      }

      .dates input {
        border: 1px solid #c6c6c6;
        box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.0);
        border-radius: 3px;
        margin-left: .5em;
        width: 125px;
      }

      nuxeo-date-picker {
        padding: 0 16px;
      }

      .flex-layout {
        display: flex;
        flex-wrap: wrap;
        margin: 0 -1em;
        padding: 0 8px;
      }

      .flex-layout nuxeo-card {
        flex: 1 0 calc(33% - 2em);
        margin: 0 8px 16px;
        text-align: center;
      }

      nuxeo-data-table {
        height: 450px;
      }

      chart-bar, chart-pie {
        margin: 25px auto 0 auto;
        width: 100% !important;
        display: block;
        font-size: .8rem;
      }

      @media (max-width: 1024px) {
        .flex-layout nuxeo-card {
          flex: 1 0 calc(100% - 2em);
        }
      }

    </style>

    <nuxeo-card class="dates">
      <div class="horizontal flex end-justified layout">
        <nuxeo-date-picker value="{{startDate::change}}" label="[[i18n('analytics.after')]]"></nuxeo-date-picker>
        <nuxeo-date-picker value="{{endDate::change}}" label="[[i18n('analytics.before')]]"></nuxeo-date-picker>
      </div>
    </nuxeo-card>

    <div class="flex-layout">
      <nuxeo-search-data start-date="[[startDate]]" end-date="[[_extendEndDate(endDate)]]" grouped-by="pageProviderName" data="{{callsPerProvider}}" index="[[index]]">
      </nuxeo-search-data>

      <nuxeo-card heading="[[i18n('searchAnalytics.callsPerPageProvider.heading')]]">
        <chart-pie values="[[_values(callsPerProvider)]]" labels="[[_labels(callsPerProvider)]]" options="{ &quot;legend&quot;: { &quot;display&quot;: true, &quot;position&quot;: &quot;bottom&quot;, &quot;labels&quot;: { &quot;boxWidth&quot;: 12 } }, &quot;animation&quot;: false }">
        </chart-pie>
      </nuxeo-card>

      <nuxeo-search-data start-date="[[startDate]]" end-date="[[_extendEndDate(endDate)]]" with-date-intervals="hour" without-extended-bounds="" date-format="HH" data="{{callsPerHour}}" index="[[index]]">
      </nuxeo-search-data>

      <nuxeo-card heading="[[i18n('searchAnalytics.callsPerHour.heading')]]">
        <chart-bar labels="[[_range(0,23)]]" values="[[_aggregatePerHourOfDay(callsPerHour)]]" series="[[_range(0,23)]]" options="{ &quot;legend&quot;: { &quot;display&quot;: false }, &quot;animation&quot;: false }">
        </chart-bar>
      </nuxeo-card>

      <nuxeo-search-data start-date="[[startDate]]" end-date="[[_extendEndDate(endDate)]]" with-ranges="{&quot;resultsCount&quot;:[
                       {&quot;key&quot;: &quot;no result&quot;, &quot;to&quot;: 1 },
                       {&quot;key&quot;: &quot;less than 50&quot;, &quot;from&quot; : 1, &quot;to&quot;: 50},
                       {&quot;key&quot;: &quot;between 51 and 200&quot;, &quot;from&quot; : 51, &quot;to&quot;: 200 },
                       {&quot;key&quot;: &quot;between 200 and 1000&quot;, &quot;from&quot; : 201, &quot;to&quot;: 1000},
                       {&quot;key&quot;: &quot;more than 1000&quot;, &quot;from&quot; : 1001 }]}" data="{{callPerNumberOfResults}}" index="[[index]]">
      </nuxeo-search-data>

      <nuxeo-card heading="[[i18n('searchAnalytics.numberOfResults.heading')]]">
        <nuxeo-data-table items="[[callPerNumberOfResults]]">
          <nuxeo-data-table-column name="[[i18n('searchAnalytics.numberOfResults.range')]]">
            <template>[[item.key]]</template>
          </nuxeo-data-table-column>
          <nuxeo-data-table-column name="[[i18n('searchAnalytics.numberOfResults.calls')]]">
            <template>[[item.value]]</template>
          </nuxeo-data-table-column>
        </nuxeo-data-table>
      </nuxeo-card>

      <nuxeo-search-data start-date="[[startDate]]" end-date="[[_extendEndDate(endDate)]]" grouped-by="searchDocumentModel.properties.defaults:ecm_fulltext" group-limit="5" data="{{callsPerFT}}" index="[[index]]">
      </nuxeo-search-data>

      <nuxeo-card heading="[[i18n('searchAnalytics.mostPopularSearches.heading')]]">
        <nuxeo-data-table items="[[callsPerFT]]">
          <nuxeo-data-table-column name="[[i18n('searchAnalytics.mostPopularSearches.searchTerm')]]">
            <template>[[item.key]]</template>
          </nuxeo-data-table-column>
          <nuxeo-data-table-column name="[[i18n('searchAnalytics.mostPopularSearches.numberOfCalls')]]">
            <template>[[item.value]]</template>
          </nuxeo-data-table-column>
        </nuxeo-data-table>
      </nuxeo-card>

      <nuxeo-search-data start-date="[[startDate]]" end-date="[[_extendEndDate(endDate)]]" with-ranges="{&quot;pageIndex&quot;:[
                           {&quot;key&quot;: &quot;First page&quot;, &quot;from&quot; : 0, &quot;to&quot;: 1 },
                           {&quot;key&quot;: &quot;Page 2&quot;, &quot;from&quot; : 1, &quot;to&quot;: 2},
                           {&quot;key&quot;: &quot;Pages 3 to 5&quot;, &quot;from&quot; : 2, &quot;to&quot;: 5 },
                           {&quot;key&quot;: &quot;Pages 6 to 10&quot;, &quot;from&quot; : 6, &quot;to&quot;: 10},
                           {&quot;key&quot;: &quot;After 10 pages&quot;, &quot;from&quot; : 10 }]}" data="{{callPerNumberOfPages}}" index="[[index]]">
      </nuxeo-search-data>

      <nuxeo-card heading="[[i18n('searchAnalytics.mostPopularSearches.numberOfPagesDisplayed.heading')]]">
        <nuxeo-data-table items="[[callPerNumberOfPages]]">
          <nuxeo-data-table-column name="[[i18n('searchAnalytics.mostPopularSearches.numberOfPagesDisplayed.range')]]">
            <template>[[item.key]]</template>
          </nuxeo-data-table-column>
          <nuxeo-data-table-column name="[[i18n('searchAnalytics.mostPopularSearches.numberOfPagesDisplayed.numberOfCalls')]]">
            <template>[[item.value]]</template>
          </nuxeo-data-table-column>
        </nuxeo-data-table>
      </nuxeo-card>

      <nuxeo-search-data start-date="[[startDate]]" end-date="[[_extendEndDate(endDate)]]" grouped-by="searchFields" group-limit="5" data="{{callByFilters}}">
      </nuxeo-search-data>

      <nuxeo-card heading="[[i18n('searchAnalytics.filtersUsed.heading')]]">
        <nuxeo-data-table items="[[callByFilters]]">
          <nuxeo-data-table-column name="[[i18n('searchAnalytics.filtersUsed.numberOfFilters')]]">
            <template>[[item.key]]</template>
          </nuxeo-data-table-column>
          <nuxeo-data-table-column name="[[i18n('searchAnalytics.filtersUsed.numberOfCalls')]]">
            <template>[[item.value]]</template>
          </nuxeo-data-table-column>
        </nuxeo-data-table>
      </nuxeo-card>

    </div>
  </template>

  <script>
    Polymer({
      is: 'nuxeo-search-analytics',
      behaviors: [Nuxeo.ChartDataBehavior, Nuxeo.I18nBehavior],
      properties: {
        index: {
          type: String,
          value: 'audit'
        },
        startDate: String,
        endDate: String,
        hoursBounds: {
          value: {min: 0, max: 23}
        }
      },

      ready: function() {
        this.startDate = moment().subtract(1, 'month').format('YYYY-MM-DD');
        this.endDate = moment().format('YYYY-MM-DD');
      },

      _range: function(start, end) {
        var res = [];
        for (var i = start; i <= end; i++) {
          res.push(i);
        }
        return res;
      },

      _aggregatePerHourOfDay: function(entries) {
        // aggregate our buckets by key
        var agg = {};
        entries.forEach(function(e) {
          agg[e.key] = agg[e.key] || [];
          agg[e.key].push(e.value);
        });
        // build our total per bucket
        var hours = this._range(this.hoursBounds.min, this.hoursBounds.max);
        return [hours.map(function(i) {
          if (!agg[i] || !agg[i].length) { return 0; }
          // TODO: use Array.reduce once prototype.js is removed!
          // return agg[i].reduce(function(a, b) { return a + b; });
          var sum = 0;
          agg[i].forEach(function(v) { sum += v; });
          return sum;
        })];
      }
    });
  </script>
</dom-module>
<dom-module id="nuxeo-workflow-analytics" assetpath="nuxeo-admin/">
  <template>
    <style include="iron-flex iron-flex-alignment">
      :host {
        display: block;
      }

      nuxeo-select {
        min-width: 250px;
      }

      .dates input {
        border: 1px solid #c6c6c6;
        box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.0);
        border-radius: 3px;
        margin-left: .5em;
        width: 125px;
      }

      nuxeo-date-picker {
        padding: 0 16px;
      }

      nuxeo-data-table {
        height: 450px;
      }

      .flex-layout {
        display: flex;
        flex-wrap: wrap;
        margin: 0 -1em;
        padding: 0 8px;
      }

      .flex-layout nuxeo-card {
        flex: 1 0 calc(33% - 2em);
        margin: 0 8px 16px;
        text-align: center;
      }

      iron-icon {
        color: #0f9d58;
        --iron-icon-width: 144px;
        --iron-icon-height: 144px;
        margin-top: 50px;
      }

      chart-bar, chart-pie {
        margin: 25px auto 0 auto;
        width: 100% !important;
        display: block;
        font-size: .8rem;
      }

      @media (max-width: 1024px) {
        .flex-layout nuxeo-card {
          flex: 1 0 calc(100% - 2em);
        }
      }

    </style>

    <nuxeo-resource auto="" path="workflowModel" on-response="_handleWorkflowModelResponse">
    </nuxeo-resource>

    <nuxeo-card class="dates">
      <div class="horizontal flex end-justified layout center wrap">
        <nuxeo-select label="[[i18n('analytics.workflow')]]" placeholder="[[i18n('analytics.workflow')]]" selected="{{workflow}}" options="[[workflows]]"></nuxeo-select>
        <nuxeo-date-picker value="{{startDate::change}}" label="[[i18n('analytics.after')]]"></nuxeo-date-picker>
        <nuxeo-date-picker value="{{endDate::change}}" label="[[i18n('analytics.before')]]"></nuxeo-date-picker>
      </div>
    </nuxeo-card>

    <div class="flex-layout">
      <nuxeo-workflow-data workflow="[[workflow]]" event="afterWorkflowFinish" metrics="avg(timeSinceWfStarted)" start-date="[[startDate]]" end-date="[[_extendEndDate(endDate)]]" data="{{avgWorkflowLength}}">
      </nuxeo-workflow-data>

      <nuxeo-card heading="[[i18n('workflowAnalytics.averageWorkflowDuration.heading')]]">
        <iron-icon icon="image:timer"></iron-icon>
        <h1>[[_asDuration(avgWorkflowLength)]]</h1>
      </nuxeo-card>

      <nuxeo-workflow-data workflow="[[workflow]]" event="afterWorkflowStarted" grouped-by="workflowInitiator" start-date="[[startDate]]" end-date="[[_extendEndDate(endDate)]]" data="{{initiators}}">
      </nuxeo-workflow-data>

      <nuxeo-card heading="[[i18n('workflowAnalytics.workflowInitiators.heading')]]">
        <chart-pie values="[[_values(initiators)]]" labels="[[_series(initiators)]]" options="{ &quot;legend&quot;: { &quot;display&quot;: true, &quot;position&quot;: &quot;bottom&quot;, &quot;labels&quot;: { &quot;boxWidth&quot;: 12 } }, &quot;animation&quot;: false }">
        </chart-pie>
      </nuxeo-card>

      <nuxeo-workflow-data workflow="[[workflow]]" event="afterWorkflowTaskEnded" grouped-by="taskActor, action" start-date="[[startDate]]" end-date="[[_extendEndDate(endDate)]]" data="{{numberOfActionsPerUser}}">
      </nuxeo-workflow-data>

      <nuxeo-card heading="[[i18n('workflowAnalytics.actionsPerUser.heading')]]">
        <chart-bar labels="[[_labels(numberOfActionsPerUser)]]" series="[[_series(numberOfActionsPerUser)]]" values="[[_values(numberOfActionsPerUser)]]" options="{ &quot;legend&quot;: { &quot;display&quot;: true, &quot;position&quot;: &quot;bottom&quot;, &quot;labels&quot;: { &quot;boxWidth&quot;: 12 } }, &quot;animation&quot;: false }">
        </chart-bar>
      </nuxeo-card>

      <nuxeo-workflow-data workflow="[[workflow]]" event="afterWorkflowTaskEnded" grouped-by="taskActor" metrics="avg(timeSinceTaskStarted)" start-date="[[startDate]]" end-date="[[_extendEndDate(endDate)]]" data="{{avgTaskDurationPerUser}}">
      </nuxeo-workflow-data>

      <nuxeo-card heading="[[i18n('workflowAnalytics.averageTaskDurationPerUser.heading')]]">
        <nuxeo-data-table items="[[_table(avgTaskDurationPerUser)]]">
          <nuxeo-data-table-column name="[[i18n('workflowAnalytics.averageTaskDurationPerUser.user')]]">
            <template>[[item.key]]</template>
          </nuxeo-data-table-column>
          <nuxeo-data-table-column name="[[i18n('workflowAnalytics.averageTaskDurationPerUser.duration')]]">
            <template>[[item.value]]</template>
          </nuxeo-data-table-column>
        </nuxeo-data-table>
      </nuxeo-card>

    </div>

  </template>
  <script>
    Polymer({
      is: 'nuxeo-workflow-analytics',
      behaviors: [Nuxeo.ChartDataBehavior, Nuxeo.I18nBehavior],
      properties: {
        workflow: {
          type: String,
          value: 'ParallelDocumentReview'
        },
        index: {
          type: String,
          value: 'nuxeo'
        },
        startDate: String,
        endDate: String,
        workflows: Array
      },

      ready: function() {
        this.startDate = moment().subtract(1, 'month').format('YYYY-MM-DD');
        this.endDate = moment().format('YYYY-MM-DD');
      },

      // override _labels and _values from nuxeo-chart-data-behavior.html
      _labels: function(data) {
        if (!data) { return []; }
        if (data.value) {
          return data.value.map(function(obj) {
            return obj.key;
          });
        } else {
          return this._labels(data[0]);
        }
      },

      _values: function(data) {
        var values = [];
        data.forEach(function(entry) {
          if (Array.isArray(entry.value)) {
            values.push(entry.value.map(function(e) { return e.value; }));
          } else {
            values.push(entry.value);
          }
        });
        return values;
      },

      _asDuration: function(duration) {
        var seconds = Math.floor(duration / 1000),
            minutes = Math.floor(seconds / 60),
            hours = Math.floor(minutes / 60),
            days = Math.floor(hours / 24),
            result = '';
        hours = hours - (days * 24);
        minutes = minutes - (days * 24 * 60) - (hours * 60);
        seconds = seconds - (days * 24 * 60 * 60) - (hours * 60 * 60) - (minutes * 60);
        if (days > 0) {
          result += days + ' Days ';
        }
        if (hours > 0) {
          result += hours + 'h ';
        }
        if (minutes > 0) {
          result += minutes + 'm ';
        }
        if (seconds > 0) {
          result += seconds + 's ';
        }
        return result;
      },

      _table: function(data) {
        return data.map(function(e) {
          return {key: e.key, value: this._asDuration(e.value)};
        }.bind(this));
      },

      _handleWorkflowModelResponse: function(response) {
        var _workflowModels = response.detail.response.entries;
        this.workflows = _workflowModels.map(function(wfm) {
          return {
            id: wfm.name,
            label: this.i18n(wfm.title)
          }
        }.bind(this));
        this.workflow = this.workflows[0].id;
      }

    });
  </script>
</dom-module>
<dom-module id="nuxeo-audit" assetpath="nuxeo-admin/">
  <template>
    <style>
      nuxeo-data-table {
        height: calc(100vh - 25em);
        min-height: 15em;
      }

      .row-container {
        @apply --layout-horizontal;
        @apply --layout-wrap;
      }

      .item {
        flex: 1 0 0;
        margin-right: 8px;
      }

      @media (max-width: 768px) {
        .item {
          min-width: 100%;
        }

        nuxeo-data-table {
          height: calc(100vh - 33em);
        }
      }
    </style>

    <nuxeo-audit-page-provider id="provider" page-size="40" provider-name="EVENTS_VIEW"></nuxeo-audit-page-provider>
    <nuxeo-page>
      <div slot="header">
        <span class="flex">[[i18n('audit.heading')]]</span>
      </div>
      <div>
        <nuxeo-card>
          <nuxeo-user-suggestion value="{{principalName}}" label="[[i18n('audit.username')]]" placeholder="[[i18n('audit.usernamePlaceholder')]]"></nuxeo-user-suggestion>

          <div class="row-container">
            <nuxeo-date-picker role="widget" class="item" value="{{startDate}}" label="[[i18n('audit.from')]]">
            </nuxeo-date-picker>
            <nuxeo-date-picker role="widget" class="item" value="{{endDate}}" label="[[i18n('audit.to')]]">
            </nuxeo-date-picker>
          </div>

          <div class="row-container">
            <nuxeo-directory-suggestion class="item" role="widget" label="[[i18n('audit.eventTypes')]]" directory-name="eventTypes" value="{{selectedEventTypes}}" multiple="true" placeholder="[[i18n('audit.selectEventTypes')]]" min-chars="0">
            </nuxeo-directory-suggestion>

            <nuxeo-directory-suggestion class="item" role="widget" label="[[i18n('audit.eventCategory')]]" directory-name="eventCategories" value="{{selectedEventCategory}}" placeholder="[[i18n('audit.selectEventCategory')]]" min-chars="0">
            </nuxeo-directory-suggestion>
          </div>
        </nuxeo-card>

        <nuxeo-card>
          <nuxeo-data-table id="table" paginable="" nx-provider="provider" empty-label="[[i18n('audit.empty')]]">
            <nuxeo-data-table-column name="[[i18n('audit.performedAction')]]" sort-by="eventId">
              <template>[[_formati18n('eventType.', item.eventId)]]</template>
            </nuxeo-data-table-column>
            <nuxeo-data-table-column name="[[i18n('audit.date')]]" sort-by="eventDate">
              <template><nuxeo-date datetime="[[item.eventDate]]"></nuxeo-date></template>
            </nuxeo-data-table-column>
            <nuxeo-data-table-column name="[[i18n('audit.username')]]" sort-by="principalName">
              <template>
                <nuxeo-user-tag user="[[item.principalName]]"></nuxeo-user-tag>
              </template>
            </nuxeo-data-table-column>
            <nuxeo-data-table-column name="[[i18n('audit.category')]]" sort-by="category">
              <template>[[_formati18n('eventCategory.', item.category)]]</template>
            </nuxeo-data-table-column>
            <nuxeo-data-table-column name="[[i18n('audit.document')]]">
              <template>[[_formatDocument(item)]]</template>
            </nuxeo-data-table-column>
            <nuxeo-data-table-column name="[[i18n('audit.comment')]]">
              <template>[[item.comment]]</template>
            </nuxeo-data-table-column>
          </nuxeo-data-table>
      </nuxeo-card>
      </div>
    </nuxeo-page>
  </template>

  <script>
    Polymer({
      is: 'nuxeo-audit',
      behaviors: [Nuxeo.FormatBehavior],
      properties: {
        visible: {
          type: Boolean
        },
        entries: {
          type: Array,
          value: []
        },
        selectedEventTypes: {
          type: Array,
          value: []
        },
        selectedEventCategory: {
          type: String,
          value: ''
        },
        startDate: {
          type: String,
          value: ''
        },
        endDate: {
          type: String,
          value: ''
        },
        principalName: {
          type: String,
          value: ''
        }
      },
      observers: [
        '_refresh(startDate, endDate, selectedEventTypes.*, selectedEventCategory, principalName)'
      ],

      _formati18n: function(path, key) {
        return key ? this.i18n(path + key) : '';
      },

      _formatDocument: function(item) {
        if (item) {
          return (item.docUUID || '') + (item.docType ? ' (' + item.docType + ') ' : '') + (item.docPath || '');
        }
      },

      /* Builds the parameters object to be used on the query */
      _buildParams: function() {
        var params = {
          principalName: this.principalName
        };
        if (this.startDate) {
          params.startDate = this.startDate;
        }
        if (this.endDate) {
          params.endDate = this.endDate;
        }
        if (this.selectedEventTypes && this.selectedEventTypes.length > 0) {
          params.eventIds = this.selectedEventTypes.join();
        }
        if (this.selectedEventCategory) {
          params.eventCategory = this.selectedEventCategory;
        }
        return params;
      },

      _refresh: function() {
        if (this.visible) {
          this.$.provider.params = this._buildParams();
          this.$.table.fetch();
        }
      }
    });
  </script>
</dom-module>
<dom-module id="nuxeo-oauth2-tokens" assetpath="nuxeo-cloud-services/">
  <template>
    <style include="nuxeo-styles">
      nuxeo-data-table {
        height: var(--nuxeo-oauth2-tokens-table-height, calc(100vh - 172px));
      }
    </style>
    <nuxeo-resource id="tokens"></nuxeo-resource>

    <nuxeo-data-table name="table" icon="nuxeo:view-list" empty-label="[[i18n('cloudTokens.emptyResult')]]" items="[[tokens]]">

      <nuxeo-data-table-column name="[[i18n('cloudTokens.serviceName')]]" field="serviceName" sort-by="serviceName">
        <template>
          <span>[[item.serviceName]]</span>
        </template>
      </nuxeo-data-table-column>

      <nuxeo-data-table-column name="[[i18n('cloudTokens.nuxeoLogin')]]" field="nuxeoLogin" sort-by="nuxeoLogin">
        <template>
          <span>[[item.nuxeoLogin]]</span>
        </template>
      </nuxeo-data-table-column>

      <nuxeo-data-table-column name="[[i18n('cloudTokens.serviceLogin')]]" field="serviceLogin" sort-by="serviceLogin">
        <template>
          <span>[[item.serviceLogin]]</span>
        </template>
      </nuxeo-data-table-column>

      <nuxeo-data-table-column name="[[i18n('cloudTokens.creationDate')]]" field="creationDate" sort-by="creationDate">
        <template>
          <nuxeo-date datetime="[[item.creationDate]]"></nuxeo-date>
        </template>
      </nuxeo-data-table-column>

      <nuxeo-data-table-column name="[[i18n('cloudTokens.isShared')]]" field="isShared" sort-by="isShared">
        <template>
          <paper-checkbox noink="" checked="[[item.isShared]]" disabled=""></paper-checkbox>
        </template>
      </nuxeo-data-table-column>

      <nuxeo-data-table-column name="[[i18n(col.name)]]" key="[[col.key]]">
        <template>
          <paper-icon-button name="edit" icon="nuxeo:edit" on-tap="_editEntry" title="[[i18n('cloudTokens.edit')]]"></paper-icon-button>
          <paper-icon-button name="delete" icon="nuxeo:delete" on-tap="_deleteEntry" title="[[i18n('cloudTokens.delete')]]"></paper-icon-button>
        </template>
      </nuxeo-data-table-column>
    </nuxeo-data-table>

    <nuxeo-dialog id="dialog" with-backdrop="" no-auto-focus="">
      <h2>[[i18n('cloudTokens.popup.editEntry')]]</h2>
      <paper-dialog-scrollable>
        <iron-form id="form">
          <form>
            <nuxeo-input disabled="" label="[[i18n('cloudTokenEdit.serviceName')]]" name="serviceName" value="{{_selectedEntry.serviceName}}">
            </nuxeo-input>

            <nuxeo-input disabled="" label="[[i18n('cloudTokenEdit.nuxeoLogin')]]" name="description" value="{{_selectedEntry.nuxeoLogin}}">
            </nuxeo-input>

            <nuxeo-input required="" label="[[i18n('cloudTokenEdit.serviceLogin')]]" name="clientId" value="{{_selectedEntry.serviceLogin}}">
            </nuxeo-input>

            <nuxeo-date-picker name="creationDate" required="" label="[[i18n('cloudTokenEdit.creationDate')]]" value="{{_selectedEntry.creationDate}}">
            </nuxeo-date-picker>

            <paper-checkbox noink="" checked="{{_selectedEntry.isShared}}">
              [[i18n('cloudTokenEdit.isShared')]]
            </paper-checkbox>

            <nuxeo-user-suggestion label="[[i18n('cloudTokenEdit.shareWith')]]" value="{{_selectedEntry.sharedWith}}" prefixed="" multiple="">
            </nuxeo-user-suggestion>
          </form>
        </iron-form>
      </paper-dialog-scrollable>
      <div class="buttons">
        <paper-button id="cancel" name="cancel" noink="" dialog-dismiss="">[[i18n('command.cancel')]]</paper-button>
        <paper-button id="save" name="save" noink="" class="primary" on-tap="_save">[[i18n('command.save')]]</paper-button>
      </div>
    </nuxeo-dialog>
  </template>
  <script>
    var OAUTH2_PROVIDER_TOKENS_PATH = 'oauth2/token/provider/';
    var OAUTH2_CLIENT_TOKENS_PATH = 'oauth2/token/client/';

    Polymer({
      is: 'nuxeo-oauth2-tokens',
      behaviors: [Nuxeo.FormatBehavior],
      properties: {
        tokens: {
          type: Array,
          value: []
        },

        _selectedEntry: {
          type: Object
        }
      },

      get _isClientToken() {
        !!(this._selectedEntry && this._selectedEntry.clientId);
      },

      _deleteEntry: function(e) {
        if (confirm(this.i18n('cloudTokens.confirmDelete'))) {
          var item = e.target.parentNode.item;

          this.$.tokens.path = (item.clientId ? OAUTH2_CLIENT_TOKENS_PATH + '/' + item.clientId :
                                                OAUTH2_PROVIDER_TOKENS_PATH + item.serviceName) + '/' +
                                                'user/' + item.nuxeoLogin;
          this.$.tokens.remove().then(function() {
            this.fire('oauth2-token-deleted');
            this.fire('notify', {message: this.i18n('cloudTokens.successfullyDeleted')});
          }.bind(this), function() {
            this.fire('notify', {message: this.i18n('label.error').toUpperCase() + ': ' +
              this.i18n('cloudTokens.errorDeleting')
            });
          }.bind(this));
        }
      },

      _editEntry: function(e) {
        this._selectedEntry = JSON.parse(JSON.stringify(e.target.parentNode.item));
        this.$.dialog.toggle();
      },

      _save: function() {
        var valid = this.$.form.validate();
        if (valid) {
          this._selectedEntry.creationDate = this.formatDate(this._selectedEntry.creationDate, 'YYYY-MM-DD HH:MM:SS');
          this.$.tokens.data = this._selectedEntry;
          this.$.tokens.path = (this._isClientToken ? OAUTH2_CLIENT_TOKENS_PATH + '/' + this._selectedEntry.clientId :
                                OAUTH2_PROVIDER_TOKENS_PATH + this._selectedEntry.serviceName) + '/' +
                                'user/' + this._selectedEntry.nuxeoLogin;
          this.$.tokens.put().then(function() {
            this.$.dialog.toggle();
            this.fire('oauth2-token-saved');
            this.fire('notify', {message: this.i18n('cloudTokens.successfullyEdited')});
          }.bind(this), function(err) {
            this.fire('notify', {
              message: this.i18n('label.error').toUpperCase() + ': ' +
              (err.message && err.message.length > 0 ? err.message :
                this.i18n('cloudTokens.errorEditing'))
            });
          }.bind(this));
        }
      }
    });
  </script>
</dom-module>
<dom-module id="nuxeo-cloud-tokens" assetpath="nuxeo-cloud-services/">
  <template>
    <nuxeo-resource id="tokens" path="oauth2/token/"></nuxeo-resource>
    <nuxeo-card heading="[[i18n('cloudTokens.OAuth2Tokens')]]">
      <nuxeo-oauth2-tokens tokens="[[tokens]]" on-oauth2-token-saved="refresh" on-oauth2-token-deleted="refresh"></nuxeo-oauth2-tokens>
    </nuxeo-card>

  </template>
  <script>
    Polymer({
      is: 'nuxeo-cloud-tokens',
      behaviors: [Nuxeo.I18nBehavior],
      properties: {
        tokens: {
          type: Array,
          value: []
        }
      },

      refresh: function() {
        this.$.tokens.get().then(function(response) {
          this.tokens = response.entries;
        }.bind(this));
      }
    });
  </script>
</dom-module>
<dom-module id="nuxeo-cloud-providers" assetpath="nuxeo-cloud-services/">
  <template>
    <style include="nuxeo-styles iron-flex iron-flex-alignment">
      nuxeo-data-table {
        height: calc(100vh - 210px);
      }
    </style>

    <nuxeo-resource id="oauth"></nuxeo-resource>

    <nuxeo-card heading="[[i18n('cloudProviders.OAuth2ServiceProviders')]]">
      <div class="layout horizontal center end-justified">
        <paper-button id="addEntry" class="primary" on-tap="_addEntry">
          <span>[[i18n('cloudProviders.add')]]</span>
        </paper-button>
      </div>

      <nuxeo-data-table id="table" name="table" icon="nuxeo:view-list" empty-label="[[i18n('cloudProviders.emptyResult')]]" items="[[oauth2Providers]]">

        <nuxeo-data-table-column name="[[i18n('cloudProviders.serviceName')]]" field="serviceName" sort-by="serviceName">
          <template>
            <span name="serviceName">[[item.serviceName]]</span>
          </template>
        </nuxeo-data-table-column>

        <nuxeo-data-table-column name="[[i18n('cloudProviders.description')]]" field="description" sort-by="description">
          <template>
            <span>[[item.description]]</span>
          </template>
        </nuxeo-data-table-column>

        <nuxeo-data-table-column name="[[i18n('cloudProviders.enabled')]]" field="isEnabled" sort-by="isEnabled">
          <template>
            <paper-checkbox noink="" checked="[[item.isEnabled]]" disabled=""></paper-checkbox>
          </template>
        </nuxeo-data-table-column>

        <nuxeo-data-table-column name="[[i18n(col.name)]]" key="[[col.key]]">
          <template>
            <paper-icon-button name="edit" icon="nuxeo:edit" on-tap="_editEntry" title="[[i18n('cloudProviders.edit')]]"></paper-icon-button>
            <paper-icon-button name="delete" icon="nuxeo:delete" on-tap="_deleteEntry" title="[[i18n('cloudProviders.delete')]]"></paper-icon-button>
          </template>
        </nuxeo-data-table-column>
      </nuxeo-data-table>
    </nuxeo-card>

    <nuxeo-dialog id="dialog" with-backdrop="" no-auto-focus="">
      <h2>[[i18n('cloudProviders.popup.editEntry')]]</h2>
      <paper-dialog-scrollable>
        <iron-form id="form">
          <form>
            <nuxeo-input required="" label="[[i18n('cloudProviderEdit.serviceName')]]" name="serviceName" value="{{_selectedEntry.serviceName}}">
            </nuxeo-input>

            <nuxeo-input label="[[i18n('cloudProviderEdit.description')]]" name="description" value="{{_selectedEntry.description}}">
            </nuxeo-input>

            <nuxeo-input label="[[i18n('cloudProviderEdit.clientId')]]" name="clientId" value="{{_selectedEntry.clientId}}">
            </nuxeo-input>

            <nuxeo-input label="[[i18n('cloudProviderEdit.clientSecret')]]" name="clientSecret" value="{{_selectedEntry.clientSecret}}">
            </nuxeo-input>

            <nuxeo-input label="[[i18n('cloudProviderEdit.authorizationServerURL')]]" name="authorizationServerURL" pattern="(http[s]?:\/\/).*" value="{{_selectedEntry.authorizationServerURL}}">
            </nuxeo-input>

            <nuxeo-input label="[[i18n('cloudProviderEdit.tokenServerURL')]]" name="tokenServerURL" pattern="(http[s]?:\/\/).*" value="{{_selectedEntry.tokenServerURL}}">
            </nuxeo-input>

            <nuxeo-input label="[[i18n('cloudProviderEdit.userAuthorizationURL')]]" name="userAuthorizationURL" pattern="(http[s]?:\/\/).*" value="{{_selectedEntry.userAuthorizationURL}}">
            </nuxeo-input>

            <nuxeo-input label="[[i18n('cloudProviderEdit.scopes')]]" name="scopes" value="{{_selectedEntry.scopes}}">
            </nuxeo-input>

            <paper-checkbox noink="" id="isEnabled" checked="{{_selectedEntry.isEnabled}}">
              [[i18n('cloudProviderEdit.isEnabled')]]
            </paper-checkbox>
          </form>
        </iron-form>
      </paper-dialog-scrollable>
      <div class="buttons">
        <paper-button id="cancel" name="cancel" noink="" dialog-dismiss="">[[i18n('command.cancel')]]</paper-button>
        <paper-button id="save" name="save" noink="" class="primary" on-tap="_save">[[i18n('command.save')]]</paper-button>
      </div>
    </nuxeo-dialog>
  </template>
  <script>
    var OAUTH2_PROVIDERS_BASE_PATH = 'oauth2/provider/';

    Polymer({
      is: 'nuxeo-cloud-providers',
      behaviors: [Nuxeo.FormatBehavior],
      properties: {
        _selectedEntry: {
          type: Object
        },

        oauth2Providers: {
          type: Array,
          value: []
        },

        _isNew: {
          type: Boolean
        },

        _selectedServiceName: {
          type: String
        }
      },

      refresh: function() {
        this.$.oauth.path = OAUTH2_PROVIDERS_BASE_PATH;
        this.$.oauth.get().then(function(response) {
          this.oauth2Providers = response.entries;
          // ELEMENTS-322 - fix this on nuxeo-data-table
          this.async(this.$.table.$.list.notifyResize.bind(this.$.table.$.list), 1000);
        }.bind(this));
      },

      _editEntry: function(e) {
        this._isNew = false;
        this._selectedEntry = JSON.parse(JSON.stringify(e.target.parentNode.item));
        this._selectedServiceName = this._selectedEntry.serviceName;
        if (Array.isArray(this._selectedEntry.scopes)) {
          this._selectedEntry.scopes = this._selectedEntry.scopes.join();
        }
        this.$.dialog.toggle();
      },

      _addEntry: function() {
        this._isNew = true;
        this._selectedEntry = {
          'entity-type': 'nuxeoOAuth2ServiceProvider',
          scopes: '',
          isEnabled: false
        };
        this.$.dialog.toggle();
      },

      _save: function() {
        var valid = this.$.form.validate();
        if (valid){
          this._selectedEntry.scopes = this._selectedEntry.scopes ? this._selectedEntry.scopes.split(',') : [];
          this.$.oauth.data = this._selectedEntry;

          if (this._isNew) {
            this._create(this._selectedEntry);
          } else {
            this._update(this._selectedServiceName, this._selectedEntry);
          }
        }
      },

      _create: function(entry) {
        this.$.oauth.path = OAUTH2_PROVIDERS_BASE_PATH;
        this.$.oauth.data = entry;
        this.$.oauth.post().then(function() {
          this.refresh();
          this.$.dialog.toggle();
          this.fire('notify', {message: this.i18n('cloudProviders.successfullyCreated')});
        }.bind(this), function(err) {
          this.fire('notify', {
            message: this.i18n('label.error').toUpperCase() + ': ' +
            (err.message && err.message.length > 0 ? err.message :
              this.i18n('cloudProviders.errorCreating'))
          });
        }.bind(this));
      },

      _update: function(serviceName, entry) {
        this.$.oauth.path = OAUTH2_PROVIDERS_BASE_PATH + serviceName;
        this.$.oauth.data = entry;
        this.$.oauth.put().then(function() {
          this.$.dialog.toggle();
          this.fire('notify', {message: this.i18n('cloudProviders.successfullyEdited')});
          this.refresh();
        }.bind(this), function(err) {
          this.fire('notify', {
            message: this.i18n('label.error').toUpperCase() + ': ' +
            (err.message && err.message.length > 0 ? err.message :
              this.i18n('cloudProviders.errorEditing'))
          });
        }.bind(this));
      },

      _deleteEntry: function(e) {
        if (confirm(this.i18n('cloudProviders.confirmDelete'))) {
          var item =  e.target.parentNode.item;
          this.$.oauth.path = OAUTH2_PROVIDERS_BASE_PATH + item.serviceName;
          this.$.oauth.remove().then(function() {
            this.refresh();
            this.fire('notify', {message: this.i18n('cloudProviders.successfullyDeleted')});
          }.bind(this), function() {
            this.fire('notify', {
              message: this.i18n('label.error').toUpperCase() + ': ' +
              this.i18n('cloudProviders.errorDeleting')
            });
          }.bind(this));
        }
      }
    });
  </script>
</dom-module>
<dom-module id="nuxeo-cloud-services" assetpath="nuxeo-cloud-services/">
  <template>
    <style include="nuxeo-styles iron-flex">
      /* document views items (pills) */
      #documentViewsItems {
        @apply --layout-horizontal;
        --paper-listbox-background-color: transparent;
      }

      paper-listbox {
        padding: 0;
      }

      @media (max-width: 1024px) {
        paper-listbox {
          padding-right: 7rem;
        }
      }
    </style>
    <nuxeo-page>
      <div slot="header">
        <span class="flex">[[i18n('cloudServices.heading')]]</span>
      </div>
      <div slot="tabs">
        <paper-listbox id="documentViewsItems" selected="{{selectedTab}}" attr-for-selected="name">
          <nuxeo-page-item name="providers" label="cloudServices.providers"></nuxeo-page-item>
          <nuxeo-page-item name="tokens" label="cloudServices.tokens"></nuxeo-page-item>
        </paper-listbox>
      </div>
      <div>
        <iron-pages selected="[[selectedTab]]" attr-for-selected="name" selected-item="{{page}}">
          <nuxeo-cloud-providers id="providers" name="providers"></nuxeo-cloud-providers>
          <nuxeo-cloud-tokens id="tokens" name="tokens"></nuxeo-cloud-tokens>
        </iron-pages>
      </div>
    </nuxeo-page>
  </template>
  <script>
    Polymer({
      is: 'nuxeo-cloud-services',
      behaviors: [Nuxeo.I18nBehavior],
      properties: {
        visible: {
          type: Boolean
        },

        selectedTab: {
          type: String,
          value: 'providers'
        },

        page: {
          type: Object
        }
      },

      observers: ['refresh(visible, page)'],

      refresh: function() {
        if (this.page && this.visible) {
          this.page.refresh();
        }
      }
    });
  </script>
</dom-module>
<dom-module id="nuxeo-sort-select" assetpath="bower_components/nuxeo-ui-elements/widgets/">
  <template>
    <style>
      :host {
        display: block;
        @apply --layout-horizontal;
        @apply --layout-center;
      }

      nuxeo-select {
        padding-left: 8px;
        width: 160px;
        --paper-input-container: {
          padding: 0;
        };
        --paper-input-container-input: {
          font-size: var(--nuxeo-sort-select-input-font-size, inherit);
          font-weight: bold;
        };
      }

      span {
        font-size: var(--nuxeo-sort-select-input-font-size, inherit);
      }

      paper-icon-button {
        max-width: var(--nuxeo-sort-select-order-toggle-width, 20px);
        max-height: var(--nuxeo-sort-select-order-toggle-height, 20px);
        padding: 0;
        margin: 0 16px;
      }
    </style>

    <nuxeo-select attr-for-selected="option" selected="{{selected}}">
      <dom-if if="[[options]]">
        <template>
          <dom-repeat items="[[options]]" as="item">
            <template>
              <paper-item option="[[item]]">[[item.label]]</paper-item>
            </template>
          </dom-repeat>
        </template>
      </dom-if>
    </nuxeo-select>

    <paper-icon-button id="reverse" noink="" on-click="_toggleSortOrder" icon="[[_sortOrderIcon(_sortOrder)]]"></paper-icon-button>
    <nuxeo-tooltip for="reverse">[[i18n('sortSelect.reverseOrder')]]</nuxeo-tooltip>

  </template>

  <script>
    {
      /**
       * An element to select sort field and sort order.
       *
       * @appliesMixin Nuxeo.I18nBehavior
       * @memberof Nuxeo
       * @demo demo/nuxeo-sort-select/index.html
       */
      class SortSelect extends Polymer.mixinBehaviors([Nuxeo.I18nBehavior], Nuxeo.Element) {

        static get is() {
          return 'nuxeo-sort-select';
        }

        static get properties() {
          return {
            options: {
              type: Array,
              value: [],
              observer: '_optionsChanged',
            },

            selected: {
              type: String,
              observer: '_selectedChanged',
              notify: true,
            },

            _sortOrder: {
              type: String,
              value: 'asc',
            },
          };
        }

        _optionsChanged() {
          this.options.forEach((option) => {
            if (option.selected) {
              this.selected = option;
            }
          });
        }

        _selectedChanged() {
          if (this.selected) {
            this._sortOrder = this.selected.order;
          }
        }

        _toggleSortOrder() {
          this._sortOrder = this._sortOrder === 'asc' ? 'desc' : 'asc';
          if (this.selected) {
            this.set('selected.order', this._sortOrder);
            this.dispatchEvent(new CustomEvent('sort-order-changed', {
              composed: true,
              bubbles: true,
              detail: { sort: this.selected },
            }));
          }
        }

        _sortOrderIcon() {
          return this._sortOrder === 'asc' ? 'icons:arrow-upward' : 'icons:arrow-downward';
        }

      }

      customElements.define(SortSelect.is, SortSelect);
      Nuxeo.SortSelect = SortSelect;
    }
  </script>

</dom-module>


<dom-module id="nuxeo-selection-toolbar" assetpath="nuxeo-selection/">
  <template>

    <style is="iron-flex iron-flex-alignment nuxeo-styles">
      :host {
        font-family: var(--nuxeo-app-font);
      }

      .toolbar {
        @apply --layout-horizontal;
        @apply --layout-center;
        @apply --layout-fit;
        height: 60px;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        z-index: 199;
        padding: 0 2em;
        font-weight: 300;
        box-shadow: 0 0 3px rgba(0,0,0,0.4);
        background: var(--nuxeo-selection-toolbar-background, #000);
        color: var(--nuxeo-selection-toolbar-text, #fff);
        @apply --nuxeo-selection-toolbar;
      }

      .actions {
        @apply --layout-horizontal;
        @apply --layout-center;
        @apply --layout-flex;
        @apply --layout-end-justified;
      }

      .count {
        font-weight: 600;
      }

      #selectedItemsPopup {
        margin-top: 196px;
      }

      .horizontal {
        @apply --layout-flex;
        @apply --layout-horizontal;
      }

      /* links */
      a, a:active, a:visited, a:focus {
        display: inline-block;
        vertical-align: bottom;
        text-decoration: underline;
        margin-left: 1em;
        color: var(--nuxeo-selection-toolbar-link, #fff);
        cursor: pointer;
      }
      a:hover {
        color: var(--nuxeo-selection-toolbar-link-hover, #000);
      }
    </style>

    <div class="horizontal center layout" id="content">
      <div id="selectionToolbar" class="toolbar">
        <div class="selection">
          <span class="count">[[i18n('selectionToolbar.selected.items', selectedItems.length)]]</span>
          <a class="selectionLink" on-tap="toogleSelectedItemsPopup">
            <span>[[i18n('selectionToolbar.display.selection')]]</span>
          </a>
          <a class="selectionLink" on-tap="clearSelection">
            <span>[[i18n('command.clear')]]</span>
          </a>
        </div>
        <div class="actions">
          <slot></slot>
        </div>
      </div>
    </div>

    <nuxeo-dialog id="selectedItemsPopup" no-auto-focus="" with-backdrop="">
      <h2>[[i18n('selectionToolbar.dialog.heading')]]</h2>
      <paper-dialog-scrollable>
        <template is="dom-repeat" items="[[selectedItems]]">
          <div class="layout horizontal center">
            <nuxeo-document-thumbnail document="[[item]]"></nuxeo-document-thumbnail><div>[[item.title]]</div>
          </div>
        </template>
      </paper-dialog-scrollable>
      <div class="buttons">
        <paper-button dialog-dismiss="">[[i18n('command.close')]]</paper-button>
      </div>
    </nuxeo-dialog>

  </template>

  <script>
    Polymer({
      is: 'nuxeo-selection-toolbar',
      behaviors: [Nuxeo.I18nBehavior],
      properties: {
        hidden: {
          type: Boolean,
          value: false,
          reflectToAttribute: true
        },
        selectedItems: {
          type: Object,
          value: [],
          notify: true
        },
        _isDisplayToolbar: {
          type: Boolean,
          value: false
        }
      },

      observers: [
        '_observeSelectedItems(selectedItems)'
      ],

      _observeSelectedItems: function() {
        this.hidden = !this.selectedItems || (this.selectedItems.length === 0);
      },

      toogleSelectedItemsPopup: function() {
        this.$$('#selectedItemsPopup').toggle();
      },

      clearSelection: function() {
        this.fire('clear-selected-items');
      }
    });
  </script>

</dom-module>
<dom-module id="nuxeo-results" assetpath="nuxeo-results/">
  <template>

    <style>

      :host([loading]) .resultsCount {
        opacity: 0.1;
        transition: opacity 300ms ease-in-out;
      }

      .displayMode {
        @apply --nuxeo-action;
      }

      .displayMode:hover {
        @apply --nuxeo-action-hover;
      }

      .main {
        @apply --layout-vertical;
      }

      .resultActions, .viewModes, .rightHand {
        @apply --layout-horizontal;
        @apply --layout-center;
      }

      .resultActions, .rightHand {
        @apply --layout-wrap;
      }

      .rightHand {
        @apply --layout-flex;
        @apply --layout-end-justified;
      }

      .resultActions {
        margin-bottom: 16px;
        min-height: 38px;
      }

      .resultActions paper-icon-button {
        width: 2em;
        height: 2em;
        padding: .3em;
        margin-left: 4px;
      }

      .resultsCount {
        opacity: 0.5;
        margin-right: 16px;
        transition: opacity 100ms ease-in-out;
      }

      paper-icon-button[selected] {
        color: var(--icon-toggle-outline-color, var(--nuxeo-action-color-activated));
      }

      nuxeo-actions-menu {
        height: 100%;
        max-width: var(--nuxeo-results-selection-actions-menu-max-width, 240px);
      }

      nuxeo-quick-filters {
        margin-right: 16px;
      }

    </style>

    <nuxeo-connection id="nxcon"></nuxeo-connection>

    <div class="main">

      <nuxeo-selection-toolbar id="toolbar" selected-items="[[selectedItems]]" class="toolbar" on-refresh="_refreshAndFetch" on-refresh-display="_refreshDisplay" on-clear-selected-items="_clearSelectedItems">

        <nuxeo-actions-menu>
          <slot name="selectionActions"></slot>
          <nuxeo-slot slot="RESULTS_SELECTION_ACTIONS" model="[[actionContext]]"></nuxeo-slot>
        </nuxeo-actions-menu>

      </nuxeo-selection-toolbar>

      <div class="resultActions" hidden$="[[hideContentViewActions]]">

        <template is="dom-if" if="[[_displaySort(displaySort, view)]]">
          <nuxeo-sort-select options="[[_sortOptions(view, sortOptions)]]" selected="{{sortSelected}}" on-sort-order-changed="_sortChanged"></nuxeo-sort-select>
        </template>
        <template is="dom-if" if="[[_displayQuickFilters(displayQuickFilters, view)]]">
          <nuxeo-quick-filters quick-filters="{{quickFilters}}" on-quick-filters-changed="fetch">
          </nuxeo-quick-filters>
        </template>
        <span class="resultsCount" hidden$="[[!_showResultsCount(nxProvider, resultsCount)]]">[[i18n('results.heading.count', resultsCount)]]</span>

        <div class="rightHand">
          <slot name="actions"></slot>

          <nuxeo-slot slot="DOCUMENT_LISTING_ACTIONS" model="[[actionContext]]"></nuxeo-slot>

          <nuxeo-slot slot="RESULTS_ACTIONS" model="[[actionContext]]"></nuxeo-slot>

          <div class="viewModes">
            <template is="dom-repeat" items="[[_displayModes]]">
              <paper-icon-button class="displayMode" icon="[[item.icon]]" title$="[[_displayModeTitle(item, i18n)]]" selected$="[[_isCurrentDisplayMode(item, displayMode)]]" disabled$="[[_isCurrentDisplayMode(item, displayMode)]]" on-tap="_toggleDisplayMode">
              </paper-icon-button>
            </template>
          </div>
        </div>

      </div>

      <iron-pages id="views" attr-for-selected="name" selected="{{displayMode}}" selected-item="{{view}}" on-iron-items-changed="_updateViews">
        <slot></slot>
      </iron-pages>

    </div>

    <iron-localstorage id="prefStorage" name="[[_localStorageName]]" value="{{_settings}}" on-iron-localstorage-load="restoreSettings" on-iron-localstorage-load-empty="initializeSettings" auto-save-disabled="">
    </iron-localstorage>

  </template>

  <script>
    Polymer({
      is: 'nuxeo-results',
      behaviors: [Nuxeo.RoutingBehavior, Nuxeo.FormatBehavior],
      properties: {
        /**
         * the page provider to display results for
         */
        nxProvider: {
          type: Object,
          observer: '_providerChanged',
        },

        /**
         * Used as key for settings in local storage. Without a `name`, no settings are saved/restored.
         */
        name: String,

        /**
         * Active display mode. If no `displayMode` is specified, it will fallback to the first display mode found.
         */
        displayMode: {
          type: String,
          notify: true
        },

        view: {
          type: Object,
          observer: '_viewChanged'
        },

        /**
         * Document available in the action context.
         */
        document: Object,

        actionContext: {
          type: Object,
          notify: true
        },
        _settings: {
          type: Object
        },
        selectedItems: {
          type: Array,
          value: [],
          notify: true
        },
        columns: {
          type: Array,
          value: []
        },
        hideContentViewActions: {
          type: Boolean,
          value: false,
          reflectToAttribute: true
        },
        /**
         * If enabled, it displays the list of quickfilters defined on the associated
         * page provider at the top of the search results.
         */
        displayQuickFilters: {
          type: Boolean,
          value: false,
        },
        /**
         * Specify here a subset of quick filters in case you want to
         * specify the ones to be displayed on the search results.
         * Expected format : ['quickfilter1','quickfilter2']
         */
        quickFilters: {
          type: Array
        },
        /**
         * If enabled, it allows to sort the results of the search results.
         */
        displaySort: {
          type: Boolean,
          value: false,
        },
        /**
         * Sort option selected by default (can retrieve the one configured in sort-options).
         */
        sortSelected: {
          type: Object,
          observer: '_sortSelectedChanged',
        },
        /**
         * List of properties available to sort the result list.
         * It should be formatted as a JSON array of objects like:
         * ```
         * [
         *   {field: 'dc:title', label: this.i18n('searchResults.sort.field.title'), order: 'asc'},
         *   {field: 'dc:created', label: this.i18n('searchResults.sort.field.created'), order: 'asc', selected: true}
         * ]
         * ```
         */
        sortOptions: {
          type: Array,
          value: [],
        },

        resultsCount: {
          type: Number,
        },

        /**
         * `true` if results are being loaded.
         */
        loading: {
          type: Boolean,
          reflectToAttribute: true,
          notify: true,
          readOnly: true,
          value: false,
        },


        _displayModes:  Array,

        _localStorageName: String

      },

      observers: [
        '_updateStorage(name)',
        '_updateActionContext(displayMode, nxProvider.*, nxProvider.sort.*, selectedItems, columns, document)'
      ],

      listeners: {
        'settings-changed': '_updateActionContext'
      },

      ready: function() {
        this.$.nxcon.connect().then(this._updateStorage.bind(this));
      },

      get items() {
        if (this.view && this.view.items) {
          return this.view.items;
        }
        // XXX: this.view.items is not working
        return (this.view && this.view.$.list) ? this.view.$.list.items : [];
      },

      detached: function() {
        if (this.view) {
          this.unlisten(this.view, 'columns-changed', '_columnsChanged');
          this.unlisten(this.view, 'selected-items-changed', '_selectedItemsChanged');
          this.unlisten(this.view, 'settings-changed', '_saveViewSettings');
        }
        this.columns = [];
        this.view = null;
      },

      _displayQuickFilters: function() {
        // XXX check previous view properties for compatibility
        return this.view && !this.view.handlesFiltering &&
          (this.view.hasAttribute('display-quick-filters') || this.displayQuickFilters);
      },

      _displaySort: function() {
        // XXX check previous view properties for compatibility
        return this.view && !this.view.handlesSorting && (this.view.hasAttribute('display-sort') || this.displaySort);
      },

      _sortOptions: function() {
        // XXX check previous view properties for compatibility
        return (this.view && this.view.sortOptions) || this.sortOptions;
      },

      _sortChanged: function() {
        if (this.sortSelected && this.nxProvider) {
          var sort = {};
          sort[this.sortSelected.field] = this.sortSelected.order;
          this.nxProvider.sort = sort;
          this.fetch();
        }
      },

      _sortSelectedChanged: function(newSort, oldSort) {
        // do not trigger fetch results when sort options are being initialized
        if (newSort && oldSort) {
          this._sortChanged();
        }
      },

      fetch: function() {
        return new Promise(function(resolve, error) {
          this.debounce('fetch', function() {
            if (this.view) {
              this.view.fetch().then(resolve).catch(error);
            } else {
              resolve();
            }
          }.bind(this), 100);
        }.bind(this));
      },

      reset: function() {
        if (this.view) {
          this.view.reset();
        }
      },

      _viewChanged: function(view, oldView) {
        if (oldView) {
          this.unlisten(oldView, 'columns-changed', '_columnsChanged');
          this.unlisten(oldView, 'selected-items-changed', '_selectedItemsChanged');
          this.unlisten(oldView, 'settings-changed', '_saveViewSettings');
          this.unlisten(oldView, 'items-changed', '_itemsChanged');
          this.unlisten(oldView, 'quick-filters-changed', '_quickFiltersChanged');
        }
        if (view) {
          // initialize columns
          if (this.columns.length === 0 && Array.isArray(view.columns) && view.columns.length > 0) {
            this.set('columns', view.columns);
          }
          // restore settings
          if (this._settings) {
            this.set('_settings.displayMode', this.displayMode);
            this.saveSettings();
            view.settings = this._settings[this.displayMode];
          }
          // restore selection
          if (this.selectedItems) {
            this.selectedItems = []; // NXP-23186: this line removes selection synchronization between view modes
            this.selectItems(this.selectedItems.slice());
          }
          // listen for columns, settings and selection changed
          this.listen(view, 'columns-changed', '_columnsChanged');
          this.listen(view, 'selected-items-changed', '_selectedItemsChanged');
          this.listen(view, 'settings-changed', '_saveViewSettings');
          this.listen(view, 'items-changed', '_itemsChanged');
          this.listen(view, 'quick-filters-changed', '_quickFiltersChanged');
          view.nxProvider = this.nxProvider;
          // update view
          this.reset();
          this.fetch();
          this.fire('search-results-view', {view: view, name: this.name});
        }
      },

      _updateViews: function() {
        var hasDisplayMode;
        this._displayModes = [];
        this.$.views.items.forEach(function(view) {
          var name = view.getAttribute("name"),
              icon = view.getAttribute("icon");
          view.nxProvider = this.nxProvider;
          if (this._settings && view.settings) {
            view.settings = this._settings[name];
          }
          if (name === this.displayMode) {
            hasDisplayMode = true;
          }
          this.push('_displayModes', {name: name, icon: icon});
        }.bind(this));

        // if current selected display mode is not available use the first one
        if (!hasDisplayMode) {
          this.displayMode = this._displayModes[0] && this._displayModes[0].name;
        }

      },

      _displayModeTitle: function(item) {
        return this.i18n('displayModeButton.display.' + item.name);
      },

      _isCurrentDisplayMode: function(item) {
        return item.name === this.displayMode;
      },

      _toggleDisplayMode: function(e) {
        this.displayMode = e.model.item.name;
      },

      _refreshAndFetch: function() {
        if (this.view) {
          this.view.reset();
          this.fetch();
        }
      },

      _updateStorage: function() {
        if (this.$.nxcon.user && this.name) {
          this._localStorageName = this.$.nxcon.user.id + '-nuxeo-results-' + this.name;
        }
      },

      _updateActionContext: function() {
        this.actionContext = {
          baseUrl: this.$.nxcon.url,
          displayMode: this.displayMode,
          nxProvider: this.nxProvider,
          selectedItems: this.selectedItems,
          items: this.items,
          columns: this.columns,
          document: this.document
        };
      },

      _clearSelectedItems: function() {
        this.clearSelection();
      },

      initializeSettings: function() {
        this._settings = {};
      },

      restoreSettings: function() {
        if (this._settings && this.name) {
          if (this._settings.displayMode && this._settings.displayMode.length > 0) {
            this.displayMode = this._settings.displayMode;
          }
          if (this._settings[this.displayMode] && this.view) {
            this.view.settings = this._settings[this.displayMode];
          }
        }
      },

      saveSettings: function() {
        if (this.name && this._localStorageName) {
          this.$.prefStorage.save();
        }
      },

      _columnsChanged: function(e) {
        this.columns = e.target.columns;
      },

      _selectedItemsChanged: function() {
        this.selectedItems = [];
        this.set('selectedItems', this.view.selectedItems);
      },

      _refreshDisplay: function(e) {
        this.refresh();

        if (this.selectedItems && this.selectedItems.length > 0) {
          var tmp = this.selectedItems.slice();
          this.selectedItems = [];
          if (e.detail.focusIndex || e.detail.focusIndex === 0) {
            this.selectItems(tmp);
            if (e.detail.focusIndex > -1) {
              this.view.focusOnIndexIfNotVisible && this.view.focusOnIndexIfNotVisible(e.detail.focusIndex);
            }
          }
        }
      },

      get size() {
        return this.view.size;
      },

      clearSelection: function() {
        this.view.clearSelection();
      },

      selectItems: function(items) {
        this.clearSelection();
        this.view.selectItems(items);
        this.view.notifyResize();
      },

      refresh: function() {
        this.view.notifyResize();
      },

      _saveViewSettings: function() {
        if (this.view.settings) {
          this.set('_settings.' + this.displayMode, this.view.settings);
          this.saveSettings();
        }
      },

      _providerChanged: function(provider, oldProvider) {
        if (oldProvider) {
          this.unlisten(oldProvider, 'loading-changed', '_loadingChanged');
        }
        if (provider) {
          this.listen(provider, 'loading-changed', '_loadingChanged');
          this._setLoading(provider.loading);
        }
      },

      _loadingChanged: function() {
        this._setLoading(this.nxProvider.loading);
      },

      _showResultsCount: function() {
        return this.nxProvider && this.resultsCount;
      },

      _itemsChanged: function(e) {
        if (this.nxProvider && e.detail.value) {
          this.resultsCount = this.nxProvider.resultsCount;
        }
      },

      _quickFiltersChanged: function(e) {
        if (this.nxProvider && e.detail.value) {
          this.quickFilters = this.nxProvider.quickFilters;
        }
      },
    });
  </script>

</dom-module>
<dom-module id="nuxeo-download-button" assetpath="bower_components/nuxeo-ui-elements/actions/">
  <template>
    <style include="nuxeo-action-button-styles"></style>

    <dom-if if="[[_isAvailable(document)]]">
      <template>
        <div class="action" on-click="_download">
          <paper-icon-button icon="[[icon]]" noink=""></paper-icon-button>
          <span class="label" hidden$="[[!showLabel]]">[[_label]]</span>
        </div>
        <nuxeo-tooltip>[[_label]]</nuxeo-tooltip>
      </template>
    </dom-if>

  </template>

  <script>
    {
      /**
       * A button element for downloading the main file from a document.
       *
       * Example:
       *
       *     <nuxeo-download-button document="[[document]]"></nuxeo-download-button>
       *
       * @appliesMixin Nuxeo.FormatBehavior
       * @appliesMixin Nuxeo.FiltersBehavior
       * @memberof Nuxeo
       * @demo demo/nuxeo-download-button/index.html
       */
      class DownloadButton extends Polymer.mixinBehaviors([Nuxeo.FormatBehavior, Nuxeo.FiltersBehavior], Nuxeo.Element) {

        static get is() {
          return 'nuxeo-download-button';
        }

        static get properties() {
          return {
            /**
             * Input document.
             */
            document: Object,

            /**
             * Icon to use (iconset_name:icon_name).
             */
            icon: {
              type: String,
              value: 'nuxeo:download',
            },

            /**
             *
             * Path of the file object to download.
             * For example `xpath="files:files/0/file"`.
             */
            xpath: {
              type: String,
              value: 'file:content',
            },

            /**
             * `true` if the action should display the label, `false` otherwise.
             */
            showLabel: {
              type: Boolean,
              value: false,
            },

            _label: {
              type: String,
              computed: '_computeLabel(i18n)',
            },
          };
        }

        _isAvailable(doc) {
          return this.hasContent(doc, this.formatPropertyXpath(this.xpath));
        }

        _computeLabel() {
          return this.i18n('downloadButton.tooltip');
        }

        _download() {
          const blob = this.document && this._deepFind(this.document.properties, this.xpath);
          if (blob) {
            location.href = blob.data;
          }
        }

        _deepFind(obj, props) {
          for (let i = 0, path = props.split('/'), len = path.length; i < len; i++) {
            if (!obj || obj === []) {
              break;
            }
            obj = obj[path[i]];
          }
          return obj;
        }

      }

      customElements.define(DownloadButton.is, DownloadButton);
      Nuxeo.DownloadButton = DownloadButton;
    }
  </script>

</dom-module>
<dom-module id="nuxeo-favorites-toggle-button" assetpath="bower_components/nuxeo-ui-elements/actions/">
  <template>
    <style include="nuxeo-action-button-styles">
      :host([favorite]) paper-icon-button {
        color: var(--icon-toggle-pressed-color, var(--nuxeo-action-color-activated));
      }
    </style>

    <nuxeo-operation id="opAdd" op="Document.AddToFavorites" input="[[document.uid]]"></nuxeo-operation>
    <nuxeo-operation id="opRemove" op="Document.RemoveFromFavorites" input="[[document.uid]]"></nuxeo-operation>

    <dom-if if="[[_isAvailable(document)]]">
      <template>
        <div class="action">
          <paper-icon-button icon="[[icon]]" noink=""></paper-icon-button>
          <span class="label" hidden$="[[!showLabel]]">[[_label]]</span>
        </div>
        <nuxeo-tooltip>[[_label]]</nuxeo-tooltip>
      </template>
    </dom-if>

  </template>

  <script>
    {
      /**
       * A toggle button element for adding/removing a document from the favorites.
       *
       * Example:
       *
       *     <nuxeo-favorites-toggle-button document="[[document]]"></nuxeo-favorites-toggle-button>
       *
       * @appliesMixin Nuxeo.I18nBehavior
       * @appliesMixin Nuxeo.FiltersBehavior
       * @memberof Nuxeo
       * @demo demo/nuxeo-favorites-toggle-button/index.html
       */
      class FavoritesToggleButton
        extends Polymer.mixinBehaviors([Nuxeo.I18nBehavior, Nuxeo.FiltersBehavior], Nuxeo.Element) {

        static get is() {
          return 'nuxeo-favorites-toggle-button';
        }

        static get properties() {
          return {
            /**
             * Input document.
             */
            document: {
              type: Object,
              observer: '_documentChanged',
            },

            /**
             * Icon to use (iconset_name:icon_name).
             */
            icon: {
              type: String,
              value: 'nuxeo:favorites',
            },

            favorite: {
              type: Boolean,
              notify: true,
              reflectToAttribute: true,
            },

            /**
             * `true` if the action should display the label, `false` otherwise.
             */
            showLabel: {
              type: Boolean,
              value: false,
            },

            _label: {
              type: String,
              computed: '_computeLabel(favorite, i18n)',
            },
          };
        }

        ready() {
          super.ready();
          this.removeFromFavoritesHandler = (e) => {
            if (this.document && e.detail.docUid && e.detail.docUid === this.document.uid) {
              this.favorite = false;
            }
          };
          window.addEventListener('removed-from-favorites', this.removeFromFavoritesHandler);
          this.addEventListener('click', this._toggle);
        }

        disconnectedCallback() {
          super.disconnectedCallback();
          window.removeEventListener('removed-from-favorites', this.removeFromFavoritesHandler);
          this.removeFromFavoritesHandler = null;
        }

        _isAvailable(doc) {
          return this.isCollectionMember(doc);
        }

        _toggle() {
          if (!this.favorite) {
            this.$.opAdd.execute().then(() => {
              this.dispatchEvent(new CustomEvent('added-to-favorites', {
                composed: true,
                bubbles: true,
                detail: { doc: this.document },
              }));
              this.favorite = true;
            });
          } else {
            this.$.opRemove.execute().then(() => {
              this.dispatchEvent(new CustomEvent('removed-from-favorites', {
                composed: true,
                bubbles: true,
                detail: { doc: this.document },
              }));
              this.favorite = false;
            });
          }
        }

        _computeLabel(favorite) {
          return this.i18n(`favoritesToggleButton.tooltip.${favorite ? 'remove' : 'add'}`);
        }

        _documentChanged() {
          this.favorite = this.isFavorite(this.document);
        }

      }

      customElements.define(FavoritesToggleButton.is, FavoritesToggleButton);
      Nuxeo.FavoritesToggleButton = FavoritesToggleButton;
    }
  </script>

</dom-module>
<dom-module id="nuxeo-document-grid-thumbnail" assetpath="nuxeo-data-grid/">
  <template>

    <style>
      :host {
        outline: none;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        cursor: pointer;
      }

      a {
        @apply --nuxeo-link;
      }

      .bubbleBox {
        display: block;
        margin: 0 .4em .8em;
        position: relative;
        width: 220px;
        height: 260px;
        background-color: var(--nuxeo-box);
        box-shadow: 0 3px 5px rgba(0,0,0,0.04);;
        padding: 0;
        filter: 0.1s ease-out, filter 0.1s ease-out;
        -webkit-filter: 0.1s ease-out, filter 0.1s ease-out;
        border: 2px solid transparent;
      }

      .bubbleBox:hover,
      .bubbleBox:focus {
        z-index: 500;
        border: 2px solid var(--nuxeo-link-hover-color);
        box-shadow: 0 3px 5px rgba(0,0,0,0.04);
      }

      .bubbleBox .title {
        margin-bottom: .4em;
      }

      .bubbleBox:hover .title {
        color: var(--nuxeo-link-hover-color);
      }

      .thumbnailContainer {
        background-color: rgba(0,0,0,0.1);
        width: 100%;
        height: 190px;
        position: relative;
      }

      .thumbnailContainer img {
        height: auto;
        width: auto;
        max-height: 100%;
        max-width: 100%;
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        margin: auto;
      }

      .dataContainer {
        padding: .3em .8em;
      }

      .dataContainer p {
        margin: 0 0 .4em;
        font-size: .75rem;
      }

      .bubbleBox .select {
        display: none;
        position: absolute;
        top: 1rem;
        left: 1rem;
        border: 2px solid #ddd;
        background-color: var(--nuxeo-box);
        z-index: 2;
        border-radius: 3em;
      }

      .select paper-icon-button {
        margin: 0;
        padding: .3em;
        box-sizing: border-box;
      }

      .bubbleBox .select,
      .select paper-icon-button {
        width: 2.5em;
        height: 2.5em;
      }

      .select:hover paper-icon-button {
        color: #fff;
      }

      .title {
        text-overflow: ellipsis;
        overflow: hidden;
        white-space: nowrap;
        display: block;
      }

      .bubbleBox .actions {
        display: none;
        background-color: var(--nuxeo-box);
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        min-height: 2.5em;
      }

      .actions paper-icon-button iron-icon {
        @apply --nuxeo-action;
      }

      .actions paper-icon-button:hover iron-icon {
        @apply --nuxeo-action-hover;
      }

      .bubbleBox:hover .actions,
      .bubbleBox:hover .select,
      .bubbleBox[selection-mode] .select {
        display: block;
      }

      .bubbleBox:hover .select:hover {
        border: 2px solid var(--nuxeo-button-primary);
        background-color: var(--nuxeo-button-primary);
      }

      :host([selected]) .bubbleBox .select,
      :host([selected]) .bubbleBox:hover .select:hover {
        border: 2px solid var(--nuxeo-grid-selected);
        background-color: var(--nuxeo-grid-selected);
        display: block;
      }

      :host([selected]) .select paper-icon-button {
        color: #fff;
      }

      :host([selected]) .bubbleBox {
        border: 2px solid var(--nuxeo-grid-selected);
        box-shadow: 0 3px 5px rgba(0,0,0,0.04);
      }

      :host(.droptarget-hover) .bubbleBox {
        border: 2px dashed var(--nuxeo-grid-selected);
      }

    </style>

    <div class="bubbleBox grid-box" selection-mode$="[[selectionMode]]">
      <div class="thumbnailContainer" on-tap="handleClick">
        <img src="[[_thumbnail(doc)]]">
      </div>
      <template is="dom-if" if="[[_hasDocument(doc)]]">
        <a class="title" href$="[[urlFor('browse', doc.path)]]" on-tap="handleClick">
          <div class="dataContainer">
            <div class="title">[[doc.title]]</div>
            <nuxeo-tag>[[formatDocType(doc.type)]]</nuxeo-tag>
          </div>
        </a>
        <div class="actions">
          <nuxeo-favorites-toggle-button document="[[doc]]"></nuxeo-favorites-toggle-button>
          <nuxeo-download-button document="[[doc]]"></nuxeo-download-button>
        </div>
        <div class="select">
          <paper-icon-button noink="" icon="icons:check" title="select" on-tap="_onCheckBoxTap"></paper-icon-button>
        </div>
      </template>
    </div>

  </template>

  <script>
    Polymer({
      is: 'nuxeo-document-grid-thumbnail',
      behaviors: [Nuxeo.FormatBehavior, Nuxeo.RoutingBehavior],
      properties: {
        doc: {
          type: Object,
          notify: true
        },

        offset: {
          type: Number,
          value: -1
        },

        selected: {
          type: Boolean,
          value: false,
          reflectToAttribute: true
        },

        selectedItems: {
          type: Array,
          value: []
        },

        index: {
          type: Number
        }
      },

      observers: [
        '_selectedItemsChanged(selectedItems.splices)'
      ],

      _thumbnail: function(doc) {
        return doc && doc.uid && doc.contextParameters && doc.contextParameters.thumbnail &&
               doc.contextParameters.thumbnail.url ? doc.contextParameters.thumbnail.url : '';
      },

      handleClick: function(e) {
        if (this.selectionMode) {
          this._toogleSelect(e);
        } else if (!(e.ctrlKey || e.shiftKey || e.metaKey || e.button === 1)) {
          this.fire('navigate', {item: this.doc, index: this.index});
        }
      },

      _onCheckBoxTap: function(e) {
        this._toogleSelect(e);
      },

      _toogleSelect: function(e) {
        this.selected = !this.selected;
        this.fire('selected', {index: this.index, shiftKey: e.detail.sourceEvent.shiftKey});
      },

      _selectedItemsChanged: function(){
        this.selectionMode = this.selectedItems && this.selectedItems.length > 0;
      },

      _hasDocument: function() {
        return this.doc && this.doc.uid;
      }
    });
  </script>
</dom-module>
<dom-module id="nuxeo-default-results" assetpath="nuxeo-results/">
  <template>
    <style include="nuxeo-styles">

      nuxeo-data-table {
        min-height: calc(100vh - 9.3em);
      }

      nuxeo-data-grid, nuxeo-data-list {
        display: block;
        position: relative;
      }

      nuxeo-data-grid, nuxeo-data-list {
        min-height: calc(100vh - 8em);
      }

      .ellipsis {
        text-overflow: ellipsis;
        overflow: hidden;
        white-space: nowrap;
        display: block;
      }

      .capitalize {
        text-transform: capitalize;
      }
    </style>

    <nuxeo-results id="results" display-mode="table" name="[[name]]" nx-provider="[[nxProvider]]" selected-items="{{selectedItems}}" display-quick-filters="">

      <slot name="selectionActions" slot="selectionActions"></slot>

      <nuxeo-data-grid name="grid" icon="nuxeo:view-thumbnails" empty-label="[[emptyLabel]]" empty-label-when-filtered="[[emptyLabelWhenFiltered]]" selection-enabled="">
        <template>
          <nuxeo-document-grid-thumbnail class="grid-box" tabindex$="{{tabIndex}}" selected$="{{selected}}" selected-items="[[selectedItems]]" index="[[index]]" doc="[[item]]" on-navigate="_navigate">
          </nuxeo-document-grid-thumbnail>
        </template>
      </nuxeo-data-grid>

      <nuxeo-data-table name="table" icon="nuxeo:view-list" settings-enabled="" empty-label="[[emptyLabel]]" empty-label-when-filtered="[[emptyLabelWhenFiltered]]" selection-enabled="" on-row-clicked="_navigate">
        <nuxeo-data-table-column name="[[i18n('documentContentView.datatable.header.title')]]" field="dc:title" sort-by="dc:title" flex="100">
          <template>
            <nuxeo-document-thumbnail document="[[item]]"></nuxeo-document-thumbnail>
            <a class="title ellipsis" href$="[[urlFor('browse', item.path)]]" on-tap="_navigateLink" data-index="[[index]]">
              [[item.title]]
            </a>
          </template>
        </nuxeo-data-table-column>
        <nuxeo-data-table-column name="[[i18n('documentContentView.datatable.header.type')]]" field="type" hidden="">
          <template>
            <nuxeo-tag>[[formatDocType(item.type)]]</nuxeo-tag>
          </template>
        </nuxeo-data-table-column>
        <nuxeo-data-table-column name="[[i18n('documentContentView.datatable.header.modified')]]" field="dc:modified" sort-by="dc:modified" flex="50">
          <template>
            <nuxeo-date datetime="[[item.properties.dc:modified]]"></nuxeo-date>
          </template>
        </nuxeo-data-table-column>
        <nuxeo-data-table-column name="[[i18n('documentContentView.datatable.header.lastContributor')]]" field="dc:lastContributor" sort-by="dc:lastContributor" flex="50">
          <template>
            <nuxeo-user-tag user="[[item.properties.dc:lastContributor]]"></nuxeo-user-tag>
          </template>
        </nuxeo-data-table-column>
        <nuxeo-data-table-column name="[[i18n('documentContentView.datatable.header.state')]]" field="currentLifeCycleState" hidden="">
          <template><span class="capitalize">[[formatLifecycleState(item.state)]]</span></template>
        </nuxeo-data-table-column>
        <nuxeo-data-table-column name="[[i18n('documentContentView.datatable.header.version')]]" field="versionLabel" hidden="">
          <template>
            [[formatVersion(item)]]
          </template>
        </nuxeo-data-table-column>
        <nuxeo-data-table-column name="[[i18n('documentContentView.datatable.header.created')]]" field="dc:created" sort-by="dc:created" flex="50" hidden="">
          <template>
            <nuxeo-date datetime="[[item.properties.dc:created]]"></nuxeo-date>
          </template>
        </nuxeo-data-table-column>
        <nuxeo-data-table-column name="[[i18n('documentContentView.datatable.header.author')]]" field="dc:creator" sort-by="dc:creator" hidden="">
          <template>
            <nuxeo-user-tag user="[[item.properties.dc:creator]]"></nuxeo-user-tag>
          </template>
        </nuxeo-data-table-column>
        <nuxeo-data-table-column name="[[i18n('documentContentView.datatable.header.nature')]]" field="dc:nature" hidden="">
          <template>
            <nuxeo-tag hidden$="[[!item.properties.dc:nature]]">
              [[formatDirectory(item.properties.dc:nature)]]
            </nuxeo-tag>
          </template>
        </nuxeo-data-table-column>
        <nuxeo-data-table-column name="[[i18n('documentContentView.datatable.header.coverage')]]" field="dc:coverage" hidden="">
          <template>
            <nuxeo-tag hidden$="[[!item.properties.dc:coverage]]">
              [[formatDirectory(item.properties.dc:coverage)]]
            </nuxeo-tag>
          </template>
        </nuxeo-data-table-column>
        <nuxeo-data-table-column name="[[i18n('documentContentView.datatable.header.subjects')]]" field="dc:subjects" hidden="" flex="60">
          <template>
            <template is="dom-repeat" items="[[item.properties.dc:subjects]]" as="subject">
              <nuxeo-tag>[[formatDirectory(subject)]]</nuxeo-tag>
            </template>
          </template>
        </nuxeo-data-table-column>
      </nuxeo-data-table>
    </nuxeo-results>
  </template>
  <script>
    Polymer({
      is: 'nuxeo-default-results',
      behaviors: [Nuxeo.RoutingBehavior, Nuxeo.FormatBehavior],
      properties: {
        nxProvider: Object,

        name: String,

        selectedItems: {
          type: Array,
          notify: true
        },

        emptyLabel: String,
        emptyLabelWhenFiltered: String
      },

      _refreshAndFetch: function() {
        this.$.results._refreshAndFetch();
      },

      get items() {
        if (this.shadowRoot) {
          return this.shadowRoot.querySelector('#results').items;
        }
        return null;
      },

      _navigate: function(e) {
        this.fire('navigate', {doc: (e.model || e.detail).item, index: (e.model || e.detail).index});
        e.stopPropagation();
      },

      _navigateLink: function(e) {
        e.detail = {item: this.items[e.target.dataIndex], index: e.target.dataIndex};
        this._navigate(e);
      }
    });
  </script>
</dom-module>
<dom-module id="nuxeo-document-content" assetpath="nuxeo-results/">
  <template>

    <style include="nuxeo-styles">
      :host {
        display: block;
      }

      .results {
        @apply --layout-vertical;
        @apply --layout-flex;
        min-height: var(--nuxeo-document-content-min-height, calc(100vh - 216px - var(--nuxeo-app-top)));
        margin-bottom: var(--nuxeo-document-content-margin-bottom, 0);
      }

      .results.dragging {
        border: 2px dashed var(--nuxeo-primary-color);
      }

      .ellipsis {
        text-overflow: ellipsis;
        overflow: hidden;
        white-space: nowrap;
        display: block;
        width: calc(100% - 38px);
      }

      .capitalize {
        text-transform: capitalize;
      }

      nuxeo-tag {
        margin-right: 2px;
      }
    </style>

    <nuxeo-connection id="nxcon"></nuxeo-connection>

    <nuxeo-page-provider id="nxProvider" provider="[[provider]]" page-size="[[pageSize]]" aggregations="{{aggregations}}" enrichers="[[enrichers]]" params="[[params]]" schemas="[[schemas]]" headers="[[headers]]" fetch-aggregates="">
    </nuxeo-page-provider>

    <nuxeo-results id="results" display-mode="table" name="[[document.uid]]" nx-provider="[[nxProvider]]" selected-items="{{selectedItems}}" document="[[document]]" display-quick-filters="" display-sort="[[_canSort(document, sortOptions)]]" sort-options="[[sortOptions]]">
      <nuxeo-data-grid name="grid" icon="nuxeo:view-thumbnails" class="results" empty-label="[[emptyLabel]]" empty-label-when-filtered="[[emptyLabelWhenFiltered]]" selection-enabled="" draggable$="[[_hasWritePermission(document)]]" drop-target-filter="[[_dropTargetFilter]]">
        <template>
          <nuxeo-document-grid-thumbnail class="grid-box" tabindex$="{{tabIndex}}" selected$="{{selected}}" index="[[index]]" doc="[[item]]" on-navigate="_navigate" selected-items="[[selectedItems]]">
          </nuxeo-document-grid-thumbnail>
        </template>
      </nuxeo-data-grid>

      <nuxeo-data-table name="table" icon="nuxeo:view-list" class="results" settings-enabled="" empty-label="[[emptyLabel]]" empty-label-when-filtered="[[emptyLabelWhenFiltered]]" selection-enabled="" on-row-clicked="_navigate" draggable$="[[_hasWritePermission(document)]]" drop-target-filter="[[_dropTargetFilter]]">
        <nuxeo-data-table-column name="[[i18n('documentContentView.datatable.header.title')]]" field="dc:title" sort-by="[[_displaySort(document, 'dc:title')]]" filter-by="title" flex="100">
          <template>
            <nuxeo-document-thumbnail document="[[item]]"></nuxeo-document-thumbnail>
            <a class="title ellipsis" href$="[[urlFor('browse', item.path)]]" on-tap="_navigate">[[item.title]]</a>
          </template>
        </nuxeo-data-table-column>
        <nuxeo-data-table-column name="[[i18n('documentContentView.datatable.header.type')]]" field="type" hidden="">
          <template>
            <nuxeo-tag>[[formatDocType(item.type)]]</nuxeo-tag>
          </template>
        </nuxeo-data-table-column>
        <nuxeo-data-table-column name="[[i18n('documentContentView.datatable.header.modified')]]" field="dc:modified" sort-by="[[_displaySort(document, 'dc:modified')]]" filter-by="dc_modified_agg" flex="50">
          <template is="header">
            <nuxeo-dropdown-aggregation placeholder="[[i18n('documentContentView.datatable.header.modified')]]" data="[[aggregations.dc_modified_agg]]" value="{{column.filterValue}}" multiple="">
            </nuxeo-dropdown-aggregation>
          </template>
          <template>
            <nuxeo-date datetime="[[item.properties.dc:modified]]"></nuxeo-date>
          </template>
        </nuxeo-data-table-column>
        <nuxeo-data-table-column name="[[i18n('documentContentView.datatable.header.lastContributor')]]" filter-by="dc_last_contributor_agg" field="dc:lastContributor" sort-by="[[_displaySort(document, 'dc:lastContributor')]]" flex="50">
          <template is="header">
            <nuxeo-dropdown-aggregation placeholder="[[i18n('documentContentView.datatable.header.lastContributor')]]" data="[[aggregations.dc_last_contributor_agg]]" value="{{column.filterValue}}" multiple="">
            </nuxeo-dropdown-aggregation>
          </template>
          <template>
            <nuxeo-user-tag user="[[item.properties.dc:lastContributor]]"></nuxeo-user-tag>
          </template>
        </nuxeo-data-table-column>
        <nuxeo-data-table-column name="[[i18n('documentContentView.datatable.header.state')]]" field="currentLifeCycleState" hidden="">
          <template><span class="capitalize">[[formatLifecycleState(item.state)]]</span></template>
        </nuxeo-data-table-column>
        <nuxeo-data-table-column name="[[i18n('documentContentView.datatable.header.version')]]" field="versionLabel" hidden="">
          <template>
            [[formatVersion(item)]]
          </template>
        </nuxeo-data-table-column>
        <nuxeo-data-table-column name="[[i18n('documentContentView.datatable.header.created')]]" field="dc:created" sort-by="[[_displaySort(document, 'dc:created')]]" flex="50" hidden="">
          <template>
            <nuxeo-date datetime="[[item.properties.dc:created]]"></nuxeo-date>
          </template>
        </nuxeo-data-table-column>
        <nuxeo-data-table-column name="[[i18n('documentContentView.datatable.header.author')]]" field="dc:creator" sort-by="[[_displaySort(document, 'dc:creator')]]" hidden="">
          <template>
            <nuxeo-user-tag user="[[item.properties.dc:creator]]"></nuxeo-user-tag>
          </template>
        </nuxeo-data-table-column>
        <nuxeo-data-table-column name="[[i18n('documentContentView.datatable.header.nature')]]" field="dc:nature" hidden="">
          <template>
            <nuxeo-tag hidden$="[[!item.properties.dc:nature]]">
              [[formatDirectory(item.properties.dc:nature)]]
            </nuxeo-tag>
          </template>
        </nuxeo-data-table-column>
        <nuxeo-data-table-column name="[[i18n('documentContentView.datatable.header.coverage')]]" field="dc:coverage" hidden="">
          <template>
            <nuxeo-tag hidden$="[[!item.properties.dc:coverage]]">
              [[formatDirectory(item.properties.dc:coverage)]]
            </nuxeo-tag>
          </template>
        </nuxeo-data-table-column>
        <nuxeo-data-table-column name="[[i18n('documentContentView.datatable.header.subjects')]]" field="dc:subjects" hidden="" flex="60">
          <template>
            <template is="dom-repeat" items="[[item.properties.dc:subjects]]" as="subject">
              <nuxeo-tag>[[formatDirectory(subject)]]</nuxeo-tag>
            </template>
          </template>
        </nuxeo-data-table-column>
      </nuxeo-data-table>
    </nuxeo-results>

  </template>

  <script>
    Polymer({
      is: 'nuxeo-document-content',
      behaviors: [Nuxeo.DocumentContentBehavior],
      properties: {
        /**
         * The parameters to be passed on to `provider`.
         */
        params: {
          type: Object
        },
        /**
         * The name of the page provider to be used.
         */
        provider: {
          type: String,
          value: 'advanced_document_content'
        },
        /**
         * The number of results per page.
         */
        pageSize: {
          type: Number,
          value: 40
        },
        /**
         * List of comma separated values of the document schemas to be returned.
         * All document schemas are returned by default.
         */
        schemas: {
          type: String,
          value: 'dublincore,common,uid,file'
        },
        /**
         * List of content enrichers passed on to `provider`.
         * Already set by default are thumbnail, permissions and highlight.
         */
        enrichers: {
          type: String,
          value: 'thumbnail, permissions'
        },
        /**
         * The headers passed on to `provider`.
         * Already set by default are 'X-NXfetch.document': 'properties' and 'X-NXtranslate.directoryEntry': 'label'.
         */
        headers: {
          type: String,
          value: {'X-NXfetch.document': 'properties', 'X-NXtranslate.directoryEntry': 'label'}
        },
        /**
         * The label to be dislayed when there are no results.
         */
        emptyLabel: String,
        /**
         * The label to be dislayed when there are no results with filtering applied.
         */
        emptyLabelWhenFiltered: String
      },

      _computeParams: function(document) {
        if (document) {
          if (this.hasFacet(document, 'Orderable')) {
            this.$.nxProvider.set('sort', { 'ecm:pos': 'ASC' });
          } else {
            this.$.nxProvider.set('sort', {});
          }
          return { 'ecm_parentId': document.uid, 'ecm_trashed': this.isTrashed(document) }
        }
        return {};
      }
    });
  </script>

</dom-module>
<dom-module id="nuxeo-document-trash-content" assetpath="nuxeo-results/">
  <template>

    <style include="nuxeo-styles">
      :host {
        display: block;
      }

      nuxeo-tag {
        margin-right: 2px;
      }

      .results {
        @apply --layout-vertical;
        @apply --layout-flex;
        min-height: var(--nuxeo-document-trash-content-min-height, calc(100vh - 168px - var(--nuxeo-app-top)));
        margin-bottom: var(--nuxeo-document-trash-content-margin-bottom, 0);
      }

      .ellipsis {
        text-overflow: ellipsis;
        overflow: hidden;
        white-space: nowrap;
        display: block;
        width: calc(100% - 38px);
      }

      .capitalize {
        text-transform: capitalize;
      }
    </style>

    <nuxeo-connection id="nxcon"></nuxeo-connection>

    <nuxeo-operation id="opEmptyTrash" op="Document.EmptyTrash" params="{&quot;parent&quot;: &quot;[[document.uid]]&quot;}" sync-indexing=""></nuxeo-operation>

    <nuxeo-page-provider id="nxProvider" provider="[[provider]]" page-size="[[pageSize]]" aggregations="{{aggregations}}" enrichers="[[enrichers]]" params="[[params]]" schemas="[[schemas]]" headers="[[headers]]" fetch-aggregates="">
    </nuxeo-page-provider>

    <nuxeo-results id="results" display-mode="table" name="[[document.uid]]-trashed" nx-provider="[[nxProvider]]" selected-items="{{selectedItems}}" document="[[document]]" display-quick-filters="" display-sort="" sort-options="[[sortOptions]]">

      <div slot="actions">
        <template is="dom-if" if="[[hasPermission(document, 'Everything')]]">
          <paper-button noink="" on-tap="_emptyTrash">[[i18n('documentTrashContent.emptyTrash')]]</paper-button>
        </template>
      </div>

      <nuxeo-data-grid name="grid" icon="nuxeo:view-thumbnails" class="results" empty-label="[[emptyLabel]]" empty-label-when-filtered="[[emptyLabelWhenFiltered]]" selection-enabled="">
        <template>
          <nuxeo-document-grid-thumbnail class="grid-box" tabindex$="{{tabIndex}}" selected$="{{selected}}" index="[[index]]" doc="[[item]]" on-navigate="_navigate" selected-items="[[selectedItems]]">
          </nuxeo-document-grid-thumbnail>
        </template>
      </nuxeo-data-grid>

      <nuxeo-data-table name="table" icon="nuxeo:view-list" class="results" settings-enabled="" empty-label="[[emptyLabel]]" empty-label-when-filtered="[[emptyLabelWhenFiltered]]" selection-enabled="" on-row-clicked="_navigate">
        <nuxeo-data-table-column name="[[i18n('documentContentView.datatable.header.title')]]" field="dc:title" sort-by="dc:title" filter-by="title" flex="100">
          <template>
            <nuxeo-document-thumbnail document="[[item]]"></nuxeo-document-thumbnail>
            <a class="title ellipsis" href$="[[urlFor('browse', item.path)]]" on-tap="_navigate">[[item.title]]</a>
          </template>
        </nuxeo-data-table-column>
        <nuxeo-data-table-column name="[[i18n('documentContentView.datatable.header.type')]]" field="type" hidden="">
          <template>
            <nuxeo-tag>[[item.type]]</nuxeo-tag>
          </template>
        </nuxeo-data-table-column>
        <nuxeo-data-table-column name="[[i18n('documentContentView.datatable.header.modified')]]" field="dc:modified" sort-by="dc:modified" filter-by="dc_modified_agg" flex="50">
          <template is="header">
            <nuxeo-dropdown-aggregation placeholder="[[i18n('documentContentView.datatable.header.modified')]]" data="[[aggregations.dc_modified_agg]]" value="{{column.filterValue}}" multiple="">
            </nuxeo-dropdown-aggregation>
          </template>
          <template>
            <nuxeo-date datetime="[[item.properties.dc:modified]]"></nuxeo-date>
          </template>
        </nuxeo-data-table-column>
        <nuxeo-data-table-column name="[[i18n('documentContentView.datatable.header.lastContributor')]]" filter-by="dc_last_contributor_agg" field="dc:lastContributor" sort-by="dc:lastContributor" flex="50">
          <template is="header">
            <nuxeo-dropdown-aggregation placeholder="[[i18n('documentContentView.datatable.header.lastContributor')]]" data="[[aggregations.dc_last_contributor_agg]]" value="{{column.filterValue}}" multiple="">
            </nuxeo-dropdown-aggregation>
          </template>
          <template>
            <nuxeo-user-tag user="[[item.properties.dc:lastContributor]]"></nuxeo-user-tag>
          </template>
        </nuxeo-data-table-column>
        <nuxeo-data-table-column name="[[i18n('documentContentView.datatable.header.state')]]" field="currentLifeCycleState" hidden="">
          <template><span class="capitalize">[[formatLifecycleState(item.state)]]</span></template>
        </nuxeo-data-table-column>
        <nuxeo-data-table-column name="[[i18n('documentContentView.datatable.header.version')]]" field="versionLabel" hidden="">
          <template>
            [[formatVersion(item)]]
          </template>
        </nuxeo-data-table-column>
        <nuxeo-data-table-column name="[[i18n('documentContentView.datatable.header.created')]]" field="dc:created" sort-by="dc:created" flex="50" hidden="">
          <template>
            <nuxeo-date datetime="[[item.properties.dc:created]]"></nuxeo-date>
          </template>
        </nuxeo-data-table-column>
        <nuxeo-data-table-column name="[[i18n('documentContentView.datatable.header.author')]]" field="dc:creator" sort-by="dc:creator" hidden="">
          <template>
            <nuxeo-user-tag user="[[item.properties.dc:creator]]"></nuxeo-user-tag>
          </template>
        </nuxeo-data-table-column>
        <nuxeo-data-table-column name="[[i18n('documentContentView.datatable.header.nature')]]" field="dc:nature" hidden="">
          <template>
            <nuxeo-tag hidden$="[[!item.properties.dc:nature]]">
              [[formatDirectory(item.properties.dc:nature)]]
            </nuxeo-tag>
          </template>
        </nuxeo-data-table-column>
        <nuxeo-data-table-column name="[[i18n('documentContentView.datatable.header.coverage')]]" field="dc:coverage" hidden="">
          <template>
            <nuxeo-tag hidden$="[[!item.properties.dc:coverage]]">
              [[formatDirectory(item.properties.dc:coverage)]]
            </nuxeo-tag>
          </template>
        </nuxeo-data-table-column>
        <nuxeo-data-table-column name="[[i18n('documentContentView.datatable.header.subjects')]]" field="dc:subjects" hidden="" flex="60">
          <template>
            <template is="dom-repeat" items="[[item.properties.dc:subjects]]" as="subject">
              <nuxeo-tag>[[formatDirectory(subject)]]</nuxeo-tag>
            </template>
          </template>
        </nuxeo-data-table-column>
      </nuxeo-data-table>

    </nuxeo-results>

  </template>

  <script>
    Polymer({
      is: 'nuxeo-document-trash-content',
      behaviors: [Nuxeo.DocumentContentBehavior],
      properties: {
        /**
         * The name of the page provider to be used.
         */
        provider: {
          type: String,
          value: 'advanced_document_content'
        },
        /**
         * The number of results per page.
         */
        pageSize: {
          type: Number,
          value: 40
        },
        /**
         * List of comma separated values of the document schemas to be returned.
         * All document schemas are returned by default.
         */
        schemas: {
          type: String,
          value: 'dublincore,common,uid,file'
        },
        /**
         * List of content enrichers passed on to `provider`.
         * Already set by default are thumbnail, permissions and highlight.
         */
        enrichers: {
          type: String,
          value: 'thumbnail, permissions'
        },
        /**
         * The headers passed on to `provider`.
         * Already set by default are 'X-NXfetch.document': 'properties' and 'X-NXtranslate.directoryEntry': 'label'.
         */
        headers: {
          type: String,
          value: {'X-NXfetch.document': 'properties', 'X-NXtranslate.directoryEntry': 'label'}
        },
        /**
         * The label to be dislayed when there are no results.
         */
        emptyLabel: String,
        /**
         * The label to be dislayed when there are no results with filtering applied.
         */
        emptyLabelWhenFiltered: String
      },

      _emptyTrash: function() {
        this.$.opEmptyTrash.execute().then(function() {
          this.fire('notify', { message: this.i18n('documentTrashContent.emptyTrash.success') });
          this._refresh();
        }.bind(this)).catch(function(error) {
          this.fire('notify', { message: this.i18n('documentTrashContent.emptyTrash.error') });
          if (error.status !== 404) {
            throw error;
          }
        }.bind(this));
      },

      _computeParams: function(document) {
        return document ? {'ecm_parentId': document.uid, 'ecm_trashed': true} : {};
      },

      _computeSortOptions: function() {
        return [
          {field: 'dc:title', label: this.i18n('searchResults.sort.field.title'), order: 'asc'},
          {field: 'dc:created', label: this.i18n('searchResults.sort.field.created'), order: 'asc', selected: true},
          {field: 'dc:modified', label: this.i18n('searchResults.sort.field.modified'), order: 'desc'},
          {field: 'dc:lastContributor', label: this.i18n('searchResults.sort.field.lastContributor'), order: 'asc'}
        ];
      }

    });
  </script>

</dom-module>
<dom-module id="nuxeo-document-highlights" assetpath="nuxeo-document-highlight/">
  <template>

    <style>
      .category {
        opacity: .7;
        text-transform: uppercase;
        font-size: .75rem;
        padding-right: .5rem;
      }

      .segment em {
        color: var(--nuxeo-result-highlight, #0066CC);
        font-weight: bold;
        font-style: normal;
        border-bottom: 1px solid var(--nuxeo-result-highlight, #0066CC);
      }

      .segment + .segment::before {
        display: inline-block;
        content: '...';
      }
    </style>

    <div class="highlights" id="highlights">
      <template is="dom-repeat" items="[[highlights]]" as="highlight">
        <div class="highlight">
          <span class="category">[[_highlightFieldLabel(highlight)]]</span>
          <span class="segments">
            <template is="dom-repeat" items="[[highlight.segments]]" as="segment">
              <span class="segment">
                <template is="dom-repeat" items="[[_segmentOc(segment)]]" as="segmentOc">
                    [[_preSegment(segmentOc)]]
                    <em>
                      [[_segment(segmentOc)]]
                    </em>
                    [[_postSegment(segmentOc)]]
                </template>
              </span>
            </template>
          </span>
        <div>
      </div></div></template>
    </div>

  </template>

  <script>
    Polymer({
      is: 'nuxeo-document-highlights',
      behaviors: [Nuxeo.I18nBehavior],
      properties: {
        highlights: {
          type: Array
        }
      },

      _highlightFieldLabel: function(highlight) {
        return this.i18n('searchResults.highlight.field.' + highlight.field);
      },

      _preSegment: function(segment) {
        var soEmIdx = segment.indexOf('<em>');
        if (soEmIdx > -1) {
          return segment.substring(0, soEmIdx);
        } else {
          return segment;
        }
      },

      _segment: function(segment) {
        var soEmIdx = segment.indexOf('<em>');
        var eoEmIdx = segment.indexOf('</em>');
        if (soEmIdx > -1 && eoEmIdx > -1) {
          return segment.substring(soEmIdx + 4, eoEmIdx);
        } else {
          return '';
        }
      },

      _segmentOc: function(segment) {
        var segmentOc = [];
        segment.split('<em>').forEach(function(item, idx) {
          segmentOc.push(idx > 0 ? '<em>' + item: item);
        });
        return segmentOc;
      },

      _postSegment: function(segment) {
        var eoEmIdx = segment.indexOf('</em>');
        if (eoEmIdx > -1) {
          return segment.substring(eoEmIdx + 5, segment.length);
        } else {
          return '';
        }
      }
    });
  </script>
</dom-module>
<dom-module id="nuxeo-document-list-item" assetpath="nuxeo-data-list/">
  <template>

    <style include="iron-flex iron-flex-alignment">
      :host {
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        cursor: pointer;
      }

      .listBox {
        display: block;
        margin: 0 .4em .8em;
        position: relative;
        background-color: var(--nuxeo-box);
        box-shadow: 0 3px 5px rgba(0,0,0,0.04);;
        padding: 0;
        filter: 0.1s ease-out, filter 0.1s ease-out;
        -webkit-filter: 0.1s ease-out, filter 0.1s ease-out;
        border: 2px solid transparent;
      }

      .listBox:hover,
      .listBox:focus {
        border: 2px solid var(--nuxeo-link-hover-color);
        box-shadow: 0 3px 5px rgba(0,0,0,0.04);
      }

      .listBox .title {
        margin-bottom: .4em;
      }

      .listBox:hover .title {
        color: var(--nuxeo-link-hover-color);
      }

      .thumbnailContainer {
        background-color: rgba(0,0,0,0.1);
        width: 10rem;
        height: 10rem;
        position: relative;
      }

      .thumbnailContainer img {
        height: auto;
        width: auto;
        max-height: 100%;
        max-width: 100%;
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        margin: auto;
      }

      .dataContainer {
        padding: .5rem 1rem;
      }

      .dataContainer p {
        margin: 0 0 .4em;
        font-size: .75rem;
      }

      .listBox .select {
        display: none;
        position: absolute;
        top: 1rem;
        left: 1rem;
        border: 2px solid #ddd;
        background-color: var(--nuxeo-box);
        z-index: 2;
        border-radius: 3em;
      }

      .select paper-icon-button {
        margin: 0;
        padding: .3em;
        box-sizing: border-box;
      }

      .listBox .select,
      .select paper-icon-button {
        width: 2.5em;
        height: 2.5em;
      }

      .select:hover paper-icon-button {
        color: #fff;
      }

      .title {
        text-overflow: ellipsis;
        overflow: hidden;
        white-space: nowrap;
        display: block;
      }

      .listBox .actions {
        display: none;
        background-color: var(--nuxeo-box);
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        min-height: 2.5em;
        width: 10rem;
      }

      .actions ::content paper-icon-button ::content iron-icon {
        @apply --nuxeo-action;
      }

      .actions ::content paper-icon-button:hover ::content iron-icon {
        @apply --nuxeo-action-hover;
      }

      .listBox:hover .actions,
      .listBox:hover .select,
      .listBox[selection-mode] .select {
        display: block;
      }

      .listBox:hover .select:hover {
        border: 2px solid var(--nuxeo-button-primary);
        background-color: var(--nuxeo-button-primary);
      }

      :host([selected]) .listBox .select,
      :host([selected]) .listBox:hover .select:hover {
        border: 2px solid var(--nuxeo-grid-selected);
        background-color: var(--nuxeo-grid-selected);
        display: block;
      }

      :host([selected]) .select paper-icon-button {
        color: #fff;
      }

      :host([selected]) .listBox {
        border: 2px solid var(--nuxeo-grid-selected);
        box-shadow: 0 3px 5px rgba(0,0,0,0.04);
      }

      :host(.droptarget-hover) .listBox {
        border: 2px dashed var(--nuxeo-grid-selected);
      }

      .typeSelection paper-button {
        width: var(--nuxeo-document-creation-form-button-width, 128px);
        height: var(--nuxeo-document-creation-form-button-height, 128px);
        box-shadow: none;
        background-color: var(--nuxeo-dialog-buttons-bar);
      }

      nuxeo-document-highlights {
        font-size: .85rem;
      }

      .vignette {
        display: flex;
      }

    </style>

    <div class="listBox grid-box" selection-mode$="[[selectionMode]]">
      <div class="horizontal layout">
        <div class="vignette thumbnailContainer" on-tap="handleClick">
          <img src="[[_thumbnail(doc)]]">
        </div>
        <div class="dataContainer flex" on-tap="handleClick">
          <div class="horizontal layout center">
            <a class="title flex">
              <div class="title">[[doc.title]]</div>
            </a>
            <nuxeo-tag>[[formatDocType(doc.type)]]</nuxeo-tag>
          </div>
          <nuxeo-document-highlights highlights="[[doc.contextParameters.highlight]]"></nuxeo-document-highlights>
        </div>
        <div class="actions">
          <nuxeo-favorites-toggle-button document="[[doc]]"></nuxeo-favorites-toggle-button>
          <nuxeo-download-button document="[[doc]]"></nuxeo-download-button>
        </div>
        <div class="select">
          <paper-icon-button noink="" icon="icons:check" title="select" on-tap="_onCheckBoxTap"></paper-icon-button>
        </div>
      </div>
    </div>

  </template>

  <script>
    Polymer({
      is: 'nuxeo-document-list-item',
      behaviors: [Nuxeo.FormatBehavior, Nuxeo.RoutingBehavior],
      properties: {
        doc: {
          type: Object,
          notify: true
        },

        offset: {
          type: Number,
          value: -1
        },

        selected: {
          type: Boolean,
          value: false,
          reflectToAttribute: true
        },

        selectedItems: {
          type: Array,
          value: []
        },

        index: {
          type: Number
        }
      },

      observers: [
        '_selectedItemsChanged(selectedItems.splices)'
      ],

      _thumbnail: function(doc) {
        return doc && doc.uid && doc.contextParameters && doc.contextParameters.thumbnail &&
               doc.contextParameters.thumbnail.url ? doc.contextParameters.thumbnail.url : '';
      },

      handleClick: function(e) {
        if (this.selectionMode) {
          this._toogleSelect(e);
        } else if (!(e.ctrlKey || e.shiftKey || e.metaKey || e.button === 1)) {
          this.fire('navigate', {item: this.doc, index: this.index});
        }
      },

      _onCheckBoxTap: function(e) {
        this._toogleSelect(e);
      },

      _toogleSelect: function(e) {
        this.selected = !this.selected;
        this.fire('selected', {index: this.index, shiftKey: e.detail.sourceEvent.shiftKey});
      },

      _selectedItemsChanged: function() {
        this.selectionMode = this.selectedItems && this.selectedItems.length > 0;
      }
    });
  </script>
</dom-module>
<dom-module id="paper-fab" assetpath="bower_components/paper-fab/">
  <template strip-whitespace="">
    <style include="paper-material-styles">
      :host {
        @apply --layout-vertical;
        @apply --layout-center-center;

        background: var(--paper-fab-background, var(--accent-color));
        border-radius: 50%;
        box-sizing: border-box;
        color: var(--text-primary-color);
        cursor: pointer;
        height: 56px;
        min-width: 0;
        outline: none;
        padding: 16px;
        position: relative;
        -moz-user-select: none;
        -ms-user-select: none;
        -webkit-user-select: none;
        user-select: none;
        width: 56px;
        z-index: 0;

        /* NOTE: Both values are needed, since some phones require the value `transparent`. */
        -webkit-tap-highlight-color: rgba(0,0,0,0);
        -webkit-tap-highlight-color: transparent;

        @apply --paper-fab;
      }

      [hidden] {
        display: none !important;
      }

      :host([mini]) {
        width: 40px;
        height: 40px;
        padding: 8px;

        @apply --paper-fab-mini;
      }

      :host([disabled]) {
        color: var(--paper-fab-disabled-text, var(--paper-grey-500));
        background: var(--paper-fab-disabled-background, var(--paper-grey-300));

        @apply --paper-fab-disabled;
      }

      iron-icon {
        @apply --paper-fab-iron-icon;
      }

      span {
        width: 100%;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        text-align: center;

        @apply --paper-fab-label;
      }

      :host(.keyboard-focus) {
        background: var(--paper-fab-keyboard-focus-background, var(--paper-pink-900));
      }

      :host([elevation="1"]) {
        @apply --paper-material-elevation-1;
      }

      :host([elevation="2"]) {
        @apply --paper-material-elevation-2;
      }

      :host([elevation="3"]) {
        @apply --paper-material-elevation-3;
      }

      :host([elevation="4"]) {
        @apply --paper-material-elevation-4;
      }

      :host([elevation="5"]) {
        @apply --paper-material-elevation-5;
      }
    </style>

    <iron-icon id="icon" hidden$="{{!_computeIsIconFab(icon, src)}}" src="[[src]]" icon="[[icon]]"></iron-icon>
    <span hidden$="{{_computeIsIconFab(icon, src)}}">{{label}}</span>
  </template>

  <script>
    Polymer({
      is: 'paper-fab',

      behaviors: [
        Polymer.PaperButtonBehavior
      ],

      properties: {
        /**
         * The URL of an image for the icon. If the src property is specified,
         * the icon property should not be.
         */
        src: {
          type: String,
          value: ''
        },

        /**
         * Specifies the icon name or index in the set of icons available in
         * the icon's icon set. If the icon property is specified,
         * the src property should not be.
         */
        icon: {
          type: String,
          value: ''
        },

        /**
         * Set this to true to style this is a "mini" FAB.
         */
        mini: {
          type: Boolean,
          value: false,
          reflectToAttribute: true
        },

        /**
         * The label displayed in the badge. The label is centered, and ideally
         * should have very few characters.
         */
        label: {
          type: String,
          observer: '_labelChanged'
        }
      },

      _labelChanged: function() {
        this.setAttribute('aria-label', this.label);
      },

      _computeIsIconFab: function(icon, src) {
        return (icon.length > 0) || (src.length > 0);
      }
    });
  </script>
</dom-module>
<dom-module id="nuxeo-keys" assetpath="nuxeo-keys/">
  <template>
    <iron-a11y-keys id="a11y" keys="[[keys]]" target="[[target]]" on-keys-pressed="_keysPressed"></iron-a11y-keys>
  </template>
</dom-module>

<script>
  (function() {
    Polymer({
      is: 'nuxeo-keys',

      properties: {
        /**
         * Space delimited list of keys to listen.
         */
        keys: {
          type: String,
        },

        /**
         * Target node where keys will be listened.
         * By default: body
         */
        target: {
          type: Object,
          value: function() {
            return document.body;
          }
        },

        invasive: {
          type: Boolean,
          value: false,
        },
      },

      _keysPressed: function(e) {
        var keyboardEvent = e.detail.keyboardEvent;
        if (this._getMatchingKeyBindings(keyboardEvent).length === 0) {
          return;
        }

        if (this.target === document.body) {
          var element = keyboardEvent.composedPath()[0];
          switch (element.tagName) {
            case 'INPUT':
            case 'TEXTAREA':
              if (!this.invasive) {
                return;
              }
              break;
            case 'DIV':
              if (!this.invasive && element.isContentEditable) {
                return;
              }
              if (element.id === 'input') {
                e.preventDefault();
                return;
              }
              break;
            case 'NUXEO-DIALOG':
            case 'PAPER-DIALOG':
            case 'PAPER-BUTTON':
            case 'PAPER-CHECKBOX':
            case 'PAPER-RADIO-BUTTON':
              e.preventDefault();
              return;
          }
        }
        this.fire('pressed', e.detail, {});
      },

      _getMatchingKeyBindings: function(keyboardEvent) {
        return this.$.a11y._keyBindings[keyboardEvent.type].filter(function(entry) {
          var bind = entry[0];
          return bind.key.toLowerCase() === this._transformKey(keyboardEvent.key)
            && keyboardEvent.altKey === !!bind.altKey && keyboardEvent.ctrlKey === !!bind.ctrlKey
            && keyboardEvent.metaKey === !!bind.metaKey && keyboardEvent.shiftKey === !!bind.shiftKey;
        }.bind(this));
      },

      /**
       * Transforms the key to match iron-a11y-keys logic.
       * @param {string} key The KeyBoardEvent.key
       *
       * @see https://github.com/PolymerElements/iron-a11y-keys-behavior/blob/v2.1.1/iron-a11y-keys-behavior.html#L102-L130
       */
      _transformKey: function(key) {
        var validKey = '';
        if (key) {
          var lKey = key.toLowerCase();
          if (lKey === ' ' || /^space(bar)?/.test(lKey)) {
            validKey = 'space';
          } else if (/^escape$/.test(lKey)) {
            validKey = 'esc';
          } else if (/^arrow/.test(lKey)) {
            validKey = lKey.replace('arrow', '');
          } else if (lKey === 'multiply') {
            validKey = '*';
          } else {
            validKey = lKey;
          }
        }
        return validKey;
      }

    });
  })();
</script>
<dom-module id="nuxeo-document-create-button" assetpath="nuxeo-document-create-button/">
  <template>
    <style>
      paper-fab {
        width: var(--nuxeo-document-create-button-width, 56px);
        height: var(--nuxeo-document-create-button-height, 56px);
        color: var(--nuxeo-button-primary-text);
        --paper-fab-background: var(--nuxeo-button-primary);
        --paper-fab-keyboard-focus-background: var(--nuxeo-button-primary-focus);
        @apply --nuxeo-document-create-button;
        transition: color 0.25s ease-in-out;
      }

      paper-fab:hover,
      paper-fab:focus {
        background-color: var(--nuxeo-button-primary-focus);
      }

      #tray {
        position: absolute;
        bottom: 32px;
        right: 32px;
        z-index: 10;
      }

      #shortcuts {
        opacity: 0;
        transition: opacity 0.25s ease-in-out;
      }

      #shortcuts.open {
        opacity: 1;
      }

      nuxeo-document-create-shortcuts {
        --nuxeo-document-create-shortcut-margin: 0 0 16px 0;
      }
    </style>

    <nuxeo-document id="defaultDoc" doc-path="[[parent.path]]" enrichers="permissions, subtypes" response="{{parent}}">
    </nuxeo-document>

    <div id="tray" on-mouseenter="_onMouseEnter" on-mouseleave="_onMouseLeave">
      <div id="shortcuts" class$="[[_animateOpen(shortcutsVisible)]]">
        <div hidden$="[[!shortcutsVisible]]">
          <nuxeo-slot slot="DOCUMENT_CREATE_ACTIONS" model="[[actionContext]]"></nuxeo-slot>
        </div>
      </div>

      <paper-fab id="createBtn" noink="" icon="nuxeo:add" on-tap="_displayWizard"></paper-fab>
       <paper-tooltip for="createBtn" position="left">[[i18n('documentCreateButton.tooltip')]]</paper-tooltip>
    </div>

    <nuxeo-document-creation-stats id="creationStats"></nuxeo-document-creation-stats>

    <nuxeo-keys keys="c" on-pressed="_displayWizard"></nuxeo-keys>

  </template>

  <script>
    Polymer({
      is: 'nuxeo-document-create-button',
      behaviors: [Nuxeo.I18nBehavior],
      properties: {
        parent: {
          type: Object,
          observer: '_parentChanged'
        },
        subtypes: {
          type: Array
        },
        shortcutsVisible: {
          type: Boolean,
          value: false
        },
        actionContext: {
          type: Object,
          value: function() {
            return {};
          },
          computed: '_actionContext(shortcutsVisible,subtypes)'
        }
      },

      listeners: {
        'create-document': '_hideShortcuts'
      },

      _parentChanged: function() {
        if (this.parent) {
          if (!this.parent.contextParameters || !this.parent.contextParameters.subtypes ||
            !this.parent.contextParameters.permissions) {
            this.$.defaultDoc.get();
          } else {
            var subtypes = (this.parent.contextParameters && this.parent.contextParameters.subtypes) ?
              this.parent.contextParameters.subtypes.map(function(type) {
                type.id = type.type.toLowerCase();
                return type;
              }) : [];
            var filteredSubtypes = [];
            if (this._canCreateIn(this.parent)) {
              subtypes.forEach(function(type) {
                if (type.facets.indexOf('HiddenInCreation') === -1) {
                  filteredSubtypes.push(type.id);
                }
              }.bind(this));
            }
            this.set('subtypes', filteredSubtypes);
          }
        }
      },

      _canCreateIn: function(document) {
        if (document && document.contextParameters && document.contextParameters.permissions) {
          return document.contextParameters.permissions.indexOf('Write') > -1 ||
            document.contextParameters.permissions.indexOf('Everything') > -1;
        } else {
          return false;
        }
      },

      _actionContext: function() {
        return {hostVisible: this.shortcutsVisible, subtypes: this.subtypes};
      },

      _showShortcuts: function() {
        this.shortcutsVisible = true;
      },

      _hideShortcuts: function() {
        this.shortcutsVisible = false;
      },

      _onMouseEnter: function() {
        this._showShortcuts();
      },

      _onMouseLeave: function() {
        this._hideShortcuts();
      },

      _displayWizard: function(e) {
        if (!this.hidden) {
          this.fire('create-document', e.detail);
        }
      },

      _animateOpen: function() {
        return this.shortcutsVisible ? 'open' : '';
      }
    });
  </script>

</dom-module>
<dom-module id="paper-dialog" assetpath="bower_components/paper-dialog/">
  <template>
    <style include="paper-dialog-shared-styles"></style>
    <slot></slot>
  </template>
</dom-module>

<script>
Polymer({
  is: 'paper-dialog',

  behaviors: [
    Polymer.PaperDialogBehavior,
    Polymer.NeonAnimationRunnerBehavior
  ],

  listeners: {
    'neon-animation-finish': '_onNeonAnimationFinish'
  },

  _renderOpened: function() {
    this.cancelAnimation();
    this.playAnimation('entry');
  },

  _renderClosed: function() {
    this.cancelAnimation();
    this.playAnimation('exit');
  },

  _onNeonAnimationFinish: function() {
    if (this.opened) {
      this._finishRenderOpened();
    } else {
      this._finishRenderClosed();
    }
  }
});
</script>
<iron-iconset-svg name="paper-tabs" size="24">
<svg><defs>
<g id="chevron-left"><path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"></path></g>
<g id="chevron-right"><path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"></path></g>
</defs></svg>
</iron-iconset-svg>
<dom-module id="paper-tab" assetpath="bower_components/paper-tabs/">
  <template>
    <style>
      :host {
        @apply --layout-inline;
        @apply --layout-center;
        @apply --layout-center-justified;
        @apply --layout-flex-auto;

        position: relative;
        padding: 0 12px;
        overflow: hidden;
        cursor: pointer;
        vertical-align: middle;

        @apply --paper-font-common-base;
        @apply --paper-tab;
      }

      :host(:focus) {
        outline: none;
      }

      :host([link]) {
        padding: 0;
      }

      .tab-content {
        height: 100%;
        transform: translateZ(0);
          -webkit-transform: translateZ(0);
        transition: opacity 0.1s cubic-bezier(0.4, 0.0, 1, 1);
        @apply --layout-horizontal;
        @apply --layout-center-center;
        @apply --layout-flex-auto;
        @apply --paper-tab-content;
      }

      :host(:not(.iron-selected)) > .tab-content {
        opacity: 0.8;

        @apply --paper-tab-content-unselected;
      }

      :host(:focus) .tab-content {
        opacity: 1;
        font-weight: 700;
      }

      paper-ripple {
        color: var(--paper-tab-ink, var(--paper-yellow-a100));
      }

      .tab-content > ::slotted(a) {
        @apply --layout-flex-auto;

        height: 100%;
      }
    </style>

    <div class="tab-content">
      <slot></slot>
    </div>
  </template>

  <script>
    Polymer({
      is: 'paper-tab',

      behaviors: [
        Polymer.IronControlState,
        Polymer.IronButtonState,
        Polymer.PaperRippleBehavior
      ],

      properties: {

        /**
         * If true, the tab will forward keyboard clicks (enter/space) to
         * the first anchor element found in its descendants
         */
        link: {type: Boolean, value: false, reflectToAttribute: true}

      },

      /** @private */
      hostAttributes: {role: 'tab'},

      listeners: {down: '_updateNoink', tap: '_onTap'},

      attached: function() {
        this._updateNoink();
      },

      get _parentNoink() {
        var parent = Polymer.dom(this).parentNode;
        return !!parent && !!parent.noink;
      },

      _updateNoink: function() {
        this.noink = !!this.noink || !!this._parentNoink;
      },

      _onTap: function(event) {
        if (this.link) {
          var anchor = this.queryEffectiveChildren('a');

          if (!anchor) {
            return;
          }

          // Don't get stuck in a loop delegating
          // the listener from the child anchor
          if (event.target === anchor) {
            return;
          }

          anchor.click();
        }
      }

    });
  </script>
</dom-module>
<dom-module id="paper-tabs" assetpath="bower_components/paper-tabs/">
  <template>
    <style>
      :host {
        @apply --layout;
        @apply --layout-center;

        height: 48px;
        font-size: 14px;
        font-weight: 500;
        overflow: hidden;
        -moz-user-select: none;
        -ms-user-select: none;
        -webkit-user-select: none;
        user-select: none;

        /* NOTE: Both values are needed, since some phones require the value to be `transparent`. */
        -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
        -webkit-tap-highlight-color: transparent;

        @apply --paper-tabs;
      }

      :host(:dir(rtl)) {
        @apply --layout-horizontal-reverse;
      }

      #tabsContainer {
        position: relative;
        height: 100%;
        white-space: nowrap;
        overflow: hidden;
        @apply --layout-flex-auto;
        @apply --paper-tabs-container;
      }

      #tabsContent {
        height: 100%;
        -moz-flex-basis: auto;
        -ms-flex-basis: auto;
        flex-basis: auto;
        @apply --paper-tabs-content;
      }

      #tabsContent.scrollable {
        position: absolute;
        white-space: nowrap;
      }

      #tabsContent:not(.scrollable),
      #tabsContent.scrollable.fit-container {
        @apply --layout-horizontal;
      }

      #tabsContent.scrollable.fit-container {
        min-width: 100%;
      }

      #tabsContent.scrollable.fit-container > ::slotted(*) {
        /* IE - prevent tabs from compressing when they should scroll. */
        -ms-flex: 1 0 auto;
        -webkit-flex: 1 0 auto;
        flex: 1 0 auto;
      }

      .hidden {
        display: none;
      }

      .not-visible {
        opacity: 0;
        cursor: default;
      }

      paper-icon-button {
        width: 48px;
        height: 48px;
        padding: 12px;
        margin: 0 4px;
      }

      #selectionBar {
        position: absolute;
        height: 0;
        bottom: 0;
        left: 0;
        right: 0;
        border-bottom: 2px solid var(--paper-tabs-selection-bar-color, var(--paper-yellow-a100));
          -webkit-transform: scale(0);
        transform: scale(0);
          -webkit-transform-origin: left center;
        transform-origin: left center;
          transition: -webkit-transform;
        transition: transform;

        @apply --paper-tabs-selection-bar;
      }

      #selectionBar.align-bottom {
        top: 0;
        bottom: auto;
      }

      #selectionBar.expand {
        transition-duration: 0.15s;
        transition-timing-function: cubic-bezier(0.4, 0.0, 1, 1);
      }

      #selectionBar.contract {
        transition-duration: 0.18s;
        transition-timing-function: cubic-bezier(0.0, 0.0, 0.2, 1);
      }

      #tabsContent > ::slotted(:not(#selectionBar)) {
        height: 100%;
      }
    </style>

    <paper-icon-button icon="paper-tabs:chevron-left" class$="[[_computeScrollButtonClass(_leftHidden, scrollable, hideScrollButtons)]]" on-up="_onScrollButtonUp" on-down="_onLeftScrollButtonDown" tabindex="-1"></paper-icon-button>

    <div id="tabsContainer" on-track="_scroll" on-down="_down">
      <div id="tabsContent" class$="[[_computeTabsContentClass(scrollable, fitContainer)]]">
        <div id="selectionBar" class$="[[_computeSelectionBarClass(noBar, alignBottom)]]" on-transitionend="_onBarTransitionEnd"></div>
        <slot></slot>
      </div>
    </div>

    <paper-icon-button icon="paper-tabs:chevron-right" class$="[[_computeScrollButtonClass(_rightHidden, scrollable, hideScrollButtons)]]" on-up="_onScrollButtonUp" on-down="_onRightScrollButtonDown" tabindex="-1"></paper-icon-button>

  </template>

  <script>
    Polymer({
      is: 'paper-tabs',

      behaviors: [Polymer.IronResizableBehavior, Polymer.IronMenubarBehavior],

      properties: {
        /**
         * If true, ink ripple effect is disabled. When this property is changed,
         * all descendant `<paper-tab>` elements have their `noink` property
         * changed to the new value as well.
         */
        noink: {type: Boolean, value: false, observer: '_noinkChanged'},

        /**
         * If true, the bottom bar to indicate the selected tab will not be shown.
         */
        noBar: {type: Boolean, value: false},

        /**
         * If true, the slide effect for the bottom bar is disabled.
         */
        noSlide: {type: Boolean, value: false},

        /**
         * If true, tabs are scrollable and the tab width is based on the label
         * width.
         */
        scrollable: {type: Boolean, value: false},

        /**
         * If true, tabs expand to fit their container. This currently only applies
         * when scrollable is true.
         */
        fitContainer: {type: Boolean, value: false},

        /**
         * If true, dragging on the tabs to scroll is disabled.
         */
        disableDrag: {type: Boolean, value: false},

        /**
         * If true, scroll buttons (left/right arrow) will be hidden for scrollable
         * tabs.
         */
        hideScrollButtons: {type: Boolean, value: false},

        /**
         * If true, the tabs are aligned to bottom (the selection bar appears at the
         * top).
         */
        alignBottom: {type: Boolean, value: false},

        selectable: {type: String, value: 'paper-tab'},

        /**
         * If true, tabs are automatically selected when focused using the
         * keyboard.
         */
        autoselect: {type: Boolean, value: false},

        /**
         * The delay (in milliseconds) between when the user stops interacting
         * with the tabs through the keyboard and when the focused item is
         * automatically selected (if `autoselect` is true).
         */
        autoselectDelay: {type: Number, value: 0},

        _step: {type: Number, value: 10},

        _holdDelay: {type: Number, value: 1},

        _leftHidden: {type: Boolean, value: false},

        _rightHidden: {type: Boolean, value: false},

        _previousTab: {type: Object}
      },

      /** @private */
      hostAttributes: {role: 'tablist'},

      listeners: {
        'iron-resize': '_onTabSizingChanged',
        'iron-items-changed': '_onTabSizingChanged',
        'iron-select': '_onIronSelect',
        'iron-deselect': '_onIronDeselect'
      },

      /**
       * @type {!Object}
       */
      keyBindings: {'left:keyup right:keyup': '_onArrowKeyup'},

      created: function() {
        this._holdJob = null;
        this._pendingActivationItem = undefined;
        this._pendingActivationTimeout = undefined;
        this._bindDelayedActivationHandler =
            this._delayedActivationHandler.bind(this);
        this.addEventListener('blur', this._onBlurCapture.bind(this), true);
      },

      ready: function() {
        this.setScrollDirection('y', this.$.tabsContainer);
      },

      detached: function() {
        this._cancelPendingActivation();
      },

      _noinkChanged: function(noink) {
        var childTabs = Polymer.dom(this).querySelectorAll('paper-tab');
        childTabs.forEach(
            noink ? this._setNoinkAttribute : this._removeNoinkAttribute);
      },

      _setNoinkAttribute: function(element) {
        element.setAttribute('noink', '');
      },

      _removeNoinkAttribute: function(element) {
        element.removeAttribute('noink');
      },

      _computeScrollButtonClass: function(
          hideThisButton, scrollable, hideScrollButtons) {
        if (!scrollable || hideScrollButtons) {
          return 'hidden';
        }

        if (hideThisButton) {
          return 'not-visible';
        }

        return '';
      },

      _computeTabsContentClass: function(scrollable, fitContainer) {
        return scrollable ? 'scrollable' + (fitContainer ? ' fit-container' : '') :
                            ' fit-container';
      },

      _computeSelectionBarClass: function(noBar, alignBottom) {
        if (noBar) {
          return 'hidden';
        } else if (alignBottom) {
          return 'align-bottom';
        }

        return '';
      },

      // TODO(cdata): Add `track` response back in when gesture lands.

      _onTabSizingChanged: function() {
        this.debounce('_onTabSizingChanged', function() {
          this._scroll();
          this._tabChanged(this.selectedItem);
        }, 10);
      },

      _onIronSelect: function(event) {
        this._tabChanged(event.detail.item, this._previousTab);
        this._previousTab = event.detail.item;
        this.cancelDebouncer('tab-changed');
      },

      _onIronDeselect: function(event) {
        this.debounce('tab-changed', function() {
          this._tabChanged(null, this._previousTab);
          this._previousTab = null;
          // See polymer/polymer#1305
        }, 1);
      },

      _activateHandler: function() {
        // Cancel item activations scheduled by keyboard events when any other
        // action causes an item to be activated (e.g. clicks).
        this._cancelPendingActivation();

        Polymer.IronMenuBehaviorImpl._activateHandler.apply(this, arguments);
      },

      /**
       * Activates an item after a delay (in milliseconds).
       */
      _scheduleActivation: function(item, delay) {
        this._pendingActivationItem = item;
        this._pendingActivationTimeout =
            this.async(this._bindDelayedActivationHandler, delay);
      },

      /**
       * Activates the last item given to `_scheduleActivation`.
       */
      _delayedActivationHandler: function() {
        var item = this._pendingActivationItem;
        this._pendingActivationItem = undefined;
        this._pendingActivationTimeout = undefined;
        item.fire(this.activateEvent, null, {bubbles: true, cancelable: true});
      },

      /**
       * Cancels a previously scheduled item activation made with
       * `_scheduleActivation`.
       */
      _cancelPendingActivation: function() {
        if (this._pendingActivationTimeout !== undefined) {
          this.cancelAsync(this._pendingActivationTimeout);
          this._pendingActivationItem = undefined;
          this._pendingActivationTimeout = undefined;
        }
      },

      _onArrowKeyup: function(event) {
        if (this.autoselect) {
          this._scheduleActivation(this.focusedItem, this.autoselectDelay);
        }
      },

      _onBlurCapture: function(event) {
        // Cancel a scheduled item activation (if any) when that item is
        // blurred.
        if (event.target === this._pendingActivationItem) {
          this._cancelPendingActivation();
        }
      },

      get _tabContainerScrollSize() {
        return Math.max(
            0, this.$.tabsContainer.scrollWidth - this.$.tabsContainer.offsetWidth);
      },

      _scroll: function(e, detail) {
        if (!this.scrollable) {
          return;
        }

        var ddx = (detail && -detail.ddx) || 0;
        this._affectScroll(ddx);
      },

      _down: function(e) {
        // go one beat async to defeat IronMenuBehavior
        // autorefocus-on-no-selection timeout
        this.async(function() {
          if (this._defaultFocusAsync) {
            this.cancelAsync(this._defaultFocusAsync);
            this._defaultFocusAsync = null;
          }
        }, 1);
      },

      _affectScroll: function(dx) {
        this.$.tabsContainer.scrollLeft += dx;

        var scrollLeft = this.$.tabsContainer.scrollLeft;

        this._leftHidden = scrollLeft === 0;
        this._rightHidden = scrollLeft === this._tabContainerScrollSize;
      },

      _onLeftScrollButtonDown: function() {
        this._scrollToLeft();
        this._holdJob = setInterval(this._scrollToLeft.bind(this), this._holdDelay);
      },

      _onRightScrollButtonDown: function() {
        this._scrollToRight();
        this._holdJob =
            setInterval(this._scrollToRight.bind(this), this._holdDelay);
      },

      _onScrollButtonUp: function() {
        clearInterval(this._holdJob);
        this._holdJob = null;
      },

      _scrollToLeft: function() {
        this._affectScroll(-this._step);
      },

      _scrollToRight: function() {
        this._affectScroll(this._step);
      },

      _tabChanged: function(tab, old) {
        if (!tab) {
          // Remove the bar without animation.
          this.$.selectionBar.classList.remove('expand');
          this.$.selectionBar.classList.remove('contract');
          this._positionBar(0, 0);
          return;
        }

        var r = this.$.tabsContent.getBoundingClientRect();
        var w = r.width;
        var tabRect = tab.getBoundingClientRect();
        var tabOffsetLeft = tabRect.left - r.left;

        this._pos = {
          width: this._calcPercent(tabRect.width, w),
          left: this._calcPercent(tabOffsetLeft, w)
        };

        if (this.noSlide || old == null) {
          // Position the bar without animation.
          this.$.selectionBar.classList.remove('expand');
          this.$.selectionBar.classList.remove('contract');
          this._positionBar(this._pos.width, this._pos.left);
          return;
        }

        var oldRect = old.getBoundingClientRect();
        var oldIndex = this.items.indexOf(old);
        var index = this.items.indexOf(tab);
        var m = 5;

        // bar animation: expand
        this.$.selectionBar.classList.add('expand');

        var moveRight = oldIndex < index;
        var isRTL = this._isRTL;
        if (isRTL) {
          moveRight = !moveRight;
        }

        if (moveRight) {
          this._positionBar(
              this._calcPercent(tabRect.left + tabRect.width - oldRect.left, w) - m,
              this._left);
        } else {
          this._positionBar(
              this._calcPercent(oldRect.left + oldRect.width - tabRect.left, w) - m,
              this._calcPercent(tabOffsetLeft, w) + m);
        }

        if (this.scrollable) {
          this._scrollToSelectedIfNeeded(tabRect.width, tabOffsetLeft);
        }
      },

      _scrollToSelectedIfNeeded: function(tabWidth, tabOffsetLeft) {
        var l = tabOffsetLeft - this.$.tabsContainer.scrollLeft;
        if (l < 0) {
          this.$.tabsContainer.scrollLeft += l;
        } else {
          l += (tabWidth - this.$.tabsContainer.offsetWidth);
          if (l > 0) {
            this.$.tabsContainer.scrollLeft += l;
          }
        }
      },

      _calcPercent: function(w, w0) {
        return 100 * w / w0;
      },

      _positionBar: function(width, left) {
        width = width || 0;
        left = left || 0;

        this._width = width;
        this._left = left;
        this.transform(
            'translateX(' + left + '%) scaleX(' + (width / 100) + ')',
            this.$.selectionBar);
      },

      _onBarTransitionEnd: function(e) {
        var cl = this.$.selectionBar.classList;
        // bar animation: expand -> contract
        if (cl.contains('expand')) {
          cl.remove('expand');
          cl.add('contract');
          this._positionBar(this._pos.width, this._pos.left);
          // bar animation done
        } else if (cl.contains('contract')) {
          cl.remove('contract');
        }
      }
    });
  </script>
</dom-module>
<dom-module id="nuxeo-document-create-popup" assetpath="nuxeo-document-create-popup/">
  <template>
    <style include="iron-flex">

      :host {
        --paper-tabs-selection-bar-color: var(--nuxeo-primary-color);
        display: block;
      }

      paper-tabs {
        border-bottom: 1px solid var(--divider-color);
      }

      paper-tab {
        text-transform: uppercase;
      }

      paper-tabs,
      #holder {
        margin: 0;
        padding: 0;
      }

      iron-pages,
      nuxeo-document-import {
        /*Firefox fix (NXP-22349)*/
        min-height: 100%;
      }

      #holder {
        height: 80vh;
        width: 65vw;
      }

      iron-pages {
        @apply --layout-flex;
        @apply --layout-horizontal;
      }

      /* IE11 fix (NXP-23550) */
      *::-ms-backdrop, iron-pages * {
        height: 80vh;
      }
    </style>

    <nuxeo-document id="defaultDoc" doc-path="[[parentPath]]" enrichers="permissions, subtypes" response="{{parent}}">
    </nuxeo-document>

    <paper-dialog id="createDocDialog" opened="{{opened}}" modal="" no-auto-focus="">

      <paper-tabs hidden$="[[!_showTabs]]" selected="{{selectedTab}}" attr-for-selected="name" noink="">
        <nuxeo-slot slot="CREATE_POPUP_ITEMS" model="[[importContext]]"></nuxeo-slot>
      </paper-tabs>
      <div id="holder" class="vertical layout flex">
        <iron-pages selected="[[selectedTab]]" attr-for-selected="name" selected-attribute="visible">
          <nuxeo-slot slot="CREATE_POPUP_PAGES" model="[[importContext]]"></nuxeo-slot>
          <nuxeo-document-create id="simpleCreation" name="create" parent="[[parent]]" target-path="{{parentPath}}" suggester-children="{{suggesterChildren}}"></nuxeo-document-create>
          <nuxeo-document-import id="bulkCreation" name="import" parent="[[parent]]" target-path="{{parentPath}}" suggester-children="{{suggesterChildren}}"></nuxeo-document-import>
        </iron-pages>
      </div>
    </paper-dialog>

  </template>

  <script>
    Polymer({
      is: 'nuxeo-document-create-popup',
      behaviors: [Nuxeo.I18nBehavior],
      properties: {
        parent: {
          type: Object
        },

        _showTabs: {
          type: Boolean,
          value: true
        },
        selectedTab: {
          type: String,
          value: ''
        },
        parentPath: {
          type: String
        },
        defaultPath: {
          type: String
        },
        opened: {
          type: Boolean,
          value: false,
          observer: '_openedChanged'
        },
        importContext: {
          type: Object,
          computed: '_importContext(parent, i18n)'
        }
      },

      listeners: {
        'nx-creation-wizard-hide-tabs': '_hideTabs',
        'nx-creation-wizard-show-tabs': '_displayTabs',
        'nx-document-creation-finished': '_close',
        'nx-document-creation-suggester-parent-changed': '_parentPathChanged'
      },

      _hideTabs: function() {
        this._showTabs = false;
      },

      _displayTabs: function() {
        this._showTabs = true;
      },

      _close: function() {
        if (this.$.createDocDialog.opened) {
          this.$.createDocDialog.toggle();
          this._showTabs = true;
        }
      },

      toggleDialogCreate: function(type) {
        this.selectedTab = 'create';
        this._showTabs = false;
        this._fetchParent().then(function() {
          if (this._noPermission) {
            this.fire('notify', {message: this.i18n('documentCreationBehavior.error.noPermission')});
          } else {
            this.$$('#simpleCreation').init(type);
            this.$$('#bulkCreation').init();
            this.$.createDocDialog.toggle();
          }
        }.bind(this));
      },

      toggleDialogImport: function(files) {
        this.selectedTab = 'import';
        this._fetchParent().then(function() {
          if (this._noPermission) {
            this.fire('notify', {message: this.i18n('documentCreationBehavior.error.noPermission')});
          } else {
            this.$$('#bulkCreation').init(files);
            this.$.createDocDialog.toggle();
          }
        }.bind(this));
      },

      toggleDialog: function() {
        this._fetchParent().then(function() {
          if (this._noPermission) {
            this.fire('notify', {message: this.i18n('documentCreationBehavior.error.noPermission')});
          } else {
            this.$$('#bulkCreation').init();
            this.$.createDocDialog.toggle();
          }
        }.bind(this));
      },

      _fetchParent: function() {
        this._noPermission = false;
        if (!this.parentPath) {
          this.set('parentPath', this.defaultPath);
        }
        if (!this.parent || !this.parent.contextParameters) {
          return this.$.defaultDoc.get().catch(function(err) {
            if (err && err.status === 403) {
              this._noPermission = true;
            } else {
              throw err;
            }
          }.bind(this));
        } else {
          return Promise.resolve();
        }
      },

      _parentPathChanged: function(e) {
        if (e.detail.isValidTargetPath &&
          (!this.parent || (this.parentPath && this.parent.path !== this.parentPath.replace(/(.+)\/$/, "$1")))) {
          this.$.defaultDoc.get();
        }
      },

      _openedChanged: function() {
        if (this.opened) {
          if (this.selectedTab === '') {
            this.selectedTab = 'create';
          }
        } else {
          this.selectedTab = '';
        }
      },

      _importContext: function() {
        return {parent: this.parent, i18n: this.i18n};
      }

    });
  </script>

</dom-module>
<dom-module id="nuxeo-document-create-shortcut" assetpath="nuxeo-document-create-actions/">
  <template>
    <style is="custom-style">
      :host {
        display: inline-block;
      }

      #createBtn {
        color: var(--nuxeo-button-primary-text);
        --paper-fab-background: var(--nuxeo-button-primary);
        --paper-fab-keyboard-focus-background: var(--nuxeo-button-primary-focus);
      }

      paper-fab:hover,
      paper-fab:focus {
        background-color: var(--nuxeo-button-primary-focus);
      }

      paper-fab {
        --paper-fab-iron-icon: {
          filter: brightness(100);
        }
      }

    </style>

    <paper-fab mini="" noink="" id="createBtn" src="[[icon]]" on-tap="_tap"></paper-fab>
    <nuxeo-tooltip for="createBtn" position="left">[[i18n(label)]]</nuxeo-tooltip>

  </template>

  <script>
    Polymer({
      is: 'nuxeo-document-create-shortcut',
      behaviors: [Nuxeo.I18nBehavior],
      properties: {
        type: String,
        icon: String,
        label: String
      },

      _tap: function() {
        this.fire('create-document', {type: this.type});
      }

    });
  </script>

</dom-module>
<dom-module id="nuxeo-document-create-shortcuts" assetpath="nuxeo-document-create-actions/">
  <template>
    <style>
      #shortcuts {
        @apply --layout-vertical;
        @apply --layout-center;
        @apply --layout-end-justified;
      }

      nuxeo-document-create-shortcut {
        margin: var(--nuxeo-document-create-shortcut-margin);
      }
    </style>

    <div id="shortcuts"></div>

    <nuxeo-document-creation-stats id="creationStats"></nuxeo-document-creation-stats>

  </template>

  <script>
    Polymer({
      is: 'nuxeo-document-create-shortcuts',

      behaviors: [Nuxeo.FormatBehavior],

      properties: {
        hostVisible: {
          type: Boolean,
          observer: '_observeVisibility'
        },
        subtypes: {
          type: Array
        }
      },

      _observeVisibility: function() {
        if (this.hostVisible) {
          this._updateShortcuts();
        }
      },

      _updateShortcuts: function() {
        var types = this.$.creationStats.lastType(1);
        this.$.creationStats.mostCommonType(2).forEach(function(type) {
          if (types.indexOf(type) < 0) {
            types.push(type);
          }
        });

        var shorcuts = [];
        types.forEach(function(type) {
          if (this.subtypes && this.subtypes.indexOf(type) > -1) {
            var el = document.createElement('nuxeo-document-create-shortcut');
            el.type = type;
            el.icon =  'images/doctypes/' + type + '.svg';
            el.label = this.formatDocType(type);
            shorcuts.push(el);
          }
        }.bind(this));

        this._putNodes(Polymer.dom(this.$.shortcuts), shorcuts.reverse());
      },

      _putNodes: function(parent) {
        while (parent.firstChild) {
          parent.removeChild(parent.firstChild);
        }
        if (arguments && arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
            if (Array.isArray(arguments[i])) {
              for (var j = 0; j < arguments[i].length; j++) {
                parent.appendChild(arguments[i][j]);
              }
            } else {
              parent.appendChild(arguments[i]);
            }
          }
        }
      }

    });
  </script>

</dom-module>
<dom-module id="nuxeo-document-export" assetpath="nuxeo-document-export/">
  <template>
    <style>

      iron-icon {
        width: 1em;
        height: 1em;
        margin-right: 16px;
        @apply --icon-theme;
      }

      .rendition-container {
        padding: 6px;
        @apply --rendition-container-theme;
        @apply --layout-horizontal;
        @apply --layout-center;
      }

      .rendition-container + .rendition-container {
        border-top: 1px solid #ddd;
        @apply --rendition-container-in-between-theme;
      }

      a {
        color: #00adff;
        font-weight: 700;
        text-decoration: none;
        @apply --rendition-name-theme;
      }
    </style>

  <template is="dom-repeat" items="[[_filterRenditions(document)]]">
    <div class="rendition-container">
      <iron-icon src="[[item.icon]]"></iron-icon>
      <a href="[[item.url]]">[[i18n(item.name)]]</a>
    </div>
  </template>

  </template>
  <script>
    Polymer({
      is: 'nuxeo-document-export',
      behaviors: [Nuxeo.I18nBehavior],
      properties: {
        document: Object
      },

      _filterRenditions: function(document) {
        if (document && document.contextParameters) {
          return document.contextParameters.renditions.filter(function(rendition) {
            return rendition.kind !== 'nuxeo:video:conversion' && rendition.kind !== 'nuxeo:picture:conversion';
          }).map(function(item) {
            item.name = 'documentExport.' + item.name;
            return item;
          });
        } else {
          return [];
        }
      }

    });
  </script>
</dom-module>
<dom-module id="nuxeo-document-viewer" assetpath="nuxeo-document-viewer/">
  <template>
    <style include="nuxeo-styles">
      :host {
        display: block;
      }

      iron-image, nuxeo-document-preview {
        width: 100%;
        height: calc(80vh - 100px);
      }

      nuxeo-document-blob, nuxeo-dropzone {
        margin-top: 8px;
      }
    </style>

    <template is="dom-if" if="[[!document.properties.file:content.data]]">
      <iron-image position="center" sizing="contain" src="[[_thumbnail(document)]]"></iron-image>
      <template is="dom-if" if="[[_hasWritePermission(document)]]">
        <nuxeo-dropzone document="{{document}}" update-document=""></nuxeo-dropzone>
      </template>
    </template>
    <template is="dom-if" if="[[document.properties.file:content.data]]">
      <nuxeo-document-preview document="[[document]]"></nuxeo-document-preview>
      <nuxeo-document-blob document="[[document]]"></nuxeo-document-blob>
    </template>

  </template>

</dom-module>

<script>
  Polymer({
    is: 'nuxeo-document-viewer',
    behaviors: [Nuxeo.I18nBehavior, Nuxeo.FiltersBehavior],
    properties: {
      document: Object
    },

    _thumbnail: function(doc) {
      return doc && doc.uid && doc.contextParameters && doc.contextParameters.thumbnail &&
      doc.contextParameters.thumbnail.url ? doc.contextParameters.thumbnail.url : '';
    },

    _hasWritePermission: function (doc) {
      return doc && this.hasPermission(doc, 'Write') &&
        !this.isImmutable(doc) && doc.type !== 'Root' && !this.isTrashed(doc);
    },
  });
</script>
<dom-module id="nuxeo-document-attachments" assetpath="nuxeo-document-attachments/">
  <template>
    <style include="nuxeo-styles iron-flex">
      :host {
        display: block;
      }

      nuxeo-dropzone {
        margin-top: 8px;
      }

      nuxeo-document-blob {
        border-top: 1px solid var(--nuxeo-border);
        padding: 8px 0;
      }

      .empty {
        opacity: .5;
        padding-bottom: 8px;
        font-size: 1.1em;
      }
    </style>

    <h3>[[i18n('documentAttachments.heading')]]</h3>

    <div class="vertical layout">
      <template is="dom-repeat" items="[[_computeFiles(document.*, xpath)]]">
        <nuxeo-document-blob document="[[document]]" xpath="[[_computeBlobXpath(xpath, index)]]"></nuxeo-document-blob>
      </template>

      <template is="dom-if" if="[[!_hasFiles(document)]]">
        <div class="empty">[[i18n('documentAttachments.empty')]]</div>
      </template>
    </div>

    <template is="dom-if" if="[[_hasWritePermission(document)]]">
      <nuxeo-dropzone document="{{document}}" xpath="[[xpath]]" uploaded-message="[[i18n('documentAttachments.upload.uploaded')]]" message="[[i18n('documentAttachments.upload.add')]]" blob-list="" update-document="">
      </nuxeo-dropzone>
    </template>

  </template>

  <script>
    Polymer({
      is: 'nuxeo-document-attachments',
      behaviors: [Nuxeo.I18nBehavior, Nuxeo.FiltersBehavior],
      properties: {
        document: Object,

        xpath: {
          type: String,
          value: 'files:files'
        }
      },

      _hasFiles: function(doc) {
        return doc && doc.properties && doc.properties[this.xpath] && doc.properties[this.xpath].length > 0;
      },

      _hasWritePermission: function (doc) {
        return doc && this.hasPermission(doc, 'Write') &&
          !this.isImmutable(doc) && doc.type !== 'Root' && !this.isTrashed(doc);
      },

      _computeFiles: function() {
        if (this._hasFiles(this.document)) {
          return this.document.properties[this.xpath];
        }
        return [];
      },

      _computeBlobXpath: function(xpath, index) {
        if (xpath === 'files:files') {
          return 'files:files/' + index + '/file';
        }
        return xpath + '/' + index;
      }
    });
  </script>

</dom-module>
<dom-module id="paper-spinner" assetpath="bower_components/paper-spinner/">
  <template strip-whitespace="">
    <style include="paper-spinner-styles"></style>

    <div id="spinnerContainer" class-name="[[__computeContainerClasses(active, __coolingDown)]]" on-animationend="__reset" on-webkit-animation-end="__reset">
      <div class="spinner-layer layer-1">
        <div class="circle-clipper left"></div>
        <div class="circle-clipper right"></div>
      </div>

      <div class="spinner-layer layer-2">
        <div class="circle-clipper left"></div>
        <div class="circle-clipper right"></div>
      </div>

      <div class="spinner-layer layer-3">
        <div class="circle-clipper left"></div>
        <div class="circle-clipper right"></div>
      </div>

      <div class="spinner-layer layer-4">
        <div class="circle-clipper left"></div>
        <div class="circle-clipper right"></div>
      </div>
    </div>
  </template>

  <script>
    Polymer({
      is: 'paper-spinner',

      behaviors: [
        Polymer.PaperSpinnerBehavior
      ]
    });
  </script>
</dom-module>
<dom-module id="nuxeo-document-tree" assetpath="nuxeo-document-tree/">
  <template>
    <style include="iron-flex iron-positioning nuxeo-styles">
      :host {
        display: block;
        --nuxeo-tree-theme: {
          padding: 1em;
          color: var(--nuxeo-drawer-text);
        };
        --nuxeo-tree-node-theme: {
          min-height: 24px;
        };
        --nuxeo-tree-children-theme: {
          padding-left: 1em;
        };
        --nuxeo-tree-node-more-theme: {
          line-height: 1.3em;
          display: inline-block;
          vertical-align: text-top;
          margin-left: 1.3em;
          word-break: break-word;
        }
      }

      .content {
        padding: 5px 0;
        overflow: auto;
        height: calc(100vh - 72px - var(--nuxeo-app-top));
      }

      .node-name {
        line-height: 1.3em;
        display: inline-block;
        vertical-align: text-top;
        margin-left: 1.3em;
        word-break: break-word;
      }

      a {
        @apply --nuxeo-link;
      }

      a:hover {
        @apply --nuxeo-link-hover;
      }

      #root a, a:active, a:visited, a:focus {
        color: var(--nuxeo-drawer-text);
      }

      iron-icon {
        opacity: .3;
        width: 1.3rem;
        margin-right: -1.6em;
        margin-top: -0.07rem;
      }

      [toggle] {
        cursor: pointer;
      }

      .parents {
        line-height: 1.5em;
      }

      .parents + nuxeo-tree {
        padding: 6px 5px;
      }

      .parents > nuxeo-tree {
        padding: 4px 5px;
      }

      .parents a {
        @apply --layout-horizontal;
        padding: .35em;
        color: var(--nuxeo-drawer-text);
        border-bottom: 1px solid var(--nuxeo-border);
      }

      .parents span {
        text-overflow: ellipsis;
        overflow: hidden;
        white-space: nowrap;
        display: block;
        min-width: 1.3em;
      }

      .parent {
        padding: .12em 0 0;
      }

      paper-spinner {
        height: 1.1rem;
        width: 1.1rem;
        margin-right: -1.4em;
      }

      .noPermission {
        opacity: .5;
        font-weight: 300;
        padding: 1.5em .7em;
        text-align: center;
        font-size: 1.1rem;
      }
    </style>

    <nuxeo-document id="doc" doc-path="[[docPath]]" response="{{document}}" enrichers="hasFolderishChild"></nuxeo-document>

    <nuxeo-page-provider id="children" provider="tree_children" enrichers="hasFolderishChild" schemas="dublincore,common">
    </nuxeo-page-provider>

    <div class="header" hidden$="[[!label]]">[[i18n(label)]]</div>

    <div class="content">
      <div class="parents" hidden$="[[_noPermission]]">
        <a href$="[[urlFor('browse', '/')]]" class="layout horizontal" hidden$="[[_hideRoot(document)]]">
          <span><iron-icon icon="icons:chevron-left"></iron-icon></span>
          <span class="parent">[[i18n('browse.root')]]</span>
        </a>
        <template is="dom-repeat" items="[[parents]]" as="item">
          <a href$="[[urlFor('browse', item.path)]]">
            <span><iron-icon icon="icons:chevron-left"></iron-icon></span>
            <span class="parent">[[item.title]]</span>
          </a>
        </template>
      </div>
      <nuxeo-tree id="tree" data="[[document]]" controller="[[controller]]" node-key="uid">
        <template class="horizontal layout">
          <template class="flex" is="dom-if" if="[[!isLeaf]]">
            <paper-spinner active$="[[loading]]"></paper-spinner>
            <iron-icon icon="[[_expandIcon(opened)]]" toggle="" hidden$="[[loading]]"></iron-icon>
          </template>
          <span class="node-name flex">
            <a href$="[[urlFor('browse', item.path)]]">[[_title(item)]]</a>
          </span>
        </template>
      </nuxeo-tree>
      <div class="noPermission" hidden$="[[!_noPermission]]">[[i18n('browse.tree.noDocument')]]</div>
    </div>

  </template>
  <script>
    Polymer({
      is: 'nuxeo-document-tree',
      behaviors: [Nuxeo.RoutingBehavior, Nuxeo.I18nBehavior, Nuxeo.FiltersBehavior],
      properties: {
        controller: Object,
        auto: {
          type: Boolean,
          value: false
        },
        rootDocPath: {
          type: String,
          value: '/',
          observer: '_rootDocPathChanged'
        },
        docPath: {
          type: String,
          value: '/'
        },
        document: {
          type: Object,
          observer: '_documentChanged'
        },
        currentDocument: {
          type: Object,
          observer: '_currentDocumentChanged'
        },
        parents: {
          type: Array,
          value: []
        },
        label: String,
        visible: {
          type: Boolean
        },
        cannotSee: {
          type: Boolean,
          value: false
        },
        _noPermission: {
          type: Boolean,
          value: false
        }
      },

      observers: [
        '_fetchDocument(docPath, visible)'
      ],

      ready: function() {
        window.addEventListener('nuxeo-documents-deleted', function(e) {
          this.removeDocuments(e.detail.documents);
        }.bind(this));

        window.addEventListener('refresh-display', function() {
          this._fetchDocument();
        }.bind(this));

        this.controller = {
          getChildren: function(node, page) {
            this.$.children.params = [node.uid];
            this.$.children.page = page;
            return this.$.children.fetch().then(function(data) {
              return {
                items: data.entries,
                isNextAvailable: this.$.children.isNextPageAvailable
              }
            }.bind(this));
          }.bind(this),

          isLeaf: function(node) {
            var hasFolderishChild = node.contextParameters && node.contextParameters.hasFolderishChild;
            return !hasFolderishChild;
          }
        };
      },

      _hideRoot: function(doc) {
        return this.rootDocPath !== '/' || (doc && doc.type && doc.type === 'Root');
      },

      _fetchDocument: function() {
        if (this.visible && this.docPath) {
          this._noPermission = false;
          this.$.doc.execute().catch(function(err) {
            if (err && err.status === 403) {
              this._noPermission = true;
            } else {
              throw err;
            }
          }.bind(this));
        }
      },

      _currentDocumentChanged: function() {
        var doc = this.currentDocument;
        if (doc && doc.path.startsWith(this.rootDocPath)) {

          if (this.docPath === doc.path && this.document && this.document.title !== doc.title) {
            //If document is the same as before but its name changed, get the document again
            this.$.doc.get();
          }

          if (this.docPath !== doc.path && !this.hasFacet(doc, 'HiddenInNavigation')) {
            this.$.tree.style.display = 'none';
            this.parents = [];

            if (doc.type === 'Root') {
              this.docPath = doc.path;
              return;
            }

            var entries = doc.contextParameters.breadcrumb.entries;
            var lastEntry = entries[entries.length - 1];
            if (this.hasFacet(lastEntry, 'Folderish') || entries.length === 1) {
              this.docPath = lastEntry.path;
            } else {
              this.docPath = entries[entries.length - 2].path;
            }

            for (var i = 0; i < entries.length - 1; i++) {
              var entry = entries[i];
              if (!this.hasFacet(entry, 'HiddenInNavigation') && entry.path.startsWith(this.rootDocPath)) {
                this.push('parents', entry);
              }
            }

          }
        }
      },

      _documentChanged: function() {
        if (this.document) {
          this.$.tree.style.display = 'block';
        }
      },

      _rootDocPathChanged: function() {
        this.docPath = this.rootDocPath;
      },

      _expandIcon: function(opened) {
        return 'hardware:keyboard-arrow-' + (opened ? 'down' : 'right');
      },

      _icon: function(opened) {
        return opened ? 'icons:folder-open' : 'icons:folder';
      },

      _title: function(item) {
        return (item.type === 'Root') ? this.i18n('browse.root') : item.title;
      },

      removeDocuments: function(documents) {
        var uids = documents.map(function(doc) {
          return doc.uid;
        });
        this.$.tree.removeNodes(uids);
      }
    });
  </script>
</dom-module>
<dom-module id="nuxeo-document-history" assetpath="nuxeo-document-history/">
  <template>
    <style>
      #heading {
        @apply --layout-horizontal;
        @apply --layout-end-justified;
      }

      #table {
        height: calc(100vh - 370px);
      }

      nuxeo-date-picker {
        padding: 0 16px;
      }
    </style>

    <nuxeo-audit-page-provider id="provider" page-size="40"></nuxeo-audit-page-provider>

    <nuxeo-card>
      <div id="heading">
        <template is="dom-if" if="[[visible]]">
          <nuxeo-date-picker role="widget" label="[[i18n('documentHistory.filter.after')]]" value="{{startDate}}">
          </nuxeo-date-picker>
          <nuxeo-date-picker role="widget" label="[[i18n('documentHistory.filter.before')]]" value="{{endDate}}">
          </nuxeo-date-picker>
        </template>
      </div>
    </nuxeo-card>

    <nuxeo-card>
      <nuxeo-data-table id="table" paginable="" nx-provider="provider" empty-label="[[i18n('documentHistory.empty')]]">
        <nuxeo-data-table-column name="[[i18n('documentHistory.performedAction')]]" sort-by="eventId">
          <template>[[_formatActivity(item.eventId)]]</template>
        </nuxeo-data-table-column>
        <nuxeo-data-table-column name="[[i18n('documentHistory.date')]]" sort-by="eventDate">
          <template><nuxeo-date datetime="[[item.eventDate]]"></nuxeo-date></template>
        </nuxeo-data-table-column>
        <nuxeo-data-table-column name="[[i18n('documentHistory.username')]]" sort-by="principalName">
          <template><nuxeo-user-tag user="[[item.principalName]]"></nuxeo-user-tag></template>
        </nuxeo-data-table-column>
        <nuxeo-data-table-column name="[[i18n('documentHistory.category')]]" sort-by="category">
          <template>[[_formatActivity(item.category)]]</template>
        </nuxeo-data-table-column>
        <nuxeo-data-table-column name="[[i18n('documentHistory.comment')]]">
          <template>
            <a href$="[[_parseComment(item.comment)]]">[[item.comment]]</a>
          </template>
        </nuxeo-data-table-column>
        <nuxeo-data-table-column name="[[i18n('documentHistory.state')]]">
          <template><nuxeo-tag uppercase="">[[formatLifecycleState(item.docLifeCycle)]]</nuxeo-tag></template>
        </nuxeo-data-table-column>
      </nuxeo-data-table>
    </nuxeo-card>

  </template>

  <script>
    Polymer({
      is: 'nuxeo-document-history',
      behaviors: [Nuxeo.FormatBehavior, Nuxeo.RoutingBehavior],
      properties: {
        document: Object,
        visible: {
          type: Boolean,
          value: false,
          observer: '_refresh'
        },
        startDate: {
          type: String,
          notify: true,
          observer: '_observeStartDate'
        },
        endDate: {
          type: String,
          notify: true,
          observer: '_observeEndDate'
        }
      },

      _observeStartDate: function() {
        if (this.startDate && this.startDate.length > 0) {
          this.$.provider.params.startDate = this.startDate;
          if (this.endDate && this.endDate.length > 0) {
            var start = Date.parse(this.startDate);
            var end = Date.parse(this.endDate);
            if (start > end) {
              this.endDate = moment(start).add(7, 'day').format('YYYY-MM-DD');
            }
          }
          this._refresh();
        } else if(this.$.provider.params.startDate) {
          delete this.$.provider.params.startDate;
          this._refresh();
        }
      },

      _observeEndDate: function() {
        if (this.endDate && this.endDate.length > 0) {
          this.$.provider.params.endDate = this.endDate;
          if (this.startDate && this.startDate.length > 0) {
            var start = Date.parse(this.startDate);
            var end = Date.parse(this.endDate);
            if (start > end) {
              this.startDate = moment(end).subtract(7, 'day').format('YYYY-MM-DD');
            }
          }
          this._refresh();
        } else if(this.$.provider.params.endDate) {
          delete this.$.provider.params.endDate;
          this._refresh();
        }
      },

      _refresh: function() {
        if (this.document && this.visible) {
          this.$.provider.page = 1;
          this.$.provider.docId = this.document.uid;
          this.$.table.fetch();
        }
      },

      _formatActivity: function(key) {
        return this.i18n('activity.' + key);
      },

      _parseComment: function(comment) {
        if (comment) {
          var split = comment.split(':');
          if (split.length >= 2) {
            // split[0] is repo name, split[1] is doc id
            return this.urlFor('document', split[1]);
          }
          return null;
        }
        return null;
      }

    });
  </script>

</dom-module>
<dom-module id="nuxeo-collection-move-up-action" assetpath="nuxeo-collections/">
  <template>
    <style include="nuxeo-action-button-styles"></style>

    <nuxeo-operation op="Document.MoveCollectionMember" id="moveUpOp"></nuxeo-operation>

    <template id="availability" is="dom-if" if="[[_isAvailable(members)]]">
      <div class="action" on-tap="moveUp">
        <paper-icon-button noink="" id="upButton" icon="icons:arrow-upward"></paper-icon-button>
        <span class="label" hidden$="[[!showLabel]]">[[_label]]</span>
      </div>
      <nuxeo-tooltip for="upButton" position="[[tooltipPosition]]">[[_label]]</nuxeo-tooltip>
    </template>
  </template>

  <script>
    Polymer({
      is: 'nuxeo-collection-move-up-action',
      behaviors: [Nuxeo.I18nBehavior],
      properties: {
        members: {
          type: Object
        },
        allMembers: {
          type: Object
        },
        collection: {
          type: Object
        },
        tooltipPosition: {
          type: String,
          value: 'bottom'
        },
        /**
         * `true` if the action should display the label, `false` otherwise.
         */
        showLabel: {
          type: Boolean,
          value: false,
        },
        _label: {
          type: String,
          computed: '_computeLabel(i18n)'
        },
        _member1Idx: {
          type: Number
        },
        _member2Idx: {
          type: Number
        }
      },

      moveUp: function() {
        if (this.members && this.members.length === 1 && this.allMembers) {
          var member2 = this.members[0].uid;
          var i = 0;
          for (; i < this.allMembers.length; i++) {
            if (this.allMembers[i].uid === member2) {
              if (i > 0) {
                this._member2Idx = i;
                this._member1Idx = i - 1;
                var member1 = this.allMembers[this._member1Idx].uid;
                this.$.moveUpOp.input = this.collection.uid;
                this.$.moveUpOp.params = {
                  member1: member1,
                  member2: member2
                };
                this.$.moveUpOp.execute().then(function() {
                  this.allMembers[this._member2Idx] = this.allMembers.splice(this._member1Idx, 1,
                    this.allMembers[this._member2Idx])[0];
                  this.fire('refresh-display', {focusIndex: this._member1Idx});
                }.bind(this));
              }
              break;
            }
          }
        }
      },

      _isAvailable: function() {
        if (this.members && this.members.length === 1) {
          if (this.allMembers && this.allMembers.length <= 1) {
            return false;
          }
          if (this.allMembers[0].uid === this.members[0].uid) {
            return false;
          }
          return true;
        }
        return false;
      },

      _computeLabel: function() {
        return this.i18n('collections.moveUp');
      }

    });
  </script>
</dom-module>
<dom-module id="nuxeo-collection-move-down-action" assetpath="nuxeo-collections/">
  <template>
    <style include="nuxeo-action-button-styles"></style>

    <nuxeo-operation op="Document.MoveCollectionMember" id="moveDownOp"></nuxeo-operation>

    <template id="availability" is="dom-if" if="[[_isAvailable(members)]]">
      <div class="action" on-tap="moveDown">
        <paper-icon-button noink="" id="downButton" icon="icons:arrow-downward"></paper-icon-button>
        <span class="label" hidden$="[[!showLabel]]">[[_label]]</span>
      </div>
      <nuxeo-tooltip for="downButton" position="[[tooltipPosition]]">[[_label]]</nuxeo-tooltip>
    </template>
  </template>

  <script>
    Polymer({
      is: 'nuxeo-collection-move-down-action',
      behaviors: [Nuxeo.I18nBehavior],
      properties: {
        members: {
          type: Object
        },
        allMembers: {
          type: Object
        },
        collection: {
          type: Object
        },
        tooltipPosition: {
          type: String,
          value: 'bottom'
        },
        /**
         * `true` if the action should display the label, `false` otherwise.
         */
        showLabel: {
          type: Boolean,
          value: false,
        },
        _label: {
          type: String,
          computed: '_computeLabel(i18n)'
        },
        _member1Idx: {
          type: Number
        },
        _member2Idx: {
          type: Number
        }
      },

      moveDown: function() {
        if (this.members && this.members.length === 1 && this.allMembers) {
          var member2 = this.members[0].uid;
          var i = 0;
          for (; i < this.allMembers.length; i++) {
            if (this.allMembers[i].uid === member2) {
              if (i < this.allMembers.length - 1) {
                this._member2Idx = i;
                this._member1Idx = i + 1;
                var member1 = this.allMembers[this._member1Idx].uid;
                this.$.moveDownOp.input = this.collection.uid;
                this.$.moveDownOp.params = {
                  member1: member1,
                  member2: member2
                };
                this.$.moveDownOp.execute().then(function() {
                  this.allMembers[this._member2Idx] = this.allMembers.splice(this._member1Idx, 1,
                    this.allMembers[this._member2Idx])[0];
                  this.fire('refresh-display', {focusIndex: this._member1Idx});
                }.bind(this));
              }
              break;
            }
          }
        }
      },

      _isAvailable: function() {
        if (this.members && this.members.length === 1) {
          if (this.allMembers && this.allMembers.length <= 1) {
            return false;
          }
          if (this.allMembers[this.allMembers.length - 1].uid === this.members[0].uid) {
            return false;
          }
          return true;
        }
        return false;
      },

      _computeLabel: function() {
        return this.i18n('collections.moveDown');
      }

    });
  </script>
</dom-module>
<dom-module id="nuxeo-collection-move-top-action" assetpath="nuxeo-collections/">
  <template>
    <style include="nuxeo-action-button-styles"></style>

    <nuxeo-operation op="Document.MoveCollectionMember" id="moveTopOp"></nuxeo-operation>

    <template id="availability" is="dom-if" if="[[_isAvailable(members)]]">
      <div class="action" on-tap="moveUp">
        <paper-icon-button noink="" id="topButton" icon="editor:vertical-align-top"></paper-icon-button>
        <span class="label" hidden$="[[!showLabel]]">[[_label]]</span>
      </div>
      <nuxeo-tooltip for="topButton" position="[[tooltipPosition]]">[[_label]]</nuxeo-tooltip>
    </template>
  </template>

  <script>
    Polymer({
      is: 'nuxeo-collection-move-top-action',
      behaviors: [Nuxeo.I18nBehavior],
      properties: {
        members: {
          type: Object
        },
        allMembers: {
          type: Object
        },
        collection: {
          type: Object
        },
        tooltipPosition: {
          type: String,
          value: 'bottom'
        },
        /**
         * `true` if the action should display the label, `false` otherwise.
         */
        showLabel: {
          type: Boolean,
          value: false,
        },

        _label: {
          type: String,
          computed: '_computeLabel(i18n)'
        },
        _member1Idx: {
          type: Number
        },
        _member2Idx: {
          type: Number
        }
      },

      moveUp: function() {
        if (this.members && this.members.length === 1 && this.allMembers) {
          var member2 = this.members[0].uid;
          var i = 0;
          for (; i < this.allMembers.length; i++) {
            if (this.allMembers[i].uid === member2) {
              if (i > 0) {
                this._member2Idx = i;
                this._member1Idx = 0;
                var member1 = this.allMembers[this._member1Idx].uid;
                this.$.moveTopOp.input = this.collection.uid;
                this.$.moveTopOp.params = {
                  member1: member1,
                  member2: member2
                };
                this.$.moveTopOp.execute().then(function() {
                  this.allMembers[this._member2Idx] = this.allMembers.splice(this._member1Idx, 1,
                    this.allMembers[this._member2Idx])[0];
                  this.fire('refresh-display', {focusIndex: this._member1Idx});
                }.bind(this));
              }
              break;
            }
          }
        }
      },

      _isAvailable: function() {
        if (this.members && this.members.length === 1) {
          if (this.allMembers && this.allMembers.length <= 1) {
            return false;
          }
          if (this.allMembers[0].uid === this.members[0].uid) {
            return false;
          }
          return true;
        }
        return false;
      },

      _computeLabel: function() {
        return this.i18n('collections.moveTop');
      }

    });
  </script>
</dom-module>
<dom-module id="nuxeo-collection-move-bottom-action" assetpath="nuxeo-collections/">
  <template>

    <style include="nuxeo-action-button-styles"></style>

    <nuxeo-operation op="Document.MoveCollectionMember" id="moveBottomOp"></nuxeo-operation>

    <template id="availability" is="dom-if" if="[[_isAvailable(members)]]">
      <div class="action" on-tap="moveBottom">
        <paper-icon-button noink="" id="bottomButton" icon="editor:vertical-align-bottom"></paper-icon-button>
        <span class="label" hidden$="[[!showLabel]]">[[_label]]</span>
      </div>
      <nuxeo-tooltip for="bottomButton" position="[[tooltipPosition]]">[[_label]]</nuxeo-tooltip>
    </template>
  </template>

  <script>
    Polymer({
      is: 'nuxeo-collection-move-bottom-action',
      behaviors: [Nuxeo.I18nBehavior],
      properties: {
        members: {
          type: Object
        },
        allMembers: {
          type: Object
        },
        collection: {
          type: Object
        },
        tooltipPosition: {
          type: String,
          value: 'bottom'
        },
        /**
         * `true` if the action should display the label, `false` otherwise.
         */
        showLabel: {
          type: Boolean,
          value: false,
        },
        _label: {
          type: String,
          computed: '_computeLabel(i18n)'
        },
        _member1Idx: {
          type: Number
        },
        _member2Idx: {
          type: Number
        }
      },

      moveBottom: function() {
        if (this.members && this.members.length === 1 && this.allMembers) {
          var member2 = this.members[0].uid;
          var i = 0;
          for (; i < this.allMembers.length; i++) {
            if (this.allMembers[i].uid === member2) {
              if (i < this.allMembers.length - 1) {
                this._member2Idx = i;
                this._member1Idx = this.allMembers.length - 1;
                var member1 = this.allMembers[this._member1Idx].uid;
                this.$.moveBottomOp.input = this.collection.uid;
                this.$.moveBottomOp.params = {
                  member1: member1,
                  member2: member2
                };
                this.$.moveBottomOp.execute().then(function() {
                  this.allMembers[this._member2Idx] = this.allMembers.splice(this._member1Idx, 1,
                    this.allMembers[this._member2Idx])[0];
                  this.fire('refresh-display', {focusIndex: this._member1Idx});
                }.bind(this));
              }
              break;
            }
          }
        }
      },

      _isAvailable: function() {
        if (this.members && this.members.length === 1) {
          if (this.allMembers && this.allMembers.length <= 1) {
            return false;
          }
          if (this.allMembers[this.allMembers.length - 1].uid === this.members[0].uid) {
            return false;
          }
          return true;
        }
        return false;
      },

      _computeLabel: function() {
        return this.i18n('collections.moveBottom');
      }

    });
  </script>
</dom-module>
<dom-module id="nuxeo-collection-remove-action" assetpath="nuxeo-collections/">
  <template>
    <style include="nuxeo-action-button-styles"></style>

    <nuxeo-operation op="Collection.RemoveFromCollection" id="removeOp"></nuxeo-operation>

    <template id="availability" is="dom-if" if="[[_isAvailable(members, collection)]]">
      <div class="action" on-tap="remove">
        <paper-icon-button noink="" id="removeButton" icon="nuxeo:remove"></paper-icon-button>
        <span class="label" hidden$="[[!showLabel]]">[[_label]]</span>
      </div>
      <nuxeo-tooltip for="removeButton" position="[[tooltipPosition]]">[[_label]]</nuxeo-tooltip>
    </template>
  </template>

  <script>
    Polymer({
      is: 'nuxeo-collection-remove-action',
      behaviors: [Nuxeo.I18nBehavior],
      properties: {
        members: {
          type: Object
        },
        collection: {
          type: Object
        },

        tooltipPosition: {
          type: String,
          value: 'bottom'
        },

        /**
         * `true` if the action should display the label, `false` otherwise.
         */
        showLabel: {
          type: Boolean,
          value: false,
        },

        _label: {
          type: String,
          computed: '_computeLabel(i18n)'
        }
      },

      remove: function() {
        if (this.members && this.members.length > 0) {
          var uids = this.members.map(function(doc) {
            return doc.uid;
          }).join(',');
          this.$.removeOp.input = 'docs:' + uids;
          this.$.removeOp.params = {collection: this.collection.uid};
          this.$.removeOp.execute().then(function() {
            this.members = [];
            this.fire('refresh');
          }.bind(this));
        }
      },

      _isAvailable: function(members, collection) {
        if (collection && collection.contextParameters && collection.contextParameters.permissions) {
          // NXP-21408: prior to 8.10-HF01 the permissions enricher wouldn't return ReadCanCollect
          // Action will therefore not be available
          return collection.contextParameters.permissions.indexOf('ReadCanCollect') > -1;
        }
        return false;
      },

      _computeLabel: function() {
        return this.i18n('collections.remove');
      }

    });
  </script>
</dom-module>
<dom-module id="nuxeo-document-publications" assetpath="nuxeo-publication/">
  <template>
    <style include="nuxeo-styles">
      :host {
        display: block;
      }

      .results {
        @apply --layout-vertical;
        @apply --layout-flex;
        display: block;
        position: relative;
        min-height: calc(100vh - 17em - var(--nuxeo-app-top));
        margin-top: 8px;
      }

      .ellipsis {
        text-overflow: ellipsis;
        overflow: hidden;
        white-space: nowrap;
        display: block;
        width: calc(100% - 38px);
      }

      .capitalize {
        text-transform: capitalize;
      }

      .uppercase {
        text-transform: uppercase;
      }

      .resultActions {
        display: block;
        @apply --layout-horizontal;
        @apply --layout-center;
        @apply --layout-end-justified;
      }

      .resultActions paper-icon-button {
        padding: .3em;
        margin-left: 4px;
      }

    </style>

    <nuxeo-operation id="unpublishOp" op="Document.Delete" sync-indexing="">
    </nuxeo-operation>
    <nuxeo-operation id="unpublishAllOp" op="Document.UnpublishAll" sync-indexing="" input="[[_src]]">
    </nuxeo-operation>
    <nuxeo-operation id="srcDocOp" op="Proxy.GetSourceDocument" input="[[document.uid]]">
    </nuxeo-operation>
    <nuxeo-operation id="publishOp" op="Document.PublishToSection">
    </nuxeo-operation>

    <nuxeo-page-provider id="provider" page-size="40" provider="nxql_search" params="[[_computeParams(_src)]]" sort="{&quot;dc:modified&quot;: &quot;desc&quot;, &quot;uid:major_version&quot;: &quot;desc&quot;, &quot;uid:minor_version&quot;: &quot;desc&quot;}" enrichers="thumbnail, permissions" headers="{&quot;X-NXfetch.document&quot;: &quot;properties&quot;, &quot;X-NXtranslate.directoryEntry&quot;: &quot;label&quot;}" schemas="dublincore,common,uid,rendition">
    </nuxeo-page-provider>

    <nuxeo-card heading="[[i18n('publication.details')]]">

      <div class="resultActions">
        <paper-button class="uppercase" on-tap="_unpublishAll" disabled$="[[!hasPublications]]">[[i18n('publication.unpublishAll')]]</paper-button>
      </div>
      <nuxeo-data-table id="table" nx-provider="provider" class="results" items="{{publishedDocs}}" empty-label="[[i18n('publication.noPublications')]]">
        <nuxeo-data-table-column name="[[i18n('documentContentView.datatable.header.title')]]" flex="200">
          <template>
            <nuxeo-document-thumbnail document="[[item]]"></nuxeo-document-thumbnail>
            <a class="path ellipsis" href$="[[urlFor('browse', item.path)]]">[[item.path]]</a>
            <nuxeo-tooltip>[[item.path]]</nuxeo-tooltip>
          </template>
        </nuxeo-data-table-column>
        <nuxeo-data-table-column name="[[i18n('documentContentView.datatable.header.version')]]" flex="10">
          <template>
            <span class="version">[[formatVersion(item)]]</span>
          </template>
        </nuxeo-data-table-column>
        <nuxeo-data-table-column name="[[i18n('publication.rendition')]]" flex="10">
          <template>
            <span class="uppercase ellipsis rendition">
              [[formatRendition(item.properties.rend:renditionName)]]
            </span>
          </template>
        </nuxeo-data-table-column>
        <nuxeo-data-table-column name="[[i18n('publication.publisher')]]" flex="40">
          <template>
            <nuxeo-user-tag user="[[item.properties.dc:lastContributor]]"></nuxeo-user-tag>
          </template>
        </nuxeo-data-table-column>
        <nuxeo-data-table-column name="[[i18n('publication.publishDate')]]" flex="30">
          <template>
            <nuxeo-date datetime="[[item.properties.dc:modified]]"></nuxeo-date>
          </template>
        </nuxeo-data-table-column>
        <nuxeo-data-table-column flex="10">
          <template>
            <template is="dom-if" if="[[_canUnpublish(item)]]">
              <paper-button class="uppercase unpublish" on-tap="_unpublish">[[i18n('publication.unpublish')]]</paper-button>
            </template>
          </template>
        </nuxeo-data-table-column>
        <nuxeo-data-table-column flex="10">
          <template>
            <template is="dom-if" if="[[_canRepublish(item)]]">
              <paper-button class="uppercase primary republish" on-tap="_republish">[[i18n('publication.republish')]]</paper-button>
            </template>
          </template>
        </nuxeo-data-table-column>
      </nuxeo-data-table>
    </nuxeo-card>
  </template>

  <script>
    Polymer({
      is: 'nuxeo-document-publications',
      behaviors: [Nuxeo.LayoutBehavior],
      properties: {
        document: Object,
        _src: Object,
        visible: Boolean,
        hasPublications: {
          type: Boolean,
          computed: '_hasPublications(publishedDocs)'
        }
      },

      observers: [
        '_fetchPublications(_src, visible)',
        '_observeDocument(document, visible)'
      ],

      listeners : {
        'nx-publish-success': '_fetchPublications',
        'nx-unpublish-success': '_fetchPublications'
      },

      _observeDocument: function() {
        if (this.document && this.visible) {
          if (!this.document.isVersion) {
            this._src = this.document;
          } else {
            this.$.srcDocOp.execute().then(function(src) {
              this._src = src;
            }.bind(this));
          }
        } else {
          this._src = null;
        }
      },

      _computeParams: function() {
        if (this._src) {
          var uid = this._src.uid;
          return {queryParams: 'SELECT * FROM Document WHERE ecm:isProxy = 1 AND ecm:isTrashed = 0' +
            'AND (rend:sourceVersionableId = "' +
            uid +
            '" OR ecm:proxyVersionableId = "' +
            uid +
            '")'
          };
        }
      },

      _fetchPublications: function() {
        if (this.visible && this._src) {
          this.$.table.fetch();
        }
      },

      _unpublish: function(e) {
        if (e && e.target) {
          if (!confirm(this.i18n('publication.unpublish.confirm'))) {
            return;
          }
          var doc = e.target.parentNode.item;
          this.$.unpublishOp.input = doc;
          this.$.unpublishOp.execute().then(function() {
            this.fire('notify', {'message': this.i18n('publication.unpublish.success')});
            this._fetchPublications();
          }.bind(this)).catch(function() {
            this.fire('notify', {'message': this.i18n('publication.unpublish.error')});
          }.bind(this));
        }
      },

      _republish: function(e) {
        if (e && e.target) {
          if (!confirm(this.i18n('publication.republish.confirm'))) {
            return;
          }
          var obsolete = e.target.parentNode.item;
          this.$.publishOp.params = {
            'target': obsolete.parentRef,
            'override': true,
            'renditionName': obsolete.properties['rend:renditionName']
          }
          this.$.publishOp.input = this._src.uid;
          this.$.publishOp.execute().then(function() {
            this.fire('notify', {
              'message': this.i18n('publication.internal.publish.success')
            });
            this.fire('document-updated');
            this.fire('nx-publish-success');
          }.bind(this)).catch(function(err) {
            this.fire('notify', {
              'message': this.i18n('publication.internal.publish.error')
            });
            throw err;
          }.bind(this));
        }
      },

      _canUnpublish: function(doc) {
        return doc && this.hasPermission(doc, 'Write');
      },

      _canRepublish: function(doc) {
        if (this._src && this._canUnpublish(doc)) {
          var pubMaj = doc.properties['uid:major_version'];
          var srcMaj = this._src.properties['uid:major_version'];
          if (pubMaj < srcMaj) {
            return true;
          } else if (pubMaj === srcMaj) {
            var pubMin = doc.properties['uid:minor_version'];
            var srcMin = this._src.properties['uid:minor_version'];
            return pubMin < srcMin || (pubMin === srcMin && this._src.isCheckedOut);
          }
        }
        return false;
      },

      _hasPublications: function(docs) {
        return docs && docs.length > 0;
      },

      _unpublishAll: function() {
        if (!confirm(this.i18n('publication.unpublish.all.confirm'))) {
          return;
        }
        this.$.unpublishAllOp.execute().then(function() {
          this.fire('notify', {'message': this.i18n('publication.unpublish.all.success')});
          this._fetchPublications();
        }.bind(this)).catch(function() {
          this.fire('notify', {'message': this.i18n('publication.unpublish.all.error')});
        });
      }

    });
  </script>
</dom-module>
<dom-module id="nuxeo-internal-publish" assetpath="nuxeo-publication/">
  <template>
    <style include="iron-flex iron-flex-alignment iron-flex-factors nuxeo-styles">
      :host {
        display: block;
        @apply --layout-flex;
        @apply --layout-horizontal;
      }

      .container {
        margin: 2rem;
        padding: 0 1rem 0 0;
        display: inline-block;
        @apply --layout-flex;
        @apply --layout-vertical;
      }

      .versions, .options {
        margin-left: 3em;
      }

      label {
        @apply --nuxeo-label;
      }

      .error {
        border-left: 4px solid var(--nuxeo-warn-text);
        color: var(--nuxeo-text-default);
        padding-left: 8px;
        margin-bottom: 8px;
      }
    </style>

    <nuxeo-operation id="op" op="Document.PublishToSection" sync-indexing="">
    </nuxeo-operation>

    <nuxeo-document id="srcDoc">
    </nuxeo-document>

    <div class="container">
      <nuxeo-document-suggestion id="target" required="" label="[[i18n('publication.internal.location')]]" placeholder="[[i18n('publication.internal.location.placeholder')]]" selected-item="{{publishSpace}}" min-chars="0" selection-formatter="[[targetFormatter]]" enrichers="permissions" page-provider="publish_space_suggestion" repository="[[document.repository]]">
      </nuxeo-document-suggestion>
      <template is="dom-if" if="[[errorMessage]]">
        <span class="horizontal layout error">[[errorMessage]]</span>
      </template>

      <div class="horizontal layout flex">
        <nuxeo-select id="rendition" label="[[i18n('publication.internal.renditons.label')]]" placeholder="[[i18n('publication.internal.renditons.placeholder')]]" selected="{{selectedRendition}}" attr-for-selected="name">
          <template is="dom-repeat" items="[[_computeRenditionOptions(document, i18n)]]" as="rendition">
            <paper-item name$="[[rendition.id]]">[[rendition.label]]</paper-item>
          </template>
        </nuxeo-select>
        <template is="dom-if" if="[[!_isMultiple]]">
          <div class="versions">
            <label>[[i18n('documentInfo.version')]]</label>
            <nuxeo-document-versions id="version" document="[[document]]"></nuxeo-document-versions>
          </div>
        </template>
        <div class="options">
          <label>[[i18n('publication.internal.options')]]</label>
          <paper-checkbox id="override" checked="{{override}}">
            [[i18n('publication.internal.override')]]
          </paper-checkbox>
        </div>
      </div>
      <div class="buttons horizontal end-justified layout">
        <div class="flex start-justified">
          <paper-button noink="" dialog-dismiss="" on-tap="_cancel">[[i18n('command.cancel')]]</paper-button>
        </div>
        <paper-button id="publish" noink="" class="primary" on-tap="_publish" disabled$="[[!_canPublish(document,publishSpace)]]">
            [[i18n('publication.publish')]]
        </paper-button>
      </div>
    </div>

  </template>

  <script>
    Polymer({
      is: 'nuxeo-internal-publish',
      behaviors: [Nuxeo.I18nBehavior, Nuxeo.LayoutBehavior],
      properties: {
        /**
         * Input document.
         */
        document: Object,

        /**
         * Input documents.
         */
        documents: Array,

        publishSpace: Object,

        selectedRendition: {
          type: String,
          value: 'none'
        },

        _isMultiple: {
          type: Boolean,
          computed: '_computeMultiple(document, documents.length)'
        },

        targetFormatter: {
          type: Function,
          value: function() {
            return this._targetFormatter.bind(this);
          }
        }
      },

      _computeMultiple: function() {
        return !!(this.documents && this.documents.length > 0);
      },

      _computeRenditionOptions: function() {
        var options = [
          {'id': 'none', 'label': this.i18n('publication.internal.renditon.none')},
          {'id': 'default', 'label': this.i18n('publication.internal.renditon.default')}
        ];
        if (this.document && this.document.contextParameters && this.document.contextParameters.renditions) {
          this.document.contextParameters.renditions.forEach(function(item) {
            options.push({'id': item.name, 'label': this.formatRendition(item.name), 'icon': item.icon});
          }.bind(this));
        }
        return options;
      },

      _publish: function() {
        this.$.op.params = {
          'target': this.publishSpace.uid,
          'override': this.override,
          'renditionName': null
        }
        if (this.selectedRendition) {
          if (this.selectedRendition === 'default') {
            this.$.op.params.defaultRendition = true;
          } else if (this.selectedRendition !== 'none') {
            this.$.op.params.renditionName = this.selectedRendition;
          }
        }
        this.$.op.input = this._isMultiple ? 'docs:' + this.documents.map(function(doc) {
          return doc.uid;
        }).join(',') : this.document.uid;
        this.$.op.execute().then(function() {
          this.fire('notify', {
            'message': this.i18n('publication.internal.publish.success' + (this._isMultiple ? '.multiple' : ''))
          });
          this._isMultiple ? this.fire('navigate', {doc: this.publishSpace}) : this.fire('document-updated');
          this.fire('nx-publish-success');
        }.bind(this)).catch(function(err) {
          this.fire('notify', {
            'message': this.i18n('publication.internal.publish.error' + (this._isMultiple ? '.multiple' : ''))
          });
          throw err;
        }.bind(this));
      },

      _canPublish: function() {
        this.errorMessage = null;
        if(!this.publishSpace) {
          return false;
        }
        var hasPermission = this.hasPermission(this.publishSpace, 'AddChildren');
        if(!hasPermission) {
          this.errorMessage = this.i18n('publication.internal.location.error.noPermission');
        }
        return hasPermission;
      },

      _cancel: function() {
        this.fire('cancel');
      },

      _targetFormatter: function(doc) {
        return doc.title;
      }
    });
  </script>

</dom-module>
<dom-module id="nuxeo-publish-button" assetpath="nuxeo-publication/">
  <template>
    <style include="nuxeo-action-button-styles">
      :host {
        --paper-tabs-selection-bar-color: var(--nuxeo-primary-color);
        display: block;
      }

      paper-tabs {
        border-bottom: 1px solid var(--divider-color);
      }

      paper-tab {
        text-transform: uppercase;
      }

      paper-tabs,
      #container {
        margin: 0;
        padding: 0;
      }

      iron-pages,
      nuxeo-document-import {
        /*Firefox fix (NXP-22349)*/
        min-height: 100%;
      }

      #container {
        height: 250px;
        min-width: 50vw;
      }

      iron-pages {
        @apply --layout-flex;
        @apply --layout-horizontal;
      }

      /* IE11 fix (NXP-23550) */
      *::-ms-backdrop, iron-pages * {
        height: 80vh;
      }
    </style>

    <template is="dom-if" if="[[_isAvailable(document, documents.splices)]]">
      <div class="action" on-tap="_toggleDialog">
        <paper-icon-button id="publishButton" icon="[[icon]]" noink=""></paper-icon-button>
        <span class="label" hidden$="[[!showLabel]]">[[_label]]</span>
        <nuxeo-tooltip>[[_label]]</nuxeo-tooltip>
      </div>
    </template>

    <nuxeo-dialog id="publishDialog" modal="" opened="{{opened}}" no-auto-focus="">
      <paper-tabs selected="{{selectedTab}}" attr-for-selected="name" noink="">
        <nuxeo-slot slot="PUBLISH_ITEMS" model="[[publishContext]]"></nuxeo-slot>
      </paper-tabs>
      <div id="container" class="vertical layout flex">
        <iron-pages selected="[[selectedTab]]" attr-for-selected="name" selected-attribute="visible">
          <nuxeo-slot slot="PUBLISH_PAGES" model="[[publishContext]]"></nuxeo-slot>
        </iron-pages>
      </div>
    </nuxeo-dialog>

  </template>

  <script>
    Polymer({
      is: 'nuxeo-publish-button',
      behaviors: [Nuxeo.I18nBehavior, Nuxeo.FiltersBehavior],
      properties: {
        /**
         * Input document.
         */
        document: Object,

        /**
         * Input documents.
         */
        documents: Object,

        /**
          * Icon to use (iconset_name:icon_name).
          */
        icon: {
          type: String,
          value: 'editor:publish',
        },

        selectedTab: {
          type: String,
          value: 'internal'
        },
        publishContext: {
          type: Object,
          computed: '_publishContext(document, documents.splices, i18n, opened)'
        },
        /**
         * `true` if the action should display the label, `false` otherwise.
         */
        showLabel: {
          type: Boolean,
          value: false,
        },
        _label: {
          type: String,
          computed: '_computeLabel(i18n)'
        }
      },

      listeners: {
        'nx-publish-success': '_close',
        'cancel': '_close'
      },

      _toggleDialog: function() {
        this.$.publishDialog.toggle();
      },

      _close: function() {
        this.$.publishDialog.close();
      },

      _publishContext: function() {
        return this.opened ? {document: this.document, documents: this.documents, i18n: this.i18n} : {};
      },

      _computeLabel: function() {
        return this.i18n('publication.button.tooltip');
      },

      _isAvailable: function() {
        return (this.document && this.isPublishable(this.document)) || (this.documents && this.documents.every(
          function(doc) {
            return this.isPublishable(doc);
          }.bind(this)));
      },

      _checkDocsPermissions: function() {
        this.docsHavePermissions = this.documents && !(this.documents.some(
          function(document) {
            return !this._docHasPermissions(document);
          }.bind(this)));
        return this.docsHavePermissions;
      },

    });
  </script>

</dom-module>
<dom-module id="nuxeo-suggester" assetpath="nuxeo-suggester/">
  <template>
    <style include="nuxeo-styles">
      :host {
        @apply --layout-horizontal;
        @apply --layout-flex;
        @apply --layout-center;
      }

      paper-input {
        width: var(--nuxeo-suggester-width, 60%);

        --paper-input-container-input: {
          color: var(--nuxeo-quicksearch-text);
          font-size: 1rem;
          font-family: var(--nuxeo-app-font);
        };

        --paper-input-container-underline: {
          background-color: transparent;
        };

        --paper-input-container-underline-focus: {
          background-color: transparent;
        };

        --paper-input-container-label: {
          color: var(--nuxeo-text-default);
          font-size: 1rem;
          font-family: var(--nuxeo-app-font);
          line-height: unset;
          padding-left: 5px;
        };

        --paper-input-container-label-focus: {
          color: #e8e8e8;
          font-size: 1rem;
          line-height: unset;
          padding-left: 5px;
        };
      }

      .input-content.paper-input-container label {
        left: 7px;
      }

      #searchButton {
        border-left: 1px solid rgba(0,0,0,0.1);
        position: fixed;
        z-index: 100;
        top: 0;
        color: var(--nuxeo-app-header);
        @apply --nuxeo-suggester-button
      }

      #searchButton:hover {
        background-color: var(--nuxeo-button-primary);
        color: var(--nuxeo-button-primary-text);
      }

      #searchButton.toggled {
        color: var(--nuxeo-button-primary-text);
        background-color: var(--nuxeo-button-primary);
        z-index: 1001;
      }

      #suggester {
        top: 0;
        left: 0;
        position: fixed;
        z-index: 1001;
        width: 100%;
        height: 100%;
        @apply --layout-vertical;
        @apply --layout-center;
      }

      #searchBar {
        height: 53px;
        background-color: var(--nuxeo-quicksearch-background);
        color: var(--nuxeo-quicksearch-text);
        @apply --layout-horizontal;
        @apply --layout-center;
        @apply --layout-center-justified;
        @apply --layout-self-stretch;
      }

      #suggester .unfocused-line.paper-input-container,
      #suggester .focused-line.paper-input-container {
        background-color: transparent;
      }

      #results {
        width: var(--nuxeo-suggester-width, 65%);
        margin: .5em 0 3em;
        height: calc(100% - 130px);
        padding: 0 2em;
        box-sizing: border-box;
        overflow-y: auto;
        @apply --layout-vertical;
      }

      .item {
        display: block;
        padding: 1em;
        background-color: var(--nuxeo-quicksearch-background);
        @apply --layout-horizontal;
        @apply --layout-center;
      }

      .item.details {
        @apply --layout-vertical;
      }

      .item .details {
        min-width: 1px;
      }

      .item + .item {
        border-top: 1px solid var(--nuxeo-border);
      }

      .item iron-icon {
        margin: 0 16px 0 4px;
      }

      a.item:hover,
      a.iron-selected {
        color: var(--nuxeo-text-default);
        @apply --nuxeo-block-selected;
      }

      a .itemName {
        text-overflow: ellipsis;
        overflow: hidden;
        white-space: nowrap;
      }

      a .itemPath {
        opacity: .7;
        font-size: .8em;
      }

      a:hover .itemName {
        color: var(--nuxeo-primary-color);
      }

      .fade {
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        position: fixed;
        opacity: .8;
        z-index: -1;
        background: var(--primary-text-color);
      }

      .thumbnailContainer {
        width: 60px;
        height: 60px;
        margin-right: 10px;
      }

      nuxeo-document-highlights {
        font-size: .85rem;
      }

      @media (max-width: 1024px) {
        #searchButton {
          background-color: var(--nuxeo-app-header-background);
          z-index: 100;
        }

        #searchBar {
          justify-content: flex-start;
        }

        paper-input {
          width: var(--nuxeo-suggester-media-width, calc(100% - 90px));
          margin-left: var(--nuxeo-suggester-media-margin-left, 1.2rem);
        }

        #results {
          width: 100%;
          padding: 1em;
        }
      }
    </style>

    <nuxeo-connection id="nxcon"></nuxeo-connection>
    <nuxeo-operation id="op" op="Search.SuggestersLauncher" response="{{items}}" params="{&quot;searchTerm&quot;:&quot;[[searchTerm]]&quot;}"></nuxeo-operation>

    <div hidden$="[[!toggled]]">
      <div id="suggester">
        <div class="fade" on-tap="toggle"></div>
        <div id="searchBar">
          <paper-input noink="" id="searchInput" value="{{searchTerm}}" type="search" auto-focus="" label="[[i18n('suggester.label')]]" no-label-float=""></paper-input>
        </div>
        <div id="results" hidden$="[[!_canShowResults(searchTerm, items, items.splices)]]">
          <iron-selector id="selector">
            <template is="dom-repeat" items="{{items}}">
              <a class="item" href$="[[_getUrl(item, false, urlFor)]]" on-click="_itemClicked">
                <div class="thumbnailContainer">
                  <iron-image src="[[_getIcon(item)]]" sizing="cover" position="center" class="thumbnailContainer">
                  </iron-image>
                </div>
                <div class="details">
                  <div class="itemName">[[item.label]]</div>
                  <div class="itemPath">[[_getUrl(item, true, urlFor)]]</div>
                  <nuxeo-document-highlights highlights="[[item.highlights]]"></nuxeo-document-highlights>
                </div>
              </a>
            </template>
          </iron-selector>
        </div>
      </div>
    </div>
    <paper-icon-button noink="" id="searchButton" icon="nuxeo:search" name="browser" on-tap="toggle"></paper-icon-button>

    <nuxeo-keys target="[[target]]" keys="up" on-pressed="_upPressed"></nuxeo-keys>
    <nuxeo-keys target="[[target]]" keys="down" on-pressed="_downPressed"></nuxeo-keys>
    <nuxeo-keys target="[[target]]" keys="enter" on-pressed="_enterPressed"></nuxeo-keys>
    <nuxeo-keys target="[[target]]" keys="esc" on-pressed="closeResults"></nuxeo-keys>

  </template>

  <script>
    var Nuxeo = Nuxeo || {};
    (function() {
      var commands = [];
      Nuxeo._Suggester = Nuxeo._Suggester || {};
      /**
       * Adds a custom command to nuxeo-suggester. Expected command format:
       * { id: String, startsWith: Boolean, searchTerm: String, suggestion: Object, run: Function }
       * Here, suggestion must have and id, icon and label.
       */
      Nuxeo._Suggester.addCommand = function(command) {
        if (!command) {
          return;
        }
        var index = commands.indexOf(function(c) {
          return c.id === command.id
        });
        if (index > -1) {
          commands.splice(index, 1, command);
        } else {
          commands.push(command);
        }
        command.suggestion.command = command;
      };
      Polymer({
        is: 'nuxeo-suggester',
        behaviors: [Nuxeo.RoutingBehavior, Nuxeo.I18nBehavior],
        properties: {
          toggled: {
            type: Boolean,
            notify: true,
            value: false
          },
          searchTerm: {
            type: String,
            value: '',
            notify: true,
            observer: '_searchTermChanged'
          },
          searchDelay: {
            type: Number,
            value: 200
          },
          target: {
            type: Object,
            value: function() {
              return this;
            }
          },
          items: {
            type: Array
          }
        },

        toggle: function() {
          this.toggled = !this.toggled;
          this.searchTerm = '';
          this.toggleClass('toggled', this.toggled, this.$.searchButton);
          if (this.toggled) {
            this.$.searchInput.focus();
          }
        },

        closeResults: function(e) {
          e.detail.keyboardEvent.preventDefault();
          this.toggle();
        },

        _searchTermChanged: function() {
          this.$.selector.selected = 0;
          if (this.searchTerm === '') {
            this.items = [];
          } else {
            this.debounce('suggester-search', function() {
              this.$.op.execute().then(function() {
                commands.forEach(function(command) {
                  var addSuggestion = false;
                  if (command.trigger.regex) {
                    addSuggestion = this.searchTerm.match(command.trigger.regex);
                  } else if (command.trigger.searchTerm) {
                    var commandTerm = command.trigger.searchTerm.trim().toLowerCase();
                    var searchTerm = this.searchTerm.trim().toLowerCase();
                    addSuggestion = command.trigger.startsWith ?
                                          commandTerm.startsWith(searchTerm) :
                                          commandTerm === searchTerm;
                  }
                  if (addSuggestion) {
                    this.push('items', command.suggestion);
                  }
                }.bind(this));
              }.bind(this));
            }.bind(this), this.searchDelay);
          }
        },

        _canShowResults: function() {
          return this.searchTerm !== '' && this.items &&
            (Array.isArray(this.items) ? this.items.length > 0 : true);
        },

        _getIcon: function(item) {
          if (item.command) {
            return item.icon;
          } else if (item.thumbnailUrl && item.thumbnailUrl.length > 0) {
            return this.$.nxcon.url + '/' + item.thumbnailUrl;
          } else {
            return this.$.nxcon.url + item.icon;
          }
        },

        _getUrl: function(item, replaceHashbang) {
          var url;
          if (!item.command) {
            url = item.type && this.urlFor(item.type, item.id)
          }
          if (url && replaceHashbang) {
            url = url.replace('/#!', '');
          }
          return url;
        },

        _upPressed: function(e) {
          e.detail.keyboardEvent.preventDefault();
          this.$.selector.selectPrevious();
        },

        _downPressed: function(e) {
          e.detail.keyboardEvent.preventDefault();
          this.$.selector.selectNext();
        },

        _enterPressed: function(e) {
          if (this.$.selector.items.length > 0) {
            e.detail.keyboardEvent.preventDefault();
            this.$.selector.items[this.$.selector.selected].click();
          }
        },

        _itemClicked: function(e) {
          if (e.model.item.command && e.model.item.command.run) {
            e.model.item.command.run(this.searchTerm);
          }
          this.toggle();
        },
      });
    })();
  </script>
</dom-module>
<dom-module id="nuxeo-tasks-list" assetpath="nuxeo-tasks/">
  <template>
    <style include="iron-flex">
      :host {
        display: block;
        position: relative;
        height: calc(100vh - 7.7em);
      }

      .task-box {
        line-height: 155%;
      }

      .task-box + .task-box {
        border-top: 1px solid var(--divider-color);
      }

      .task-property {
        opacity: .5;
        margin-right: .5rem;
      }

      .taskDoc .doc-title, .date {
        text-overflow: ellipsis;
        white-space: nowrap;
        max-width: 85%;
        overflow: hidden;
      }

      .date {
        color: var(--nuxeo-warn-text);
      }

      .list-item {
        cursor: pointer;
        padding: 1em;
        border-bottom: 1px solid var(--nuxeo-border);
      }

      .list-item:hover {
        @apply --nuxeo-block-hover;
      }

      .list-item.selected,
      .list-item:focus,
      .list-item.selected:focus {
        @apply --nuxeo-block-selected;
      }

      nuxeo-data-list {
        display: block;
        position: absolute;
        left: 0;
        top: 0;
        right: 0;
        bottom: 0;
        min-height: auto;
      }

      /* fix IE11 tap selection not working for task list items (NXP-21833) */
      .task-box {
        pointer-events: none;
        @apply --layout-vertical;
      }
      /* prevent previous fix from disabling the default nuxeo-user-tag click behavior (NXP-21833) */
      .task-box nuxeo-date {
        pointer-events: all;
      }

      .task-name {
        font-weight: bold;
        text-transform: uppercase;
      }

      .horizontal {
        @apply --layout-horizontal;
        @apply --layout-center;
      }
    </style>

    <nuxeo-data-list items="[[tasks]]" id="list" as="task" selected-item="{{_selection}}" empty-label="[[i18n('tasksList.noTasks')]]" selection-enabled="" select-on-tap="">
      <template>
        <div tabindex$="{{tabIndex}}" class$="[[_computedClass(selected)]]">
          <div class="task-box">
            <div class="horizontal layout center">
              <span class="task-name">[[i18n(task.name)]]</span>
            </div>
            <div class="task-detail">
              <div class="taskDoc horizontal">
                <span class="doc-title">[[task.targetDocumentIds.0.title]]</span>
              </div>
              <div class="horizontal">
                <span class="due-date task-property">[[i18n('tasksList.dueDate')]]</span>
                <span class="date"> <nuxeo-date datetime="[[task.dueDate]]" format="relative"></nuxeo-date></span>
              </div>
            </div>
            <div class="horizontal">
              <span class="workflow-name">[[i18n(task.workflowModelName)]]</span>
            </div>
          </div>
        </div>
      </template>
    </nuxeo-data-list>
  </template>

  <script>
    Polymer({
      is: 'nuxeo-tasks-list',
      behaviors: [Nuxeo.RoutingBehavior, Nuxeo.I18nBehavior],
      properties: {
        tasks: Array,

        current: {
          type: Object,
          observer: '_currentChanged'
        },

        _selection: {
          type: Object,
          observer: '_selectionChanged'
        },

        /**
         * Set to true to prevent from fire event to navigate to the task.
         **/
        noNavigation: Boolean
      },

      _selectionChanged: function() {
        if (this._selection && !this.noNavigation) {
          this.navigateTo('tasks', this._selection.id);
        }
      },

      _currentChanged: function(newVal, oldVal) {
        if (newVal && oldVal && newVal.id === oldVal.id) {
          return;
        }
        if (newVal && this.tasks) {
          for (var i = 0; i < this.tasks.length; i++) {
            if (this.tasks[i].id === newVal.id) {
              this.$.list.selectItem(this.tasks[i]);
              break;
            }
          }
        } else {
          var _exists = this.tasks && this.tasks.indexOf(oldVal) > -1;
          // make sure this task still exists to avoid iron-list exceptions
          if (_exists) {
            this.$.list.deselectItem(oldVal);
          }
        }
      },

      _computedClass: function(isSelected) {
        var classes = 'list-item';
        if (isSelected) {
          classes += ' selected';
        }
        return classes;
      }

    });
  </script>
</dom-module>
<dom-module id="nuxeo-tasks-drawer" assetpath="nuxeo-tasks/">
  <template>
    <style include="nuxeo-styles">
      .tasks-dashboard {
        padding: .7em 1em;
        display: block;
        border-top: 1px solid var(--nuxeo-border);
      }
    </style>

    <div class="header">[[i18n('app.tasks')]]</div>
    <nuxeo-tasks-list tasks="[[tasks]]" current="[[currentTask]]"></nuxeo-tasks-list>
    <div class="tasks-dashboard">
      <a href$="[[urlFor('tasks')]]">[[i18n('app.viewTasksDashboard')]]</a>
    </div>

  </template>
  <script>
    Polymer({
      is: 'nuxeo-tasks-drawer',
      behaviors: [Nuxeo.RoutingBehavior, Nuxeo.I18nBehavior],
      properties: {
        tasks: Array,
        currentTask: Object
      }
    });
  </script>
</dom-module>
<dom-module id="nuxeo-theme" assetpath="nuxeo-themes/">
  <template>

    <style>
      :host {
        display: block;
      }

      nuxeo-card[selected] {
        border: 2px solid var(--default-primary-color);
        border-radius: 3px;
      }

      iron-image {
        width: 100%;
        height: 250px;
        margin-bottom: 8px;
        background-color: rgba(0,0,0,0.05);
      }

      .details {
        @apply --layout-horizontal;
        @apply --layout-justified;
        @apply --layout-center;
      }

      .label {
        margin-left: 8px;
      }

      paper-button {
        @apply --nx-button-primary;
      }

      paper-button[disabled] {
        @apply --nx-button-disabled;
      }
    </style>

    <nuxeo-card selected$="[[_selected(name)]]">
      <iron-image src="[[_image(name)]]" sizing="contain"></iron-image>
      <div class="details">
        <div class="label">[[_label(name)]]</div>
        <paper-button on-tap="_apply" noink="" disabled$="[[_selected(name)]]">
          [[_button(name)]]
        </paper-button>
      </div>
    </nuxeo-card>

  </template>
  <script>
    Polymer({
      is: 'nuxeo-theme',
      behaviors: [Nuxeo.I18nBehavior],
      properties: {
        name: String,
        title: String,
        preview: String
      },

      _image: function(name) {
        return (this.preview) ? this.preview : 'themes/' + name + '/preview.jpg';
      },

      _label: function(name) {
        return (this.title) ? this.title : this.i18n('themes.' + name);
      },

      _button: function(name) {
        return this.i18n('themes.' + (this._selected(name) ? 'current' : 'apply'));
      },

      _selected: function(name) {
        var theme = localStorage.getItem('theme');
        return (theme) ? theme === name : name === 'default';
      },

      _apply: function() {
        localStorage.setItem('theme', this.name);
        this.fire('theme-changed', {theme: this.name});
      }

    });
  </script>
</dom-module>
<dom-module id="nuxeo-note-editor" assetpath="nuxeo-note-editor/">
  <template>

    <style include="nuxeo-styles iron-flex iron-flex-alignment">
      :host {
        display: block;
      }

      .main {
        position: relative;
      }

      .edit {
        position: absolute;
      }

      #editNote.edit {
        right: 10px;
        top: 10px;
      }

      #editHtml.edit {
        left: 0;
        bottom: 0;
        padding: 0;
        width: 24px;
        height: 24px;
        z-index: 1;
      }

      .html-editor-container paper-textarea {
        padding: 0;
      }

      paper-textarea,
      nuxeo-document-preview,
      nuxeo-html-editor {
        display: block;
        min-height: calc(80vh - 132px);
      }

      paper-textarea {
        --paper-input-container-underline: {
          border-bottom: none 0;
        };
        --paper-input-container-underline-focus: {
          border-bottom: none 0;
        };
      }

    </style>

    <nuxeo-document id="note" doc-id="[[document.uid]]"></nuxeo-document>

    <div class="main">

      <template is="dom-if" if="[[_isHTML(document)]]">
        <div class="html-editor-container">
          <paper-icon-button id="editHtml" class="edit" icon="[[_computeHtmlEditIcon(_viewMode)]]" on-tap="_toggleHtmlSource" hidden$="[[!_canEdit(document)]]"></paper-icon-button>
          <paper-tooltip for="editHtml" position="right">[[_computeHtmlEditLabel(_viewMode, i18n)]]</paper-tooltip>
          <template is="dom-if" if="[[_viewMode]]">
            <nuxeo-html-editor value="{{_value}}" read-only="[[!_canEdit(document)]]"></nuxeo-html-editor>
          </template>
          <template is="dom-if" if="[[!_viewMode]]">
            <paper-textarea value="{{_value}}" no-label-float="" placeholder="[[i18n('noteViewLayout.placeholder')]]"></paper-textarea>
          </template>
          <div class="layout horizontal end-justified">
            <paper-button name="editorSave" noink="" class="primary" on-tap="_editorSave" hidden$="[[!_canEdit(document)]]">[[i18n('command.save')]]</paper-button>
          </div>
        </div>
      </template>

      <template is="dom-if" if="[[!_isHTML(document)]]">
        <template is="dom-if" if="[[_viewMode]]">
          <paper-icon-button id="editNote" class="edit" icon="nuxeo:edit" on-tap="_edit" hidden$="[[!_canEdit(document)]]"></paper-icon-button>
          <paper-tooltip for="editNote" position="bottom">[[i18n('command.edit')]]</paper-tooltip>
          <nuxeo-document-preview document="[[document]]"></nuxeo-document-preview>
        </template>
        <template is="dom-if" if="[[!_viewMode]]">
          <paper-textarea value="{{_value}}" no-label-float="" placeholder="[[i18n('noteViewLayout.placeholder')]]"></paper-textarea>
          <div class="layout horizontal end-justified">
            <paper-button noink="" on-tap="_cancel">[[i18n('command.cancel')]]</paper-button>
            <paper-button name="editorSave" noink="" class="primary" on-tap="_editorSave">[[i18n('command.save')]]</paper-button>
          </div>
        </template>
      </template>

    </div>

  </template>

</dom-module>

<script>
  (function() {
    Polymer({
      is: 'nuxeo-note-editor',
      behaviors: [Nuxeo.LayoutBehavior],
      properties: {
        document: {
          type: Object,
          observer: '_documentChanged'
        },
        _viewMode: {
          type: Boolean,
          value: true
        },
        _value: {
          type: String,
          value: ''
        }
      },

      _documentChanged: function() {
        this._value = this.document.properties['note:note'];
      },

      _isHTML: function() {
        return this.document && this.document.properties['note:mime_type'] === 'text/html';
      },

      _computeHtmlEditIcon: function() {
        return this._viewMode ? 'icons:code' : 'nuxeo:edit';
      },

      _computeHtmlEditLabel: function() {
        return this._viewMode ? this.i18n('noteEditor.editSource') : this.i18n('noteEditor.editRich');
      },

      _editorSave: function() {
        this.$.note.data = {
          'entity-type': 'document',
          uid: this.document.uid,
          properties: {
            'note:note': this._value
          }
        };
        this.$.note.put().then(function() {
          this.fire('notify', {message: this.i18n('noteViewLayout.note.saved')});
          this._viewMode = true;
          this.fire('document-updated');
        }.bind(this));
      },

      _isMutable: function(document) {
        return !this.hasFacet(document, 'Immutable') && document.type !== 'Root' && !this.isTrashed(document);
      },

      _canEdit: function(document) {
        return document.type !== 'Root' && this.hasPermission(document, 'Write') && this._isMutable(document);
      },

      _edit: function() {
        this._value = this.document.properties['note:note'];
        this._viewMode = false;
      },

      _cancel: function() {
        this._value = '';
        this._viewMode = true;
      },

      _toggleHtmlSource: function() {
        this._viewMode = !this._viewMode;
      }
    });
  })();
</script>
<dom-module id="nuxeo-video-info" assetpath="nuxeo-video/">
  <template>

    <style>
      .properties {
        -moz-column-width: 25em; /* Firefox */
        -webkit-column-width: 25em; /* webkit, Safari, Chrome */
        column-width: 25em;
        column-count: 3;
        -moz-column-count: 3; /* Firefox */
        -webkit-column-count: 3; /* webkit, Safari, Chrome */
      }

      .properties label {
        width: 10em;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .item {
        @apply --layout-horizontal;
        @apply --layout-flex;
      }

      .item label {
        color: var(--secondary-text-color);
      }
    </style>

    <div class="properties">
      <div class="item">
        <label>[[i18n('videoViewLayout.format')]]</label>
        <div>[[document.properties.vid:info.format]]</div>
      </div>
      <div class="item">
        <label>[[i18n('videoViewLayout.duration')]]</label>
        <div>[[document.properties.vid:info.duration]]</div>
      </div>
      <div class="item">
        <label>[[i18n('videoViewLayout.width')]]</label>
        <div>[[document.properties.vid:info.width]]</div>
      </div>
      <div class="item">
        <label>[[i18n('videoViewLayout.height')]]</label>
        <div>[[document.properties.vid:info.height]]</div>
      </div>
      <div class="item">
        <label>[[i18n('videoViewLayout.frameRate')]]</label>
        <div>[[document.properties.vid:info.frameRate]]</div>
      </div>
    </div>

  </template>

  <script>
    Polymer({
      is: 'nuxeo-video-info',
      behaviors: [Nuxeo.I18nBehavior],
      properties: {
        document: Object
      }
    });
  </script>

</dom-module>
<dom-module id="nuxeo-video-conversions" assetpath="nuxeo-video/">
  <template>
    <style include="iron-flex">
      a, a:active, a:visited, a:focus {
        @apply --nuxeo-link;
      }
      a:hover {
        @apply --nuxeo-link-hover;
      }
    </style>

    <h3>[[label]]</h3>
    <div>
      <template is="dom-repeat" items="[[document.properties.vid:transcodedVideos]]" as="conversion">
        <template is="dom-if" if="[[conversion.content]]">
          <div class="layout horizontal center">
            <label class="flex">[[conversion.name]]</label>
            <div class="flex">[[conversion.info.width]] x [[conversion.info.height]]</div>
            <div class="flex">[[formatSize(conversion.content.length)]]</div>
            <a href="[[conversion.content.data]]">
              <iron-icon icon="nuxeo:download"></iron-icon>
              <nuxeo-tooltip>[[i18n('videoViewLayout.download.tooltip')]]</nuxeo-tooltip>
            </a>
          </div>
        </template>
      </template>
    </div>
  </template>

  <script>
    Polymer({
      is: 'nuxeo-video-conversions',
      behaviors: [Nuxeo.I18nBehavior, Nuxeo.FormatBehavior],
      properties: {
        document: Object
      }
    });
  </script>
</dom-module>
<dom-module id="nuxeo-clipboard" assetpath="nuxeo-clipboard/">
  <template>
    <style include="nuxeo-styles">
      :host {
        overflow: hidden;
      }

      .content {
        @apply --layout-vertical;
        height: calc(100vh - 61px - var(--nuxeo-app-top));
      }

      nuxeo-data-list {
        display: block;
        position: relative;
        height: 100%;
      }

      .list-item {
        cursor: pointer;
        padding: 1em;
        border-bottom: 1px solid var(--nuxeo-border);
      }

      .list-item:hover {
        @apply --nuxeo-block-hover;
      }

      .list-item.selected,
      .list-item:focus,
      .list-item.selected:focus {
        @apply --nuxeo-block-selected;
      }

      .list-item-box {
        @apply --layout-vertical;
      }

      .list-item-info {
        @apply --layout-horizontal;
        @apply --layout-center;
      }

      .list-item-thumbnail {
        @apply --layout-vertical;
        @apply --layout-center;
      }

      .list-item-title {
        @apply --layout-flex;
        text-overflow: ellipsis;
        overflow: hidden;
        white-space: nowrap;
      }

      .list-item iron-icon {
        display: block;
        @apply --nuxeo-action;
        color: var(--nuxeo-drawer-text);
      }

      .list-item iron-icon:hover {
        @apply --nuxeo-action-hover;
        color: var(--nuxeo-drawer-text);
      }

      .remove {
        padding: 0;
        width: 1.5em;
        height: 1.5em;
      }

      .toolbar {
        @apply --layout-horizontal;
        @apply --layout-center-justified;
        @apply --nx-actions;
        padding-bottom: 8px;
      }

      .tip {
        opacity: .5;
        display: block;
        font-weight: 300;
        padding: 8px;
        text-align: center;
        font-size: 1rem;
      }

    </style>

    <nuxeo-document-storage id="storage" name="nuxeo-clipboard" documents="{{documents}}"></nuxeo-document-storage>
    <nuxeo-operation id="op" input="docs:[[_uids(documents.*)]]" params="[[_opParams(targetDocument)]]" sync-indexing=""></nuxeo-operation>

    <div class="header">[[i18n('app.clipboard')]]</div>

    <div class="content">
      <nuxeo-data-list items="[[documents]]" id="list" selected-item="{{selectedDocument}}" selection-enabled="" select-on-tap="" as="document" empty-label="[[i18n('clipboard.empty')]]" empty-label-when-filtered="[[i18n('clipboard.empty')]]">
        <template>
          <div tabindex$="{{tabIndex}}" class$="[[_computedClass(selected)]]">
            <div class="list-item-box">
              <div class="list-item-info">
                <div class="list-item-thumbnail">
                  <nuxeo-document-thumbnail document="[[document]]"></nuxeo-document-thumbnail>
                </div>
                <div class="list-item-title">[[document.title]]</div>
                <iron-icon class="remove" icon="nuxeo:remove" alt="Remove" on-tap="_remove"></iron-icon>
              </div>
            </div>
          </div>
        </template>
      </nuxeo-data-list>

      <div class="tip">
        [[i18n('clipboard.tip')]]
      </div>

      <div class="toolbar">
        <div class="actions">
          <paper-button id="paste" on-tap="execute" data-op="Document.Copy" disabled="[[!canPaste(documents, targetDocument)]]" noink="" class="primary clear">
            <iron-icon icon="nuxeo:copy"></iron-icon>
            [[i18n('clipboard.copy')]]
          </paper-button>
          <nuxeo-tooltip for="paste">[[i18n('clipboard.copy')]]</nuxeo-tooltip>
          <paper-button id="move" on-tap="execute" data-op="Document.Move" disabled="[[!canPaste(documents, targetDocument)]]" noink="" class="primary clear">
            <iron-icon icon="nuxeo:move"></iron-icon>
            [[i18n('clipboard.move')]]
          </paper-button>
          <nuxeo-tooltip for="move">[[i18n('clipboard.move')]]</nuxeo-tooltip>
        </div>
      </div>
    </div>
  </template>
  <script>
    Polymer({
      is: 'nuxeo-clipboard',
      behaviors: [Nuxeo.RoutingBehavior, Nuxeo.I18nBehavior, Nuxeo.FiltersBehavior],

      properties: {
        documents: {
          type: Array,
          notify: true
        },
        targetDocument: {
          type: Object,
          observer: '_documentChanged'
        },
        selectedDocument: {
          type: Object,
          observer: '_observeSelectedDocument'
        }
      },

      observers: [
        '_observeDocuments(documents.splices)'
      ],

      _observeDocuments: function() {
        if (this.documents) {
          this.fire('nx-clipboard-updated', {docCount: this.documents.length});
        }
      },

      _documentChanged: function(newValue) {
        if (newValue && this.contains(newValue)) {
          var document = this.$.storage.get(newValue);
          if (document && document.title !== newValue.title) {
            this.$.storage.update(document, { title: newValue.title })
          }
        }
      },

      add: function (docs) {
        var uids = [];

        if (docs instanceof Array) {
          docs.forEach(function (doc) {
            this.$.storage.add(doc);
          }.bind(this));
          uids = docs.map(function(doc) {
            return doc.uid;
          });
        }
        else {
          this.$.storage.add(docs);
          uids.push(docs.uid);
        }
        this.fire('added-to-clipboard', {docIds : uids});
      },

      contains: function(doc) {
        return this.$.storage.contains(doc);
      },

      remove: function(doc) {
        this.$.storage.remove(doc);
      },

      canPaste: function(documents, doc) {
        return documents && documents.length && this.hasFacet(doc, 'Folderish');
      },

      execute: function(evt) {
        this.$.op.op = evt.currentTarget.dataset.op;
        this.$.op.execute().then(function() {
          this.documents = [];
          this.fire('document-updated');
        }.bind(this));
      },

      _remove: function(evt) {
        evt.stopImmediatePropagation();
        this.remove(evt.model.document);
        this.fire('removed-from-clipboard', {docId : evt.model.document.uid});
      },

      _uids: function() {
        if (this.documents && this.documents !== null) {
          return this.documents.map(function(doc) {
            return doc.uid;
          }).join(',');
        }
        return '';
      },

      _opParams: function() {
        if (this.targetDocument) {
          return {
            target: this.targetDocument.uid
          };
        }
      },

      _observeSelectedDocument: function(doc) {
        if (doc) {
          if (doc.isVersion) {
            this.navigateTo('document', doc.uid);
          } else {
            this.navigateTo('browse', doc.path);
          }
        }
      },

      _computedClass: function(isSelected) {
        var classes = 'list-item';
        if (isSelected) {
          classes += ' selected';
        }
        return classes;
      }
    });
  </script>
</dom-module>
<dom-module id="nuxeo-collections" assetpath="nuxeo-collections/">
  <template>
    <style include="nuxeo-styles iron-flex">
    :host {
      @apply --layout-vertical;
      @apply --layout-flex;
      display: block;
    }

    .header {
      line-height: 4.2rem;
      display: inline-block !important;
      white-space: nowrap;
      max-width: 70%;
      overflow: hidden;
    }

    nuxeo-data-list {
      height: calc(100vh - 61px - var(--nuxeo-app-top));
    }

    nuxeo-data-list {
      display: block;
      position: relative;
    }

    .collections {
      height: calc(100vh - 61px - var(--nuxeo-app-top));
      overflow: auto;
    }

    neon-animatable.nuxeo-collections {
      box-shadow: 0 -1px 0 rgba(0, 0, 0, 0.1);
    }

    .switch {
      position: absolute;
      top: 0;
      right: 0;
      width: 60px;
      height: 53px;
      padding: 16px;
      z-index: 101;
      border-left: 1px solid var(--divider-color);
    }

    .switch:hover {
      background-color: var(--nuxeo-button-primary);
      color: var(--nuxeo-button-primary-text);
    }

    .content {
      @apply --layout-flex;
      @apply --layout-vertical;
      height: calc(100vh - 61px - var(--nuxeo-app-top));
      width: 293px;
    }

    .collection-box {
      line-height: 155%;
    }

    .collection-box + .collection-box {
      border-top: 1px solid var(--divider-color);
    }

    iron-icon.collection-name-icon {
      height: .9em;
      width: .9em;
      border-radius: 50px;
      background-color: var(--dark-primary-color);
      color: white;
      padding: .4em;
    }

    .collection-name {
      font-weight: 700;
      margin-left: .5em;
    }

    .collection-detail {
      margin-left: 2.2em;
    }

    .collection-property {
      opacity: .5;
      margin-right: .2em;
    }

    .list-item {
      cursor: pointer;
      padding: 1em;
      border-bottom: 1px solid var(--nuxeo-border);
    }

    .list-item:hover {
      @apply --nuxeo-block-hover;
    }

    .list-item.selected,
    .list-item:focus,
    .list-item.selected:focus {
      @apply --nuxeo-block-selected;
    }

    .list-item iron-icon {
      @apply --nuxeo-action;
    }

    .list-item iron-icon:hover {
      @apply --nuxeo-action-hover;
    }

    .remove {
      width: 1.7em;
      height: 1.7em;
      margin-left: 1em;
    }

    .list-item-property {
      opacity: .5;
      display: block;
      margin: .2em 0;
      font-size: .8rem;
    }

    .horizontal {
      @apply --layout-flex;
      @apply --layout-horizontal;
    }
    </style>

    <nuxeo-operation op="Collection.RemoveFromCollection" id="removeFromCollectionOp"></nuxeo-operation>

    <div class="header ellipsis search-header">
      <template is="dom-if" if="[[_isDisplayMembers]]">
        [[selectedCollection.title]]
        <paper-icon-button class="switch" icon="icons:arrow-back" id="backToCollections" on-tap="displayCollections">
        </paper-icon-button>
        <nuxeo-tooltip for="backToCollections">[[i18n('collections.backToCollections')]]</nuxeo-tooltip>
      </template>
      <template is="dom-if" if="[[!_isDisplayMembers]]">
        [[i18n('collections.heading')]]
      </template>
    </div>


      <neon-animated-pages class="content" id="queues" selected="[[_selectedPage]]" entry-animation="[[_entryAnimation]]" exit-animation="[[_exitAnimation]]">
        <neon-animatable>

          <div id="collections" class="collections" hidden$="{{_isDisplayMembers}}">
            <nuxeo-page-provider id="collectionsProvider" provider="user_collections" page-size="40" params="{&quot;searchTerm&quot;:&quot;%&quot;,&quot;user&quot;:&quot;$currentUser&quot;}" sort="{&quot;dc:modified&quot;:&quot;desc&quot;}" schemas="dublincore,common" enrichers="permissions" headers="{&quot;X-NXfetch.document&quot;: &quot;properties&quot;}">
            </nuxeo-page-provider>

            <nuxeo-data-list nx-provider="collectionsProvider" id="collectionsList" selected-item="{{selectedCollection}}" selection-enabled="" select-on-tap="" as="collection" empty-label="[[i18n('collections.empty')]]" empty-label-when-filtered="[[i18n('collections.empty')]]">
              <template>
                <div tabindex$="{{tabIndex}}" class$="[[_computedClass(selected)]]">
                  <div class="collection-box">
                    <div class="collection-info horizontal layout center">
                      <iron-icon class="collection-name-icon" icon="nuxeo:collections"></iron-icon>
                      <span class="collection-name title">[[collection.title]]</span>
                    </div>
                    <div class="collection-detail">
                      <div class="date horizontal layout center">
                        <span class="collection-property">[[i18n('collections.lastModified')]] </span>
                        <nuxeo-date datetime="[[collection.properties.dc:modified]]"></nuxeo-date>
                      </div>
                      <div class="layout center">
                        <span class="collection-property">[[i18n('collections.ownedBy')]]</span>
                        <nuxeo-user-tag user="[[collection.properties.dc:creator]]"></nuxeo-user-tag>
                      </div>
                    </div>
                  </div>
                </div>
              </template>
            </nuxeo-data-list>
          </div>

        </neon-animatable>

        <neon-animatable>

          <div id="queue" hidden$="{{!_isDisplayMembers}}">
            <nuxeo-data-list id="membersList" selected-item="{{selectedMember}}" selection-enabled="" select-on-tap="" as="member" empty-label="[[i18n('collections.members.empty')]]" empty-label-when-filtered="[[i18n('collections.members.empty')]]">
              <template>
                <div tabindex$="{{tabIndex}}" class$="[[_computedClass(selected)]]">

                  <div class="list-item-box">
                    <div class="list-item-info horizontal layout center">
                      <div class="vertical layout center">
                        <nuxeo-document-thumbnail document="[[member]]"></nuxeo-document-thumbnail>
                      </div>
                      <div class="flex">
                        <span class="list-item-title ellipsis">[[member.title]]</span>
                        <span class="list-item-property ellipsis">[[formatDocType(member.type)]]</span>
                      </div>
                      <iron-icon id="removeFromCollection" class="remove" hidden$="[[!_canRemove(selectedCollection)]]" icon="nuxeo:remove" data-uid$="[[member.uid]]" on-tap="_removeFromCollection">
                      </iron-icon>
                    </div>
                  </div>

                </div>
              </template>
            </nuxeo-data-list>
          </div>

        </neon-animatable>
      </neon-animated-pages>

    <nuxeo-keys keys="right l" on-pressed="_navigateOnRight"></nuxeo-keys>
    <nuxeo-keys keys="left h" on-pressed="_navigateOnLeft"></nuxeo-keys>
    <nuxeo-keys keys="down j" on-pressed="_navigateOnDown"></nuxeo-keys>
    <nuxeo-keys keys="up k" on-pressed="_navigateOnUp"></nuxeo-keys>

  </template>

  <script>
    Polymer({
      is: 'nuxeo-collections',
      behaviors: [Nuxeo.RoutingBehavior, Nuxeo.FormatBehavior, Nuxeo.FiltersBehavior],

      properties: {

        selectedSearch: {
          type: String,
          value: 'faceted'
        },
        _isDisplayMembers: {
          type: Boolean,
          value: false,
          observer: '_observeIsDisplayMembers'
        },
        selectedCollection: {
          type: Object,
          observer: '_selectedCollectionChanged',
          notify: true
        },
        selectedMember: {
          type: Object,
          observer: '_selectedMemberChanged',
          notify: true
        },
        _entryAnimation: {
          type: String,
          value: 'slide-from-right-animation'
        },
        _exitAnimation: {
          type: String,
          value: 'slide-left-animation'
        },
        visible: {
          type: Boolean,
          observer: '_visibleChanged'
        }
      },

      _navigateOnRight: function(e) {
        if (!this._isDisplayMembers) {
          e.detail.keyboardEvent.preventDefault();
          if (this.selectedCollection) {
            this.displayMembers();
            this.$.membersList.fire('iron-resize');
            if (this.$.membersList.items.length > 0) {
              this.$.membersList.selectIndex(0);
            }
          }
          this._tmpJustRight = true;
        }
      },

      _navigateOnLeft: function(e) {
        if (this._isDisplayMembers) {
          e.detail.keyboardEvent.preventDefault();
          this.displayCollections();
          this.$.collectionsList.fire('iron-resize');
        }
        this._tmpJustLeft = true;
      },

      _navigateOnDown: function(e) {
        if (this._isDisplayMembers) {
          e.detail.keyboardEvent.preventDefault();
          if (this._tmpJustRight) {
            this.$.membersList.selectNext();
            this._tmpJustRight = false;
          }
        } else {
          if (this._tmpJustLeft) {
            e.detail.keyboardEvent.preventDefault();
            this.$.collectionsList.selectNext();
            this._tmpJustLeft = false;
          }
        }
      },

      _navigateOnUp: function(e) {
        if (this._isDisplayMembers) {
          if (this._tmpJustRight) {
            e.detail.keyboardEvent.preventDefault();
            this.$.membersList.selectPrevious();
            this._tmpJustRight = false;
          }
        } else {
          if (this._tmpJustLeft) {
            e.detail.keyboardEvent.preventDefault();
            this.$.collectionsList.selectPrevious();
            this._tmpJustLeft = false;
          }
        }
      },

      _observeIsDisplayMembers: function() {
        if (this._isDisplayMembers) {
          this._entryAnimation = 'slide-from-right-animation';
          this._exitAnimation = 'slide-left-animation';
          this._selectedPage = 1;
        } else {
          this._entryAnimation = 'slide-from-left-animation';
          this._exitAnimation = 'slide-right-animation';
          this._selectedPage = 0;
          if (this.selectedCollection) {
            this.fire('navigate', {doc: this.selectedCollection});
          }
        }
      },

      displayMembers: function(collection, index) {
        this._isDisplayMembers = true;
        if (typeof index === 'number') {
          if (this.selectedCollection && collection && this.selectedCollection.uid === collection.uid) {
            this.$.membersList.selectIndex(index);
            this.$.membersList.scrollToIndex(index);
          }
        }
      },

      displayCollections: function() {
        this._isDisplayMembers = false;
      },

      _removeFromCollection: function(evt) {
        var op = this.$.removeFromCollectionOp;
        var memberId = evt.currentTarget.dataset.uid;
        op.input = memberId;
        op.params = {
          'collection': this.selectedCollection.uid
        };
        op.execute().then(function() {
          this._removeFromMembers(memberId)
          this.fire('removed-from-collection',
            {
              innerRemove: true,
              doc: memberId,
              collectionId: evt.target.dataset.uid

            }
          );
        }.bind(this));
      },

      _removeFromMembers: function(uid) {
        var memberIndex = memberIndex = this.$.membersList.items.findIndex(function(el) {
          return el.uid === uid;
        });
        if (memberIndex > -1) {
          this.$.membersList.splice('items', memberIndex, 1);
          if (this.$.membersList.items.length > memberIndex) {
            this.$.membersList.selectIndex(memberIndex);
          } else {
            this.$.membersList.selectIndex(this.$.membersList.items.length - 1);
          }
        }
      },

      _computedClass: function(isSelected) {
        var classes = 'list-item';
        if (isSelected) {
          classes += ' selected';
        }
        return classes;
      },

      _selectedMemberChanged: function(doc) {
        if (doc) {
          if (doc.isVersion) {
            this.navigateTo('document', doc.uid);
          } else {
            this.navigateTo('browse', doc.path);
          }
        }
      },

      _selectedCollectionChanged: function(collection) {
        if (collection) {
          this.fire('navigate', {doc: collection});
        }
      },

      _isEmpty: function(items) {
        return items && items.length === 0;
      },

      ready: function() {
        window.addEventListener('added-to-collection', function() {
          if (this.visible) {
            this._refreshCollections();
          }
        }.bind(this));
        window.addEventListener('removed-from-collection', function(e) {
          if (this.visible) {
            if (e.detail.innerRemove) {
              return;
            }
            if (this.selectedCollection && this.selectedCollection.uid === e.detail.collectionId) {
              this._removeFromMembers(e.detail.doc.uid);
            } else if (!this._isDisplayMembers) {
              this._refreshCollections();
            }
          }
        }.bind(this));

      },

      _visibleChanged: function() {
        if (this.visible) {
          this.selectedCollection = null;
          this._refreshCollections();
          this.displayCollections();
        }
      },

      _canRemove: function(collection) {
        if (collection && collection.contextParameters && collection.contextParameters.permissions) {
          // NXP-21408: prior to 8.10-HF01 the permissions enricher wouldn't return ReadCanCollect
          // Action will therefore not be available
          return collection.contextParameters.permissions.indexOf('ReadCanCollect') > -1;
        }
        return false;
      },

      _refreshCollections: function() {
        this.$.collectionsList.reset();
        this.$.collectionsList.fetch();
      },

      loadCollection: function(collection, provider) {
        if (provider) {
          this.$.membersList.nxProvider = provider;
          if (collection && this.selectedCollection && this.selectedCollection.uid === collection.uid) {
            this.$.membersList.reset();
            this.$.membersList.fetch();
            this.displayCollections();
          }
        }
      }

    });
  </script>
</dom-module>
<dom-module id="nuxeo-favorites" assetpath="nuxeo-collections/">
  <template>
    <style include="nuxeo-styles">

      .content {
        @apply --layout-vertical;
      }

      nuxeo-data-list {
        display: block;
        position: relative;
        min-height: calc(100vh - 61px - var(--nuxeo-app-top))
      }

      .list-item {
        cursor: pointer;
        padding: 1em;
        border-bottom: 1px solid var(--nuxeo-border);
      }

      .list-item-box {
        @apply --layout-vertical;
      }

      .list-item-info {
        @apply --layout-horizontal;
        @apply --layout-center;
      }

      .list-item-thumbnail {
        @apply --layout-vertical;
        @apply --layout-center;
      }

      .list-item-title {
        @apply --layout-flex;
        text-overflow: ellipsis;
        overflow: hidden;
        white-space: nowrap;
      }

      .list-item:hover {
        @apply --nuxeo-block-hover;
      }

      .list-item.selected,
      .list-item:focus,
      .list-item.selected:focus {
        @apply --nuxeo-block-selected;
      }

      .list-item-property {
        opacity: .5;
        margin-right: .2em;
      }

      .list-item iron-icon {
        display: block;
        @apply --nuxeo-action;
        color: var(--nuxeo-drawer-text);
      }

      .list-item iron-icon:hover {
        @apply --nuxeo-action-hover;
        color: var(--nuxeo-drawer-text);
      }

      .remove {
        width: 1.5em;
        height: 1.5em;
      }
    </style>

    <nuxeo-operation id="removeFromFavOp" op="Document.RemoveFromFavorites"></nuxeo-operation>

    <nuxeo-operation id="fetchFavOp" op="Favorite.Fetch" response="favorite"></nuxeo-operation>

    <nuxeo-page-provider id="favoritesProvider" provider="default_content_collection" page-size="30" schemas="dublincore,common" enrichers="thumbnail">
    </nuxeo-page-provider>

    <div class="header">[[i18n('app.favorites')]]</div>
    <div class="content">
      <nuxeo-data-list nx-provider="favoritesProvider" id="favoritesList" selected-item="{{selectedFavorite}}" items="{{favorites}}" selection-enabled="" select-on-tap="" as="favorite" empty-label="[[i18n('favorites.empty')]]" empty-label-when-filtered="[[i18n('favorites.empty')]]">
        <template>
          <div tabindex$="{{tabIndex}}" class$="[[_computedClass(selected)]]">
            <div class="list-item-box">
              <div class="list-item-info">
                <div class="list-item-thumb">
                  <nuxeo-document-thumbnail document="[[favorite]]"></nuxeo-document-thumbnail>
                </div>
                <div class="list-item-title">[[favorite.title]]</div>
                <iron-icon id="removeFromFavorites" class="remove" icon="nuxeo:remove" data-uid$="[[favorite.uid]]" on-tap="_removeFromFavorites">
                </iron-icon>
              </div>
            </div>
          </div>
        </template>
      </nuxeo-data-list>

    </div>
  </template>
  <script>
    Polymer({
      is: 'nuxeo-favorites',
      behaviors: [Nuxeo.RoutingBehavior, Nuxeo.I18nBehavior, Nuxeo.FiltersBehavior],
      properties: {
        favorites: {
          type: Object,
          notify: true
        },
        selectedFavorite: {
          type: Object,
          observer: '_selectedFavoriteChanged',
          notify: true
        },
        visible: {
          type: Boolean,
          observer: '_visibleChanged'
        }
      },

      _visibleChanged: function() {
        if (this.visible && !this.favorite) {
          this._refresh();
        }
      },

      ready: function() {
        window.addEventListener('added-to-favorites', this._refresh.bind(this));
        window.addEventListener('removed-from-favorites', this._refresh.bind(this));
      },

      _refresh: function() {
        this._fetchFavorite().then(function(favorite) {
          if (!favorite) {
            return;
          }
          this.$.favoritesProvider.params = [favorite.uid];
          this.$.favoritesProvider.page = 1;
          this.$.favoritesList.fetch();
        }.bind(this));
      },

      _fetchFavorite: function() {
        if (this.favorite) {
          return Promise.resolve(this.favorite);
        } else {
          return this.$.fetchFavOp.execute()
            .then(function(resp) {
              if (resp.status === 204) {
                // Pas de bras, pas de chocolat.
                this.favorite = null;
              } else {
                this.favorite = resp;
              }
              return this.favorite;
            }.bind(this));
        }
      },

      _computedClass: function(isSelected) {
        var classes = 'list-item';
        if (isSelected) {
          classes += ' selected';
        }
        return classes;
      },

      _selectedFavoriteChanged: function(doc) {
        if (doc) {
          if (doc.isVersion) {
            this.navigateTo('document', doc.uid);
          } else {
            this.navigateTo('browse', doc.path);
          }
        }
      },

      _removeFromFavorites: function(e) {
        e.stopImmediatePropagation();
        var docUid = e.model.favorite.uid;
        this.$.removeFromFavOp.input = docUid;
        this.$.removeFromFavOp.execute().then(function() {
          this.fire('removed-from-favorites', {docUid: docUid});
        }.bind(this));
      }

    });
  </script>
</dom-module>
<dom-module id="nuxeo-add-to-collection-button" assetpath="bower_components/nuxeo-ui-elements/actions/">
  <template>
    <style include="nuxeo-action-button-styles">
      /* Fix known stacking issue in iOS (NXP-24600)
         https://github.com/PolymerElements/paper-dialog-scrollable/issues/72 */
      paper-dialog-scrollable {
        --paper-dialog-scrollable: {
          -webkit-overflow-scrolling: auto;
        };
      }
    </style>

    <nuxeo-operation id="addToCollectionOp" op="Document.AddToCollection" input="[[document.uid]]"></nuxeo-operation>
    <nuxeo-operation id="createCollectionOp" op="Collection.Create"></nuxeo-operation>

    <dom-if if="[[_isAvailable(document)]]">
      <template>
        <div class="action" on-click="_toggleDialog">
          <paper-icon-button icon="[[icon]]" noink=""></paper-icon-button>
          <span class="label" hidden$="[[!showLabel]]">[[_label]]</span>
        </div>
        <nuxeo-tooltip>[[_label]]</nuxeo-tooltip>
      </template>
    </dom-if>

    <nuxeo-dialog id="add-to-collection-dialog" with-backdrop="" on-iron-overlay-closed="_resetPopup" no-auto-focus="">
      <h2>[[i18n('addToCollectionButton.dialog.heading')]]</h2>
      <paper-dialog-scrollable>
        <nuxeo-selectivity id="nxSelect" label="[[i18n('addToCollectionButton.dialog.collections')]]" required="" operation="Collection.Suggestion" min-chars="0" placeholder="[[i18n('addToCollectionButton.dialog.select')]]" value="{{collection}}" tagging="true" query-results-filter="[[resultsFilter]]" result-formatter="[[resultFormatter]]" selection-formatter="[[selectionFormatter]]" new-entry-formatter="[[newEntryFormatter]]">
        </nuxeo-selectivity>
        <nuxeo-textarea label="[[i18n('addToCollectionButton.dialog.description')]]" value="{{description::input}}" hidden$="[[!_isNew(collection)]]">
        </nuxeo-textarea>
      </paper-dialog-scrollable>
      <div class="buttons">
        <paper-button dialog-dismiss="">[[i18n('addToCollectionButton.dialog.cancel')]]</paper-button>
        <paper-button dialog-confirm="" class="primary" name="add" on-click="_add" disabled$="[[!_isValid(collection)]]">
          [[i18n('addToCollectionButton.dialog.add')]]
        </paper-button>
      </div>
    </nuxeo-dialog>

  </template>

  <script>
    {
      /**
       * A button element for adding a document to a collection
       *
       * Example:
       *
       *     <nuxeo-add-to-collection-button document="[[document]]"></nuxeo-add-to-collection-button>
       *
       * @appliesMixin Nuxeo.I18nBehavior
       * @appliesMixin Nuxeo.FiltersBehavior
       * @memberof Nuxeo
       * @demo demo/nuxeo-add-to-collection-button/index.html
       */
      class AddToCollectionButton
        extends Polymer.mixinBehaviors([Nuxeo.I18nBehavior, Nuxeo.FiltersBehavior], Nuxeo.Element) {

        static get is() {
          return 'nuxeo-add-to-collection-button';
        }

        static get properties() {
          return {
            /**
             * Input document.
             */
            document: Object,

            /**
             * Icon to use (iconset_name:icon_name).
             */
            icon: {
              type: String,
              value: 'nuxeo:collections',
            },

            collection: {
              type: String,
              value: '',
            },

            resultsFilter: {
              type: Function,
              value() {
                return this._resultsFilter.bind(this);
              },
            },

            resultFormatter: {
              type: Function,
              value() {
                return this._resultFormatter.bind(this);
              },
            },

            selectionFormatter: {
              type: Function,
              value() {
                return this._selectionFormatter.bind(this);
              },
            },

            newEntryFormatter: {
              type: Function,
              value() {
                return this._newEntryFormatter.bind(this);
              },
            },

            /**
             * `true` if the action should display the label, `false` otherwise.
             */
            showLabel: {
              type: Boolean,
              value: false,
            },

            _label: {
              type: String,
              computed: '_computeLabel(i18n)',
            },
          };
        }

        _isAvailable(doc) {
          return this.isCollectionMember(doc);
        }

        _computeLabel() {
          return this.i18n('addToCollectionButton.tooltip');
        }

        _toggleDialog() {
          this.$['add-to-collection-dialog'].toggle();
        }

        _add() {
          if (this._isNew()) {
            const op = this.$$('#createCollectionOp');
            // XXX
            const name = this.$.nxSelect.selectedItem.displayLabel;
            op.params = {
              name,
              description: this.description,
            };
            return op.execute().then((response) => {
              this.collection = response.uid;
              this._addToCollection();
            });
          } else {
            this._addToCollection();
          }
        }

        _addToCollection() {
          const op = this.$$('#addToCollectionOp');
          op.params = {
            collection: this.collection,
          };
          return op.execute().then(() => {
            this.dispatchEvent(new CustomEvent('added-to-collection', {
              composed: true,
              bubbles: true,
              detail: { docId: this.document.uid, collectionId: this.collection },
            }));
            this._resetPopup();
          });
        }

        _resultsFilter(entry) {
          return entry.id.indexOf('-999999') === -1;
        }

        _resultFormatter(item) {
          const label = item.displayLabel || item.title;

          // if we are adding a new entry with the _newEntryFormatter we don't want to escape the HTML
          return item.id === -1 ? `<iron-icon icon="nuxeo:add" item-icon></iron-icon>${label}`
            : this.$.nxSelect.escapeHTML(label);
        }

        _selectionFormatter(item) {
          const label = item.displayLabel || item.title;

          // if we are adding a new entry with the _newEntryFormatter we don't want to escape the HTML
          return item.id === -1 ? label : this.$.nxSelect.escapeHTML(label);
        }

        _newEntryFormatter(term) {
          return { id: -1, displayLabel: term };
        }

        _isValid() {
          return this.collection !== '';
        }

        _isNew() {
          return this.collection === -1;
        }

        _resetPopup() {
          this.set('collection', null);
          this.description = '';
        }

      }

      customElements.define(AddToCollectionButton.is, AddToCollectionButton);
      Nuxeo.AddToCollectionButton = AddToCollectionButton;
    }
  </script>

</dom-module>
<dom-module id="nuxeo-share-button" assetpath="bower_components/nuxeo-ui-elements/actions/">
  <template>
    <style include="nuxeo-action-button-styles">
      #copyLink {
        cursor: pointer;
        color: var(--nuxeo-primary-color, #0066ff);
      }

      .heading {
        @apply --layout-horizontal;
        @apply --layout-center;
        @apply --layout-justified;
      }
    </style>

    <dom-if if="[[_isAvailable(document)]]">
      <template>
        <div class="action" on-click="_toggleDialog">
          <paper-icon-button icon="[[icon]]" noink=""></paper-icon-button>
          <span class="label" hidden$="[[!showLabel]]">[[_label]]</span>
        </div>
        <nuxeo-tooltip>[[_label]]</nuxeo-tooltip>
      </template>
    </dom-if>

    <nuxeo-dialog id="dialog" with-backdrop="">
      <div class="heading">
        <h2>[[i18n('shareButton.dialog.heading')]]</h2>
        <span id="copyLink" on-click="_copyPermalink">[[i18n('shareButton.operation.copy')]]</span>
      </div>
      <nuxeo-input id="permalink" value="[[_buildPermalink(document)]]" on-click="_copyPermalink" autofocus="" readonly="">
      </nuxeo-input>
      <div class="buttons">
        <paper-button dialog-dismiss="">[[i18n('shareButton.dialog.close')]]</paper-button>
      </div>
    </nuxeo-dialog>

  </template>

  <script>
    {
      /**
       * A button element for sharing a document.
       *
       * Example:
       *
       *     <nuxeo-share-button document="[[document]]"></nuxeo-share-button>
       *
       * @appliesMixin Nuxeo.I18nBehavior
       * @memberof Nuxeo
       * @demo demo/nuxeo-share-button/index.html
       */
      class ShareButton extends Polymer.mixinBehaviors([Nuxeo.I18nBehavior], Nuxeo.Element) {

        static get is() {
          return 'nuxeo-share-button';
        }

        static get properties() {
          return {
            /**
             * Input document.
             */
            document: Object,

            /**
             * Icon to use (iconset_name:icon_name).
             */
            icon: {
              type: String,
              value: 'nuxeo:share',
            },

            /**
             * `true` if the action should display the label, `false` otherwise.
             */
            showLabel: {
              type: Boolean,
              value: false,
            },

            _label: {
              type: String,
              computed: '_computeLabel(i18n)',
            },
          };
        }

        _isAvailable(document) {
          return document;
        }

        _computeLabel() {
          return this.i18n('shareButton.tooltip');
        }

        _toggleDialog() {
          this.$.dialog.toggle();
          this._selectPermalink();
        }

        _buildPermalink(document) {
          return document ? `${location.origin + location.pathname}#!/doc/${document.uid}` : '';
        }

        _copyPermalink() {
          this._selectPermalink();
          if (!window.document.execCommand('copy')) {
            return;
          }

          const link = this.$.copyLink;
          this._debouncer = Polymer.Debouncer.debounce(
            this._debouncer,
            Polymer.Async.timeOut.after(3000), () => {
              link.innerText = this.i18n('shareButton.operation.copy');
            },
          );
          link.innerText = this.i18n('shareButton.operation.copied');
        }

        _selectPermalink() {
          this.$.permalink.$.paperInput.inputElement.inputElement.select();
        }

      }

      customElements.define(ShareButton.is, ShareButton);
      Nuxeo.ShareButton = ShareButton;
    }
  </script>

</dom-module>
<dom-module id="nuxeo-notifications-toggle-button" assetpath="bower_components/nuxeo-ui-elements/actions/">
  <template>

    <style include="nuxeo-action-button-styles">
      :host([subscribed]) paper-icon-button {
        color: var(--icon-toggle-outline-color, var(--nuxeo-action-color-activated));
      }
    </style>

    <nuxeo-operation id="opSubscribe" op="Document.Subscribe" input="[[document.uid]]"></nuxeo-operation>
    <nuxeo-operation id="opUnsubscribe" op="Document.Unsubscribe" input="[[document.uid]]"></nuxeo-operation>

    <dom-if if="[[_isAvailable(document)]]">
      <template>
        <div class="action">
          <paper-icon-button icon="[[icon]]" noink=""></paper-icon-button>
          <span class="label" hidden$="[[!showLabel]]">[[_label]]</span>
        </div>
        <nuxeo-tooltip>[[_label]]</nuxeo-tooltip>
      </template>
    </dom-if>

  </template>

  <script>
    {
      /**
       * A toggle button element for subscribe/unsubscribe a document.
       *
       * Example:
       *
       *     <nuxeo-notifications-toggle-button document="[[document]]"></nuxeo-notifications-toggle-button>
       *
       * @appliesMixin Nuxeo.I18nBehavior
       * @appliesMixin Nuxeo.FiltersBehavior
       * @memberof Nuxeo
       * @demo demo/nuxeo-notifications-toggle-button/index.html
       */
      class NotificationsToggleButton
        extends Polymer.mixinBehaviors([Nuxeo.I18nBehavior, Nuxeo.FiltersBehavior], Nuxeo.Element) {

        static get is() {
          return 'nuxeo-notifications-toggle-button';
        }

        static get properties() {
          return {
            /**
             * Input document.
             */
            document: {
              type: Object,
              observer: '_documentChanged',
            },

            /**
             * Icon to use (iconset_name:icon_name).
             */
            icon: {
              type: String,
              value: 'nuxeo:notify',
            },

            subscribed: {
              type: Boolean,
              notify: true,
              reflectToAttribute: true,
            },

            /**
             * `true` if the action should display the label, `false` otherwise.
             */
            showLabel: {
              type: Boolean,
              value: false,
            },

            _label: {
              type: String,
              computed: '_computeLabel(subscribed, i18n)',
            },
          };
        }

        ready() {
          super.ready();
          this.documentUnsubscribedHandler = (e) => {
            if (this.document && e.detail.docUid && e.detail.docUid === this.document.uid) {
              this.subscribed = false;
            }
          };
          window.addEventListener('document-unsubscribed', this.documentUnsubscribedHandler);
          this.addEventListener('click', this._toggle);
        }

        disconnectedCallback() {
          super.disconnectedCallback();
          window.removeEventListener('document-unsubscribed', this.documentUnsubscribedHandler);
          this.documentUnsubscribedHandler = null;
        }

        _isAvailable(doc) {
          return doc && !doc.isVersion;
        }

        _toggle() {
          if (!this.subscribed) {
            this.$.opSubscribe.execute().then(() => {
              this.dispatchEvent(new CustomEvent('document-subscribed', {
                composed: true,
                bubbles: true,
                detail: { doc: this.document },
              }));
              this.subscribed = true;
            });
          } else {
            this.$.opUnsubscribe.execute().then(() => {
              this.dispatchEvent(new CustomEvent('document-unsubscribed', {
                composed: true,
                bubbles: true,
                detail: { doc: this.document },
              }));
              this.subscribed = false;
            });
          }
        }

        _computeLabel(isSubscribed) {
          return this.i18n(`notificationsToggleButton.tooltip.${isSubscribed ? 'doNotNotify' : 'notify'}`);
        }

        _documentChanged() {
          this.subscribed = this.isSubscribed(this.document);
        }

      }

      customElements.define(NotificationsToggleButton.is, NotificationsToggleButton);
      Nuxeo.NotificationsToggleButton = NotificationsToggleButton;
    }
  </script>

</dom-module>
<dom-module id="nuxeo-link-button" assetpath="bower_components/nuxeo-ui-elements/actions/">
  <template>
    <style include="nuxeo-action-button-styles">
      .action {
        text-decoration: none;
        color: var(--nuxeo-text-default);
      }
    </style>

    <template is="dom-if" if="[[_isAvailable(href, icon, iconSrc)]]">
      <a class="action" href="[[href]]" tabindex="-1" target="[[target]]">
        <paper-icon-button src="[[iconSrc]]" icon="[[icon]]" noink=""></paper-icon-button>
        <span class="label" hidden$="[[!showLabel]]">[[i18n(label)]]</span>
      </a>
      <nuxeo-tooltip>[[i18n(label)]]</nuxeo-tooltip>
    </template>
  </template>

  <script>
    {
      /**
       * A button element for displaying a link with an icon button.
       *
       * Example:
       *
       *     <nnuxeo-link-button href="http://www.nuxeo.org" icon=""></nuxeo-link-button>
       *
       * @appliesMixin Nuxeo.I18nBehavior
       * @memberof Nuxeo
       */
      class LinkButton extends Polymer.mixinBehaviors([Nuxeo.I18nBehavior], Nuxeo.Element) {

        static get is() {
          return 'nuxeo-link-button';
        }

        static get properties() {
          return {
            /**
             * Link.
             */
            href: String,

            /**
             * Target.
             */
            target: String,

            /**
             *  The URL of an image for the icon. If the iconSrc property is specified,
             * the icon property should not be.
             */
            iconSrc: String,

            /**
             * Icon to use (iconset_name:icon_name).
             * If the icon property is specified the iconSrc property should not be.
             */
            icon: String,

            /**
             * `true` if the action should display the label, `false` otherwise.
             */
            showLabel: {
              type: Boolean,
              value: false,
            },

            /**
             * Label (i18n key) to use as tooltip and label when `showLabel`is true.
             */
            label: String,
          };
        }

        _isAvailable() {
          return this.href && (this.icon || this.iconSrc);
        }
      }

      customElements.define(LinkButton.is, LinkButton);
      Nuxeo.LinkButton = LinkButton;
    }
  </script>

</dom-module>
<dom-module id="nuxeo-lock-toggle-button" assetpath="bower_components/nuxeo-ui-elements/actions/">
  <template>
    <style include="nuxeo-action-button-styles">
      :host([locked]) paper-icon-button {
        color: var(--icon-toggle-outline-color, var(--nuxeo-action-color-activated));
      }
    </style>

    <nuxeo-connection id="nxcon"></nuxeo-connection>

    <nuxeo-operation id="opLock" op="Document.Lock" input="[[document.uid]]" headers="{&quot;X-NXfetch.document&quot;: &quot;lock&quot;}"></nuxeo-operation>
    <nuxeo-operation id="opUnlock" op="Document.Unlock" input="[[document.uid]]" headers="{&quot;X-NXfetch.document&quot;: &quot;lock&quot;}"></nuxeo-operation>

    <dom-if if="[[_isAvailable(document)]]">
      <template>
        <div class="action">
          <paper-icon-button icon="[[icon]]" noink=""></paper-icon-button>
          <span class="label" hidden$="[[!showLabel]]">[[_label]]</span>
        </div>
        <nuxeo-tooltip>[[tooltip]]</nuxeo-tooltip>
      </template>
    </dom-if>

  </template>

  <script>
    {
      /**
       * A toggle button element for lock/unlock a document.
       *
       * Example:
       *
       *     <nuxeo-lock-toggle-button document="[[document]]"></nuxeo-lock-toggle-button>
       *
       * @appliesMixin Nuxeo.I18nBehavior
       * @appliesMixin Nuxeo.FiltersBehavior
       * @appliesMixin Nuxeo.FormatBehavior
       * @memberof Nuxeo
       * @demo demo/nuxeo-lock-toggle-button/index.html
       */
      class LockToggleButton
        extends Polymer.mixinBehaviors([Nuxeo.I18nBehavior, Nuxeo.FiltersBehavior, Nuxeo.FormatBehavior], Nuxeo.Element) {

        static get is() {
          return 'nuxeo-lock-toggle-button';
        }

        static get properties() {
          return {
            /**
             * Input document.
             */
            document: {
              type: Object,
              observer: '_documentChanged',
            },

            /**
             * Icon to use (iconset_name:icon_name).
             */
            icon: {
              type: String,
              computed: '_computeIcon(locked)',
            },

            locked: {
              type: Boolean,
              notify: true,
              reflectToAttribute: true,
            },

            /**
             * The translated label to be displayed by the action.
             */
            tooltip: {
              type: String,
              notify: true,
              computed: '_computeTooltip(locked, i18n)',
            },

            /**
             * `true` if the action should display the label, `false` otherwise.
             */
            showLabel: {
              type: Boolean,
              value: false,
            },

            _label: {
              type: String,
              computed: '_computeLabel(locked, i18n)',
            },
          };
        }

        ready() {
          super.ready();
          this.addEventListener('click', this._toggle);
        }

        _isAvailable(doc) {
          return doc && !doc.isVersion && this.hasPermission(doc, 'Write') && !this.isImmutable(doc)
              && doc.type !== 'Root';
        }

        _toggle() {
          if (!this.locked && this._canLock()) {
            this.$.opLock.execute().then((doc) => {
              this.locked = true;
              this.dispatchEvent(new CustomEvent('document-locked', {
                composed: true,
                bubbles: true,
                detail: { doc },
              }));
            });
          } else if (this._canUnlock()) {
            this.$.opUnlock.execute().then((doc) => {
              this.locked = false;
              this.dispatchEvent(new CustomEvent('document-unlocked', {
                composed: true,
                bubbles: true,
                detail: { doc },
              }));
            });
          }
        }

        _computeTooltip(locked) {
          if (locked && this.document.lockOwner && this.document.lockCreated) {
            return this.i18n(
              'lockToggleButton.tooltip.lockedBy',
              this.document.lockOwner, this.formatDate(this.document.lockCreated),
            );
          } else {
            return this.i18n(`lockToggleButton.tooltip.${locked ? 'unlock' : 'lock'}`);
          }
        }

        _computeLabel(locked) {
          return this.i18n(`lockToggleButton.tooltip.${locked ? 'unlock' : 'lock'}`);
        }

        _computeIcon(locked) {
          return locked ? 'nuxeo:lock' : 'nuxeo:unlock';
        }

        _documentChanged() {
          this.locked = !!(this.document && this.document.lockCreated);
        }

        _canLock() {
          return this.$.nxcon.connect().then((currentUser) => {
            if (this.document.isProxy || this.document.isVersion) {
              return false;
            } else {
              return currentUser.isAdministrator || this.document.contextParameters.permissions.indexOf('Everything') > -1
              || this.document.contextParameters.permissions.indexOf('Write') > -1;
            }
          });
        }

        _canUnlock() {
          return this.$.nxcon.connect().then((currentUser) => {
            if (this.document.isProxy) {
              return false;
            } else {
              return (currentUser.isAdministrator
              || this.document.contextParameters.permissions.indexOf('Everything') > -1
                ? true
                : (currentUser.id === this.document.lockOwner)
              && this.document.contextParameters.permissions.indexOf('Write') > -1)
              && !document.isVersion;
            }
          });
        }

      }

      customElements.define(LockToggleButton.is, LockToggleButton);
      Nuxeo.LockToggleButton = LockToggleButton;
    }
  </script>

</dom-module>
<dom-module id="nuxeo-preview-button" assetpath="bower_components/nuxeo-ui-elements/actions/">
  <template>
    <style include="nuxeo-action-button-styles">
      #close-icon {
        position: absolute;
        right: -12px;
        top: -12px;
        width: 25px;
        height: 25px;
        border: 1px solid rgba(0, 0, 0, 0.4);
        padding: 3px;
        background: var(--nuxeo-secondary-color);
        color: var(--nuxeo-button-primary-text);
      }

      #close-icon:hover {
        border-color: var(--nuxeo-primary-color);
      }

      nuxeo-dialog {
        width: 100%;
        height: 100%;
        min-width: 480px;
      }

      nuxeo-dialog > nuxeo-document-preview {
        height: 100%;
      }

      nuxeo-dialog > * {
        margin: 0;
        padding: 0;
      }

      nuxeo-dialog > nuxeo-document-preview ::slotted(audio) {
        height: 50%;
      }
    </style>

    <dom-if if="[[_isAvailable(document)]]">
      <template>
        <div class="action" on-click="_toggleDialog">
          <paper-icon-button icon="[[icon]]" noink=""></paper-icon-button>
          <span class="label" hidden$="[[!showLabel]]">[[_label]]</span>
        </div>
        <nuxeo-tooltip>[[_label]]</nuxeo-tooltip>

        <nuxeo-dialog on-iron-overlay-closed="_previewClosed" id="dialog" with-backdrop="">
          <template>
            <nuxeo-document-preview id="preview" document="[[document]]" xpath="[[xpath]]"></nuxeo-document-preview>
            <paper-icon-button id="close-icon" icon="nuxeo:clear" on-click="_toggleDialog" noink=""></paper-icon-button>
          </template>
        </nuxeo-dialog>
      </template>
    </dom-if>
  </template>

  <script>
    {
      /**
       * A button element for show the preview of a document.
       *
       * Example:
       *
       *     <nuxeo-preview-button document="[[document]]"></nuxeo-preview-button>
       *
       * @appliesMixin Nuxeo.I18nBehavior
       * @appliesMixin Nuxeo.FiltersBehavior
       * @memberof Nuxeo
       * @demo demo/nuxeo-preview-button/index.html
       */
      class PreviewButton extends Polymer.mixinBehaviors([Nuxeo.I18nBehavior, Nuxeo.FiltersBehavior], Nuxeo.Element) {

        static get is() {
          return 'nuxeo-preview-button';
        }

        static get properties() {
          return {
            /**
             * Input document.
             */
            document: Object,

            /**
             * Path of the file object to preview.
             * For example `xpath="files:files/0/file"`.
             */
            xpath: {
              type: String,
              value: 'file:content',
            },

            /**
             * Icon to use (iconset_name:icon_name).
             */
            icon: {
              type: String,
              value: 'nuxeo:preview',
            },

            /**
             * `true` if the action should display the label, `false` otherwise.
             */
            showLabel: {
              type: Boolean,
              value: false,
            },

            _label: {
              type: String,
              computed: '_computeLabel(i18n)',
            },
          };
        }

        _previewClosed() {
          this.$$('#preview').stop();
        }

        _isAvailable(document) {
          return !(this.hasFacet(document, 'Folderish') || this.hasFacet(document, 'Collection'));
        }

        _computeLabel() {
          return this.i18n('previewButton.tooltip');
        }

        _toggleDialog() {
          this.$$('#dialog').toggle();
        }

      }

      customElements.define(PreviewButton.is, PreviewButton);
      Nuxeo.PreviewButton = PreviewButton;
    }
  </script>

</dom-module>
<dom-module id="nuxeo-export-button" assetpath="bower_components/nuxeo-ui-elements/actions/">
  <template>
    <style include="nuxeo-action-button-styles">
      .item {
        @apply --layout-horizontal;
        @apply --layout-center;
        padding-top: 0.4em;
        padding-bottom: 0.4em;
      }

      .item iron-icon {
        margin-right: 1em;
      }
    </style>

    <dom-if if="[[_isAvailable(document)]]">
      <template>
        <div class="action" on-click="_toggleDialog">
          <paper-icon-button icon="[[icon]]" noink=""></paper-icon-button>
          <span class="label" hidden$="[[!showLabel]]">[[_label]]</span>
        </div>
        <nuxeo-tooltip>[[_label]]</nuxeo-tooltip>
      </template>
    </dom-if>

    <nuxeo-dialog id="dialog" with-backdrop="">
      <h2>[[i18n('exportButton.dialog.heading')]]</h2>

      <dom-repeat items="[[_filterRenditions(document, i18n)]]">
        <template>
          <div class="item">
            <iron-icon src="[[item.icon]]"></iron-icon> <a href="[[item.url]]" download="">[[item.label]]</a>
          </div>
        </template>
      </dom-repeat>

      <div class="buttons">
        <paper-button dialog-dismiss="">[[i18n('exportButton.dialog.cancel')]]</paper-button>
      </div>
    </nuxeo-dialog>

  </template>

  <script>
    {
      /**
       * A button element for exporting document's content.
       *
       * Example:
       *
       *     <nuxeo-export-button document="[[document]]"></nuxeo-export-button>
       *
       * @appliesMixin Nuxeo.I18nBehavior
       * @memberof Nuxeo
       * @demo demo/nuxeo-export-button/index.html
       */
      class ExportButton extends Polymer.mixinBehaviors([Nuxeo.FormatBehavior], Nuxeo.Element) {

        static get is() {
          return 'nuxeo-export-button';
        }

        static get properties() {
          return {
            /**
             * Input document.
             */
            document: Object,

            /**
             * Icon to use (iconset_name:icon_name).
             */
            icon: {
              type: String,
              value: 'nuxeo:export',
            },

            /**
             * `true` if the action should display the label, `false` otherwise.
             */
            showLabel: {
              type: Boolean,
              value: false,
            },

            _label: {
              type: String,
              computed: '_computeLabel(i18n)',
            },
          };
        }

        _isAvailable(document) {
          return document;
        }

        _computeLabel() {
          return this.i18n('exportButton.tooltip');
        }

        _toggleDialog() {
          this.$.dialog.toggle();
        }

        _filterRenditions(document) {
          if (document && document.contextParameters && document.contextParameters.renditions) {
            return document.contextParameters.renditions
              .filter((rendition) =>
                rendition.kind !== 'nuxeo:video:conversion' && rendition.kind !== 'nuxeo:picture:conversion')
              .map((item) =>
                Object.assign({label: this.formatRendition(item.name)}, item));
          }
          return [];
        }

      }

      customElements.define(ExportButton.is, ExportButton);
      Nuxeo.ExportButton = ExportButton;
    }
  </script>

</dom-module>
&gt;
<dom-module id="nuxeo-move-documents-down-button" assetpath="bower_components/nuxeo-ui-elements/actions/">
  <template>

    <style include="nuxeo-action-button-styles">
      iron-icon:hover {
        fill: var(--nuxeo-link-hover-color);
      }
    </style>

    <nuxeo-operation id="moveDownOp" op="Document.Order" params="[[_computeParams(_beforeUid)]]" sync-indexing="" input="[[_sortedDocuments]]">
    </nuxeo-operation>

    <dom-if id="availability" if="[[_available]]">
      <template>
        <div class="action">
          <paper-icon-button noink="" icon="icons:arrow-downward"></paper-icon-button>
          <span class="label" hidden$="[[!showLabel]]">[[_label]]</span>
        </div>
        <nuxeo-tooltip>[[_label]]</nuxeo-tooltip>
      </template>
    </dom-if>

  </template>

  <script>
    {
      /**
       * A button element for moving documents down within an OrderedFolder.
       *
       * @appliesMixin Nuxeo.I18nBehavior
       * @memberof Nuxeo
       * @demo demo/nuxeo-move-documents-down-button/index.html
       */
      class MoveDocumentsDown extends Polymer.mixinBehaviors([Nuxeo.I18nBehavior], Nuxeo.Element) {

        static get is() {
          return 'nuxeo-move-documents-down-button';
        }

        static get properties() {
          return {
            /**
             * All sibling documents.
             */
            documents: Array,
            /**
             * Input documents to be moved down.
             */
            selectedDocuments: Array,
            /**
             * Possible positions are  top|bottom|left|right. The default position is bottom.
             */
            tooltipPosition: {
              type: String,
              value: 'bottom',
            },
            /**
             * `true` if the action should display the label, `false` otherwise.
             */
            showLabel: {
              type: Boolean,
              value: false,
            },
            _label: {
              type: String,
              computed: '_computeLabel(i18n)',
            },
            _available: Boolean,
            _beforeUid: Document,
            _sortedDocuments: Array,
          };
        }

        static get observers() {
          return [
            '_isAvailable(selectedDocuments.splices)',
          ];
        }

        ready() {
          super.ready();
          this.addEventListener('click', this.move);
        }

        move() {
          this.$.moveDownOp.execute().then(() => {
            for (let i = 0; i < this._sortedDocuments.length; i++) {
              this.documents.splice(this.documents.indexOf(this._sortedDocuments[i]), 1);
              this.documents.splice(this._focusIndex, 0, this._sortedDocuments[i]);
            }
            this._sortedDocuments = [];
            this.dispatchEvent(new CustomEvent('refresh-display', {
              composed: true,
              bubbles: true,
              detail: { focusIndex: this._focusIndex + 1 },
            }));
          }).catch(() => {
            this.dispatchEvent(new CustomEvent('notify', {
              composed: true,
              bubbles: true,
              detail: { message: this.i18n('moveDocumentButton.error') },
            }));
          });
        }

        _isAvailable() {
          this._available = false;
          if (this.selectedDocuments && this.selectedDocuments.length > 0) {
            // Let's sort
            this._sortedDocuments = this.selectedDocuments.slice(0);
            try {
              this._sortedDocuments.sort((a, b) => {
                const idxa = this.documents.indexOf(a);
                const idxb = this.documents.indexOf(b);
                if (idxa < 0 || idxb < 0) {
                  throw new Error('Document is not in the list.');
                }
                return idxb - idxa;
              });
            } catch (e) {
              this.dispatchEvent(new CustomEvent('clear-selected-items', {
                composed: true,
                bubbles: true,
              }));
              return;
            }
            let sequenceBreakIdx;
            const isSequence = this._sortedDocuments.every((doc, idx) => {
              if (idx > 0) {
                if (this._sortedDocuments[idx - 1].uid === this.documents[this.documents.indexOf(doc) + 1].uid) {
                  return true;
                } else {
                  sequenceBreakIdx = idx;
                  return false;
                }
              }
              return true;
            });
            if (this._sortedDocuments[0].uid === this.documents[this.documents.length - 1].uid) {
              if (isSequence) {
                return;
              }
              this._focusIndex = this.documents.indexOf(this._sortedDocuments[0]) - sequenceBreakIdx;
              this._sortedDocuments.splice(0, sequenceBreakIdx);
              this._beforeUid = this.documents[this._focusIndex + 1].uid;
            } else {
              const tmpIdx = this.documents.indexOf(this._sortedDocuments[0]);
              if (tmpIdx < this.documents.length - 2) {
                this._beforeUid = this.documents[tmpIdx + 2].uid;
                this._focusIndex = tmpIdx + 1;
              } else {
                this._beforeUid = null;
                this._focusIndex = this.documents.length - 1;
              }
            }
            this._sortedDocuments.sort((a, b) => this.documents.indexOf(a) - this.documents.indexOf(b));
            this._available = true;
          }
        }

        _computeLabel() {
          return this.i18n('moveDocumentButton.down.tooltip');
        }

        _computeParams() {
          return this._beforeUid ? { before: this._beforeUid } : {};
        }

      }

      customElements.define(MoveDocumentsDown.is, MoveDocumentsDown);
      Nuxeo.MoveDocumentsDown = MoveDocumentsDown;
    }
  </script>
</dom-module>
<dom-module id="nuxeo-move-documents-up-button" assetpath="bower_components/nuxeo-ui-elements/actions/">
  <template>

    <style include="nuxeo-action-button-styles">
      iron-icon:hover {
        fill: var(--nuxeo-link-hover-color);
      }
    </style>

    <nuxeo-operation id="moveUpOp" op="Document.Order" params="{&quot;before&quot;: &quot;[[_beforeUid]]&quot;}" sync-indexing="" input="[[_sortedDocuments]]">
    </nuxeo-operation>

    <dom-if id="availability" if="[[_available]]">
      <template>
        <div class="action">
          <paper-icon-button noink="" icon="icons:arrow-upward"></paper-icon-button>
          <span class="label" hidden$="[[!showLabel]]">[[_label]]</span>
        </div>
        <nuxeo-tooltip>[[_label]]</nuxeo-tooltip>
      </template>
    </dom-if>

  </template>

  <script>
    {
      /**
       * A button element for moving documents up within an OrderedFolder.
       *
       * @appliesMixin Nuxeo.I18nBehavior
       * @memberof Nuxeo
       * @demo demo/nuxeo-move-documents-up-button/index.html
       */
      class MoveDocumentsUp extends Polymer.mixinBehaviors([Nuxeo.I18nBehavior], Nuxeo.Element) {

        static get is() {
          return 'nuxeo-move-documents-up-button';
        }

        static get properties() {
          return {
            /**
             * All sibling documents.
             */
            documents: Array,
            /**
             * Input documents to be moved down.
             */
            selectedDocuments: Array,
            /**
             * Possible positions are  top|bottom|left|right. The default position is bottom.
             */
            tooltipPosition: {
              type: String,
              value: 'bottom',
            },
            /**
             * `true` if the action should display the label, `false` otherwise.
             */
            showLabel: {
              type: Boolean,
              value: false,
            },
            _label: {
              type: String,
              computed: '_computeLabel(i18n)',
            },
            _available: Boolean,
            _beforeUid: Document,
            _sortedDocuments: Array,
          };
        }

        static get observers() {
          return [
            '_isAvailable(selectedDocuments.splices)',
          ];
        }

        ready() {
          super.ready();
          this.addEventListener('click', this.move);
        }

        move() {
          this.$.moveUpOp.execute().then(() => {
            for (let i = this._sortedDocuments.length - 1; i >= 0; i--) {
              this.documents.splice(this.documents.indexOf(this._sortedDocuments[i]), 1);
              this.documents.splice(this._focusIndex, 0, this._sortedDocuments[i]);
            }
            this._sortedDocuments = [];
            this.dispatchEvent(new CustomEvent('refresh-display', {
              composed: true,
              bubbles: true,
              detail: { focusIndex: this._focusIndex },
            }));
          }).catch(() => {
            this.dispatchEvent(new CustomEvent('notify', {
              composed: true,
              bubbles: true,
              detail: { message: this.i18n('moveDocumentButton.error')},
            }));
          });
        }

        _isAvailable() {
          this._available = false;
          if (this.selectedDocuments && this.selectedDocuments.length > 0) {
            // Let's sort
            this._sortedDocuments = this.selectedDocuments.slice(0);
            try {
              this._sortedDocuments.sort((a, b) => {
                const idxa = this.documents.indexOf(a);
                const idxb = this.documents.indexOf(b);
                if (idxa < 0 || idxb < 0) {
                  throw new Error('Document is not in the list.');
                }
                return idxa - idxb;
              });
            } catch (e) {
              this.dispatchEvent(new CustomEvent('clear-selected-items', {
                composed: true,
                bubbles: true,
                detail: {},
              }));
              return;
            }
            let sequenceBreakIdx;
            const isSequence = this._sortedDocuments.every((doc, idx) => {
              if (idx > 0) {
                if (this._sortedDocuments[idx - 1].uid === this.documents[this.documents.indexOf(doc) - 1].uid) {
                  return true;
                } else {
                  sequenceBreakIdx = idx;
                  return false;
                }
              }
              return true;
            });
            if (this._sortedDocuments[0].uid === this.documents[0].uid) {
              if (isSequence) {
                return;
              }
              this._focusIndex = this.documents.indexOf(this._sortedDocuments[sequenceBreakIdx - 1]) + 1;
              this._sortedDocuments.splice(0, sequenceBreakIdx);
            } else {
              this._focusIndex = this.documents.indexOf(this._sortedDocuments[0]) - 1;
            }
            this._beforeUid = this.documents[this._focusIndex].uid;
            this._available = true;
          }
        }

        _computeLabel() {
          return this.i18n('moveDocumentButton.up.tooltip');
        }

      }

      customElements.define(MoveDocumentsUp.is, MoveDocumentsUp);
      Nuxeo.MoveDocumentsDown = MoveDocumentsUp;
    }
  </script>
</dom-module>
<dom-module id="nuxeo-clipboard-toggle-button" assetpath="nuxeo-document-actions/">
  <template>
    <style include="nuxeo-action-button-styles">
      :host([in-clipboard]) {
        color: var(--icon-toggle-pressed-color, var(--nuxeo-action-color-activated));
      }
    </style>

    <template is="dom-if" if="[[_isAvailable(document)]]">
      <div class="action" on-tap="toggle">
        <paper-icon-button icon="[[icon]]" active="[[inClipboard]]" noink=""></paper-icon-button>
        <span class="label" hidden$="[[!showLabel]]">[[_label]]</span>
      </div>
      <nuxeo-tooltip>[[_label]]</nuxeo-tooltip>
    </template>
  </template>
  <script>
    Polymer({
      is: 'nuxeo-clipboard-toggle-button',
      behaviors: [Nuxeo.I18nBehavior, Nuxeo.FiltersBehavior],
      properties: {

        /**
         * Input document.
         */
        document: {
          type: Object,
          observer: '_update'
        },

        clipboard: {
          type: Object,
          observer: '_clipboardChanged'
        },

        /**
         * Icon to use (iconset_name:icon_name).
         */
        icon: {
          type: String,
          value: 'icons:content-paste'
        },

        inClipboard: {
          type: Boolean,
          notify: true,
          reflectToAttribute: true
        },

        /**
         * `true` if the action should display the label, `false` otherwise.
         */
        showLabel: {
          type: Boolean,
          value: false,
        },

        _label: {
          type: String,
          computed: '_computeLabel(inClipboard, i18n)'
        }
      },

      _isAvailable: function(doc) {
        return !doc.isVersion;
      },

      toggle: function() {
        if (this.clipboard.contains(this.document)) {
          this.clipboard.remove(this.document);
          this.fire('removed-from-clipboard', {docId : this.document.uid});
        } else {
          this.clipboard.add(this.document);
        }
      },

      _computeLabel: function(inClipboard) {
        return this.i18n('clipboardToggleButton.tooltip.' + (inClipboard ? 'remove' : 'add'));
      },

      _update: function() {
        this.inClipboard = this.clipboard && this.document && this.clipboard.contains(this.document);
      },

      _clipboardChanged: function(newValue, oldValue) {
        this._listener = this._listener || this._update.bind(this);
        if (oldValue) {
          oldValue.removeEventListener('documents-changed', this._listener);
        }
        if (newValue) {
          newValue.addEventListener('documents-changed', this._listener);
        }
        this._update();
      }

    });
  </script>
</dom-module>
<dom-module id="nuxeo-document-form-button" assetpath="nuxeo-document-actions/">
  <template>
    <style include="nuxeo-action-button-styles">
      .container {
        margin: 0;
        padding: 24px 0 0 0;
      }
      @media (min-width: 1024px) {
        nuxeo-dialog {
          min-width: 915px;
        }
      }
    </style>

    <template is="dom-if" if="[[_isAvailable(document)]]">
      <div class="action" on-tap="_openDialog">
        <paper-icon-button noink="" id="[[layout]]-button" icon="[[icon]]"></paper-icon-button>
        <span class="label" hidden$="[[!showLabel]]">[[i18n(label)]]</span>
      </div>
      <nuxeo-tooltip for="[[layout]]-button">[[i18n(label)]]</nuxeo-tooltip>
    </template>

    <nuxeo-dialog id="[[layout]]-dialog" no-auto-focus="" with-backdrop="" modal="">
      <div class="container">
        <nuxeo-document-form-layout id="layout" document="[[document]]" layout="[[layout]]" on-document-updated="_closeDialog"></nuxeo-document-form-layout>
      </div>
    </nuxeo-dialog>

  </template>
  <script>
    Polymer({
      is: 'nuxeo-document-form-button',
      behaviors: [Nuxeo.I18nBehavior, Nuxeo.FiltersBehavior],
      properties: {

        /**
         * Input document.
         */
        document: {
          type: Object
        },

        /**
         * Document form layout to load (default is `edit`)
         */
        layout: {
          type: String,
          value: 'edit'
        },

        /**
         * `true` if the action should display the label, `false` otherwise.
         */
        showLabel: {
          type: Boolean,
          value: false,
        },

        label: {
          type: String
        },

        icon: {
          type: String,
          value: 'nuxeo:edit'
        },
      },

      get dialog() {
        return this.root.getElementById(this.layout + '-dialog');
      },

      get button() {
        return this.root.getElementById(this.layout + '-button');
      },

      _isAvailable: function(doc) {
        return doc && doc.type !== 'Root' && this.hasPermission(doc, 'Write') && this._isMutable(doc);
      },

      _isMutable: function(doc) {
        return doc && !this.hasFacet(doc, 'Immutable') && doc.type !== 'Root' && !this.isTrashed(doc);
      },

      _openDialog: function() {
        this.dialog.open();
      },

      _closeDialog: function() {
        this.dialog.close();
      }
    });
  </script>
</dom-module>
<dom-module id="nuxeo-document-edit-button" assetpath="nuxeo-document-actions/">
  <template>
    <nuxeo-document-form-button document="[[document]]" layout="edit" label="documentEditAction.tooltip" show-label$="[[showLabel]]"></nuxeo-document-form-button>
  </template>
  <script>
    Polymer({
      is: 'nuxeo-document-edit-button',
      properties: {
        /**
         * Input document.
         */
        document: {
          type: Object
        },

        /**
         * `true` if the action should display the label, `false` otherwise.
         */
        showLabel: {
          type: Boolean,
          value: false,
        }
      }
    });
  </script>
</dom-module>
<dom-module id="nuxeo-replace-blob-button" assetpath="nuxeo-document-actions/">
  <template>
    <style include="nuxeo-action-button-styles nuxeo-styles">
      #dropzone {
        display: block;
      }
    </style>

    <nuxeo-document id="doc" doc-id="[[document.uid]]" response="{{document}}" sync-indexing=""></nuxeo-document>

    <dom-if if="[[_isAvailable(document)]]">
      <template>
        <div class="action" on-tap="_toggleDialog">
          <paper-icon-button id="replaceBtn" icon="[[icon]]" noink=""></paper-icon-button>
          <span class="label" hidden$="[[!showLabel]]">[[_label]]</span>
        </div>
        <nuxeo-tooltip for="replaceBtn">[[_label]]</nuxeo-tooltip>
      </template>
    </dom-if>

    <nuxeo-dialog id="dialog" with-backdrop="">
      <h2>[[i18n('replaceBlobButton.dialog.heading')]]</h2>
      <nuxeo-dropzone id="dropzone" document="{{document}}" xpath="[[xpath]]" has-files="{{_canSubmit}}"></nuxeo-dropzone>
      <div class="buttons">
        <paper-button dialog-dismiss="" on-tap="_cancel">[[i18n('replaceBlobButton.dialog.cancel')]]</paper-button>
        <paper-button noink="" class="primary" dialog-confirm="" on-tap="_replaceBlob" disabled="[[!_canSubmit]]">[[i18n('replaceBlobButton.dialog.replace')]]</paper-button>
      </div>
    </nuxeo-dialog>

  </template>
  <script>
    Polymer({
      /**
       * A button element for replacing a file blob from a document.
       *
       * Example:
       *
       *     <nuxeo-replace-blob-button document="[[document]]"></nuxeo-replace-blob-button>
       *
       * @appliesMixin Nuxeo.I18nBehavior
       * @appliesMixin Nuxeo.FiltersBehavior
       * @memberof Nuxeo
       */
      is: 'nuxeo-replace-blob-button',
      behaviors: [Nuxeo.I18nBehavior, Nuxeo.FiltersBehavior],
      properties: {
        /**
         * Input document.
         */
        document: Object,

        /**
         * Path of the file object to delete.
         * For example `xpath="files:files/0/file"`.
         */
        xpath: {
          type: String,
          value: 'file:content',
        },

        /**
         * Icon to use (iconset_name:icon_name).
         */
        icon: {
          type: String,
          value: 'nuxeo:replace',
        },

        /**
         * `true` if the action should display the label, `false` otherwise.
         */
        showLabel: {
          type: Boolean,
          value: false,
        },

        _canSubmit: {
          type: Boolean,
          value: false,
        },

        _label: {
          type: String,
          computed: '_computeLabel(i18n)',
        }
      },

      _cancel: function() {
        this.$.dropzone._deleteFile();
      },

      /**
       * Recursive method to create nested objects when they don't exist in a parent object.
       * It does not change any other existing objects or inner objects, only the ones referred in 'path'.
       * @param obj Parent Object where inner nested objects should be created.
       * @param path Array containing the inner object keys.
       * Usage Example:
       *
       *  - Creating document properties using xpath:
       *
       *    const xpath = 'my:custom/field/subfield/x'
       *    _createNestedObjectRecursive(this.document.properties, xpath.split('/'));
       *
       */
      _createNestedObjectRecursive: function(obj, path) {
        if (path.length === 0) {
          return;
        }
        if ((!Object.prototype.hasOwnProperty.call(obj, path[0]) && !obj[path[0]]) || typeof obj[path[0]] !== 'object') {
          obj[path[0]] = {};
        }
        return this._createNestedObjectRecursive(obj[path[0]], path.slice(1));
      },

      /**
       * Method to find which is the root property that should be sent to be updated in order to minimize the
       * possible issues due to concurrent changes, trying to avoid to change all the properties for a specific document.
       * Since there is still no way to update a specific array element, this method will assume that an array will
       * always be a root element.
       * @param pieces Array containing the inner object keys.
       * @param properties Document properties object.
       */
      _getRootProperty: function(pieces, properties) {
        var path = '';
        while(pieces.length > 0) {
          path += (path === '' ? '' : '.' ) + pieces.shift();
          if(Array.isArray(this.get(path, properties))) {
            return path;
          }
        }
        return path;
      },

      _replaceBlob: function() {
        // When xpath contains sub properties is important to check which is the root property.
        var rootProperty = this.xpath.includes('/')
          ? this._getRootProperty(this.xpath.split('/'), this.document.properties)
          : this.xpath;
        var dirtyProperties = {};
        this._createNestedObjectRecursive(dirtyProperties, rootProperty.split('.'));
        this.set(rootProperty, this.get(rootProperty, this.document.properties), dirtyProperties);

        this.$.doc.data = {
          'entity-type': 'document',
          uid: this.document.uid,
          properties: dirtyProperties
        };
        this.$.doc.put().then(function() {
          this.fire('document-updated');
        }.bind(this));
      },

      _toggleDialog: function() {
        this.$.dialog.toggle();
      },

      _computeLabel: function() {
        return this.i18n('replaceBlobButton.tooltip');
      },

      _isAvailable: function(doc) {
        return doc && this.hasPermission(doc, 'Write') && !this.isImmutable(doc) &&
          !this.hasType(doc, 'Root') && !this.isTrashed(doc);
      }
    });
  </script>
</dom-module>
<dom-module id="nuxeo-delete-blob-button" assetpath="bower_components/nuxeo-ui-elements/actions/">

  <template>
    <style include="nuxeo-action-button-styles"></style>

    <nuxeo-operation id="operation" op="Blob.RemoveFromDocument" input="[[document.uid]]" params="[[_params(xpath)]]"></nuxeo-operation>

    <dom-if if="[[_isAvailable(document)]]">
      <template>
        <div class="action" on-click="_toggleDialog">
          <paper-icon-button icon="[[icon]]" noink=""></paper-icon-button>
          <span class="label" hidden$="[[!showLabel]]">[[_label]]</span>
        </div>
        <nuxeo-tooltip>[[_label]]</nuxeo-tooltip>
      </template>
    </dom-if>

    <nuxeo-dialog id="dialog" with-backdrop="">
      <h2>[[i18n('deleteBlobButton.dialog.heading')]]</h2>
      <div>[[i18n('deleteBlobButton.dialog.message')]]</div>
      <div class="buttons">
        <paper-button dialog-dismiss="">[[i18n('deleteBlobButton.dialog.no')]]</paper-button>
        <paper-button dialog-confirm="" on-click="_remove">[[i18n('deleteBlobButton.dialog.yes')]]</paper-button>
      </div>
    </nuxeo-dialog>

  </template>

  <script>
    {
      /**
       * A button element for deleting a file blob from a document.
       *
       * Example:
       *
       *     <nuxeo-delete-blob-button document="[[document]]"></nuxeo-delete-blob-button>
       *
       * @appliesMixin Nuxeo.I18nBehavior
       * @appliesMixin Nuxeo.FiltersBehavior
       * @memberof Nuxeo
       * @demo demo/nuxeo-delete-blob-button/index.html
       */
      class DeleteBlobButton extends Polymer.mixinBehaviors([Nuxeo.I18nBehavior, Nuxeo.FiltersBehavior], Nuxeo.Element) {

        static get is() {
          return 'nuxeo-delete-blob-button';
        }

        static get properties() {
          return {
            /**
             * Input document.
             */
            document: Object,

            /**
             * Path of the file object to delete.
             * For example `xpath="files:files/0/file"`.
             */
            xpath: {
              type: String,
              value: 'file:content',
            },

            /**
             * Icon to use (iconset_name:icon_name).
             */
            icon: {
              type: String,
              value: 'nuxeo:remove',
            },

            /**
             * `true` if the action should display the label, `false` otherwise.
             */
            showLabel: {
              type: Boolean,
              value: false,
            },

            _label: {
              type: String,
              computed: '_computeLabel(i18n)',
            },
          };
        }

        _isAvailable(doc) {
          return doc && this.hasPermission(doc, 'Write') && !this.isImmutable(doc) &&
              !this.hasType(doc, 'Root') && !this.isTrashed(doc);
        }

        _computeLabel() {
          return this.i18n('deleteBlobButton.tooltip');
        }

        _toggleDialog() {
          this.$.dialog.toggle();
        }

        _params(xpath) {
          return {
            xpath: xpath.startsWith('files:') ? xpath.split('/file')[0] : xpath,
          };
        }

        _remove() {
          this.$.operation.execute().then(() => {
            this.dispatchEvent(new CustomEvent('file-deleted', {
              composed: true,
              bubbles: true,
            }));
          });
        }

      }

      customElements.define(DeleteBlobButton.is, DeleteBlobButton);
      Nuxeo.DeleteBlobButton = DeleteBlobButton;
    }
  </script>

</dom-module>
<dom-module id="nuxeo-workflow-button" assetpath="bower_components/nuxeo-ui-elements/actions/">
  <template>
    <style include="nuxeo-action-button-styles">
      nuxeo-select {
        max-width: 380px;
      }
    </style>

    <nuxeo-resource id="workflows" path="/id/[[document.uid]]/@workflow"></nuxeo-resource>

    <dom-if if="[[_isAvailable(document)]]">
      <template>
        <div class="action" on-click="_toggleDialog">
          <paper-icon-button icon="[[icon]]" noink=""></paper-icon-button>
          <span class="label" hidden$="[[!showLabel]]">[[_label]]</span>
        </div>
        <nuxeo-tooltip>[[_label]]</nuxeo-tooltip>

        <nuxeo-dialog id="dialog" with-backdrop="">
          <h2>[[i18n('workflowButton.dialog.heading')]]</h2>

          <nuxeo-select label="[[i18n('workflowButton.dialog.placeholder')]]" selected="{{selectedProcess}}" attr-for-selected="key">
            <dom-repeat items="[[processes]]" as="process">
              <template>
                <paper-item key="[[process.workflowModelName]]">[[i18n(process.title)]]</paper-item>
              </template>
            </dom-repeat>
          </nuxeo-select>

          <div class="buttons">
            <paper-button dialog-dismiss="">[[i18n('workflowButton.dialog.close')]]</paper-button>
            <paper-button id="startButton" class="primary" disabled="[[!selectedProcess]]" on-click="_startWorkflow">[[i18n('workflowButton.dialog.start')]]</paper-button>
          </div>
        </nuxeo-dialog>
      </template>
    </dom-if>
  </template>

  <script>
    {
      /**
       * A button element to start an workflow on a document.
       *
       * Example:
       *
       *     <nuxeo-workflow-button document="[[document]]"></nuxeo-workflow-button>
       *
       * @appliesMixin Nuxeo.I18nBehavior
       * @memberof Nuxeo
       * @demo demo/nuxeo-workflow-button/index.html
       */
      class WorkflowButton extends Polymer.mixinBehaviors([Nuxeo.I18nBehavior], Nuxeo.Element) {

        static get is() {
          return 'nuxeo-workflow-button';
        }

        static get properties() {
          return {
            /**
             * Input document.
             */
            document: {
              type: Object,
              observer: '_documentChanged',
            },

            processes: {
              type: Array,
            },

            selectedProcess: {
              type: String,
            },

            /* Running workflows on the document */
            workflows: {
              type: Object,
              observer: '_workflowsChanged',
            },

            /**
             * Icon to use (iconset_name:icon_name).
             */
            icon: {
              type: String,
              value: 'nuxeo:workflow',
            },

            /**
             * `true` if the action should display the label, `false` otherwise.
             */
            showLabel: {
              type: Boolean,
              value: false,
            },

            _label: {
              type: String,
              computed: '_computeLabel(i18n)',
            },
          };
        }

        _isAvailable(document) {
          if (!document) {
            return false;
          }
          this.processes = document.contextParameters.runnableWorkflows;
          this.workflows = document.contextParameters.runningWorkflows;
          this.hasWorkflowRunning = this.workflows && this.workflows.length > 0;
          return document && !this.hasWorkflowRunning && this.processes && this.processes.length > 0;
        }

        _computeLabel() {
          return this.i18n('workflowButton.tooltip');
        }

        _toggleDialog() {
          this.$$('#startButton').removeAttribute('disabled');
          this.$$('#dialog').toggle();
        }

        _startWorkflow() {
          // disable start button to prevent starting multiple workflows
          this.$$('#startButton').setAttribute('disabled', true);
          this.workflows = this.$.workflows;
          this.$.workflows.data = {
            'entity-type': 'workflow',
            workflowModelName: this.selectedProcess,
            attachedDocumentIds: [this.document.uid],
          };

          this.workflows.post().then((workflow) => {
            this.dispatchEvent(new CustomEvent('workflowStarted', {
              composed: true,
              bubbles: true,
              detail: { workflow },
            }));
            this.$$('#dialog').toggle();
          });
        }

        _workflowsChanged() {
          this.hasWorkflowRunning = this.workflows && this.workflows.length > 0;
        }

        _documentChanged() {
          if (this.document) {
            this.processes = this.document.contextParameters.runnableWorkflows;
            this.workflows = this.document.contextParameters.runningWorkflows;
            this.selectedProcess = this.processes.length > 0 ? this.processes[0].workflowModelName : null;
          }
        }

      }
    
      customElements.define(WorkflowButton.is, WorkflowButton);
      Nuxeo.WorkflowButton = WorkflowButton;
    }
  </script>

</dom-module>
<dom-module id="nuxeo-add-to-collection-documents-button" assetpath="nuxeo-document-bulk-actions/">
  <template>
    <style include="nuxeo-action-button-styles">
      :host([hidden]) {
        display: none;
      }

      /* Fix known stacking issue in iOS (NXP-24600)
         https://github.com/PolymerElements/paper-dialog-scrollable/issues/72 */
      paper-dialog-scrollable {
        --paper-dialog-scrollable: {
          -webkit-overflow-scrolling: auto;
        };
      }
    </style>

    <nuxeo-operation op="Document.AddToCollection" id="addToCollectionOp"></nuxeo-operation>
    <nuxeo-operation op="Collection.Create" id="createCollectionOp"></nuxeo-operation>

    <template is="dom-if" if="[[_isAvailable(documents.*)]]">
      <div class="action" on-tap="_toggleDialog">
        <paper-icon-button noink="" icon="nuxeo:collections" id="addColBut"></paper-icon-button>
        <span class="label" hidden$="[[!showLabel]]">[[_label]]</span>
      </div>
      <nuxeo-tooltip for="addColBut" position="[[tooltipPosition]]">[[_label]]</nuxeo-tooltip>
    </template>

    <nuxeo-dialog id="dialog" on-iron-overlay-closed="_resetPopup" with-backdrop="">
      <h2>[[i18n('addToCollectionDocumentsButton.dialog.heading')]]</h2>
      <paper-dialog-scrollable>

        <nuxeo-selectivity id="nxSelect" label="[[i18n('addToCollectionDocumentsButton.dialog.collections')]]" operation="Collection.Suggestion" min-chars="0" placeholder="[[i18n('addToCollectionDocumentsButton.dialog.select')]]" value="{{collection}}" tagging="true" query-results-filter="[[resultsFilter]]" result-formatter="[[resultAndSelectionFormatter]]" selection-formatter="[[resultAndSelectionFormatter]]" new-entry-formatter="[[newEntryFormatter]]" required="">
        </nuxeo-selectivity>
        <nuxeo-textarea label="[[i18n('addToCollectionDocumentsButton.dialog.description')]]" value="{{description::input}}" hidden$="[[!_isNew(collection)]]" always-float-label="">
        </nuxeo-textarea>
      </paper-dialog-scrollable>

      <div class="buttons">
        <paper-button noink="" dialog-dismiss="">[[i18n('addToCollectionDocumentsButton.dialog.cancel')]]</paper-button>
        <paper-button noink="" class="primary" on-tap="add" disabled$="[[!_isValid(collection)]]">
          [[i18n('addToCollectionDocumentsButton.dialog.add')]]
        </paper-button>
      </div>
    </nuxeo-dialog>

  </template>

  <script>
    Polymer({
      is: 'nuxeo-add-to-collection-documents-button',
      behaviors: [Nuxeo.I18nBehavior, Nuxeo.FiltersBehavior],
      properties: {
        documents: {
          type: Array,
          notify: true,
          value: []
        },

        collection: {
          type: String,
          value: ''
        },

        resultsFilter: {
          type: Function,
          value: function() {
            return this._resultsFilter.bind(this);
          }
        },

        resultAndSelectionFormatter: {
          type: Function,
          value: function() {
            return this._resultAndSelectionFormatter.bind(this);
          }
        },

        newEntryFormatter: {
          type: Function,
          value: function() {
            return this._newEntryFormatter.bind(this);
          }
        },

        tooltipPosition: {
          type: String,
          value: 'bottom'
        },

        /**
         * `true` if the action should display the label, `false` otherwise.
         */
        showLabel: {
          type: Boolean,
          value: false,
        },

        _label: {
          type: String,
          computed: '_computeLabel(i18n)'
        }
      },

      _isAvailable: function() {
        if (this.documents && this.documents.length > 0) {
          return this.documents.every(function(doc) {
            return !this.hasFacet(doc, 'NotCollectionMember');
          }.bind(this));
        }
        return false;
      },

      _toggleDialog: function() {
        this.$.dialog.toggle();
      },

      add: function() {
        if (this._isNew()) {
          var op = this.$$('#createCollectionOp');
          var name = this.$.nxSelect.selectedItem.displayLabel;
          op.input = undefined;
          op.params = {
            'name': name,
            'description': this.description
          };
          return op.execute().then(function(response) {
            this.collection = response.uid;
            this._addToCollection();
          }.bind(this));
        } else {
          this._addToCollection();
        }
      },

      _addToCollection: function() {
        var op = this.$$('#addToCollectionOp');
        op.params = {
          'collection': this.collection
        };
        var uids = this.documents.map(function(doc) {
          return doc.uid;
        });
        var uidsString = uids.join(',');
        op.input = 'docs:' + uidsString;
        return op.execute().then(function() {
          this.fire('added-to-collection', {docIds: uids, collectionId: this.collection});
          this._resetPopup();
          this._toggleDialog();
        }.bind(this));
      },

      _resultsFilter: function(entry) {
        return entry.id.indexOf('-999999') === -1;
      },

      _resultAndSelectionFormatter: function(item) {
        var label = item.displayLabel || item.title;
        // if we are adding a new entry with the _newEntryFormatter
        // we don't want to escape the HTML
        return item.id === -1 ? label : this.$.nxSelect.escapeHTML(label);
      },

      _newEntryFormatter: function(term) {
        return {id: -1, displayLabel: term};
      },

      _isValid: function() {
        return this.collection !== '';
      },

      _isNew: function() {
        return this.collection === -1;
      },

      _resetPopup: function() {
        this.set('collection', null);
        this.description = '';
      },

      _computeLabel: function() {
        return this.i18n('addToCollectionDocumentsButton.tooltip');
      }
    });
  </script>

</dom-module>
<dom-module id="nuxeo-clipboard-documents-button" assetpath="nuxeo-document-bulk-actions/">
  <template>
    <style include="nuxeo-action-button-styles"></style>

    <template is="dom-if" if="[[_isAvailable(documents.splices)]]">
      <div class="action" on-tap="addToClipBoard">
        <paper-icon-button noink="" id="clipboardButton" icon="icons:content-paste"></paper-icon-button>
        <span class="label" hidden$="[[!showLabel]]">[[_label]]</span>
      </div>
      <nuxeo-tooltip for="clipboardButton" position="[[tooltipPosition]]">[[_label]]</nuxeo-tooltip>
    </template>
  </template>

  <script>
    Polymer({
      is: 'nuxeo-clipboard-documents-button',
      behaviors: [Nuxeo.I18nBehavior, Nuxeo.FiltersBehavior],
      properties: {
        documents: {
          type: Array,
          notify: true,
          value: []
        },

        tooltipPosition: {
          type: String,
          value: 'bottom'
        },

        /**
         * `true` if the action should display the label, `false` otherwise.
         */
        showLabel: {
          type: Boolean,
          value: false,
        },

        _label: {
          type: String,
          computed: '_computeLabel(i18n)'
        }
      },

      addToClipBoard: function() {
        this.fire('add-to-clipboard', {documents: this.documents});
        this.fire ('clear-selected-items');
      },

      _isAvailable: function() {
        return this.documents.every(function(doc) {
          return this.isCollectionMember(doc) && !this.isTrashed(doc);
        }.bind(this));
      },

      _computeLabel: function() {
        return this.i18n('clipboardDocumentsButton.addToClipboard');
      }

    });
  </script>

</dom-module>
<dom-module id="nuxeo-delete-documents-button" assetpath="nuxeo-document-bulk-actions/">
  <template>
    <style include="nuxeo-action-button-styles"></style>

    <nuxeo-operation id="deleteOp" op="Document.Delete" sync-indexing=""></nuxeo-operation>

    <nuxeo-operation id="trashOp" op="Document.Trash" sync-indexing=""></nuxeo-operation>

    <template is="dom-if" if="[[_isAvailable(documents.splices)]]">
      <div class="action" on-tap="deleteDocuments">
        <paper-icon-button icon="[[_icon]]" id="deleteAllButton"></paper-icon-button>
        <span class="label" hidden$="[[!showLabel]]">[[_label]]</span>
      </div>
      <nuxeo-tooltip for="deleteAllButton" position="[[tooltipPosition]]">[[_label]]</nuxeo-tooltip>
    </template>
  </template>

  <script>
    Polymer({
      is: 'nuxeo-delete-documents-button',
      behaviors: [Nuxeo.I18nBehavior, Nuxeo.FiltersBehavior],
      properties: {
        documents: {
          type: Array,
          notify: true,
          value: []
        },

        /**
         * Permanently delete the documents.
         */
        hard: {
          type: Boolean,
          value: false
        },

        tooltipPosition: {
          type: String,
          value: 'bottom'
        },

        /**
         * `true` if the action should display the label, `false` otherwise.
         */
        showLabel: {
          type: Boolean,
          value: false,
        },

        _icon: {
          type: 'String',
          computed: '_computeIcon(hard)'
        },

        _label: {
          type: 'String',
          computed: '_computeLabel(hard, i18n)'
        }
      },

      deleteDocuments: function() {
        if (this.docsHavePermissions && confirm(this.i18n('deleteDocumentsButton.confirm.deleteDocuments'))) {
          if (this.documents && this.documents.length) {
            var uids = this.documents.map(function(doc) {
              return doc.uid;
            }).join(',');
            var op = this.hard ? this.$.deleteOp : this.$.trashOp;
            op.input = 'docs:' + uids;
            op.execute().then(function() {
              this.fire('nuxeo-documents-deleted', {documents: this.documents});
              this.documents = [];
              this.fire('refresh');
            }.bind(this),
            function(error) {
              this.fire('nuxeo-documents-deleted', {error: error, documents: this.documents});
            }.bind(this));
          }
        }
      },

      /**
       * Action is available if all selected items are not trashed and `hard` is not active OR if all selected items
       * are trashed and `hard` is active.
       */
      _isAvailable: function() {
        return this.documents && this.documents.length > 0 && this._checkDocsPermissions() &&
            (this.hard || !this._checkDocsAreTrashed());
      },

      /**
       * Checks if all selected documents are trashed.
       */
      _checkDocsAreTrashed: function() {
        return this.documents.every(function(document) {
          return this.isTrashed(document);
        }.bind(this));
      },

      _checkDocsPermissions: function() {
        this.docsHavePermissions = this.documents && !(this.documents.some(
          function(document) {
            return !this._docHasPermissions(document);
          }.bind(this)));
        return this.docsHavePermissions;
      },

      /*
       * Checks if a single given document has 'Everything' permission to delete or 'Write' to trash
       */
      _docHasPermissions: function(document) {
        return this.hasPermission(document, 'Everything') || (!this.hard && this.hasPermission(document, 'Write'));
      },

      _computeIcon: function(hard) {
        return hard ? 'nuxeo:delete-permanently' : 'nuxeo:delete';
      },

      _computeLabel: function(hard) {
        return this.i18n(hard ? 'deleteDocumentsButton.tooltip.permanently' : 'deleteDocumentsButton.tooltip');
      }
    });
  </script>

</dom-module>
<dom-module id="nuxeo-download-documents-button" assetpath="nuxeo-document-bulk-actions/">
  <template>
    <nuxeo-operation-button id="btn" operation="Blob.BulkDownload" input="[[_input(document, documents)]]" params="[[_params(document, documents)]]" icon="nuxeo:download" label="bulkDownload.tooltip" show-label$="[[showLabel]]" error-label="bulkDownload.error" async="" download=""></nuxeo-operation-button>
  </template>

  <script>
    Polymer({
      is: 'nuxeo-download-documents-button',
      behaviors: [Nuxeo.I18nBehavior, Nuxeo.FiltersBehavior],
      properties: {
        documents: {
          type: Array,
          notify: true,
          value: []
        },

        document: {
          type: Object,
        },

        /**
         * `true` if the action should display the label, `false` otherwise.
         */
        showLabel: {
          type: Boolean,
          value: false,
        },
      },

      ready: function() {
        this.$.btn.addEventListener('poll-start', this._onPollStart.bind(this));
        this.$.btn.addEventListener('response', this._onResponse.bind(this));
      },

      _params: function() {
        var params = {};
        if (this.document && (this.hasFacet(this.document, 'Collection') || this.hasFacet(this.document, 'Folderish'))) {
          params.filename = this.document.title + '_' + new Date().getTime() + '.zip';
        } else {
          params.filename = this.i18n('bulkDownload.filename.selection') + "-" + new Date().getTime() + ".zip"
        }
        return params;
      },

      _input: function() {
        return 'docs:' + (this.document ? [this.document] : this.documents).map(function(doc) {
          return doc.uid;
        }).join(',');
      },

      _onPollStart: function() {
        this.fire('notify', { message: this.i18n('bulkDownload.preparing') });
      },

      _onResponse: function() {
        this.fire('notify', { message: this.i18n('bulkDownload.completed') });
      }
    });
  </script>

</dom-module>
<dom-module id="nuxeo-untrash-documents-button" assetpath="nuxeo-document-bulk-actions/">
  <template>
    <style include="nuxeo-action-button-styles"></style>

    <nuxeo-operation id="operation" op="Document.Untrash" sync-indexing=""></nuxeo-operation>

    <template is="dom-if" if="[[_isAvailable(documents.splices)]]">
      <div class="action" on-tap="untrashDocuments">
        <paper-icon-button icon="nuxeo:restore-deleted" id="untrashAllButton"></paper-icon-button>
        <span class="label" hidden$="[[!showLabel]]">[[_label]]</span>
      </div>
      <nuxeo-tooltip position="[[tooltipPosition]]">[[i18n(_label)]]</nuxeo-tooltip>
    </template>
  </template>

  <script>
    Polymer({
      is: 'nuxeo-untrash-documents-button',
      behaviors: [Nuxeo.I18nBehavior, Nuxeo.FiltersBehavior],
      properties: {
        documents: {
          type: Array,
          notify: true,
          value: []
        },

        tooltipPosition: {
          type: String,
          value: 'bottom'
        },

        /**
         * `true` if the action should display the label, `false` otherwise.
         */
        showLabel: {
          type: Boolean,
          value: false,
        },

        _label: {
          type: String,
          computed: '_computeLabel(i18n)'
        }
      },

      untrashDocuments: function() {
        if (this.docsHavePermissions && confirm(this.i18n('untrashDocumentsButton.confirm.untrashDocuments'))) {
          if (this.documents && this.documents.length) {
            var uids = this.documents.map(function(doc) {
              return doc.uid;
            }).join(',');
            this.$.operation.input = 'docs:' + uids;
            var uidsArray = this.documents.map(function(doc) {
              return doc.uid;
            });
            this.$.operation.execute().then(function() {
              this.fire('nuxeo-documents-untrashed', {documentIds: uidsArray});
              this.documents = [];
              this.fire('refresh');
            }.bind(this),
            function(error) {
              this.fire('nuxeo-documents-untrashed', {error: error,  documents: uidsArray});
            }.bind(this));
          }
        }
      },

      _isAvailable: function() {
        return this.documents && this.documents.length > 0 && this._checkDocsPermissions()
            && this._checkDocsAreTrashed();
      },

      _checkDocsAreTrashed: function() {
        return this.documents.every(function(document) {
          return this.isTrashed(document);
        }.bind(this));
      },

      _checkDocsPermissions: function() {
        this.docsHavePermissions = !(this.documents.some(
          function(document) {
            return !this._docHasPermissions(document);
          }.bind(this)));
        return this.docsHavePermissions;
      },

      /*
       * Checks if a single given document has 'Write' permission
       */
      _docHasPermissions: function(document) {
        return this.hasPermission(document, 'Write');
      },

      _computeLabel: function() {
        return this.i18n('untrashDocumentsButton.tooltip');
      }
    });
  </script>

</dom-module>
<dom-module id="nuxeo-document-diff-button" assetpath="diff/">
  <template>
    <style include="nuxeo-action-button-styles"></style>

    <template is="dom-if" if="[[_isAvailable(selectedDocuments)]]">
      <div class="action" on-tap="_doDiff">
        <paper-icon-button noink="" id="diff" icon="nuxeo:compare"></paper-icon-button>
        <span class="label" hidden$="[[!showLabel]]">[[_label]]</span>
      </div>
      <nuxeo-tooltip for="diff" position="[[tooltipPosition]]">[[_label]]</nuxeo-tooltip>
    </template>
  </template>

  <script>
    Polymer({
      is: 'nuxeo-document-diff-button',
      behaviors: [Nuxeo.I18nBehavior, Nuxeo.FiltersBehavior],
      properties: {
        selectedDocuments: {
          type: Array,
          value: []
        },
        tooltipPosition: {
          type: String,
          value: 'bottom'
        },
        /**
         * `true` if the action should display the label, `false` otherwise.
         */
        showLabel: {
          type: Boolean,
          value: false,
        },

        _label: {
          type: String,
          computed: '_computeLabel(i18n)'
        }
      },

      _isAvailable: function() {
        return this.selectedDocuments && this.selectedDocuments.length > 1;
      },

      _doDiff: function() {
        this.fire('nuxeo-diff-documents', {
          documents: this.selectedDocuments
        });
      },

      _computeLabel: function() {
        return this.i18n('documentDiffButton.tooltip');
      }
    });
  </script>

</dom-module>
<dom-module id="nuxeo-versions-diff-button" assetpath="diff/">
  <template>
    <style include="nuxeo-action-button-styles"></style>

    <template is="dom-if" if="[[hasVersions(document)]]">
      <nuxeo-operation id="opGetVersions" op="Document.GetVersions" input="[[document.uid]]">
      </nuxeo-operation>
      <div class="action" on-tap="_doDiff">
        <paper-icon-button noink="" id="diff" icon="nuxeo:compare"></paper-icon-button>
        <span class="label" hidden$="[[!showLabel]]">[[_label]]</span>
      </div>
      <nuxeo-tooltip for="diff" position="[[tooltipPosition]]">[[_label]]</nuxeo-tooltip>
    </template>
  </template>

  <script>
    Polymer({
      is: 'nuxeo-versions-diff-button',
      behaviors: [Nuxeo.I18nBehavior, Nuxeo.FiltersBehavior],
      properties: {
        document: {
          type: Object
        },
        tooltipPosition: {
          type: String,
          value: 'bottom'
        },
        /**
         * `true` if the action should display the label, `false` otherwise.
         */
        showLabel: {
          type: Boolean,
          value: false,
        },

        _label: {
          type: String,
          computed: '_computeLabel(i18n)'
        }
      },

      _doDiff: function() {
        this.$$('#opGetVersions').execute().then(function(result) {
          // sort the versions from the most to the least recent
          var versions = result.entries.reverse();
          var currentIndex = versions.findIndex(function(doc) {
            return this._getMajor(doc) === this._getMajor(this.document) &&
                   this._getMinor(doc) === this._getMinor(this.document);
          }.bind(this));
          // and put the current one if the beginning of the list
          if (currentIndex > 0) {
            var current = versions[currentIndex];
            versions.splice(currentIndex, 1);
            versions.unshift(current);
          }
          if (this.document.isCheckedOut) {
            versions.unshift(this.document);
          }
          // check if there is at least two versions to be compared
          if (versions.length < 2) {
            this.fire('notify', { message: this.i18n('versionsDiffButton.nothingToCompare')} );
            return;
          }
          this.fire('nuxeo-diff-documents', {
            documents: versions
          });
        }.bind(this));
      },

      _getMajor: function(document) {
        return document.properties['uid:major_version'];
      },

      _getMinor: function(document) {
        return document.properties['uid:minor_version'];
      },

      _computeLabel: function() {
        return this.i18n('versionsDiffButton.tooltip');
      }

    });
  </script>

</dom-module>
<script>
  var Nuxeo = Nuxeo || {};
  (function() {
    function generateTextDiffHunks(text) {
      return text[0].split(/(@@[\s-+,\d]+@@)/).filter(Boolean).reduce(function(result, value, index, array) {
        if (index % 2 === 0) {
          var pair = array.slice(index, index + 2);
          var range = pair[0].match(/\d+,\d+/g);
          range = {
            original: range[0].split(',').map(Number),
            new: range[1].split(',').map(Number)
          }
          result.push({
            range: range,
            context: pair[1],
            hasAdditions: !!pair[1].match(/^\+(.*)$/gm),
            hasDeletions: !!pair[1].match(/^\-(.*)$/gm)
          });
        }
        return result;
      }, []);
    }

    /**
    * `Nuxeo.DiffBehavior` provides common behavior to elements that display differences between document properties.
    *
    * @polymerBehavior
    */
    Nuxeo.DiffBehavior = {
      properties: {
        /**
        * The property being represented
        */
        property: {
          type: String,
          reflectToAttribute: true
        },
        /**
        * The property's type.
        */
        type: {
          type: String,
          value: 'string',
          reflectToAttribute: true
        },
        /**
        * If `true`, the element is being used in single column mode.
        */
        unified: {
          type: Boolean,
          value: false,
          reflectToAttribute: true
        },
        /**
        * If `true`, deletions will not be displayed.
        */
        hideDeletions: {
          type: Boolean,
          value: false
        },
        /**
        * If `true`, additions will not be displayed.
        */
        hideAdditions: {
          type: Boolean,
          value: false
        },
        /**
        * The label to be displayed.
        */
        label: {
          type: String
        },
        /**
        * The schema to which the property belongs to.
        */
        schema: Object,
        /**
         * The id of the document on the left, where deletions occurred.
         */
        leftUid: String,
        /**
         * The id of the document on the right, where additions occurred.
         */
        rightUid: String,
        /**
        * The difference delta.
        */
        delta: Object,
        /**
        * The original value.
        */
        originalValue: Object,
        /**
        * The new value.
        */
        newValue: Object,
        /**
        * If `true`, the element should display all information, including that not covered by `delta`.
        */
        showAll: {
          type: Boolean,
          value: false
        },
        /**
        * If `true`, the `label` will be displayed.
        */
        displayLabel: {
          type: Boolean,
          value: false
        },
        /**
        * If `true`, this element is part of an array. This is mostly used to condition styling.
        */
        isArrayItem: {
          type: Boolean,
          value: false,
          reflectToAttribute: true
        },
        /**
        * The depth level, used to indent labels. Please override `_computeIndentStyle` to change indentation styling.
        */
        level: {
          type: Number,
          value: 0
        }
      },

      observers: ['_computeType(property, schema, delta, originalValue)'],

      _computeType: function(property, schema, delta, originalValue) {
        var type = this.type;
        if (property && schema && schema.fields && schema.fields[property]) {
          type = schema.fields[property];
          type = type.type || type;
        }
        // handle resolved types
        if (type === 'string' || type === 'string[]') {
          var aValue;
          // try to infer entity type from the original value
          if (this._isObject(originalValue) || (Array.isArray(originalValue) && originalValue.length > 0)) {
            aValue = Array.isArray(originalValue) ? originalValue[0] : originalValue;
          } else if (delta) {
            // no original value? let's try to find an entity type form the delta
            if (type === 'string[]') {
              var aKey = Object.keys(delta)[0];
              aValue = Array.isArray(delta[aKey]) ? delta[aKey][0] : delta[aKey];
            } else {
              aValue = Array.isArray(delta) ? delta[0] || delta[1] : delta;
            }
          }
          if (aValue && aValue['entity-type']) {
            type = aValue['entity-type'] + (type.endsWith('[]') ? '[]' : '');
          }
        }
        this.set('type', type);
      },

      _computeLabel: function(property, label) {
        return label || property;
      },

      _computeDefaultClass: function(delta, originalValue) {
        return this._isSimple(delta, originalValue) ? 'simple' : 'complex';
      },

      _computeArrayClass: function(delta, originalValue, newValue, hideAdditions, hideDeletions) {
        if (delta) {
          var arrdelta = this._getArrayDelta(delta, originalValue, newValue, hideAdditions, hideDeletions);
          return (arrdelta && arrdelta.length > 0) ?
            this._computeDefaultClass(arrdelta[0].value, arrdelta[0].originalValue) : 'simple';
        } else {
          return this._computeDefaultClass(undefined, originalValue);
        }
      },

      _showArrayItem: function(arrdelta, showAll) {
        return showAll || arrdelta.modified;
      },

      _incLevel: function(level) {
        return level + 1;
      },

      /**
      * Computes the indentation style for labels.
      */
      _computeIndentStyle: function(level, isArrayItem) {
        return 'margin-left: ' + (isArrayItem ? 0 : level * 12) + 'px;'
      },

      /* misc helpers */

      _isArray: function(value) {
        return Array.isArray(value);
      },

      _isObject: function(value) {
        return value && typeof value === 'object' && value.constructor === Object;
      },

      _isNotObjectNorArray: function(value) {
        return !this._isArray(value) && !this._isObject(value);
      },

      _getKeys: function(delta) {
        return Object.keys(delta);
      },

      _getValue: function(delta, property) {
        return delta && delta[property];
      },

      _getPropertySchema: function(schema, property) {
        return property ? (schema && schema.fields && schema.fields[property]) : schema;
      },

      _unwrapDelta: function(delta) {
        var value = delta;
        if (this._hasAddition(delta)) {
          value = this._getAddition(delta);
        } else if (this._hasDeletion(delta)) {
          value = this._getDeletion(delta);
        } else if (this._hasModification(delta)) {
          value = this._getModificationOldValue(delta) || this._getModificationNewValue(delta);
        } else if (this._hasTextDiff(delta)) {
          value = delta[0];
        } else if (this._hasArrayInnerChanges(delta)) {
          var aKey = Object.keys(delta).filter(function(key) {
            return key !== '_t';
          })[0];
          value = Array.isArray(delta[aKey]) ? delta[aKey][0] : delta[aKey];
        }
        return value;
      },

      _isSimpleDelta: function(delta) {
        return this._isNotObjectNorArray(this._unwrapDelta(delta));
      },

      _isSimple: function(delta, originalValue) {
        return delta ? this._isSimpleDelta(delta) :
          !this._isObject((Array.isArray(originalValue) && originalValue.length > 0) ? originalValue[0] : originalValue);
      },

      _getAllKeys: function(delta, originalValue, showAll) {
        return showAll ? this._getKeys(originalValue) : this._getKeys(delta);
      },

      _arrayItemType: function(type) {
        return type ? type.replace(/\[\]$/, '') : 'string';
      },

      /* delta helpers */

      _hasNoChanges: function(delta) {
        return !delta;
      },

      _hasAddition: function(delta, hideAdditions) {
        return !hideAdditions && Array.isArray(delta) && delta.length === 1;
      },

      _getAddition: function(delta) {
        return delta[0];
      },

      _hasModification: function(delta) {
        return Array.isArray(delta) && delta.length === 2;
      },

      _getModificationOldValue: function(delta) {
        return delta[0];
      },

      _getModificationNewValue: function(delta) {
        return delta[1];
      },

      _hasDeletion: function(delta, hideDeletions) {
        return !hideDeletions && Array.isArray(delta) && delta.length === 3 && delta[2] === 0;
      },

      _getDeletion: function(delta) {
        return delta[0];
      },

      _hasArrayMove: function(delta) {
        return Array.isArray(delta) && delta.length === 3 && delta[2] === 3;
      },

      _hasTextDiff: function(delta) {
        return Array.isArray(delta) && delta.length === 3 && delta[2] === 2;
      },

      _hasArrayInnerChanges: function(delta) {
        return this._isObject(delta) && delta._t === 'a';
      },

      _hasObjectInnerChanges: function(delta) {
        return this._isObject(delta) && !delta._t;
      },

      /* delta helpers: unidiff */

      _getTextDiff: function(text, originalValue, hideAdditions, hideDeletions) {
        if (!text || !originalValue) {
          return;
        }
        var hunks = generateTextDiffHunks(text);
        var result = '';
        var offset = 0;
        var start = 0;
        hunks.forEach(function(hunk){
          var end = hunk.range.original[0] - 1 + offset;
          result += originalValue.substring(start, end) + hunk.context
            .replace(/^\-(.*)$/gm, hideDeletions ? '' : '<span class="deleted">$1</span>') // removals
            .replace(/^\+(.*)$/gm, hideAdditions ? '' : '<span class="added">$1</span>') // deletions
            .replace(/^\s/gm, '') // modifier, which will by a black space for unmodified lines
            .replace(/(\r\n|\r|\n)/gm, ''); // new lines
          offset += hunk.range.original[1] - hunk.range.new[1];
          start += hunk.range.original[1] + (end - start);
        }.bind(this));
        return result;
      },

      /* delta helpers: arrays */

      _getArrayDelta: function(delta, originalValue, newValue, hideAdditions, hideDeletions) {
        if (!delta || !originalValue || !Array.isArray(originalValue)) {
          return;
        }
        var deltas = originalValue.map(function(val, index) {
          return { originalValue: val, modified: false, index: String(index), change: 'unchanged', newValue: null };
        });
        // sort and reversing assures that we'll deal first with deletions
        Object.keys(delta).filter(function(key) { return key !== '_t' }).sort().reverse().forEach(function(index) {
          var i;
          if (index.startsWith('_')) {
            i = Number(index.replace('_', ''));
            if (hideDeletions) {
              deltas.splice(i, 1);
            } else {
              deltas.splice(i, 1, {
                value: delta[index],
                modified: true,
                change: 'deleted',
                originalValue: originalValue[i],
                newValue: newValue ? newValue[i] : null,
                index: String(i)
              });
            }
          } else {
            i = Number(index);
            if (this._isObject(delta[index])) {
              deltas.splice(i, 1, {
                value: delta[index],
                modified: true,
                change: 'modified',
                originalValue: originalValue[i],
                newValue: newValue ? newValue[i] : null,
                index: String(i)
              });
            } else if (!hideAdditions) {
              deltas.splice(i, 0, {
                value: delta[index],
                modified: true,
                change: 'added',
                originalValue: originalValue[i],
                newValue: newValue ? newValue[i] : null,
                index: String(i)
              });
            }
          }
        }.bind(this));
        deltas.sort(function(a, b) {
          if (a.index === b.index) {
            if (a.change === b.change) {
              return 0;
            }
            return a.change === 'added' ? 1 : -1;
          } else {
            return a.index > b.index;
          }
        });
        return deltas;
      }
    };
  })();
</script>
<dom-module id="nuxeo-diff-styles" assetpath="diff/">
  <template>
    <style include="iron-flex iron-flex-alignment nuxeo-styles">
      :host {
        display: block;
      }

      :host([is-array-item]) .label {
        margin-right: 8px;
        @apply --layout-flex-none;
      }

      span {
        word-break: break-all;
      }

      span.added {
        display: inline;
        word-break: break-all;
        background-color: var(--nuxeo-diff-added-color, #B4EFCB);
        @apply --nuxeo-string-diff-added;
      }

      span.deleted {
        display: inline;
        word-break: break-all;
        background-color: var(--nuxeo-diff-deleted-color, #E6B1B1);
        @apply --nuxeo-string-diff-deleted;
      }

      .addition, .deletion {
        display: inherit;
      }

      .deletion ~ .addition {
        margin-left: 8px;
      }

      .addition > :not(span):not(div):not(a) {
        border-left: 4px solid var(--nuxeo-diff-added-color, #B4EFCB);
        padding-left: 2px;
        @apply --nuxeo-complex-diff-added;
      }

      .deletion > :not(span):not(div):not(a) {
        border-left: 4px solid var(--nuxeo-diff-deleted-color, #E6B1B1);
        padding-left: 2px;
        @apply --nuxeo-complex-diff-deleted;
      }

      .label {
        @apply --layout-flex;
        max-width: 150px;
        color: var(--nuxeo-diff-label-color, #D4D4D9);
        @apply --nuxeo-diff-label;
      }

      .simple .label {
        text-overflow: ellipsis;
        overflow: hidden;
        white-space: nowrap;
      }

      .value.simple {
        display: inherit;
      }

      :host(:not([is-array-item])) .value.simple {
        @apply --layout-flex-2;
      }

      .text.diff {
        word-break: break-all;
      }

      .array.complex {
        @apply --layout-vertical;
        display: block;
      }

      .array.simple {
        @apply --layout-horizontal;
        @apply --layout-flex;
        @apply --layout-wrap;
      }

      .array.diff.simple .sep {
        margin: 0 8px 0 4px;
      }

      .array.simple .item:not(:last-of-type)::after {
        content: ",";
        margin-left: 4px;
      }

      .array.simple .item:not(:last-child) {
        margin-right: 8px;
      }

      .item {
        @apply --layout-horizontal;
      }

      .array.complex .item ~ .item {
        margin-top: 12px;
      }

      .array .item nuxeo-object-diff {
        @apply --layout-flex;
      }
    </style>
  </template>
</dom-module>
<dom-module id="nuxeo-object-diff" assetpath="diff/">
  <template>
    <style include="nuxeo-diff-styles">
    </style>

    <div id="container"></div>

  </template>

  <script>
    var Nuxeo = Nuxeo || {};
    Nuxeo.Diff = Nuxeo.Diff || {};
    Nuxeo.Diff.registry = {
      default: 'nuxeo-default-diff'
    };

    /**
     * Registers a custom diff element for a set of rules to condition when the element is to be displayed.
     *
     * @param {string} id - The element id.
     * @param {Object} rules - A set of rules, following the format: `{type: 'type', property: 'propertname'}`.
     */
    Nuxeo.Diff.registerElement = function(id, rules) {
      if (rules.type) {
        if (!Nuxeo.Diff.registry.types) {
          Nuxeo.Diff.registry.types = {};
        }
        Nuxeo.Diff.registry.types[rules.type] = id;
      }
      if (rules.property) {
        if (!Nuxeo.Diff.registry.properties) {
          Nuxeo.Diff.registry.properties = {};
        }
        Nuxeo.Diff.registry.properties[rules.property] = id;
      }
    },

    /**
     * Retrieves a custom element for a given set of rules, or the default element if none is found.
     */
    Nuxeo.Diff.getElement = function(rules) {
      var id = null;
      if (Nuxeo.Diff.registry.properties && rules.property) {
        id = Nuxeo.Diff.registry.properties[rules.property];
      }
      if (!id && Nuxeo.Diff.registry.types && rules.type) {
        id = Nuxeo.Diff.registry.types[rules.type];
      }
      return id || Nuxeo.Diff.registry.default;
    }

    Polymer({
      is: 'nuxeo-object-diff',
      behaviors: [Nuxeo.DiffBehavior],
      observers: ['_updateContainer(type, property)'],

      created: function() {
        for (var prop in this.properties) {
          // XXX: use a method observer per property to keep databinding between the object diff and it's child
          // Note: we're not using a property observer here because we need to pass not only the value but also the
          // property name, in order to be able to set it on the child.
          this._createMethodObserver('_forwardProp("' + prop + '", ' + prop + ')');
        }
      },

      _forwardProp: function(prop, value) {
        if (this._instance) {
          this._instance[prop] = value;
        }
      },

      _updateContainer: function(type, property) {
        // retrieve a custom element for the given type and property combination,
        // or the default element if none is found.
        this._instance = document.createElement(Nuxeo.Diff.getElement({type: type,
          property: [this.schema && (this.schema.prefix || this.schema.name), property].filter(Boolean).join(':')}));

        for (var prop in this.properties) {
          this._instance[prop] = this[prop];
        }

        if (this.$.container.hasChildNodes()) {
          this.$.container.replaceChild(this._instance, this.$.container.firstChild);
        } else {
          this.$.container.appendChild(this._instance);
        }
      }
    });
  </script>

</dom-module>
<script type="text/javascript">(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('./empty')) :
	typeof define === 'function' && define.amd ? define(['exports', './empty'], factory) :
	(factory((global.jsondiffpatch = {}),global.chalk));
}(this, (function (exports,chalk) { 'use strict';

chalk = chalk && chalk.hasOwnProperty('default') ? chalk['default'] : chalk;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};





var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();













var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

var Processor = function () {
  function Processor(options) {
    classCallCheck(this, Processor);

    this.selfOptions = options || {};
    this.pipes = {};
  }

  createClass(Processor, [{
    key: 'options',
    value: function options(_options) {
      if (_options) {
        this.selfOptions = _options;
      }
      return this.selfOptions;
    }
  }, {
    key: 'pipe',
    value: function pipe(name, pipeArg) {
      var pipe = pipeArg;
      if (typeof name === 'string') {
        if (typeof pipe === 'undefined') {
          return this.pipes[name];
        } else {
          this.pipes[name] = pipe;
        }
      }
      if (name && name.name) {
        pipe = name;
        if (pipe.processor === this) {
          return pipe;
        }
        this.pipes[pipe.name] = pipe;
      }
      pipe.processor = this;
      return pipe;
    }
  }, {
    key: 'process',
    value: function process(input, pipe) {
      var context = input;
      context.options = this.options();
      var nextPipe = pipe || input.pipe || 'default';
      var lastPipe = void 0;
      var lastContext = void 0;
      while (nextPipe) {
        if (typeof context.nextAfterChildren !== 'undefined') {
          // children processed and coming back to parent
          context.next = context.nextAfterChildren;
          context.nextAfterChildren = null;
        }

        if (typeof nextPipe === 'string') {
          nextPipe = this.pipe(nextPipe);
        }
        nextPipe.process(context);
        lastContext = context;
        lastPipe = nextPipe;
        nextPipe = null;
        if (context) {
          if (context.next) {
            context = context.next;
            nextPipe = lastContext.nextPipe || context.pipe || lastPipe;
          }
        }
      }
      return context.hasResult ? context.result : undefined;
    }
  }]);
  return Processor;
}();

var Pipe = function () {
  function Pipe(name) {
    classCallCheck(this, Pipe);

    this.name = name;
    this.filters = [];
  }

  createClass(Pipe, [{
    key: 'process',
    value: function process(input) {
      if (!this.processor) {
        throw new Error('add this pipe to a processor before using it');
      }
      var debug = this.debug;
      var length = this.filters.length;
      var context = input;
      for (var index = 0; index < length; index++) {
        var filter = this.filters[index];
        if (debug) {
          this.log('filter: ' + filter.filterName);
        }
        filter(context);
        if ((typeof context === 'undefined' ? 'undefined' : _typeof(context)) === 'object' && context.exiting) {
          context.exiting = false;
          break;
        }
      }
      if (!context.next && this.resultCheck) {
        this.resultCheck(context);
      }
    }
  }, {
    key: 'log',
    value: function log(msg) {
      console.log('[jsondiffpatch] ' + this.name + ' pipe, ' + msg);
    }
  }, {
    key: 'append',
    value: function append() {
      var _filters;

      (_filters = this.filters).push.apply(_filters, arguments);
      return this;
    }
  }, {
    key: 'prepend',
    value: function prepend() {
      var _filters2;

      (_filters2 = this.filters).unshift.apply(_filters2, arguments);
      return this;
    }
  }, {
    key: 'indexOf',
    value: function indexOf(filterName) {
      if (!filterName) {
        throw new Error('a filter name is required');
      }
      for (var index = 0; index < this.filters.length; index++) {
        var filter = this.filters[index];
        if (filter.filterName === filterName) {
          return index;
        }
      }
      throw new Error('filter not found: ' + filterName);
    }
  }, {
    key: 'list',
    value: function list() {
      return this.filters.map(function (f) {
        return f.filterName;
      });
    }
  }, {
    key: 'after',
    value: function after(filterName) {
      var index = this.indexOf(filterName);
      var params = Array.prototype.slice.call(arguments, 1);
      if (!params.length) {
        throw new Error('a filter is required');
      }
      params.unshift(index + 1, 0);
      Array.prototype.splice.apply(this.filters, params);
      return this;
    }
  }, {
    key: 'before',
    value: function before(filterName) {
      var index = this.indexOf(filterName);
      var params = Array.prototype.slice.call(arguments, 1);
      if (!params.length) {
        throw new Error('a filter is required');
      }
      params.unshift(index, 0);
      Array.prototype.splice.apply(this.filters, params);
      return this;
    }
  }, {
    key: 'replace',
    value: function replace(filterName) {
      var index = this.indexOf(filterName);
      var params = Array.prototype.slice.call(arguments, 1);
      if (!params.length) {
        throw new Error('a filter is required');
      }
      params.unshift(index, 1);
      Array.prototype.splice.apply(this.filters, params);
      return this;
    }
  }, {
    key: 'remove',
    value: function remove(filterName) {
      var index = this.indexOf(filterName);
      this.filters.splice(index, 1);
      return this;
    }
  }, {
    key: 'clear',
    value: function clear() {
      this.filters.length = 0;
      return this;
    }
  }, {
    key: 'shouldHaveResult',
    value: function shouldHaveResult(should) {
      if (should === false) {
        this.resultCheck = null;
        return;
      }
      if (this.resultCheck) {
        return;
      }
      var pipe = this;
      this.resultCheck = function (context) {
        if (!context.hasResult) {
          console.log(context);
          var error = new Error(pipe.name + ' failed');
          error.noResult = true;
          throw error;
        }
      };
      return this;
    }
  }]);
  return Pipe;
}();

var Context = function () {
  function Context() {
    classCallCheck(this, Context);
  }

  createClass(Context, [{
    key: 'setResult',
    value: function setResult(result) {
      this.result = result;
      this.hasResult = true;
      return this;
    }
  }, {
    key: 'exit',
    value: function exit() {
      this.exiting = true;
      return this;
    }
  }, {
    key: 'switchTo',
    value: function switchTo(next, pipe) {
      if (typeof next === 'string' || next instanceof Pipe) {
        this.nextPipe = next;
      } else {
        this.next = next;
        if (pipe) {
          this.nextPipe = pipe;
        }
      }
      return this;
    }
  }, {
    key: 'push',
    value: function push(child, name) {
      child.parent = this;
      if (typeof name !== 'undefined') {
        child.childName = name;
      }
      child.root = this.root || this;
      child.options = child.options || this.options;
      if (!this.children) {
        this.children = [child];
        this.nextAfterChildren = this.next || null;
        this.next = child;
      } else {
        this.children[this.children.length - 1].next = child;
        this.children.push(child);
      }
      child.next = this;
      return this;
    }
  }]);
  return Context;
}();

var isArray = typeof Array.isArray === 'function' ? Array.isArray : function (a) {
  return a instanceof Array;
};

function cloneRegExp(re) {
  var regexMatch = /^\/(.*)\/([gimyu]*)$/.exec(re.toString());
  return new RegExp(regexMatch[1], regexMatch[2]);
}

function clone(arg) {
  if ((typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) !== 'object') {
    return arg;
  }
  if (arg === null) {
    return null;
  }
  if (isArray(arg)) {
    return arg.map(clone);
  }
  if (arg instanceof Date) {
    return new Date(arg.getTime());
  }
  if (arg instanceof RegExp) {
    return cloneRegExp(arg);
  }
  var cloned = {};
  for (var name in arg) {
    if (Object.prototype.hasOwnProperty.call(arg, name)) {
      cloned[name] = clone(arg[name]);
    }
  }
  return cloned;
}

var DiffContext = function (_Context) {
  inherits(DiffContext, _Context);

  function DiffContext(left, right) {
    classCallCheck(this, DiffContext);

    var _this = possibleConstructorReturn(this, (DiffContext.__proto__ || Object.getPrototypeOf(DiffContext)).call(this));

    _this.left = left;
    _this.right = right;
    _this.pipe = 'diff';
    return _this;
  }

  createClass(DiffContext, [{
    key: 'setResult',
    value: function setResult(result) {
      if (this.options.cloneDiffValues && (typeof result === 'undefined' ? 'undefined' : _typeof(result)) === 'object') {
        var clone$$1 = typeof this.options.cloneDiffValues === 'function' ? this.options.cloneDiffValues : clone;
        if (_typeof(result[0]) === 'object') {
          result[0] = clone$$1(result[0]);
        }
        if (_typeof(result[1]) === 'object') {
          result[1] = clone$$1(result[1]);
        }
      }
      return Context.prototype.setResult.apply(this, arguments);
    }
  }]);
  return DiffContext;
}(Context);

var PatchContext = function (_Context) {
  inherits(PatchContext, _Context);

  function PatchContext(left, delta) {
    classCallCheck(this, PatchContext);

    var _this = possibleConstructorReturn(this, (PatchContext.__proto__ || Object.getPrototypeOf(PatchContext)).call(this));

    _this.left = left;
    _this.delta = delta;
    _this.pipe = 'patch';
    return _this;
  }

  return PatchContext;
}(Context);

var ReverseContext = function (_Context) {
  inherits(ReverseContext, _Context);

  function ReverseContext(delta) {
    classCallCheck(this, ReverseContext);

    var _this = possibleConstructorReturn(this, (ReverseContext.__proto__ || Object.getPrototypeOf(ReverseContext)).call(this));

    _this.delta = delta;
    _this.pipe = 'reverse';
    return _this;
  }

  return ReverseContext;
}(Context);

var isArray$1 = typeof Array.isArray === 'function' ? Array.isArray : function (a) {
  return a instanceof Array;
};

var diffFilter = function trivialMatchesDiffFilter(context) {
  if (context.left === context.right) {
    context.setResult(undefined).exit();
    return;
  }
  if (typeof context.left === 'undefined') {
    if (typeof context.right === 'function') {
      throw new Error('functions are not supported');
    }
    context.setResult([context.right]).exit();
    return;
  }
  if (typeof context.right === 'undefined') {
    context.setResult([context.left, 0, 0]).exit();
    return;
  }
  if (typeof context.left === 'function' || typeof context.right === 'function') {
    throw new Error('functions are not supported');
  }
  context.leftType = context.left === null ? 'null' : _typeof(context.left);
  context.rightType = context.right === null ? 'null' : _typeof(context.right);
  if (context.leftType !== context.rightType) {
    context.setResult([context.left, context.right]).exit();
    return;
  }
  if (context.leftType === 'boolean' || context.leftType === 'number') {
    context.setResult([context.left, context.right]).exit();
    return;
  }
  if (context.leftType === 'object') {
    context.leftIsArray = isArray$1(context.left);
  }
  if (context.rightType === 'object') {
    context.rightIsArray = isArray$1(context.right);
  }
  if (context.leftIsArray !== context.rightIsArray) {
    context.setResult([context.left, context.right]).exit();
    return;
  }

  if (context.left instanceof RegExp) {
    if (context.right instanceof RegExp) {
      context.setResult([context.left.toString(), context.right.toString()]).exit();
    } else {
      context.setResult([context.left, context.right]).exit();
    }
  }
};
diffFilter.filterName = 'trivial';

var patchFilter = function trivialMatchesPatchFilter(context) {
  if (typeof context.delta === 'undefined') {
    context.setResult(context.left).exit();
    return;
  }
  context.nested = !isArray$1(context.delta);
  if (context.nested) {
    return;
  }
  if (context.delta.length === 1) {
    context.setResult(context.delta[0]).exit();
    return;
  }
  if (context.delta.length === 2) {
    if (context.left instanceof RegExp) {
      var regexArgs = /^\/(.*)\/([gimyu]+)$/.exec(context.delta[1]);
      if (regexArgs) {
        context.setResult(new RegExp(regexArgs[1], regexArgs[2])).exit();
        return;
      }
    }
    context.setResult(context.delta[1]).exit();
    return;
  }
  if (context.delta.length === 3 && context.delta[2] === 0) {
    context.setResult(undefined).exit();
  }
};
patchFilter.filterName = 'trivial';

var reverseFilter = function trivialReferseFilter(context) {
  if (typeof context.delta === 'undefined') {
    context.setResult(context.delta).exit();
    return;
  }
  context.nested = !isArray$1(context.delta);
  if (context.nested) {
    return;
  }
  if (context.delta.length === 1) {
    context.setResult([context.delta[0], 0, 0]).exit();
    return;
  }
  if (context.delta.length === 2) {
    context.setResult([context.delta[1], context.delta[0]]).exit();
    return;
  }
  if (context.delta.length === 3 && context.delta[2] === 0) {
    context.setResult([context.delta[0]]).exit();
  }
};
reverseFilter.filterName = 'trivial';

function collectChildrenDiffFilter(context) {
  if (!context || !context.children) {
    return;
  }
  var length = context.children.length;
  var child = void 0;
  var result = context.result;
  for (var index = 0; index < length; index++) {
    child = context.children[index];
    if (typeof child.result === 'undefined') {
      continue;
    }
    result = result || {};
    result[child.childName] = child.result;
  }
  if (result && context.leftIsArray) {
    result._t = 'a';
  }
  context.setResult(result).exit();
}
collectChildrenDiffFilter.filterName = 'collectChildren';

function objectsDiffFilter(context) {
  if (context.leftIsArray || context.leftType !== 'object') {
    return;
  }

  var name = void 0;
  var child = void 0;
  var propertyFilter = context.options.propertyFilter;
  for (name in context.left) {
    if (!Object.prototype.hasOwnProperty.call(context.left, name)) {
      continue;
    }
    if (propertyFilter && !propertyFilter(name, context)) {
      continue;
    }
    child = new DiffContext(context.left[name], context.right[name]);
    context.push(child, name);
  }
  for (name in context.right) {
    if (!Object.prototype.hasOwnProperty.call(context.right, name)) {
      continue;
    }
    if (propertyFilter && !propertyFilter(name, context)) {
      continue;
    }
    if (typeof context.left[name] === 'undefined') {
      child = new DiffContext(undefined, context.right[name]);
      context.push(child, name);
    }
  }

  if (!context.children || context.children.length === 0) {
    context.setResult(undefined).exit();
    return;
  }
  context.exit();
}
objectsDiffFilter.filterName = 'objects';

var patchFilter$1 = function nestedPatchFilter(context) {
  if (!context.nested) {
    return;
  }
  if (context.delta._t) {
    return;
  }
  var name = void 0;
  var child = void 0;
  for (name in context.delta) {
    child = new PatchContext(context.left[name], context.delta[name]);
    context.push(child, name);
  }
  context.exit();
};
patchFilter$1.filterName = 'objects';

var collectChildrenPatchFilter = function collectChildrenPatchFilter(context) {
  if (!context || !context.children) {
    return;
  }
  if (context.delta._t) {
    return;
  }
  var length = context.children.length;
  var child = void 0;
  for (var index = 0; index < length; index++) {
    child = context.children[index];
    if (Object.prototype.hasOwnProperty.call(context.left, child.childName) && child.result === undefined) {
      delete context.left[child.childName];
    } else if (context.left[child.childName] !== child.result) {
      context.left[child.childName] = child.result;
    }
  }
  context.setResult(context.left).exit();
};
collectChildrenPatchFilter.filterName = 'collectChildren';

var reverseFilter$1 = function nestedReverseFilter(context) {
  if (!context.nested) {
    return;
  }
  if (context.delta._t) {
    return;
  }
  var name = void 0;
  var child = void 0;
  for (name in context.delta) {
    child = new ReverseContext(context.delta[name]);
    context.push(child, name);
  }
  context.exit();
};
reverseFilter$1.filterName = 'objects';

function collectChildrenReverseFilter(context) {
  if (!context || !context.children) {
    return;
  }
  if (context.delta._t) {
    return;
  }
  var length = context.children.length;
  var child = void 0;
  var delta = {};
  for (var index = 0; index < length; index++) {
    child = context.children[index];
    if (delta[child.childName] !== child.result) {
      delta[child.childName] = child.result;
    }
  }
  context.setResult(delta).exit();
}
collectChildrenReverseFilter.filterName = 'collectChildren';

/*

LCS implementation that supports arrays or strings

reference: http://en.wikipedia.org/wiki/Longest_common_subsequence_problem

*/

var defaultMatch = function defaultMatch(array1, array2, index1, index2) {
  return array1[index1] === array2[index2];
};

var lengthMatrix = function lengthMatrix(array1, array2, match, context) {
  var len1 = array1.length;
  var len2 = array2.length;
  var x = void 0,
      y = void 0;

  // initialize empty matrix of len1+1 x len2+1
  var matrix = [len1 + 1];
  for (x = 0; x < len1 + 1; x++) {
    matrix[x] = [len2 + 1];
    for (y = 0; y < len2 + 1; y++) {
      matrix[x][y] = 0;
    }
  }
  matrix.match = match;
  // save sequence lengths for each coordinate
  for (x = 1; x < len1 + 1; x++) {
    for (y = 1; y < len2 + 1; y++) {
      if (match(array1, array2, x - 1, y - 1, context)) {
        matrix[x][y] = matrix[x - 1][y - 1] + 1;
      } else {
        matrix[x][y] = Math.max(matrix[x - 1][y], matrix[x][y - 1]);
      }
    }
  }
  return matrix;
};

var backtrack = function backtrack(matrix, array1, array2, index1, index2, context) {
  if (index1 === 0 || index2 === 0) {
    return {
      sequence: [],
      indices1: [],
      indices2: []
    };
  }

  if (matrix.match(array1, array2, index1 - 1, index2 - 1, context)) {
    var subsequence = backtrack(matrix, array1, array2, index1 - 1, index2 - 1, context);
    subsequence.sequence.push(array1[index1 - 1]);
    subsequence.indices1.push(index1 - 1);
    subsequence.indices2.push(index2 - 1);
    return subsequence;
  }

  if (matrix[index1][index2 - 1] > matrix[index1 - 1][index2]) {
    return backtrack(matrix, array1, array2, index1, index2 - 1, context);
  } else {
    return backtrack(matrix, array1, array2, index1 - 1, index2, context);
  }
};

var get$1 = function get(array1, array2, match, context) {
  var innerContext = context || {};
  var matrix = lengthMatrix(array1, array2, match || defaultMatch, innerContext);
  var result = backtrack(matrix, array1, array2, array1.length, array2.length, innerContext);
  if (typeof array1 === 'string' && typeof array2 === 'string') {
    result.sequence = result.sequence.join('');
  }
  return result;
};

var lcs = {
  get: get$1
};

var ARRAY_MOVE = 3;

var isArray$2 = typeof Array.isArray === 'function' ? Array.isArray : function (a) {
  return a instanceof Array;
};

var arrayIndexOf = typeof Array.prototype.indexOf === 'function' ? function (array, item) {
  return array.indexOf(item);
} : function (array, item) {
  var length = array.length;
  for (var i = 0; i < length; i++) {
    if (array[i] === item) {
      return i;
    }
  }
  return -1;
};

function arraysHaveMatchByRef(array1, array2, len1, len2) {
  for (var index1 = 0; index1 < len1; index1++) {
    var val1 = array1[index1];
    for (var index2 = 0; index2 < len2; index2++) {
      var val2 = array2[index2];
      if (index1 !== index2 && val1 === val2) {
        return true;
      }
    }
  }
}

function matchItems(array1, array2, index1, index2, context) {
  var value1 = array1[index1];
  var value2 = array2[index2];
  if (value1 === value2) {
    return true;
  }
  if ((typeof value1 === 'undefined' ? 'undefined' : _typeof(value1)) !== 'object' || (typeof value2 === 'undefined' ? 'undefined' : _typeof(value2)) !== 'object') {
    return false;
  }
  var objectHash = context.objectHash;
  if (!objectHash) {
    // no way to match objects was provided, try match by position
    return context.matchByPosition && index1 === index2;
  }
  var hash1 = void 0;
  var hash2 = void 0;
  if (typeof index1 === 'number') {
    context.hashCache1 = context.hashCache1 || [];
    hash1 = context.hashCache1[index1];
    if (typeof hash1 === 'undefined') {
      context.hashCache1[index1] = hash1 = objectHash(value1, index1);
    }
  } else {
    hash1 = objectHash(value1);
  }
  if (typeof hash1 === 'undefined') {
    return false;
  }
  if (typeof index2 === 'number') {
    context.hashCache2 = context.hashCache2 || [];
    hash2 = context.hashCache2[index2];
    if (typeof hash2 === 'undefined') {
      context.hashCache2[index2] = hash2 = objectHash(value2, index2);
    }
  } else {
    hash2 = objectHash(value2);
  }
  if (typeof hash2 === 'undefined') {
    return false;
  }
  return hash1 === hash2;
}

var diffFilter$1 = function arraysDiffFilter(context) {
  if (!context.leftIsArray) {
    return;
  }

  var matchContext = {
    objectHash: context.options && context.options.objectHash,
    matchByPosition: context.options && context.options.matchByPosition
  };
  var commonHead = 0;
  var commonTail = 0;
  var index = void 0;
  var index1 = void 0;
  var index2 = void 0;
  var array1 = context.left;
  var array2 = context.right;
  var len1 = array1.length;
  var len2 = array2.length;

  var child = void 0;

  if (len1 > 0 && len2 > 0 && !matchContext.objectHash && typeof matchContext.matchByPosition !== 'boolean') {
    matchContext.matchByPosition = !arraysHaveMatchByRef(array1, array2, len1, len2);
  }

  // separate common head
  while (commonHead < len1 && commonHead < len2 && matchItems(array1, array2, commonHead, commonHead, matchContext)) {
    index = commonHead;
    child = new DiffContext(context.left[index], context.right[index]);
    context.push(child, index);
    commonHead++;
  }
  // separate common tail
  while (commonTail + commonHead < len1 && commonTail + commonHead < len2 && matchItems(array1, array2, len1 - 1 - commonTail, len2 - 1 - commonTail, matchContext)) {
    index1 = len1 - 1 - commonTail;
    index2 = len2 - 1 - commonTail;
    child = new DiffContext(context.left[index1], context.right[index2]);
    context.push(child, index2);
    commonTail++;
  }
  var result = void 0;
  if (commonHead + commonTail === len1) {
    if (len1 === len2) {
      // arrays are identical
      context.setResult(undefined).exit();
      return;
    }
    // trivial case, a block (1 or more consecutive items) was added
    result = result || {
      _t: 'a'
    };
    for (index = commonHead; index < len2 - commonTail; index++) {
      result[index] = [array2[index]];
    }
    context.setResult(result).exit();
    return;
  }
  if (commonHead + commonTail === len2) {
    // trivial case, a block (1 or more consecutive items) was removed
    result = result || {
      _t: 'a'
    };
    for (index = commonHead; index < len1 - commonTail; index++) {
      result['_' + index] = [array1[index], 0, 0];
    }
    context.setResult(result).exit();
    return;
  }
  // reset hash cache
  delete matchContext.hashCache1;
  delete matchContext.hashCache2;

  // diff is not trivial, find the LCS (Longest Common Subsequence)
  var trimmed1 = array1.slice(commonHead, len1 - commonTail);
  var trimmed2 = array2.slice(commonHead, len2 - commonTail);
  var seq = lcs.get(trimmed1, trimmed2, matchItems, matchContext);
  var removedItems = [];
  result = result || {
    _t: 'a'
  };
  for (index = commonHead; index < len1 - commonTail; index++) {
    if (arrayIndexOf(seq.indices1, index - commonHead) < 0) {
      // removed
      result['_' + index] = [array1[index], 0, 0];
      removedItems.push(index);
    }
  }

  var detectMove = true;
  if (context.options && context.options.arrays && context.options.arrays.detectMove === false) {
    detectMove = false;
  }
  var includeValueOnMove = false;
  if (context.options && context.options.arrays && context.options.arrays.includeValueOnMove) {
    includeValueOnMove = true;
  }

  var removedItemsLength = removedItems.length;
  for (index = commonHead; index < len2 - commonTail; index++) {
    var indexOnArray2 = arrayIndexOf(seq.indices2, index - commonHead);
    if (indexOnArray2 < 0) {
      // added, try to match with a removed item and register as position move
      var isMove = false;
      if (detectMove && removedItemsLength > 0) {
        for (var removeItemIndex1 = 0; removeItemIndex1 < removedItemsLength; removeItemIndex1++) {
          index1 = removedItems[removeItemIndex1];
          if (matchItems(trimmed1, trimmed2, index1 - commonHead, index - commonHead, matchContext)) {
            // store position move as: [originalValue, newPosition, ARRAY_MOVE]
            result['_' + index1].splice(1, 2, index, ARRAY_MOVE);
            if (!includeValueOnMove) {
              // don't include moved value on diff, to save bytes
              result['_' + index1][0] = '';
            }

            index2 = index;
            child = new DiffContext(context.left[index1], context.right[index2]);
            context.push(child, index2);
            removedItems.splice(removeItemIndex1, 1);
            isMove = true;
            break;
          }
        }
      }
      if (!isMove) {
        // added
        result[index] = [array2[index]];
      }
    } else {
      // match, do inner diff
      index1 = seq.indices1[indexOnArray2] + commonHead;
      index2 = seq.indices2[indexOnArray2] + commonHead;
      child = new DiffContext(context.left[index1], context.right[index2]);
      context.push(child, index2);
    }
  }

  context.setResult(result).exit();
};
diffFilter$1.filterName = 'arrays';

var compare = {
  numerically: function numerically(a, b) {
    return a - b;
  },
  numericallyBy: function numericallyBy(name) {
    return function (a, b) {
      return a[name] - b[name];
    };
  }
};

var patchFilter$2 = function nestedPatchFilter(context) {
  if (!context.nested) {
    return;
  }
  if (context.delta._t !== 'a') {
    return;
  }
  var index = void 0;
  var index1 = void 0;

  var delta = context.delta;
  var array = context.left;

  // first, separate removals, insertions and modifications
  var toRemove = [];
  var toInsert = [];
  var toModify = [];
  for (index in delta) {
    if (index !== '_t') {
      if (index[0] === '_') {
        // removed item from original array
        if (delta[index][2] === 0 || delta[index][2] === ARRAY_MOVE) {
          toRemove.push(parseInt(index.slice(1), 10));
        } else {
          throw new Error('only removal or move can be applied at original array indices,' + (' invalid diff type: ' + delta[index][2]));
        }
      } else {
        if (delta[index].length === 1) {
          // added item at new array
          toInsert.push({
            index: parseInt(index, 10),
            value: delta[index][0]
          });
        } else {
          // modified item at new array
          toModify.push({
            index: parseInt(index, 10),
            delta: delta[index]
          });
        }
      }
    }
  }

  // remove items, in reverse order to avoid sawing our own floor
  toRemove = toRemove.sort(compare.numerically);
  for (index = toRemove.length - 1; index >= 0; index--) {
    index1 = toRemove[index];
    var indexDiff = delta['_' + index1];
    var removedValue = array.splice(index1, 1)[0];
    if (indexDiff[2] === ARRAY_MOVE) {
      // reinsert later
      toInsert.push({
        index: indexDiff[1],
        value: removedValue
      });
    }
  }

  // insert items, in reverse order to avoid moving our own floor
  toInsert = toInsert.sort(compare.numericallyBy('index'));
  var toInsertLength = toInsert.length;
  for (index = 0; index < toInsertLength; index++) {
    var insertion = toInsert[index];
    array.splice(insertion.index, 0, insertion.value);
  }

  // apply modifications
  var toModifyLength = toModify.length;
  var child = void 0;
  if (toModifyLength > 0) {
    for (index = 0; index < toModifyLength; index++) {
      var modification = toModify[index];
      child = new PatchContext(context.left[modification.index], modification.delta);
      context.push(child, modification.index);
    }
  }

  if (!context.children) {
    context.setResult(context.left).exit();
    return;
  }
  context.exit();
};
patchFilter$2.filterName = 'arrays';

var collectChildrenPatchFilter$1 = function collectChildrenPatchFilter(context) {
  if (!context || !context.children) {
    return;
  }
  if (context.delta._t !== 'a') {
    return;
  }
  var length = context.children.length;
  var child = void 0;
  for (var index = 0; index < length; index++) {
    child = context.children[index];
    context.left[child.childName] = child.result;
  }
  context.setResult(context.left).exit();
};
collectChildrenPatchFilter$1.filterName = 'arraysCollectChildren';

var reverseFilter$2 = function arraysReverseFilter(context) {
  if (!context.nested) {
    if (context.delta[2] === ARRAY_MOVE) {
      context.newName = '_' + context.delta[1];
      context.setResult([context.delta[0], parseInt(context.childName.substr(1), 10), ARRAY_MOVE]).exit();
    }
    return;
  }
  if (context.delta._t !== 'a') {
    return;
  }
  var name = void 0;
  var child = void 0;
  for (name in context.delta) {
    if (name === '_t') {
      continue;
    }
    child = new ReverseContext(context.delta[name]);
    context.push(child, name);
  }
  context.exit();
};
reverseFilter$2.filterName = 'arrays';

var reverseArrayDeltaIndex = function reverseArrayDeltaIndex(delta, index, itemDelta) {
  if (typeof index === 'string' && index[0] === '_') {
    return parseInt(index.substr(1), 10);
  } else if (isArray$2(itemDelta) && itemDelta[2] === 0) {
    return '_' + index;
  }

  var reverseIndex = +index;
  for (var deltaIndex in delta) {
    var deltaItem = delta[deltaIndex];
    if (isArray$2(deltaItem)) {
      if (deltaItem[2] === ARRAY_MOVE) {
        var moveFromIndex = parseInt(deltaIndex.substr(1), 10);
        var moveToIndex = deltaItem[1];
        if (moveToIndex === +index) {
          return moveFromIndex;
        }
        if (moveFromIndex <= reverseIndex && moveToIndex > reverseIndex) {
          reverseIndex++;
        } else if (moveFromIndex >= reverseIndex && moveToIndex < reverseIndex) {
          reverseIndex--;
        }
      } else if (deltaItem[2] === 0) {
        var deleteIndex = parseInt(deltaIndex.substr(1), 10);
        if (deleteIndex <= reverseIndex) {
          reverseIndex++;
        }
      } else if (deltaItem.length === 1 && deltaIndex <= reverseIndex) {
        reverseIndex--;
      }
    }
  }

  return reverseIndex;
};

function collectChildrenReverseFilter$1(context) {
  if (!context || !context.children) {
    return;
  }
  if (context.delta._t !== 'a') {
    return;
  }
  var length = context.children.length;
  var child = void 0;
  var delta = {
    _t: 'a'
  };

  for (var index = 0; index < length; index++) {
    child = context.children[index];
    var name = child.newName;
    if (typeof name === 'undefined') {
      name = reverseArrayDeltaIndex(context.delta, child.childName, child.result);
    }
    if (delta[name] !== child.result) {
      delta[name] = child.result;
    }
  }
  context.setResult(delta).exit();
}
collectChildrenReverseFilter$1.filterName = 'arraysCollectChildren';

var diffFilter$2 = function datesDiffFilter(context) {
  if (context.left instanceof Date) {
    if (context.right instanceof Date) {
      if (context.left.getTime() !== context.right.getTime()) {
        context.setResult([context.left, context.right]);
      } else {
        context.setResult(undefined);
      }
    } else {
      context.setResult([context.left, context.right]);
    }
    context.exit();
  } else if (context.right instanceof Date) {
    context.setResult([context.left, context.right]).exit();
  }
};
diffFilter$2.filterName = 'dates';

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var diffMatchPatch = createCommonjsModule(function (module) {
function diff_match_patch() {

  // Defaults.
  // Redefine these in your program to override the defaults.

  // Number of seconds to map a diff before giving up (0 for infinity).
  this.Diff_Timeout = 1.0;
  // Cost of an empty edit operation in terms of edit characters.
  this.Diff_EditCost = 4;
  // At what point is no match declared (0.0 = perfection, 1.0 = very loose).
  this.Match_Threshold = 0.5;
  // How far to search for a match (0 = exact location, 1000+ = broad match).
  // A match this many characters away from the expected location will add
  // 1.0 to the score (0.0 is a perfect match).
  this.Match_Distance = 1000;
  // When deleting a large block of text (over ~64 characters), how close do
  // the contents have to be to match the expected contents. (0.0 = perfection,
  // 1.0 = very loose).  Note that Match_Threshold controls how closely the
  // end points of a delete need to match.
  this.Patch_DeleteThreshold = 0.5;
  // Chunk size for context length.
  this.Patch_Margin = 4;

  // The number of bits in an int.
  this.Match_MaxBits = 32;
}


//  DIFF FUNCTIONS


/**
 * The data structure representing a diff is an array of tuples:
 * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
 * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
 */
var DIFF_DELETE = -1;
var DIFF_INSERT = 1;
var DIFF_EQUAL = 0;

/** @typedef {{0: number, 1: string}} */
diff_match_patch.prototype.diff_main = function(text1, text2, opt_checklines,
    opt_deadline) {
  // Set a deadline by which time the diff must be complete.
  if (typeof opt_deadline == 'undefined') {
    if (this.Diff_Timeout <= 0) {
      opt_deadline = Number.MAX_VALUE;
    } else {
      opt_deadline = (new Date).getTime() + this.Diff_Timeout * 1000;
    }
  }
  var deadline = opt_deadline;

  // Check for null inputs.
  if (text1 == null || text2 == null) {
    throw new Error('Null input. (diff_main)');
  }

  // Check for equality (speedup).
  if (text1 == text2) {
    if (text1) {
      return [[DIFF_EQUAL, text1]];
    }
    return [];
  }

  if (typeof opt_checklines == 'undefined') {
    opt_checklines = true;
  }
  var checklines = opt_checklines;

  // Trim off common prefix (speedup).
  var commonlength = this.diff_commonPrefix(text1, text2);
  var commonprefix = text1.substring(0, commonlength);
  text1 = text1.substring(commonlength);
  text2 = text2.substring(commonlength);

  // Trim off common suffix (speedup).
  commonlength = this.diff_commonSuffix(text1, text2);
  var commonsuffix = text1.substring(text1.length - commonlength);
  text1 = text1.substring(0, text1.length - commonlength);
  text2 = text2.substring(0, text2.length - commonlength);

  // Compute the diff on the middle block.
  var diffs = this.diff_compute_(text1, text2, checklines, deadline);

  // Restore the prefix and suffix.
  if (commonprefix) {
    diffs.unshift([DIFF_EQUAL, commonprefix]);
  }
  if (commonsuffix) {
    diffs.push([DIFF_EQUAL, commonsuffix]);
  }
  this.diff_cleanupMerge(diffs);
  return diffs;
};


/**
 * Find the differences between two texts.  Assumes that the texts do not
 * have any common prefix or suffix.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {boolean} checklines Speedup flag.  If false, then don't run a
 *     line-level diff first to identify the changed areas.
 *     If true, then run a faster, slightly less optimal diff.
 * @param {number} deadline Time when the diff should be complete by.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_compute_ = function(text1, text2, checklines,
    deadline) {
  var diffs;

  if (!text1) {
    // Just add some text (speedup).
    return [[DIFF_INSERT, text2]];
  }

  if (!text2) {
    // Just delete some text (speedup).
    return [[DIFF_DELETE, text1]];
  }

  var longtext = text1.length > text2.length ? text1 : text2;
  var shorttext = text1.length > text2.length ? text2 : text1;
  var i = longtext.indexOf(shorttext);
  if (i != -1) {
    // Shorter text is inside the longer text (speedup).
    diffs = [[DIFF_INSERT, longtext.substring(0, i)],
             [DIFF_EQUAL, shorttext],
             [DIFF_INSERT, longtext.substring(i + shorttext.length)]];
    // Swap insertions for deletions if diff is reversed.
    if (text1.length > text2.length) {
      diffs[0][0] = diffs[2][0] = DIFF_DELETE;
    }
    return diffs;
  }

  if (shorttext.length == 1) {
    // Single character string.
    // After the previous speedup, the character can't be an equality.
    return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
  }

  // Check to see if the problem can be split in two.
  var hm = this.diff_halfMatch_(text1, text2);
  if (hm) {
    // A half-match was found, sort out the return data.
    var text1_a = hm[0];
    var text1_b = hm[1];
    var text2_a = hm[2];
    var text2_b = hm[3];
    var mid_common = hm[4];
    // Send both pairs off for separate processing.
    var diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);
    var diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);
    // Merge the results.
    return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);
  }

  if (checklines && text1.length > 100 && text2.length > 100) {
    return this.diff_lineMode_(text1, text2, deadline);
  }

  return this.diff_bisect_(text1, text2, deadline);
};


/**
 * Do a quick line-level diff on both strings, then rediff the parts for
 * greater accuracy.
 * This speedup can produce non-minimal diffs.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {number} deadline Time when the diff should be complete by.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_lineMode_ = function(text1, text2, deadline) {
  // Scan the text on a line-by-line basis first.
  var a = this.diff_linesToChars_(text1, text2);
  text1 = a.chars1;
  text2 = a.chars2;
  var linearray = a.lineArray;

  var diffs = this.diff_main(text1, text2, false, deadline);

  // Convert the diff back to original text.
  this.diff_charsToLines_(diffs, linearray);
  // Eliminate freak matches (e.g. blank lines)
  this.diff_cleanupSemantic(diffs);

  // Rediff any replacement blocks, this time character-by-character.
  // Add a dummy entry at the end.
  diffs.push([DIFF_EQUAL, '']);
  var pointer = 0;
  var count_delete = 0;
  var count_insert = 0;
  var text_delete = '';
  var text_insert = '';
  while (pointer < diffs.length) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        count_insert++;
        text_insert += diffs[pointer][1];
        break;
      case DIFF_DELETE:
        count_delete++;
        text_delete += diffs[pointer][1];
        break;
      case DIFF_EQUAL:
        // Upon reaching an equality, check for prior redundancies.
        if (count_delete >= 1 && count_insert >= 1) {
          // Delete the offending records and add the merged ones.
          diffs.splice(pointer - count_delete - count_insert,
                       count_delete + count_insert);
          pointer = pointer - count_delete - count_insert;
          var a = this.diff_main(text_delete, text_insert, false, deadline);
          for (var j = a.length - 1; j >= 0; j--) {
            diffs.splice(pointer, 0, a[j]);
          }
          pointer = pointer + a.length;
        }
        count_insert = 0;
        count_delete = 0;
        text_delete = '';
        text_insert = '';
        break;
    }
    pointer++;
  }
  diffs.pop();  // Remove the dummy entry at the end.

  return diffs;
};


/**
 * Find the 'middle snake' of a diff, split the problem in two
 * and return the recursively constructed diff.
 * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {number} deadline Time at which to bail if not yet complete.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_bisect_ = function(text1, text2, deadline) {
  // Cache the text lengths to prevent multiple calls.
  var text1_length = text1.length;
  var text2_length = text2.length;
  var max_d = Math.ceil((text1_length + text2_length) / 2);
  var v_offset = max_d;
  var v_length = 2 * max_d;
  var v1 = new Array(v_length);
  var v2 = new Array(v_length);
  // Setting all elements to -1 is faster in Chrome & Firefox than mixing
  // integers and undefined.
  for (var x = 0; x < v_length; x++) {
    v1[x] = -1;
    v2[x] = -1;
  }
  v1[v_offset + 1] = 0;
  v2[v_offset + 1] = 0;
  var delta = text1_length - text2_length;
  // If the total number of characters is odd, then the front path will collide
  // with the reverse path.
  var front = (delta % 2 != 0);
  // Offsets for start and end of k loop.
  // Prevents mapping of space beyond the grid.
  var k1start = 0;
  var k1end = 0;
  var k2start = 0;
  var k2end = 0;
  for (var d = 0; d < max_d; d++) {
    // Bail out if deadline is reached.
    if ((new Date()).getTime() > deadline) {
      break;
    }

    // Walk the front path one step.
    for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
      var k1_offset = v_offset + k1;
      var x1;
      if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {
        x1 = v1[k1_offset + 1];
      } else {
        x1 = v1[k1_offset - 1] + 1;
      }
      var y1 = x1 - k1;
      while (x1 < text1_length && y1 < text2_length &&
             text1.charAt(x1) == text2.charAt(y1)) {
        x1++;
        y1++;
      }
      v1[k1_offset] = x1;
      if (x1 > text1_length) {
        // Ran off the right of the graph.
        k1end += 2;
      } else if (y1 > text2_length) {
        // Ran off the bottom of the graph.
        k1start += 2;
      } else if (front) {
        var k2_offset = v_offset + delta - k1;
        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
          // Mirror x2 onto top-left coordinate system.
          var x2 = text1_length - v2[k2_offset];
          if (x1 >= x2) {
            // Overlap detected.
            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
          }
        }
      }
    }

    // Walk the reverse path one step.
    for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
      var k2_offset = v_offset + k2;
      var x2;
      if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {
        x2 = v2[k2_offset + 1];
      } else {
        x2 = v2[k2_offset - 1] + 1;
      }
      var y2 = x2 - k2;
      while (x2 < text1_length && y2 < text2_length &&
             text1.charAt(text1_length - x2 - 1) ==
             text2.charAt(text2_length - y2 - 1)) {
        x2++;
        y2++;
      }
      v2[k2_offset] = x2;
      if (x2 > text1_length) {
        // Ran off the left of the graph.
        k2end += 2;
      } else if (y2 > text2_length) {
        // Ran off the top of the graph.
        k2start += 2;
      } else if (!front) {
        var k1_offset = v_offset + delta - k2;
        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
          var x1 = v1[k1_offset];
          var y1 = v_offset + x1 - k1_offset;
          // Mirror x2 onto top-left coordinate system.
          x2 = text1_length - x2;
          if (x1 >= x2) {
            // Overlap detected.
            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
          }
        }
      }
    }
  }
  // Diff took too long and hit the deadline or
  // number of diffs equals number of characters, no commonality at all.
  return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
};


/**
 * Given the location of the 'middle snake', split the diff in two parts
 * and recurse.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {number} x Index of split point in text1.
 * @param {number} y Index of split point in text2.
 * @param {number} deadline Time at which to bail if not yet complete.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_bisectSplit_ = function(text1, text2, x, y,
    deadline) {
  var text1a = text1.substring(0, x);
  var text2a = text2.substring(0, y);
  var text1b = text1.substring(x);
  var text2b = text2.substring(y);

  // Compute both diffs serially.
  var diffs = this.diff_main(text1a, text2a, false, deadline);
  var diffsb = this.diff_main(text1b, text2b, false, deadline);

  return diffs.concat(diffsb);
};


/**
 * Split two texts into an array of strings.  Reduce the texts to a string of
 * hashes where each Unicode character represents one line.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}
 *     An object containing the encoded text1, the encoded text2 and
 *     the array of unique strings.
 *     The zeroth element of the array of unique strings is intentionally blank.
 * @private
 */
diff_match_patch.prototype.diff_linesToChars_ = function(text1, text2) {
  var lineArray = [];  // e.g. lineArray[4] == 'Hello\n'
  var lineHash = {};   // e.g. lineHash['Hello\n'] == 4

  // '\x00' is a valid character, but various debuggers don't like it.
  // So we'll insert a junk entry to avoid generating a null character.
  lineArray[0] = '';

  /**
   * Split a text into an array of strings.  Reduce the texts to a string of
   * hashes where each Unicode character represents one line.
   * Modifies linearray and linehash through being a closure.
   * @param {string} text String to encode.
   * @return {string} Encoded string.
   * @private
   */
  function diff_linesToCharsMunge_(text) {
    var chars = '';
    // Walk the text, pulling out a substring for each line.
    // text.split('\n') would would temporarily double our memory footprint.
    // Modifying text would create many large strings to garbage collect.
    var lineStart = 0;
    var lineEnd = -1;
    // Keeping our own length variable is faster than looking it up.
    var lineArrayLength = lineArray.length;
    while (lineEnd < text.length - 1) {
      lineEnd = text.indexOf('\n', lineStart);
      if (lineEnd == -1) {
        lineEnd = text.length - 1;
      }
      var line = text.substring(lineStart, lineEnd + 1);
      lineStart = lineEnd + 1;

      if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) :
          (lineHash[line] !== undefined)) {
        chars += String.fromCharCode(lineHash[line]);
      } else {
        chars += String.fromCharCode(lineArrayLength);
        lineHash[line] = lineArrayLength;
        lineArray[lineArrayLength++] = line;
      }
    }
    return chars;
  }

  var chars1 = diff_linesToCharsMunge_(text1);
  var chars2 = diff_linesToCharsMunge_(text2);
  return {chars1: chars1, chars2: chars2, lineArray: lineArray};
};


/**
 * Rehydrate the text in a diff from a string of line hashes to real lines of
 * text.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @param {!Array.<string>} lineArray Array of unique strings.
 * @private
 */
diff_match_patch.prototype.diff_charsToLines_ = function(diffs, lineArray) {
  for (var x = 0; x < diffs.length; x++) {
    var chars = diffs[x][1];
    var text = [];
    for (var y = 0; y < chars.length; y++) {
      text[y] = lineArray[chars.charCodeAt(y)];
    }
    diffs[x][1] = text.join('');
  }
};


/**
 * Determine the common prefix of two strings.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the start of each
 *     string.
 */
diff_match_patch.prototype.diff_commonPrefix = function(text1, text2) {
  // Quick check for common null cases.
  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
    return 0;
  }
  // Binary search.
  // Performance analysis: http://neil.fraser.name/news/2007/10/09/
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerstart = 0;
  while (pointermin < pointermid) {
    if (text1.substring(pointerstart, pointermid) ==
        text2.substring(pointerstart, pointermid)) {
      pointermin = pointermid;
      pointerstart = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
};


/**
 * Determine the common suffix of two strings.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the end of each string.
 */
diff_match_patch.prototype.diff_commonSuffix = function(text1, text2) {
  // Quick check for common null cases.
  if (!text1 || !text2 ||
      text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
    return 0;
  }
  // Binary search.
  // Performance analysis: http://neil.fraser.name/news/2007/10/09/
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerend = 0;
  while (pointermin < pointermid) {
    if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==
        text2.substring(text2.length - pointermid, text2.length - pointerend)) {
      pointermin = pointermid;
      pointerend = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
};


/**
 * Determine if the suffix of one string is the prefix of another.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the end of the first
 *     string and the start of the second string.
 * @private
 */
diff_match_patch.prototype.diff_commonOverlap_ = function(text1, text2) {
  // Cache the text lengths to prevent multiple calls.
  var text1_length = text1.length;
  var text2_length = text2.length;
  // Eliminate the null case.
  if (text1_length == 0 || text2_length == 0) {
    return 0;
  }
  // Truncate the longer string.
  if (text1_length > text2_length) {
    text1 = text1.substring(text1_length - text2_length);
  } else if (text1_length < text2_length) {
    text2 = text2.substring(0, text1_length);
  }
  var text_length = Math.min(text1_length, text2_length);
  // Quick check for the worst case.
  if (text1 == text2) {
    return text_length;
  }

  // Start by looking for a single character match
  // and increase length until no match is found.
  // Performance analysis: http://neil.fraser.name/news/2010/11/04/
  var best = 0;
  var length = 1;
  while (true) {
    var pattern = text1.substring(text_length - length);
    var found = text2.indexOf(pattern);
    if (found == -1) {
      return best;
    }
    length += found;
    if (found == 0 || text1.substring(text_length - length) ==
        text2.substring(0, length)) {
      best = length;
      length++;
    }
  }
};


/**
 * Do the two texts share a substring which is at least half the length of the
 * longer text?
 * This speedup can produce non-minimal diffs.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {Array.<string>} Five element Array, containing the prefix of
 *     text1, the suffix of text1, the prefix of text2, the suffix of
 *     text2 and the common middle.  Or null if there was no match.
 * @private
 */
diff_match_patch.prototype.diff_halfMatch_ = function(text1, text2) {
  if (this.Diff_Timeout <= 0) {
    // Don't risk returning a non-optimal diff if we have unlimited time.
    return null;
  }
  var longtext = text1.length > text2.length ? text1 : text2;
  var shorttext = text1.length > text2.length ? text2 : text1;
  if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
    return null;  // Pointless.
  }
  var dmp = this;  // 'this' becomes 'window' in a closure.

  /**
   * Does a substring of shorttext exist within longtext such that the substring
   * is at least half the length of longtext?
   * Closure, but does not reference any external variables.
   * @param {string} longtext Longer string.
   * @param {string} shorttext Shorter string.
   * @param {number} i Start index of quarter length substring within longtext.
   * @return {Array.<string>} Five element Array, containing the prefix of
   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix
   *     of shorttext and the common middle.  Or null if there was no match.
   * @private
   */
  function diff_halfMatchI_(longtext, shorttext, i) {
    // Start with a 1/4 length substring at position i as a seed.
    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
    var j = -1;
    var best_common = '';
    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {
      var prefixLength = dmp.diff_commonPrefix(longtext.substring(i),
                                               shorttext.substring(j));
      var suffixLength = dmp.diff_commonSuffix(longtext.substring(0, i),
                                               shorttext.substring(0, j));
      if (best_common.length < suffixLength + prefixLength) {
        best_common = shorttext.substring(j - suffixLength, j) +
            shorttext.substring(j, j + prefixLength);
        best_longtext_a = longtext.substring(0, i - suffixLength);
        best_longtext_b = longtext.substring(i + prefixLength);
        best_shorttext_a = shorttext.substring(0, j - suffixLength);
        best_shorttext_b = shorttext.substring(j + prefixLength);
      }
    }
    if (best_common.length * 2 >= longtext.length) {
      return [best_longtext_a, best_longtext_b,
              best_shorttext_a, best_shorttext_b, best_common];
    } else {
      return null;
    }
  }

  // First check if the second quarter is the seed for a half-match.
  var hm1 = diff_halfMatchI_(longtext, shorttext,
                             Math.ceil(longtext.length / 4));
  // Check again based on the third quarter.
  var hm2 = diff_halfMatchI_(longtext, shorttext,
                             Math.ceil(longtext.length / 2));
  var hm;
  if (!hm1 && !hm2) {
    return null;
  } else if (!hm2) {
    hm = hm1;
  } else if (!hm1) {
    hm = hm2;
  } else {
    // Both matched.  Select the longest.
    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
  }

  // A half-match was found, sort out the return data.
  var text1_a, text1_b, text2_a, text2_b;
  if (text1.length > text2.length) {
    text1_a = hm[0];
    text1_b = hm[1];
    text2_a = hm[2];
    text2_b = hm[3];
  } else {
    text2_a = hm[0];
    text2_b = hm[1];
    text1_a = hm[2];
    text1_b = hm[3];
  }
  var mid_common = hm[4];
  return [text1_a, text1_b, text2_a, text2_b, mid_common];
};


/**
 * Reduce the number of edits by eliminating semantically trivial equalities.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupSemantic = function(diffs) {
  var changes = false;
  var equalities = [];  // Stack of indices where equalities are found.
  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.
  /** @type {?string} */
  var lastequality = null;
  // Always equal to diffs[equalities[equalitiesLength - 1]][1]
  var pointer = 0;  // Index of current position.
  // Number of characters that changed prior to the equality.
  var length_insertions1 = 0;
  var length_deletions1 = 0;
  // Number of characters that changed after the equality.
  var length_insertions2 = 0;
  var length_deletions2 = 0;
  while (pointer < diffs.length) {
    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.
      equalities[equalitiesLength++] = pointer;
      length_insertions1 = length_insertions2;
      length_deletions1 = length_deletions2;
      length_insertions2 = 0;
      length_deletions2 = 0;
      lastequality = diffs[pointer][1];
    } else {  // An insertion or deletion.
      if (diffs[pointer][0] == DIFF_INSERT) {
        length_insertions2 += diffs[pointer][1].length;
      } else {
        length_deletions2 += diffs[pointer][1].length;
      }
      // Eliminate an equality that is smaller or equal to the edits on both
      // sides of it.
      if (lastequality && (lastequality.length <=
          Math.max(length_insertions1, length_deletions1)) &&
          (lastequality.length <= Math.max(length_insertions2,
                                           length_deletions2))) {
        // Duplicate record.
        diffs.splice(equalities[equalitiesLength - 1], 0,
                     [DIFF_DELETE, lastequality]);
        // Change second copy to insert.
        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
        // Throw away the equality we just deleted.
        equalitiesLength--;
        // Throw away the previous equality (it needs to be reevaluated).
        equalitiesLength--;
        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
        length_insertions1 = 0;  // Reset the counters.
        length_deletions1 = 0;
        length_insertions2 = 0;
        length_deletions2 = 0;
        lastequality = null;
        changes = true;
      }
    }
    pointer++;
  }

  // Normalize the diff.
  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
  this.diff_cleanupSemanticLossless(diffs);

  // Find any overlaps between deletions and insertions.
  // e.g: <del>abcxxx</del><ins>xxxdef</ins>
  //   -> <del>abc</del>xxx<ins>def</ins>
  // e.g: <del>xxxabc</del><ins>defxxx</ins>
  //   -> <ins>def</ins>xxx<del>abc</del>
  // Only extract an overlap if it is as big as the edit ahead or behind it.
  pointer = 1;
  while (pointer < diffs.length) {
    if (diffs[pointer - 1][0] == DIFF_DELETE &&
        diffs[pointer][0] == DIFF_INSERT) {
      var deletion = diffs[pointer - 1][1];
      var insertion = diffs[pointer][1];
      var overlap_length1 = this.diff_commonOverlap_(deletion, insertion);
      var overlap_length2 = this.diff_commonOverlap_(insertion, deletion);
      if (overlap_length1 >= overlap_length2) {
        if (overlap_length1 >= deletion.length / 2 ||
            overlap_length1 >= insertion.length / 2) {
          // Overlap found.  Insert an equality and trim the surrounding edits.
          diffs.splice(pointer, 0,
              [DIFF_EQUAL, insertion.substring(0, overlap_length1)]);
          diffs[pointer - 1][1] =
              deletion.substring(0, deletion.length - overlap_length1);
          diffs[pointer + 1][1] = insertion.substring(overlap_length1);
          pointer++;
        }
      } else {
        if (overlap_length2 >= deletion.length / 2 ||
            overlap_length2 >= insertion.length / 2) {
          // Reverse overlap found.
          // Insert an equality and swap and trim the surrounding edits.
          diffs.splice(pointer, 0,
              [DIFF_EQUAL, deletion.substring(0, overlap_length2)]);
          diffs[pointer - 1][0] = DIFF_INSERT;
          diffs[pointer - 1][1] =
              insertion.substring(0, insertion.length - overlap_length2);
          diffs[pointer + 1][0] = DIFF_DELETE;
          diffs[pointer + 1][1] =
              deletion.substring(overlap_length2);
          pointer++;
        }
      }
      pointer++;
    }
    pointer++;
  }
};


/**
 * Look for single edits surrounded on both sides by equalities
 * which can be shifted sideways to align the edit to a word boundary.
 * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupSemanticLossless = function(diffs) {
  /**
   * Given two strings, compute a score representing whether the internal
   * boundary falls on logical boundaries.
   * Scores range from 6 (best) to 0 (worst).
   * Closure, but does not reference any external variables.
   * @param {string} one First string.
   * @param {string} two Second string.
   * @return {number} The score.
   * @private
   */
  function diff_cleanupSemanticScore_(one, two) {
    if (!one || !two) {
      // Edges are the best.
      return 6;
    }

    // Each port of this function behaves slightly differently due to
    // subtle differences in each language's definition of things like
    // 'whitespace'.  Since this function's purpose is largely cosmetic,
    // the choice has been made to use each language's native features
    // rather than force total conformity.
    var char1 = one.charAt(one.length - 1);
    var char2 = two.charAt(0);
    var nonAlphaNumeric1 = char1.match(diff_match_patch.nonAlphaNumericRegex_);
    var nonAlphaNumeric2 = char2.match(diff_match_patch.nonAlphaNumericRegex_);
    var whitespace1 = nonAlphaNumeric1 &&
        char1.match(diff_match_patch.whitespaceRegex_);
    var whitespace2 = nonAlphaNumeric2 &&
        char2.match(diff_match_patch.whitespaceRegex_);
    var lineBreak1 = whitespace1 &&
        char1.match(diff_match_patch.linebreakRegex_);
    var lineBreak2 = whitespace2 &&
        char2.match(diff_match_patch.linebreakRegex_);
    var blankLine1 = lineBreak1 &&
        one.match(diff_match_patch.blanklineEndRegex_);
    var blankLine2 = lineBreak2 &&
        two.match(diff_match_patch.blanklineStartRegex_);

    if (blankLine1 || blankLine2) {
      // Five points for blank lines.
      return 5;
    } else if (lineBreak1 || lineBreak2) {
      // Four points for line breaks.
      return 4;
    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {
      // Three points for end of sentences.
      return 3;
    } else if (whitespace1 || whitespace2) {
      // Two points for whitespace.
      return 2;
    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
      // One point for non-alphanumeric.
      return 1;
    }
    return 0;
  }

  var pointer = 1;
  // Intentionally ignore the first and last element (don't need checking).
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] == DIFF_EQUAL &&
        diffs[pointer + 1][0] == DIFF_EQUAL) {
      // This is a single edit surrounded by equalities.
      var equality1 = diffs[pointer - 1][1];
      var edit = diffs[pointer][1];
      var equality2 = diffs[pointer + 1][1];

      // First, shift the edit as far left as possible.
      var commonOffset = this.diff_commonSuffix(equality1, edit);
      if (commonOffset) {
        var commonString = edit.substring(edit.length - commonOffset);
        equality1 = equality1.substring(0, equality1.length - commonOffset);
        edit = commonString + edit.substring(0, edit.length - commonOffset);
        equality2 = commonString + equality2;
      }

      // Second, step character by character right, looking for the best fit.
      var bestEquality1 = equality1;
      var bestEdit = edit;
      var bestEquality2 = equality2;
      var bestScore = diff_cleanupSemanticScore_(equality1, edit) +
          diff_cleanupSemanticScore_(edit, equality2);
      while (edit.charAt(0) === equality2.charAt(0)) {
        equality1 += edit.charAt(0);
        edit = edit.substring(1) + equality2.charAt(0);
        equality2 = equality2.substring(1);
        var score = diff_cleanupSemanticScore_(equality1, edit) +
            diff_cleanupSemanticScore_(edit, equality2);
        // The >= encourages trailing rather than leading whitespace on edits.
        if (score >= bestScore) {
          bestScore = score;
          bestEquality1 = equality1;
          bestEdit = edit;
          bestEquality2 = equality2;
        }
      }

      if (diffs[pointer - 1][1] != bestEquality1) {
        // We have an improvement, save it back to the diff.
        if (bestEquality1) {
          diffs[pointer - 1][1] = bestEquality1;
        } else {
          diffs.splice(pointer - 1, 1);
          pointer--;
        }
        diffs[pointer][1] = bestEdit;
        if (bestEquality2) {
          diffs[pointer + 1][1] = bestEquality2;
        } else {
          diffs.splice(pointer + 1, 1);
          pointer--;
        }
      }
    }
    pointer++;
  }
};

// Define some regex patterns for matching boundaries.
diff_match_patch.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;
diff_match_patch.whitespaceRegex_ = /\s/;
diff_match_patch.linebreakRegex_ = /[\r\n]/;
diff_match_patch.blanklineEndRegex_ = /\n\r?\n$/;
diff_match_patch.blanklineStartRegex_ = /^\r?\n\r?\n/;

/**
 * Reduce the number of edits by eliminating operationally trivial equalities.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupEfficiency = function(diffs) {
  var changes = false;
  var equalities = [];  // Stack of indices where equalities are found.
  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.
  /** @type {?string} */
  var lastequality = null;
  // Always equal to diffs[equalities[equalitiesLength - 1]][1]
  var pointer = 0;  // Index of current position.
  // Is there an insertion operation before the last equality.
  var pre_ins = false;
  // Is there a deletion operation before the last equality.
  var pre_del = false;
  // Is there an insertion operation after the last equality.
  var post_ins = false;
  // Is there a deletion operation after the last equality.
  var post_del = false;
  while (pointer < diffs.length) {
    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.
      if (diffs[pointer][1].length < this.Diff_EditCost &&
          (post_ins || post_del)) {
        // Candidate found.
        equalities[equalitiesLength++] = pointer;
        pre_ins = post_ins;
        pre_del = post_del;
        lastequality = diffs[pointer][1];
      } else {
        // Not a candidate, and can never become one.
        equalitiesLength = 0;
        lastequality = null;
      }
      post_ins = post_del = false;
    } else {  // An insertion or deletion.
      if (diffs[pointer][0] == DIFF_DELETE) {
        post_del = true;
      } else {
        post_ins = true;
      }
      /*
       * Five types to be split:
       * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>
       * <ins>A</ins>X<ins>C</ins><del>D</del>
       * <ins>A</ins><del>B</del>X<ins>C</ins>
       * <ins>A</del>X<ins>C</ins><del>D</del>
       * <ins>A</ins><del>B</del>X<del>C</del>
       */
      if (lastequality && ((pre_ins && pre_del && post_ins && post_del) ||
                           ((lastequality.length < this.Diff_EditCost / 2) &&
                            (pre_ins + pre_del + post_ins + post_del) == 3))) {
        // Duplicate record.
        diffs.splice(equalities[equalitiesLength - 1], 0,
                     [DIFF_DELETE, lastequality]);
        // Change second copy to insert.
        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
        equalitiesLength--;  // Throw away the equality we just deleted;
        lastequality = null;
        if (pre_ins && pre_del) {
          // No changes made which could affect previous entry, keep going.
          post_ins = post_del = true;
          equalitiesLength = 0;
        } else {
          equalitiesLength--;  // Throw away the previous equality.
          pointer = equalitiesLength > 0 ?
              equalities[equalitiesLength - 1] : -1;
          post_ins = post_del = false;
        }
        changes = true;
      }
    }
    pointer++;
  }

  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
};


/**
 * Reorder and merge like edit sections.  Merge equalities.
 * Any edit section can move as long as it doesn't cross an equality.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupMerge = function(diffs) {
  diffs.push([DIFF_EQUAL, '']);  // Add a dummy entry at the end.
  var pointer = 0;
  var count_delete = 0;
  var count_insert = 0;
  var text_delete = '';
  var text_insert = '';
  var commonlength;
  while (pointer < diffs.length) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        count_insert++;
        text_insert += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_DELETE:
        count_delete++;
        text_delete += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_EQUAL:
        // Upon reaching an equality, check for prior redundancies.
        if (count_delete + count_insert > 1) {
          if (count_delete !== 0 && count_insert !== 0) {
            // Factor out any common prefixies.
            commonlength = this.diff_commonPrefix(text_insert, text_delete);
            if (commonlength !== 0) {
              if ((pointer - count_delete - count_insert) > 0 &&
                  diffs[pointer - count_delete - count_insert - 1][0] ==
                  DIFF_EQUAL) {
                diffs[pointer - count_delete - count_insert - 1][1] +=
                    text_insert.substring(0, commonlength);
              } else {
                diffs.splice(0, 0, [DIFF_EQUAL,
                                    text_insert.substring(0, commonlength)]);
                pointer++;
              }
              text_insert = text_insert.substring(commonlength);
              text_delete = text_delete.substring(commonlength);
            }
            // Factor out any common suffixies.
            commonlength = this.diff_commonSuffix(text_insert, text_delete);
            if (commonlength !== 0) {
              diffs[pointer][1] = text_insert.substring(text_insert.length -
                  commonlength) + diffs[pointer][1];
              text_insert = text_insert.substring(0, text_insert.length -
                  commonlength);
              text_delete = text_delete.substring(0, text_delete.length -
                  commonlength);
            }
          }
          // Delete the offending records and add the merged ones.
          if (count_delete === 0) {
            diffs.splice(pointer - count_insert,
                count_delete + count_insert, [DIFF_INSERT, text_insert]);
          } else if (count_insert === 0) {
            diffs.splice(pointer - count_delete,
                count_delete + count_insert, [DIFF_DELETE, text_delete]);
          } else {
            diffs.splice(pointer - count_delete - count_insert,
                count_delete + count_insert, [DIFF_DELETE, text_delete],
                [DIFF_INSERT, text_insert]);
          }
          pointer = pointer - count_delete - count_insert +
                    (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;
        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
          // Merge this equality with the previous one.
          diffs[pointer - 1][1] += diffs[pointer][1];
          diffs.splice(pointer, 1);
        } else {
          pointer++;
        }
        count_insert = 0;
        count_delete = 0;
        text_delete = '';
        text_insert = '';
        break;
    }
  }
  if (diffs[diffs.length - 1][1] === '') {
    diffs.pop();  // Remove the dummy entry at the end.
  }

  // Second pass: look for single edits surrounded on both sides by equalities
  // which can be shifted sideways to eliminate an equality.
  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
  var changes = false;
  pointer = 1;
  // Intentionally ignore the first and last element (don't need checking).
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] == DIFF_EQUAL &&
        diffs[pointer + 1][0] == DIFF_EQUAL) {
      // This is a single edit surrounded by equalities.
      if (diffs[pointer][1].substring(diffs[pointer][1].length -
          diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
        // Shift the edit over the previous equality.
        diffs[pointer][1] = diffs[pointer - 1][1] +
            diffs[pointer][1].substring(0, diffs[pointer][1].length -
                                        diffs[pointer - 1][1].length);
        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
        diffs.splice(pointer - 1, 1);
        changes = true;
      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==
          diffs[pointer + 1][1]) {
        // Shift the edit over the next equality.
        diffs[pointer - 1][1] += diffs[pointer + 1][1];
        diffs[pointer][1] =
            diffs[pointer][1].substring(diffs[pointer + 1][1].length) +
            diffs[pointer + 1][1];
        diffs.splice(pointer + 1, 1);
        changes = true;
      }
    }
    pointer++;
  }
  // If shifts were made, the diff needs reordering and another shift sweep.
  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
};


/**
 * loc is a location in text1, compute and return the equivalent location in
 * text2.
 * e.g. 'The cat' vs 'The big cat', 1->1, 5->8
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @param {number} loc Location within text1.
 * @return {number} Location within text2.
 */
diff_match_patch.prototype.diff_xIndex = function(diffs, loc) {
  var chars1 = 0;
  var chars2 = 0;
  var last_chars1 = 0;
  var last_chars2 = 0;
  var x;
  for (x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_INSERT) {  // Equality or deletion.
      chars1 += diffs[x][1].length;
    }
    if (diffs[x][0] !== DIFF_DELETE) {  // Equality or insertion.
      chars2 += diffs[x][1].length;
    }
    if (chars1 > loc) {  // Overshot the location.
      break;
    }
    last_chars1 = chars1;
    last_chars2 = chars2;
  }
  // Was the location was deleted?
  if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {
    return last_chars2;
  }
  // Add the remaining character length.
  return last_chars2 + (loc - last_chars1);
};


/**
 * Convert a diff array into a pretty HTML report.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} HTML representation.
 */
diff_match_patch.prototype.diff_prettyHtml = function(diffs) {
  var html = [];
  var pattern_amp = /&/g;
  var pattern_lt = /</g;
  var pattern_gt = />/g;
  var pattern_para = /\n/g;
  for (var x = 0; x < diffs.length; x++) {
    var op = diffs[x][0];    // Operation (insert, delete, equal)
    var data = diffs[x][1];  // Text of change.
    var text = data.replace(pattern_amp, '&amp;').replace(pattern_lt, '&lt;')
        .replace(pattern_gt, '&gt;').replace(pattern_para, '&para;<br>');
    switch (op) {
      case DIFF_INSERT:
        html[x] = '<ins style="background:#e6ffe6;">' + text + '</ins>';
        break;
      case DIFF_DELETE:
        html[x] = '<del style="background:#ffe6e6;">' + text + '</del>';
        break;
      case DIFF_EQUAL:
        html[x] = '<span>' + text + '</span>';
        break;
    }
  }
  return html.join('');
};


/**
 * Compute and return the source text (all equalities and deletions).
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} Source text.
 */
diff_match_patch.prototype.diff_text1 = function(diffs) {
  var text = [];
  for (var x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_INSERT) {
      text[x] = diffs[x][1];
    }
  }
  return text.join('');
};


/**
 * Compute and return the destination text (all equalities and insertions).
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} Destination text.
 */
diff_match_patch.prototype.diff_text2 = function(diffs) {
  var text = [];
  for (var x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_DELETE) {
      text[x] = diffs[x][1];
    }
  }
  return text.join('');
};


/**
 * Compute the Levenshtein distance; the number of inserted, deleted or
 * substituted characters.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {number} Number of changes.
 */
diff_match_patch.prototype.diff_levenshtein = function(diffs) {
  var levenshtein = 0;
  var insertions = 0;
  var deletions = 0;
  for (var x = 0; x < diffs.length; x++) {
    var op = diffs[x][0];
    var data = diffs[x][1];
    switch (op) {
      case DIFF_INSERT:
        insertions += data.length;
        break;
      case DIFF_DELETE:
        deletions += data.length;
        break;
      case DIFF_EQUAL:
        // A deletion and an insertion is one substitution.
        levenshtein += Math.max(insertions, deletions);
        insertions = 0;
        deletions = 0;
        break;
    }
  }
  levenshtein += Math.max(insertions, deletions);
  return levenshtein;
};


/**
 * Crush the diff into an encoded string which describes the operations
 * required to transform text1 into text2.
 * E.g. =3\t-2\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.
 * Operations are tab-separated.  Inserted text is escaped using %xx notation.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} Delta text.
 */
diff_match_patch.prototype.diff_toDelta = function(diffs) {
  var text = [];
  for (var x = 0; x < diffs.length; x++) {
    switch (diffs[x][0]) {
      case DIFF_INSERT:
        text[x] = '+' + encodeURI(diffs[x][1]);
        break;
      case DIFF_DELETE:
        text[x] = '-' + diffs[x][1].length;
        break;
      case DIFF_EQUAL:
        text[x] = '=' + diffs[x][1].length;
        break;
    }
  }
  return text.join('\t').replace(/%20/g, ' ');
};


/**
 * Given the original text1, and an encoded string which describes the
 * operations required to transform text1 into text2, compute the full diff.
 * @param {string} text1 Source string for the diff.
 * @param {string} delta Delta text.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @throws {!Error} If invalid input.
 */
diff_match_patch.prototype.diff_fromDelta = function(text1, delta) {
  var diffs = [];
  var diffsLength = 0;  // Keeping our own length var is faster in JS.
  var pointer = 0;  // Cursor in text1
  var tokens = delta.split(/\t/g);
  for (var x = 0; x < tokens.length; x++) {
    // Each token begins with a one character parameter which specifies the
    // operation of this token (delete, insert, equality).
    var param = tokens[x].substring(1);
    switch (tokens[x].charAt(0)) {
      case '+':
        try {
          diffs[diffsLength++] = [DIFF_INSERT, decodeURI(param)];
        } catch (ex) {
          // Malformed URI sequence.
          throw new Error('Illegal escape in diff_fromDelta: ' + param);
        }
        break;
      case '-':
        // Fall through.
      case '=':
        var n = parseInt(param, 10);
        if (isNaN(n) || n < 0) {
          throw new Error('Invalid number in diff_fromDelta: ' + param);
        }
        var text = text1.substring(pointer, pointer += n);
        if (tokens[x].charAt(0) == '=') {
          diffs[diffsLength++] = [DIFF_EQUAL, text];
        } else {
          diffs[diffsLength++] = [DIFF_DELETE, text];
        }
        break;
      default:
        // Blank tokens are ok (from a trailing \t).
        // Anything else is an error.
        if (tokens[x]) {
          throw new Error('Invalid diff operation in diff_fromDelta: ' +
                          tokens[x]);
        }
    }
  }
  if (pointer != text1.length) {
    throw new Error('Delta length (' + pointer +
        ') does not equal source text length (' + text1.length + ').');
  }
  return diffs;
};


//  MATCH FUNCTIONS


/**
 * Locate the best instance of 'pattern' in 'text' near 'loc'.
 * @param {string} text The text to search.
 * @param {string} pattern The pattern to search for.
 * @param {number} loc The location to search around.
 * @return {number} Best match index or -1.
 */
diff_match_patch.prototype.match_main = function(text, pattern, loc) {
  // Check for null inputs.
  if (text == null || pattern == null || loc == null) {
    throw new Error('Null input. (match_main)');
  }

  loc = Math.max(0, Math.min(loc, text.length));
  if (text == pattern) {
    // Shortcut (potentially not guaranteed by the algorithm)
    return 0;
  } else if (!text.length) {
    // Nothing to match.
    return -1;
  } else if (text.substring(loc, loc + pattern.length) == pattern) {
    // Perfect match at the perfect spot!  (Includes case of null pattern)
    return loc;
  } else {
    // Do a fuzzy compare.
    return this.match_bitap_(text, pattern, loc);
  }
};


/**
 * Locate the best instance of 'pattern' in 'text' near 'loc' using the
 * Bitap algorithm.
 * @param {string} text The text to search.
 * @param {string} pattern The pattern to search for.
 * @param {number} loc The location to search around.
 * @return {number} Best match index or -1.
 * @private
 */
diff_match_patch.prototype.match_bitap_ = function(text, pattern, loc) {
  if (pattern.length > this.Match_MaxBits) {
    throw new Error('Pattern too long for this browser.');
  }

  // Initialise the alphabet.
  var s = this.match_alphabet_(pattern);

  var dmp = this;  // 'this' becomes 'window' in a closure.

  /**
   * Compute and return the score for a match with e errors and x location.
   * Accesses loc and pattern through being a closure.
   * @param {number} e Number of errors in match.
   * @param {number} x Location of match.
   * @return {number} Overall score for match (0.0 = good, 1.0 = bad).
   * @private
   */
  function match_bitapScore_(e, x) {
    var accuracy = e / pattern.length;
    var proximity = Math.abs(loc - x);
    if (!dmp.Match_Distance) {
      // Dodge divide by zero error.
      return proximity ? 1.0 : accuracy;
    }
    return accuracy + (proximity / dmp.Match_Distance);
  }

  // Highest score beyond which we give up.
  var score_threshold = this.Match_Threshold;
  // Is there a nearby exact match? (speedup)
  var best_loc = text.indexOf(pattern, loc);
  if (best_loc != -1) {
    score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);
    // What about in the other direction? (speedup)
    best_loc = text.lastIndexOf(pattern, loc + pattern.length);
    if (best_loc != -1) {
      score_threshold =
          Math.min(match_bitapScore_(0, best_loc), score_threshold);
    }
  }

  // Initialise the bit arrays.
  var matchmask = 1 << (pattern.length - 1);
  best_loc = -1;

  var bin_min, bin_mid;
  var bin_max = pattern.length + text.length;
  var last_rd;
  for (var d = 0; d < pattern.length; d++) {
    // Scan for the best match; each iteration allows for one more error.
    // Run a binary search to determine how far from 'loc' we can stray at this
    // error level.
    bin_min = 0;
    bin_mid = bin_max;
    while (bin_min < bin_mid) {
      if (match_bitapScore_(d, loc + bin_mid) <= score_threshold) {
        bin_min = bin_mid;
      } else {
        bin_max = bin_mid;
      }
      bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);
    }
    // Use the result from this iteration as the maximum for the next.
    bin_max = bin_mid;
    var start = Math.max(1, loc - bin_mid + 1);
    var finish = Math.min(loc + bin_mid, text.length) + pattern.length;

    var rd = Array(finish + 2);
    rd[finish + 1] = (1 << d) - 1;
    for (var j = finish; j >= start; j--) {
      // The alphabet (s) is a sparse hash, so the following line generates
      // warnings.
      var charMatch = s[text.charAt(j - 1)];
      if (d === 0) {  // First pass: exact match.
        rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;
      } else {  // Subsequent passes: fuzzy match.
        rd[j] = (((rd[j + 1] << 1) | 1) & charMatch) |
                (((last_rd[j + 1] | last_rd[j]) << 1) | 1) |
                last_rd[j + 1];
      }
      if (rd[j] & matchmask) {
        var score = match_bitapScore_(d, j - 1);
        // This match will almost certainly be better than any existing match.
        // But check anyway.
        if (score <= score_threshold) {
          // Told you so.
          score_threshold = score;
          best_loc = j - 1;
          if (best_loc > loc) {
            // When passing loc, don't exceed our current distance from loc.
            start = Math.max(1, 2 * loc - best_loc);
          } else {
            // Already passed loc, downhill from here on in.
            break;
          }
        }
      }
    }
    // No hope for a (better) match at greater error levels.
    if (match_bitapScore_(d + 1, loc) > score_threshold) {
      break;
    }
    last_rd = rd;
  }
  return best_loc;
};


/**
 * Initialise the alphabet for the Bitap algorithm.
 * @param {string} pattern The text to encode.
 * @return {!Object} Hash of character locations.
 * @private
 */
diff_match_patch.prototype.match_alphabet_ = function(pattern) {
  var s = {};
  for (var i = 0; i < pattern.length; i++) {
    s[pattern.charAt(i)] = 0;
  }
  for (var i = 0; i < pattern.length; i++) {
    s[pattern.charAt(i)] |= 1 << (pattern.length - i - 1);
  }
  return s;
};


//  PATCH FUNCTIONS


/**
 * Increase the context until it is unique,
 * but don't let the pattern expand beyond Match_MaxBits.
 * @param {!diff_match_patch.patch_obj} patch The patch to grow.
 * @param {string} text Source text.
 * @private
 */
diff_match_patch.prototype.patch_addContext_ = function(patch, text) {
  if (text.length == 0) {
    return;
  }
  var pattern = text.substring(patch.start2, patch.start2 + patch.length1);
  var padding = 0;

  // Look for the first and last matches of pattern in text.  If two different
  // matches are found, increase the pattern length.
  while (text.indexOf(pattern) != text.lastIndexOf(pattern) &&
         pattern.length < this.Match_MaxBits - this.Patch_Margin -
         this.Patch_Margin) {
    padding += this.Patch_Margin;
    pattern = text.substring(patch.start2 - padding,
                             patch.start2 + patch.length1 + padding);
  }
  // Add one chunk for good luck.
  padding += this.Patch_Margin;

  // Add the prefix.
  var prefix = text.substring(patch.start2 - padding, patch.start2);
  if (prefix) {
    patch.diffs.unshift([DIFF_EQUAL, prefix]);
  }
  // Add the suffix.
  var suffix = text.substring(patch.start2 + patch.length1,
                              patch.start2 + patch.length1 + padding);
  if (suffix) {
    patch.diffs.push([DIFF_EQUAL, suffix]);
  }

  // Roll back the start points.
  patch.start1 -= prefix.length;
  patch.start2 -= prefix.length;
  // Extend the lengths.
  patch.length1 += prefix.length + suffix.length;
  patch.length2 += prefix.length + suffix.length;
};


/**
 * Compute a list of patches to turn text1 into text2.
 * Use diffs if provided, otherwise compute it ourselves.
 * There are four ways to call this function, depending on what data is
 * available to the caller:
 * Method 1:
 * a = text1, b = text2
 * Method 2:
 * a = diffs
 * Method 3 (optimal):
 * a = text1, b = diffs
 * Method 4 (deprecated, use method 3):
 * a = text1, b = text2, c = diffs
 *
 * @param {string|!Array.<!diff_match_patch.Diff>} a text1 (methods 1,3,4) or
 * Array of diff tuples for text1 to text2 (method 2).
 * @param {string|!Array.<!diff_match_patch.Diff>} opt_b text2 (methods 1,4) or
 * Array of diff tuples for text1 to text2 (method 3) or undefined (method 2).
 * @param {string|!Array.<!diff_match_patch.Diff>} opt_c Array of diff tuples
 * for text1 to text2 (method 4) or undefined (methods 1,2,3).
 * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
 */
diff_match_patch.prototype.patch_make = function(a, opt_b, opt_c) {
  var text1, diffs;
  if (typeof a == 'string' && typeof opt_b == 'string' &&
      typeof opt_c == 'undefined') {
    // Method 1: text1, text2
    // Compute diffs from text1 and text2.
    text1 = /** @type {string} */(a);
    diffs = this.diff_main(text1, /** @type {string} */(opt_b), true);
    if (diffs.length > 2) {
      this.diff_cleanupSemantic(diffs);
      this.diff_cleanupEfficiency(diffs);
    }
  } else if (a && typeof a == 'object' && typeof opt_b == 'undefined' &&
      typeof opt_c == 'undefined') {
    // Method 2: diffs
    // Compute text1 from diffs.
    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(a);
    text1 = this.diff_text1(diffs);
  } else if (typeof a == 'string' && opt_b && typeof opt_b == 'object' &&
      typeof opt_c == 'undefined') {
    // Method 3: text1, diffs
    text1 = /** @type {string} */(a);
    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_b);
  } else if (typeof a == 'string' && typeof opt_b == 'string' &&
      opt_c && typeof opt_c == 'object') {
    // Method 4: text1, text2, diffs
    // text2 is not used.
    text1 = /** @type {string} */(a);
    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_c);
  } else {
    throw new Error('Unknown call format to patch_make.');
  }

  if (diffs.length === 0) {
    return [];  // Get rid of the null case.
  }
  var patches = [];
  var patch = new diff_match_patch.patch_obj();
  var patchDiffLength = 0;  // Keeping our own length var is faster in JS.
  var char_count1 = 0;  // Number of characters into the text1 string.
  var char_count2 = 0;  // Number of characters into the text2 string.
  // Start with text1 (prepatch_text) and apply the diffs until we arrive at
  // text2 (postpatch_text).  We recreate the patches one by one to determine
  // context info.
  var prepatch_text = text1;
  var postpatch_text = text1;
  for (var x = 0; x < diffs.length; x++) {
    var diff_type = diffs[x][0];
    var diff_text = diffs[x][1];

    if (!patchDiffLength && diff_type !== DIFF_EQUAL) {
      // A new patch starts here.
      patch.start1 = char_count1;
      patch.start2 = char_count2;
    }

    switch (diff_type) {
      case DIFF_INSERT:
        patch.diffs[patchDiffLength++] = diffs[x];
        patch.length2 += diff_text.length;
        postpatch_text = postpatch_text.substring(0, char_count2) + diff_text +
                         postpatch_text.substring(char_count2);
        break;
      case DIFF_DELETE:
        patch.length1 += diff_text.length;
        patch.diffs[patchDiffLength++] = diffs[x];
        postpatch_text = postpatch_text.substring(0, char_count2) +
                         postpatch_text.substring(char_count2 +
                             diff_text.length);
        break;
      case DIFF_EQUAL:
        if (diff_text.length <= 2 * this.Patch_Margin &&
            patchDiffLength && diffs.length != x + 1) {
          // Small equality inside a patch.
          patch.diffs[patchDiffLength++] = diffs[x];
          patch.length1 += diff_text.length;
          patch.length2 += diff_text.length;
        } else if (diff_text.length >= 2 * this.Patch_Margin) {
          // Time for a new patch.
          if (patchDiffLength) {
            this.patch_addContext_(patch, prepatch_text);
            patches.push(patch);
            patch = new diff_match_patch.patch_obj();
            patchDiffLength = 0;
            // Unlike Unidiff, our patch lists have a rolling context.
            // http://code.google.com/p/google-diff-match-patch/wiki/Unidiff
            // Update prepatch text & pos to reflect the application of the
            // just completed patch.
            prepatch_text = postpatch_text;
            char_count1 = char_count2;
          }
        }
        break;
    }

    // Update the current character count.
    if (diff_type !== DIFF_INSERT) {
      char_count1 += diff_text.length;
    }
    if (diff_type !== DIFF_DELETE) {
      char_count2 += diff_text.length;
    }
  }
  // Pick up the leftover patch if not empty.
  if (patchDiffLength) {
    this.patch_addContext_(patch, prepatch_text);
    patches.push(patch);
  }

  return patches;
};


/**
 * Given an array of patches, return another array that is identical.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
 */
diff_match_patch.prototype.patch_deepCopy = function(patches) {
  // Making deep copies is hard in JavaScript.
  var patchesCopy = [];
  for (var x = 0; x < patches.length; x++) {
    var patch = patches[x];
    var patchCopy = new diff_match_patch.patch_obj();
    patchCopy.diffs = [];
    for (var y = 0; y < patch.diffs.length; y++) {
      patchCopy.diffs[y] = patch.diffs[y].slice();
    }
    patchCopy.start1 = patch.start1;
    patchCopy.start2 = patch.start2;
    patchCopy.length1 = patch.length1;
    patchCopy.length2 = patch.length2;
    patchesCopy[x] = patchCopy;
  }
  return patchesCopy;
};


/**
 * Merge a set of patches onto the text.  Return a patched text, as well
 * as a list of true/false values indicating which patches were applied.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 * @param {string} text Old text.
 * @return {!Array.<string|!Array.<boolean>>} Two element Array, containing the
 *      new text and an array of boolean values.
 */
diff_match_patch.prototype.patch_apply = function(patches, text) {
  if (patches.length == 0) {
    return [text, []];
  }

  // Deep copy the patches so that no changes are made to originals.
  patches = this.patch_deepCopy(patches);

  var nullPadding = this.patch_addPadding(patches);
  text = nullPadding + text + nullPadding;

  this.patch_splitMax(patches);
  // delta keeps track of the offset between the expected and actual location
  // of the previous patch.  If there are patches expected at positions 10 and
  // 20, but the first patch was found at 12, delta is 2 and the second patch
  // has an effective expected position of 22.
  var delta = 0;
  var results = [];
  for (var x = 0; x < patches.length; x++) {
    var expected_loc = patches[x].start2 + delta;
    var text1 = this.diff_text1(patches[x].diffs);
    var start_loc;
    var end_loc = -1;
    if (text1.length > this.Match_MaxBits) {
      // patch_splitMax will only provide an oversized pattern in the case of
      // a monster delete.
      start_loc = this.match_main(text, text1.substring(0, this.Match_MaxBits),
                                  expected_loc);
      if (start_loc != -1) {
        end_loc = this.match_main(text,
            text1.substring(text1.length - this.Match_MaxBits),
            expected_loc + text1.length - this.Match_MaxBits);
        if (end_loc == -1 || start_loc >= end_loc) {
          // Can't find valid trailing context.  Drop this patch.
          start_loc = -1;
        }
      }
    } else {
      start_loc = this.match_main(text, text1, expected_loc);
    }
    if (start_loc == -1) {
      // No match found.  :(
      results[x] = false;
      // Subtract the delta for this failed patch from subsequent patches.
      delta -= patches[x].length2 - patches[x].length1;
    } else {
      // Found a match.  :)
      results[x] = true;
      delta = start_loc - expected_loc;
      var text2;
      if (end_loc == -1) {
        text2 = text.substring(start_loc, start_loc + text1.length);
      } else {
        text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);
      }
      if (text1 == text2) {
        // Perfect match, just shove the replacement text in.
        text = text.substring(0, start_loc) +
               this.diff_text2(patches[x].diffs) +
               text.substring(start_loc + text1.length);
      } else {
        // Imperfect match.  Run a diff to get a framework of equivalent
        // indices.
        var diffs = this.diff_main(text1, text2, false);
        if (text1.length > this.Match_MaxBits &&
            this.diff_levenshtein(diffs) / text1.length >
            this.Patch_DeleteThreshold) {
          // The end points match, but the content is unacceptably bad.
          results[x] = false;
        } else {
          this.diff_cleanupSemanticLossless(diffs);
          var index1 = 0;
          var index2;
          for (var y = 0; y < patches[x].diffs.length; y++) {
            var mod = patches[x].diffs[y];
            if (mod[0] !== DIFF_EQUAL) {
              index2 = this.diff_xIndex(diffs, index1);
            }
            if (mod[0] === DIFF_INSERT) {  // Insertion
              text = text.substring(0, start_loc + index2) + mod[1] +
                     text.substring(start_loc + index2);
            } else if (mod[0] === DIFF_DELETE) {  // Deletion
              text = text.substring(0, start_loc + index2) +
                     text.substring(start_loc + this.diff_xIndex(diffs,
                         index1 + mod[1].length));
            }
            if (mod[0] !== DIFF_DELETE) {
              index1 += mod[1].length;
            }
          }
        }
      }
    }
  }
  // Strip the padding off.
  text = text.substring(nullPadding.length, text.length - nullPadding.length);
  return [text, results];
};


/**
 * Add some padding on text start and end so that edges can match something.
 * Intended to be called only from within patch_apply.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 * @return {string} The padding string added to each side.
 */
diff_match_patch.prototype.patch_addPadding = function(patches) {
  var paddingLength = this.Patch_Margin;
  var nullPadding = '';
  for (var x = 1; x <= paddingLength; x++) {
    nullPadding += String.fromCharCode(x);
  }

  // Bump all the patches forward.
  for (var x = 0; x < patches.length; x++) {
    patches[x].start1 += paddingLength;
    patches[x].start2 += paddingLength;
  }

  // Add some padding on start of first diff.
  var patch = patches[0];
  var diffs = patch.diffs;
  if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {
    // Add nullPadding equality.
    diffs.unshift([DIFF_EQUAL, nullPadding]);
    patch.start1 -= paddingLength;  // Should be 0.
    patch.start2 -= paddingLength;  // Should be 0.
    patch.length1 += paddingLength;
    patch.length2 += paddingLength;
  } else if (paddingLength > diffs[0][1].length) {
    // Grow first equality.
    var extraLength = paddingLength - diffs[0][1].length;
    diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];
    patch.start1 -= extraLength;
    patch.start2 -= extraLength;
    patch.length1 += extraLength;
    patch.length2 += extraLength;
  }

  // Add some padding on end of last diff.
  patch = patches[patches.length - 1];
  diffs = patch.diffs;
  if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {
    // Add nullPadding equality.
    diffs.push([DIFF_EQUAL, nullPadding]);
    patch.length1 += paddingLength;
    patch.length2 += paddingLength;
  } else if (paddingLength > diffs[diffs.length - 1][1].length) {
    // Grow last equality.
    var extraLength = paddingLength - diffs[diffs.length - 1][1].length;
    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);
    patch.length1 += extraLength;
    patch.length2 += extraLength;
  }

  return nullPadding;
};


/**
 * Look through the patches and break up any which are longer than the maximum
 * limit of the match algorithm.
 * Intended to be called only from within patch_apply.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 */
diff_match_patch.prototype.patch_splitMax = function(patches) {
  var patch_size = this.Match_MaxBits;
  for (var x = 0; x < patches.length; x++) {
    if (patches[x].length1 <= patch_size) {
      continue;
    }
    var bigpatch = patches[x];
    // Remove the big old patch.
    patches.splice(x--, 1);
    var start1 = bigpatch.start1;
    var start2 = bigpatch.start2;
    var precontext = '';
    while (bigpatch.diffs.length !== 0) {
      // Create one of several smaller patches.
      var patch = new diff_match_patch.patch_obj();
      var empty = true;
      patch.start1 = start1 - precontext.length;
      patch.start2 = start2 - precontext.length;
      if (precontext !== '') {
        patch.length1 = patch.length2 = precontext.length;
        patch.diffs.push([DIFF_EQUAL, precontext]);
      }
      while (bigpatch.diffs.length !== 0 &&
             patch.length1 < patch_size - this.Patch_Margin) {
        var diff_type = bigpatch.diffs[0][0];
        var diff_text = bigpatch.diffs[0][1];
        if (diff_type === DIFF_INSERT) {
          // Insertions are harmless.
          patch.length2 += diff_text.length;
          start2 += diff_text.length;
          patch.diffs.push(bigpatch.diffs.shift());
          empty = false;
        } else if (diff_type === DIFF_DELETE && patch.diffs.length == 1 &&
                   patch.diffs[0][0] == DIFF_EQUAL &&
                   diff_text.length > 2 * patch_size) {
          // This is a large deletion.  Let it pass in one chunk.
          patch.length1 += diff_text.length;
          start1 += diff_text.length;
          empty = false;
          patch.diffs.push([diff_type, diff_text]);
          bigpatch.diffs.shift();
        } else {
          // Deletion or equality.  Only take as much as we can stomach.
          diff_text = diff_text.substring(0,
              patch_size - patch.length1 - this.Patch_Margin);
          patch.length1 += diff_text.length;
          start1 += diff_text.length;
          if (diff_type === DIFF_EQUAL) {
            patch.length2 += diff_text.length;
            start2 += diff_text.length;
          } else {
            empty = false;
          }
          patch.diffs.push([diff_type, diff_text]);
          if (diff_text == bigpatch.diffs[0][1]) {
            bigpatch.diffs.shift();
          } else {
            bigpatch.diffs[0][1] =
                bigpatch.diffs[0][1].substring(diff_text.length);
          }
        }
      }
      // Compute the head context for the next patch.
      precontext = this.diff_text2(patch.diffs);
      precontext =
          precontext.substring(precontext.length - this.Patch_Margin);
      // Append the end context for this patch.
      var postcontext = this.diff_text1(bigpatch.diffs)
                            .substring(0, this.Patch_Margin);
      if (postcontext !== '') {
        patch.length1 += postcontext.length;
        patch.length2 += postcontext.length;
        if (patch.diffs.length !== 0 &&
            patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {
          patch.diffs[patch.diffs.length - 1][1] += postcontext;
        } else {
          patch.diffs.push([DIFF_EQUAL, postcontext]);
        }
      }
      if (!empty) {
        patches.splice(++x, 0, patch);
      }
    }
  }
};


/**
 * Take a list of patches and return a textual representation.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 * @return {string} Text representation of patches.
 */
diff_match_patch.prototype.patch_toText = function(patches) {
  var text = [];
  for (var x = 0; x < patches.length; x++) {
    text[x] = patches[x];
  }
  return text.join('');
};


/**
 * Parse a textual representation of patches and return a list of Patch objects.
 * @param {string} textline Text representation of patches.
 * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
 * @throws {!Error} If invalid input.
 */
diff_match_patch.prototype.patch_fromText = function(textline) {
  var patches = [];
  if (!textline) {
    return patches;
  }
  var text = textline.split('\n');
  var textPointer = 0;
  var patchHeader = /^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/;
  while (textPointer < text.length) {
    var m = text[textPointer].match(patchHeader);
    if (!m) {
      throw new Error('Invalid patch string: ' + text[textPointer]);
    }
    var patch = new diff_match_patch.patch_obj();
    patches.push(patch);
    patch.start1 = parseInt(m[1], 10);
    if (m[2] === '') {
      patch.start1--;
      patch.length1 = 1;
    } else if (m[2] == '0') {
      patch.length1 = 0;
    } else {
      patch.start1--;
      patch.length1 = parseInt(m[2], 10);
    }

    patch.start2 = parseInt(m[3], 10);
    if (m[4] === '') {
      patch.start2--;
      patch.length2 = 1;
    } else if (m[4] == '0') {
      patch.length2 = 0;
    } else {
      patch.start2--;
      patch.length2 = parseInt(m[4], 10);
    }
    textPointer++;

    while (textPointer < text.length) {
      var sign = text[textPointer].charAt(0);
      try {
        var line = decodeURI(text[textPointer].substring(1));
      } catch (ex) {
        // Malformed URI sequence.
        throw new Error('Illegal escape in patch_fromText: ' + line);
      }
      if (sign == '-') {
        // Deletion.
        patch.diffs.push([DIFF_DELETE, line]);
      } else if (sign == '+') {
        // Insertion.
        patch.diffs.push([DIFF_INSERT, line]);
      } else if (sign == ' ') {
        // Minor equality.
        patch.diffs.push([DIFF_EQUAL, line]);
      } else if (sign == '@') {
        // Start of next patch.
        break;
      } else if (sign === '') {
        // Blank line?  Whatever.
      } else {
        // WTF?
        throw new Error('Invalid patch mode "' + sign + '" in: ' + line);
      }
      textPointer++;
    }
  }
  return patches;
};


/**
 * Class representing one patch operation.
 * @constructor
 */
diff_match_patch.patch_obj = function() {
  /** @type {!Array.<!diff_match_patch.Diff>} */
  this.diffs = [];
  /** @type {?number} */
  this.start1 = null;
  /** @type {?number} */
  this.start2 = null;
  /** @type {number} */
  this.length1 = 0;
  /** @type {number} */
  this.length2 = 0;
};


/**
 * Emmulate GNU diff's format.
 * Header: @@ -382,8 +481,9 @@
 * Indicies are printed as 1-based, not 0-based.
 * @return {string} The GNU diff string.
 */
diff_match_patch.patch_obj.prototype.toString = function() {
  var coords1, coords2;
  if (this.length1 === 0) {
    coords1 = this.start1 + ',0';
  } else if (this.length1 == 1) {
    coords1 = this.start1 + 1;
  } else {
    coords1 = (this.start1 + 1) + ',' + this.length1;
  }
  if (this.length2 === 0) {
    coords2 = this.start2 + ',0';
  } else if (this.length2 == 1) {
    coords2 = this.start2 + 1;
  } else {
    coords2 = (this.start2 + 1) + ',' + this.length2;
  }
  var text = ['@@ -' + coords1 + ' +' + coords2 + ' @@\n'];
  var op;
  // Escape the body of the patch with %xx notation.
  for (var x = 0; x < this.diffs.length; x++) {
    switch (this.diffs[x][0]) {
      case DIFF_INSERT:
        op = '+';
        break;
      case DIFF_DELETE:
        op = '-';
        break;
      case DIFF_EQUAL:
        op = ' ';
        break;
    }
    text[x + 1] = op + encodeURI(this.diffs[x][1]) + '\n';
  }
  return text.join('').replace(/%20/g, ' ');
};


// The following export code was added by @ForbesLindesay
module.exports = diff_match_patch;
module.exports['diff_match_patch'] = diff_match_patch;
module.exports['DIFF_DELETE'] = DIFF_DELETE;
module.exports['DIFF_INSERT'] = DIFF_INSERT;
module.exports['DIFF_EQUAL'] = DIFF_EQUAL;
});

/* global diff_match_patch */
var TEXT_DIFF = 2;
var DEFAULT_MIN_LENGTH = 60;
var cachedDiffPatch = null;

var getDiffMatchPatch = function getDiffMatchPatch(required) {
  /* jshint camelcase: false */

  if (!cachedDiffPatch) {
    var instance = void 0;
    /* eslint-disable camelcase, new-cap */
    if (typeof diff_match_patch !== 'undefined') {
      // already loaded, probably a browser
      instance = typeof diff_match_patch === 'function' ? new diff_match_patch() : new diff_match_patch.diff_match_patch();
    } else if (diffMatchPatch) {
      try {
        instance = diffMatchPatch && new diffMatchPatch();
      } catch (err) {
        instance = null;
      }
    }
    /* eslint-enable camelcase, new-cap */
    if (!instance) {
      if (!required) {
        return null;
      }
      var error = new Error('text diff_match_patch library not found');
      // eslint-disable-next-line camelcase
      error.diff_match_patch_not_found = true;
      throw error;
    }
    cachedDiffPatch = {
      diff: function diff(txt1, txt2) {
        return instance.patch_toText(instance.patch_make(txt1, txt2));
      },
      patch: function patch(txt1, _patch) {
        var results = instance.patch_apply(instance.patch_fromText(_patch), txt1);
        for (var i = 0; i < results[1].length; i++) {
          if (!results[1][i]) {
            var _error = new Error('text patch failed');
            _error.textPatchFailed = true;
          }
        }
        return results[0];
      }
    };
  }
  return cachedDiffPatch;
};

var diffFilter$3 = function textsDiffFilter(context) {
  if (context.leftType !== 'string') {
    return;
  }
  var minLength = context.options && context.options.textDiff && context.options.textDiff.minLength || DEFAULT_MIN_LENGTH;
  if (context.left.length < minLength || context.right.length < minLength) {
    context.setResult([context.left, context.right]).exit();
    return;
  }
  // large text, try to use a text-diff algorithm
  var diffMatchPatch$$1 = getDiffMatchPatch();
  if (!diffMatchPatch$$1) {
    // diff-match-patch library not available,
    // fallback to regular string replace
    context.setResult([context.left, context.right]).exit();
    return;
  }
  var diff = diffMatchPatch$$1.diff;
  context.setResult([diff(context.left, context.right), 0, TEXT_DIFF]).exit();
};
diffFilter$3.filterName = 'texts';

var patchFilter$3 = function textsPatchFilter(context) {
  if (context.nested) {
    return;
  }
  if (context.delta[2] !== TEXT_DIFF) {
    return;
  }

  // text-diff, use a text-patch algorithm
  var patch = getDiffMatchPatch(true).patch;
  context.setResult(patch(context.left, context.delta[0])).exit();
};
patchFilter$3.filterName = 'texts';

var textDeltaReverse = function textDeltaReverse(delta) {
  var i = void 0;
  var l = void 0;
  var lines = void 0;
  var line = void 0;
  var lineTmp = void 0;
  var header = null;
  var headerRegex = /^@@ +-(\d+),(\d+) +\+(\d+),(\d+) +@@$/;
  var lineHeader = void 0;
  lines = delta.split('\n');
  for (i = 0, l = lines.length; i < l; i++) {
    line = lines[i];
    var lineStart = line.slice(0, 1);
    if (lineStart === '@') {
      header = headerRegex.exec(line);
      lineHeader = i;

      // fix header
      lines[lineHeader] = '@@ -' + header[3] + ',' + header[4] + ' +' + header[1] + ',' + header[2] + ' @@';
    } else if (lineStart === '+') {
      lines[i] = '-' + lines[i].slice(1);
      if (lines[i - 1].slice(0, 1) === '+') {
        // swap lines to keep default order (-+)
        lineTmp = lines[i];
        lines[i] = lines[i - 1];
        lines[i - 1] = lineTmp;
      }
    } else if (lineStart === '-') {
      lines[i] = '+' + lines[i].slice(1);
    }
  }
  return lines.join('\n');
};

var reverseFilter$3 = function textsReverseFilter(context) {
  if (context.nested) {
    return;
  }
  if (context.delta[2] !== TEXT_DIFF) {
    return;
  }

  // text-diff, use a text-diff algorithm
  context.setResult([textDeltaReverse(context.delta[0]), 0, TEXT_DIFF]).exit();
};
reverseFilter$3.filterName = 'texts';

var DiffPatcher = function () {
  function DiffPatcher(options) {
    classCallCheck(this, DiffPatcher);

    this.processor = new Processor(options);
    this.processor.pipe(new Pipe('diff').append(collectChildrenDiffFilter, diffFilter, diffFilter$2, diffFilter$3, objectsDiffFilter, diffFilter$1).shouldHaveResult());
    this.processor.pipe(new Pipe('patch').append(collectChildrenPatchFilter, collectChildrenPatchFilter$1, patchFilter, patchFilter$3, patchFilter$1, patchFilter$2).shouldHaveResult());
    this.processor.pipe(new Pipe('reverse').append(collectChildrenReverseFilter, collectChildrenReverseFilter$1, reverseFilter, reverseFilter$3, reverseFilter$1, reverseFilter$2).shouldHaveResult());
  }

  createClass(DiffPatcher, [{
    key: 'options',
    value: function options() {
      var _processor;

      return (_processor = this.processor).options.apply(_processor, arguments);
    }
  }, {
    key: 'diff',
    value: function diff(left, right) {
      return this.processor.process(new DiffContext(left, right));
    }
  }, {
    key: 'patch',
    value: function patch(left, delta) {
      return this.processor.process(new PatchContext(left, delta));
    }
  }, {
    key: 'reverse',
    value: function reverse(delta) {
      return this.processor.process(new ReverseContext(delta));
    }
  }, {
    key: 'unpatch',
    value: function unpatch(right, delta) {
      return this.patch(right, this.reverse(delta));
    }
  }, {
    key: 'clone',
    value: function clone$$1(value) {
      return clone(value);
    }
  }]);
  return DiffPatcher;
}();

var isArray$3 = typeof Array.isArray === 'function' ? Array.isArray : function (a) {
  return a instanceof Array;
};

var getObjectKeys = typeof Object.keys === 'function' ? function (obj) {
  return Object.keys(obj);
} : function (obj) {
  var names = [];
  for (var property in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, property)) {
      names.push(property);
    }
  }
  return names;
};

var trimUnderscore = function trimUnderscore(str) {
  if (str.substr(0, 1) === '_') {
    return str.slice(1);
  }
  return str;
};

var arrayKeyToSortNumber = function arrayKeyToSortNumber(key) {
  if (key === '_t') {
    return -1;
  } else {
    if (key.substr(0, 1) === '_') {
      return parseInt(key.slice(1), 10);
    } else {
      return parseInt(key, 10) + 0.1;
    }
  }
};

var arrayKeyComparer = function arrayKeyComparer(key1, key2) {
  return arrayKeyToSortNumber(key1) - arrayKeyToSortNumber(key2);
};

var BaseFormatter = function () {
  function BaseFormatter() {
    classCallCheck(this, BaseFormatter);
  }

  createClass(BaseFormatter, [{
    key: 'format',
    value: function format(delta, left) {
      var context = {};
      this.prepareContext(context);
      this.recurse(context, delta, left);
      return this.finalize(context);
    }
  }, {
    key: 'prepareContext',
    value: function prepareContext(context) {
      context.buffer = [];
      context.out = function () {
        var _buffer;

        (_buffer = this.buffer).push.apply(_buffer, arguments);
      };
    }
  }, {
    key: 'typeFormattterNotFound',
    value: function typeFormattterNotFound(context, deltaType) {
      throw new Error('cannot format delta type: ' + deltaType);
    }
  }, {
    key: 'typeFormattterErrorFormatter',
    value: function typeFormattterErrorFormatter(context, err) {
      return err.toString();
    }
  }, {
    key: 'finalize',
    value: function finalize(_ref) {
      var buffer = _ref.buffer;

      if (isArray$3(buffer)) {
        return buffer.join('');
      }
    }
  }, {
    key: 'recurse',
    value: function recurse(context, delta, left, key, leftKey, movedFrom, isLast) {
      var useMoveOriginHere = delta && movedFrom;
      var leftValue = useMoveOriginHere ? movedFrom.value : left;

      if (typeof delta === 'undefined' && typeof key === 'undefined') {
        return undefined;
      }

      var type = this.getDeltaType(delta, movedFrom);
      var nodeType = type === 'node' ? delta._t === 'a' ? 'array' : 'object' : '';

      if (typeof key !== 'undefined') {
        this.nodeBegin(context, key, leftKey, type, nodeType, isLast);
      } else {
        this.rootBegin(context, type, nodeType);
      }

      var typeFormattter = void 0;
      try {
        typeFormattter = this['format_' + type] || this.typeFormattterNotFound(context, type);
        typeFormattter.call(this, context, delta, leftValue, key, leftKey, movedFrom);
      } catch (err) {
        this.typeFormattterErrorFormatter(context, err, delta, leftValue, key, leftKey, movedFrom);
        if (typeof console !== 'undefined' && console.error) {
          console.error(err.stack);
        }
      }

      if (typeof key !== 'undefined') {
        this.nodeEnd(context, key, leftKey, type, nodeType, isLast);
      } else {
        this.rootEnd(context, type, nodeType);
      }
    }
  }, {
    key: 'formatDeltaChildren',
    value: function formatDeltaChildren(context, delta, left) {
      var self = this;
      this.forEachDeltaKey(delta, left, function (key, leftKey, movedFrom, isLast) {
        self.recurse(context, delta[key], left ? left[leftKey] : undefined, key, leftKey, movedFrom, isLast);
      });
    }
  }, {
    key: 'forEachDeltaKey',
    value: function forEachDeltaKey(delta, left, fn) {
      var keys = getObjectKeys(delta);
      var arrayKeys = delta._t === 'a';
      var moveDestinations = {};
      var name = void 0;
      if (typeof left !== 'undefined') {
        for (name in left) {
          if (Object.prototype.hasOwnProperty.call(left, name)) {
            if (typeof delta[name] === 'undefined' && (!arrayKeys || typeof delta['_' + name] === 'undefined')) {
              keys.push(name);
            }
          }
        }
      }
      // look for move destinations
      for (name in delta) {
        if (Object.prototype.hasOwnProperty.call(delta, name)) {
          var value = delta[name];
          if (isArray$3(value) && value[2] === 3) {
            moveDestinations[value[1].toString()] = {
              key: name,
              value: left && left[parseInt(name.substr(1))]
            };
            if (this.includeMoveDestinations !== false) {
              if (typeof left === 'undefined' && typeof delta[value[1]] === 'undefined') {
                keys.push(value[1].toString());
              }
            }
          }
        }
      }
      if (arrayKeys) {
        keys.sort(arrayKeyComparer);
      } else {
        keys.sort();
      }
      for (var index = 0, length = keys.length; index < length; index++) {
        var key = keys[index];
        if (arrayKeys && key === '_t') {
          continue;
        }
        var leftKey = arrayKeys ? typeof key === 'number' ? key : parseInt(trimUnderscore(key), 10) : key;
        var isLast = index === length - 1;
        fn(key, leftKey, moveDestinations[leftKey], isLast);
      }
    }
  }, {
    key: 'getDeltaType',
    value: function getDeltaType(delta, movedFrom) {
      if (typeof delta === 'undefined') {
        if (typeof movedFrom !== 'undefined') {
          return 'movedestination';
        }
        return 'unchanged';
      }
      if (isArray$3(delta)) {
        if (delta.length === 1) {
          return 'added';
        }
        if (delta.length === 2) {
          return 'modified';
        }
        if (delta.length === 3 && delta[2] === 0) {
          return 'deleted';
        }
        if (delta.length === 3 && delta[2] === 2) {
          return 'textdiff';
        }
        if (delta.length === 3 && delta[2] === 3) {
          return 'moved';
        }
      } else if ((typeof delta === 'undefined' ? 'undefined' : _typeof(delta)) === 'object') {
        return 'node';
      }
      return 'unknown';
    }
  }, {
    key: 'parseTextDiff',
    value: function parseTextDiff(value) {
      var output = [];
      var lines = value.split('\n@@ ');
      for (var i = 0, l = lines.length; i < l; i++) {
        var line = lines[i];
        var lineOutput = {
          pieces: []
        };
        var location = /^(?:@@ )?[-+]?(\d+),(\d+)/.exec(line).slice(1);
        lineOutput.location = {
          line: location[0],
          chr: location[1]
        };
        var pieces = line.split('\n').slice(1);
        for (var pieceIndex = 0, piecesLength = pieces.length; pieceIndex < piecesLength; pieceIndex++) {
          var piece = pieces[pieceIndex];
          if (!piece.length) {
            continue;
          }
          var pieceOutput = {
            type: 'context'
          };
          if (piece.substr(0, 1) === '+') {
            pieceOutput.type = 'added';
          } else if (piece.substr(0, 1) === '-') {
            pieceOutput.type = 'deleted';
          }
          pieceOutput.text = piece.slice(1);
          lineOutput.pieces.push(pieceOutput);
        }
        output.push(lineOutput);
      }
      return output;
    }
  }]);
  return BaseFormatter;
}();



var base = Object.freeze({
	default: BaseFormatter
});

var HtmlFormatter = function (_BaseFormatter) {
  inherits(HtmlFormatter, _BaseFormatter);

  function HtmlFormatter() {
    classCallCheck(this, HtmlFormatter);
    return possibleConstructorReturn(this, (HtmlFormatter.__proto__ || Object.getPrototypeOf(HtmlFormatter)).apply(this, arguments));
  }

  createClass(HtmlFormatter, [{
    key: 'typeFormattterErrorFormatter',
    value: function typeFormattterErrorFormatter(context, err) {
      context.out('<pre class="jsondiffpatch-error">' + err + '</pre>');
    }
  }, {
    key: 'formatValue',
    value: function formatValue(context, value) {
      context.out('<pre>' + htmlEscape(JSON.stringify(value, null, 2)) + '</pre>');
    }
  }, {
    key: 'formatTextDiffString',
    value: function formatTextDiffString(context, value) {
      var lines = this.parseTextDiff(value);
      context.out('<ul class="jsondiffpatch-textdiff">');
      for (var i = 0, l = lines.length; i < l; i++) {
        var line = lines[i];
        context.out('<li><div class="jsondiffpatch-textdiff-location">' + ('<span class="jsondiffpatch-textdiff-line-number">' + line.location.line + '</span><span class="jsondiffpatch-textdiff-char">' + line.location.chr + '</span></div><div class="jsondiffpatch-textdiff-line">'));
        var pieces = line.pieces;
        for (var pieceIndex = 0, piecesLength = pieces.length; pieceIndex < piecesLength; pieceIndex++) {
          /* global decodeURI */
          var piece = pieces[pieceIndex];
          context.out('<span class="jsondiffpatch-textdiff-' + piece.type + '">' + htmlEscape(decodeURI(piece.text)) + '</span>');
        }
        context.out('</div></li>');
      }
      context.out('</ul>');
    }
  }, {
    key: 'rootBegin',
    value: function rootBegin(context, type, nodeType) {
      var nodeClass = 'jsondiffpatch-' + type + (nodeType ? ' jsondiffpatch-child-node-type-' + nodeType : '');
      context.out('<div class="jsondiffpatch-delta ' + nodeClass + '">');
    }
  }, {
    key: 'rootEnd',
    value: function rootEnd(context) {
      context.out('</div>' + (context.hasArrows ? '<script type="text/javascript">setTimeout(' + (adjustArrows.toString() + ',10);<\/script>') : ''));
    }
  }, {
    key: 'nodeBegin',
    value: function nodeBegin(context, key, leftKey, type, nodeType) {
      var nodeClass = 'jsondiffpatch-' + type + (nodeType ? ' jsondiffpatch-child-node-type-' + nodeType : '');
      context.out('<li class="' + nodeClass + '" data-key="' + leftKey + '">' + ('<div class="jsondiffpatch-property-name">' + leftKey + '</div>'));
    }
  }, {
    key: 'nodeEnd',
    value: function nodeEnd(context) {
      context.out('</li>');
    }

    /* jshint camelcase: false */
    /* eslint-disable camelcase */

  }, {
    key: 'format_unchanged',
    value: function format_unchanged(context, delta, left) {
      if (typeof left === 'undefined') {
        return;
      }
      context.out('<div class="jsondiffpatch-value">');
      this.formatValue(context, left);
      context.out('</div>');
    }
  }, {
    key: 'format_movedestination',
    value: function format_movedestination(context, delta, left) {
      if (typeof left === 'undefined') {
        return;
      }
      context.out('<div class="jsondiffpatch-value">');
      this.formatValue(context, left);
      context.out('</div>');
    }
  }, {
    key: 'format_node',
    value: function format_node(context, delta, left) {
      // recurse
      var nodeType = delta._t === 'a' ? 'array' : 'object';
      context.out('<ul class="jsondiffpatch-node jsondiffpatch-node-type-' + nodeType + '">');
      this.formatDeltaChildren(context, delta, left);
      context.out('</ul>');
    }
  }, {
    key: 'format_added',
    value: function format_added(context, delta) {
      context.out('<div class="jsondiffpatch-value">');
      this.formatValue(context, delta[0]);
      context.out('</div>');
    }
  }, {
    key: 'format_modified',
    value: function format_modified(context, delta) {
      context.out('<div class="jsondiffpatch-value jsondiffpatch-left-value">');
      this.formatValue(context, delta[0]);
      context.out('</div>' + '<div class="jsondiffpatch-value jsondiffpatch-right-value">');
      this.formatValue(context, delta[1]);
      context.out('</div>');
    }
  }, {
    key: 'format_deleted',
    value: function format_deleted(context, delta) {
      context.out('<div class="jsondiffpatch-value">');
      this.formatValue(context, delta[0]);
      context.out('</div>');
    }
  }, {
    key: 'format_moved',
    value: function format_moved(context, delta) {
      context.out('<div class="jsondiffpatch-value">');
      this.formatValue(context, delta[0]);
      context.out('</div><div class="jsondiffpatch-moved-destination">' + delta[1] + '</div>');

      // draw an SVG arrow from here to move destination
      context.out(
      /* jshint multistr: true */
      '<div class="jsondiffpatch-arrow" ' + 'style="position: relative; left: -34px;">\n          <svg width="30" height="60" ' + 'style="position: absolute; display: none;">\n          <defs>\n              <marker id="markerArrow" markerWidth="8" markerHeight="8"\n                 refx="2" refy="4"\n                     orient="auto" markerUnits="userSpaceOnUse">\n                  <path d="M1,1 L1,7 L7,4 L1,1" style="fill: #339;" />\n              </marker>\n          </defs>\n          <path d="M30,0 Q-10,25 26,50"\n            style="stroke: #88f; stroke-width: 2px; fill: none; ' + 'stroke-opacity: 0.5; marker-end: url(#markerArrow);"\n          ></path>\n          </svg>\n      </div>');
      context.hasArrows = true;
    }
  }, {
    key: 'format_textdiff',
    value: function format_textdiff(context, delta) {
      context.out('<div class="jsondiffpatch-value">');
      this.formatTextDiffString(context, delta[0]);
      context.out('</div>');
    }
  }]);
  return HtmlFormatter;
}(BaseFormatter);

function htmlEscape(text) {
  var html = text;
  var replacements = [[/&/g, '&amp;'], [/</g, '&lt;'], [/>/g, '&gt;'], [/'/g, '&apos;'], [/"/g, '&quot;']];
  for (var i = 0; i < replacements.length; i++) {
    html = html.replace(replacements[i][0], replacements[i][1]);
  }
  return html;
}

var adjustArrows = function jsondiffpatchHtmlFormatterAdjustArrows(nodeArg) {
  var node = nodeArg || document;
  var getElementText = function getElementText(_ref) {
    var textContent = _ref.textContent,
        innerText = _ref.innerText;
    return textContent || innerText;
  };
  var eachByQuery = function eachByQuery(el, query, fn) {
    var elems = el.querySelectorAll(query);
    for (var i = 0, l = elems.length; i < l; i++) {
      fn(elems[i]);
    }
  };
  var eachChildren = function eachChildren(_ref2, fn) {
    var children = _ref2.children;

    for (var i = 0, l = children.length; i < l; i++) {
      fn(children[i], i);
    }
  };
  eachByQuery(node, '.jsondiffpatch-arrow', function (_ref3) {
    var parentNode = _ref3.parentNode,
        children = _ref3.children,
        style = _ref3.style;

    var arrowParent = parentNode;
    var svg = children[0];
    var path = svg.children[1];
    svg.style.display = 'none';
    var destination = getElementText(arrowParent.querySelector('.jsondiffpatch-moved-destination'));
    var container = arrowParent.parentNode;
    var destinationElem = void 0;
    eachChildren(container, function (child) {
      if (child.getAttribute('data-key') === destination) {
        destinationElem = child;
      }
    });
    if (!destinationElem) {
      return;
    }
    try {
      var distance = destinationElem.offsetTop - arrowParent.offsetTop;
      svg.setAttribute('height', Math.abs(distance) + 6);
      style.top = -8 + (distance > 0 ? 0 : distance) + 'px';
      var curve = distance > 0 ? 'M30,0 Q-10,' + Math.round(distance / 2) + ' 26,' + (distance - 4) : 'M30,' + -distance + ' Q-10,' + Math.round(-distance / 2) + ' 26,4';
      path.setAttribute('d', curve);
      svg.style.display = '';
    } catch (err) {}
  });
};

/* jshint camelcase: true */
/* eslint-enable camelcase */

var showUnchanged = function showUnchanged(show, node, delay) {
  var el = node || document.body;
  var prefix = 'jsondiffpatch-unchanged-';
  var classes = {
    showing: prefix + 'showing',
    hiding: prefix + 'hiding',
    visible: prefix + 'visible',
    hidden: prefix + 'hidden'
  };
  var list = el.classList;
  if (!list) {
    return;
  }
  if (!delay) {
    list.remove(classes.showing);
    list.remove(classes.hiding);
    list.remove(classes.visible);
    list.remove(classes.hidden);
    if (show === false) {
      list.add(classes.hidden);
    }
    return;
  }
  if (show === false) {
    list.remove(classes.showing);
    list.add(classes.visible);
    setTimeout(function () {
      list.add(classes.hiding);
    }, 10);
  } else {
    list.remove(classes.hiding);
    list.add(classes.showing);
    list.remove(classes.hidden);
  }
  var intervalId = setInterval(function () {
    adjustArrows(el);
  }, 100);
  setTimeout(function () {
    list.remove(classes.showing);
    list.remove(classes.hiding);
    if (show === false) {
      list.add(classes.hidden);
      list.remove(classes.visible);
    } else {
      list.add(classes.visible);
      list.remove(classes.hidden);
    }
    setTimeout(function () {
      list.remove(classes.visible);
      clearInterval(intervalId);
    }, delay + 400);
  }, delay);
};

var hideUnchanged = function hideUnchanged(node, delay) {
  return showUnchanged(false, node, delay);
};

var defaultInstance = void 0;

function format(delta, left) {
  if (!defaultInstance) {
    defaultInstance = new HtmlFormatter();
  }
  return defaultInstance.format(delta, left);
}



var html = Object.freeze({
	showUnchanged: showUnchanged,
	hideUnchanged: hideUnchanged,
	default: HtmlFormatter,
	format: format
});

var AnnotatedFormatter = function (_BaseFormatter) {
  inherits(AnnotatedFormatter, _BaseFormatter);

  function AnnotatedFormatter() {
    classCallCheck(this, AnnotatedFormatter);

    var _this = possibleConstructorReturn(this, (AnnotatedFormatter.__proto__ || Object.getPrototypeOf(AnnotatedFormatter)).call(this));

    _this.includeMoveDestinations = false;
    return _this;
  }

  createClass(AnnotatedFormatter, [{
    key: 'prepareContext',
    value: function prepareContext(context) {
      get(AnnotatedFormatter.prototype.__proto__ || Object.getPrototypeOf(AnnotatedFormatter.prototype), 'prepareContext', this).call(this, context);
      context.indent = function (levels) {
        this.indentLevel = (this.indentLevel || 0) + (typeof levels === 'undefined' ? 1 : levels);
        this.indentPad = new Array(this.indentLevel + 1).join('&nbsp;&nbsp;');
      };
      context.row = function (json, htmlNote) {
        context.out('<tr><td style="white-space: nowrap;">' + '<pre class="jsondiffpatch-annotated-indent"' + ' style="display: inline-block">');
        context.out(context.indentPad);
        context.out('</pre><pre style="display: inline-block">');
        context.out(json);
        context.out('</pre></td><td class="jsondiffpatch-delta-note"><div>');
        context.out(htmlNote);
        context.out('</div></td></tr>');
      };
    }
  }, {
    key: 'typeFormattterErrorFormatter',
    value: function typeFormattterErrorFormatter(context, err) {
      context.row('', '<pre class="jsondiffpatch-error">' + err + '</pre>');
    }
  }, {
    key: 'formatTextDiffString',
    value: function formatTextDiffString(context, value) {
      var lines = this.parseTextDiff(value);
      context.out('<ul class="jsondiffpatch-textdiff">');
      for (var i = 0, l = lines.length; i < l; i++) {
        var line = lines[i];
        context.out('<li><div class="jsondiffpatch-textdiff-location">' + ('<span class="jsondiffpatch-textdiff-line-number">' + line.location.line + '</span><span class="jsondiffpatch-textdiff-char">' + line.location.chr + '</span></div><div class="jsondiffpatch-textdiff-line">'));
        var pieces = line.pieces;
        for (var pieceIndex = 0, piecesLength = pieces.length; pieceIndex < piecesLength; pieceIndex++) {
          var piece = pieces[pieceIndex];
          context.out('<span class="jsondiffpatch-textdiff-' + piece.type + '">' + piece.text + '</span>');
        }
        context.out('</div></li>');
      }
      context.out('</ul>');
    }
  }, {
    key: 'rootBegin',
    value: function rootBegin(context, type, nodeType) {
      context.out('<table class="jsondiffpatch-annotated-delta">');
      if (type === 'node') {
        context.row('{');
        context.indent();
      }
      if (nodeType === 'array') {
        context.row('"_t": "a",', 'Array delta (member names indicate array indices)');
      }
    }
  }, {
    key: 'rootEnd',
    value: function rootEnd(context, type) {
      if (type === 'node') {
        context.indent(-1);
        context.row('}');
      }
      context.out('</table>');
    }
  }, {
    key: 'nodeBegin',
    value: function nodeBegin(context, key, leftKey, type, nodeType) {
      context.row('&quot;' + key + '&quot;: {');
      if (type === 'node') {
        context.indent();
      }
      if (nodeType === 'array') {
        context.row('"_t": "a",', 'Array delta (member names indicate array indices)');
      }
    }
  }, {
    key: 'nodeEnd',
    value: function nodeEnd(context, key, leftKey, type, nodeType, isLast) {
      if (type === 'node') {
        context.indent(-1);
      }
      context.row('}' + (isLast ? '' : ','));
    }

    /* jshint camelcase: false */

    /* eslint-disable camelcase */

  }, {
    key: 'format_unchanged',
    value: function format_unchanged() {}
  }, {
    key: 'format_movedestination',
    value: function format_movedestination() {}
  }, {
    key: 'format_node',
    value: function format_node(context, delta, left) {
      // recurse
      this.formatDeltaChildren(context, delta, left);
    }
  }]);
  return AnnotatedFormatter;
}(BaseFormatter);

/* eslint-enable camelcase */

var wrapPropertyName = function wrapPropertyName(name) {
  return '<pre style="display:inline-block">&quot;' + name + '&quot;</pre>';
};

var deltaAnnotations = {
  added: function added(delta, left, key, leftKey) {
    var formatLegend = ' <pre>([newValue])</pre>';
    if (typeof leftKey === 'undefined') {
      return 'new value' + formatLegend;
    }
    if (typeof leftKey === 'number') {
      return 'insert at index ' + leftKey + formatLegend;
    }
    return 'add property ' + wrapPropertyName(leftKey) + formatLegend;
  },
  modified: function modified(delta, left, key, leftKey) {
    var formatLegend = ' <pre>([previousValue, newValue])</pre>';
    if (typeof leftKey === 'undefined') {
      return 'modify value' + formatLegend;
    }
    if (typeof leftKey === 'number') {
      return 'modify at index ' + leftKey + formatLegend;
    }
    return 'modify property ' + wrapPropertyName(leftKey) + formatLegend;
  },
  deleted: function deleted(delta, left, key, leftKey) {
    var formatLegend = ' <pre>([previousValue, 0, 0])</pre>';
    if (typeof leftKey === 'undefined') {
      return 'delete value' + formatLegend;
    }
    if (typeof leftKey === 'number') {
      return 'remove index ' + leftKey + formatLegend;
    }
    return 'delete property ' + wrapPropertyName(leftKey) + formatLegend;
  },
  moved: function moved(delta, left, key, leftKey) {
    return 'move from <span title="(position to remove at original state)">' + ('index ' + leftKey + '</span> to <span title="(position to insert at final') + (' state)">index ' + delta[1] + '</span>');
  },
  textdiff: function textdiff(delta, left, key, leftKey) {
    var location = typeof leftKey === 'undefined' ? '' : typeof leftKey === 'number' ? ' at index ' + leftKey : ' at property ' + wrapPropertyName(leftKey);
    return 'text diff' + location + ', format is <a href="https://code.google.com/' + 'p/google-diff-match-patch/wiki/Unidiff">a variation of Unidiff</a>';
  }
};

var formatAnyChange = function formatAnyChange(context, delta) {
  var deltaType = this.getDeltaType(delta);
  var annotator = deltaAnnotations[deltaType];
  var htmlNote = annotator && annotator.apply(annotator, Array.prototype.slice.call(arguments, 1));
  var json = JSON.stringify(delta, null, 2);
  if (deltaType === 'textdiff') {
    // split text diffs lines
    json = json.split('\\n').join('\\n"+\n   "');
  }
  context.indent();
  context.row(json, htmlNote);
  context.indent(-1);
};

/* eslint-disable camelcase */
AnnotatedFormatter.prototype.format_added = formatAnyChange;
AnnotatedFormatter.prototype.format_modified = formatAnyChange;
AnnotatedFormatter.prototype.format_deleted = formatAnyChange;
AnnotatedFormatter.prototype.format_moved = formatAnyChange;
AnnotatedFormatter.prototype.format_textdiff = formatAnyChange;
var defaultInstance$1 = void 0;

function format$1(delta, left) {
  if (!defaultInstance$1) {
    defaultInstance$1 = new AnnotatedFormatter();
  }
  return defaultInstance$1.format(delta, left);
}



var annotated = Object.freeze({
	default: AnnotatedFormatter,
	format: format$1
});

var OPERATIONS = {
  add: 'add',
  remove: 'remove',
  replace: 'replace',
  move: 'move'
};

var JSONFormatter = function (_BaseFormatter) {
  inherits(JSONFormatter, _BaseFormatter);

  function JSONFormatter() {
    classCallCheck(this, JSONFormatter);

    var _this = possibleConstructorReturn(this, (JSONFormatter.__proto__ || Object.getPrototypeOf(JSONFormatter)).call(this));

    _this.includeMoveDestinations = true;
    return _this;
  }

  createClass(JSONFormatter, [{
    key: 'prepareContext',
    value: function prepareContext(context) {
      get(JSONFormatter.prototype.__proto__ || Object.getPrototypeOf(JSONFormatter.prototype), 'prepareContext', this).call(this, context);
      context.result = [];
      context.path = [];
      context.pushCurrentOp = function (obj) {
        var op = obj.op,
            value = obj.value;

        var val = {
          op: op,
          path: this.currentPath()
        };
        if (typeof value !== 'undefined') {
          val.value = value;
        }
        this.result.push(val);
      };

      context.pushMoveOp = function (to) {
        var from = this.currentPath();
        this.result.push({
          op: OPERATIONS.move,
          from: from,
          path: this.toPath(to)
        });
      };

      context.currentPath = function () {
        return '/' + this.path.join('/');
      };

      context.toPath = function (toPath) {
        var to = this.path.slice();
        to[to.length - 1] = toPath;
        return '/' + to.join('/');
      };
    }
  }, {
    key: 'typeFormattterErrorFormatter',
    value: function typeFormattterErrorFormatter(context, err) {
      context.out('[ERROR] ' + err);
    }
  }, {
    key: 'rootBegin',
    value: function rootBegin() {}
  }, {
    key: 'rootEnd',
    value: function rootEnd() {}
  }, {
    key: 'nodeBegin',
    value: function nodeBegin(_ref, key, leftKey) {
      var path = _ref.path;

      path.push(leftKey);
    }
  }, {
    key: 'nodeEnd',
    value: function nodeEnd(_ref2) {
      var path = _ref2.path;

      path.pop();
    }

    /* jshint camelcase: false */
    /* eslint-disable camelcase */

  }, {
    key: 'format_unchanged',
    value: function format_unchanged() {}
  }, {
    key: 'format_movedestination',
    value: function format_movedestination() {}
  }, {
    key: 'format_node',
    value: function format_node(context, delta, left) {
      this.formatDeltaChildren(context, delta, left);
    }
  }, {
    key: 'format_added',
    value: function format_added(context, delta) {
      context.pushCurrentOp({ op: OPERATIONS.add, value: delta[0] });
    }
  }, {
    key: 'format_modified',
    value: function format_modified(context, delta) {
      context.pushCurrentOp({ op: OPERATIONS.replace, value: delta[1] });
    }
  }, {
    key: 'format_deleted',
    value: function format_deleted(context) {
      context.pushCurrentOp({ op: OPERATIONS.remove });
    }
  }, {
    key: 'format_moved',
    value: function format_moved(context, delta) {
      var to = delta[1];
      context.pushMoveOp(to);
    }
  }, {
    key: 'format_textdiff',
    value: function format_textdiff() {
      throw new Error('Not implemented');
    }
  }, {
    key: 'format',
    value: function format(delta, left) {
      var context = {};
      this.prepareContext(context);
      this.recurse(context, delta, left);
      return context.result;
    }
  }]);
  return JSONFormatter;
}(BaseFormatter);

var last = function last(arr) {
  return arr[arr.length - 1];
};

var sortBy = function sortBy(arr, pred) {
  arr.sort(pred);
  return arr;
};

var compareByIndexDesc = function compareByIndexDesc(indexA, indexB) {
  var lastA = parseInt(indexA, 10);
  var lastB = parseInt(indexB, 10);
  if (!(isNaN(lastA) || isNaN(lastB))) {
    return lastB - lastA;
  } else {
    return 0;
  }
};

var opsByDescendingOrder = function opsByDescendingOrder(removeOps) {
  return sortBy(removeOps, function (a, b) {
    var splitA = a.path.split('/');
    var splitB = b.path.split('/');
    if (splitA.length !== splitB.length) {
      return splitA.length - splitB.length;
    } else {
      return compareByIndexDesc(last(splitA), last(splitB));
    }
  });
};

var partitionOps = function partitionOps(arr, fns) {
  var initArr = Array(fns.length + 1).fill().map(function () {
    return [];
  });
  return arr.map(function (item) {
    var position = fns.map(function (fn) {
      return fn(item);
    }).indexOf(true);
    if (position < 0) {
      position = fns.length;
    }
    return { item: item, position: position };
  }).reduce(function (acc, item) {
    acc[item.position].push(item.item);
    return acc;
  }, initArr);
};
var isMoveOp = function isMoveOp(_ref3) {
  var op = _ref3.op;
  return op === 'move';
};
var isRemoveOp = function isRemoveOp(_ref4) {
  var op = _ref4.op;
  return op === 'remove';
};

var reorderOps = function reorderOps(diff) {
  var _partitionOps = partitionOps(diff, [isMoveOp, isRemoveOp]),
      _partitionOps2 = slicedToArray(_partitionOps, 3),
      moveOps = _partitionOps2[0],
      removedOps = _partitionOps2[1],
      restOps = _partitionOps2[2];

  var removeOpsReverse = opsByDescendingOrder(removedOps);
  return [].concat(toConsumableArray(removeOpsReverse), toConsumableArray(moveOps), toConsumableArray(restOps));
};

var defaultInstance$2 = void 0;

var format$2 = function format(delta, left) {
  if (!defaultInstance$2) {
    defaultInstance$2 = new JSONFormatter();
  }
  return reorderOps(defaultInstance$2.format(delta, left));
};

var log = function log(delta, left) {
  console.log(format$2(delta, left));
};



var jsonpatch = Object.freeze({
	default: JSONFormatter,
	partitionOps: partitionOps,
	format: format$2,
	log: log
});

function chalkColor(name) {
  return chalk && chalk[name] || function () {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return args;
  };
}

var colors = {
  added: chalkColor('green'),
  deleted: chalkColor('red'),
  movedestination: chalkColor('gray'),
  moved: chalkColor('yellow'),
  unchanged: chalkColor('gray'),
  error: chalkColor('white.bgRed'),
  textDiffLine: chalkColor('gray')
};

var ConsoleFormatter = function (_BaseFormatter) {
  inherits(ConsoleFormatter, _BaseFormatter);

  function ConsoleFormatter() {
    classCallCheck(this, ConsoleFormatter);

    var _this = possibleConstructorReturn(this, (ConsoleFormatter.__proto__ || Object.getPrototypeOf(ConsoleFormatter)).call(this));

    _this.includeMoveDestinations = false;
    return _this;
  }

  createClass(ConsoleFormatter, [{
    key: 'prepareContext',
    value: function prepareContext(context) {
      get(ConsoleFormatter.prototype.__proto__ || Object.getPrototypeOf(ConsoleFormatter.prototype), 'prepareContext', this).call(this, context);
      context.indent = function (levels) {
        this.indentLevel = (this.indentLevel || 0) + (typeof levels === 'undefined' ? 1 : levels);
        this.indentPad = new Array(this.indentLevel + 1).join('  ');
        this.outLine();
      };
      context.outLine = function () {
        this.buffer.push('\n' + (this.indentPad || ''));
      };
      context.out = function () {
        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        for (var i = 0, l = args.length; i < l; i++) {
          var lines = args[i].split('\n');
          var text = lines.join('\n' + (this.indentPad || ''));
          if (this.color && this.color[0]) {
            text = this.color[0](text);
          }
          this.buffer.push(text);
        }
      };
      context.pushColor = function (color) {
        this.color = this.color || [];
        this.color.unshift(color);
      };
      context.popColor = function () {
        this.color = this.color || [];
        this.color.shift();
      };
    }
  }, {
    key: 'typeFormattterErrorFormatter',
    value: function typeFormattterErrorFormatter(context, err) {
      context.pushColor(colors.error);
      context.out('[ERROR]' + err);
      context.popColor();
    }
  }, {
    key: 'formatValue',
    value: function formatValue(context, value) {
      context.out(JSON.stringify(value, null, 2));
    }
  }, {
    key: 'formatTextDiffString',
    value: function formatTextDiffString(context, value) {
      var lines = this.parseTextDiff(value);
      context.indent();
      for (var i = 0, l = lines.length; i < l; i++) {
        var line = lines[i];
        context.pushColor(colors.textDiffLine);
        context.out(line.location.line + ',' + line.location.chr + ' ');
        context.popColor();
        var pieces = line.pieces;
        for (var pieceIndex = 0, piecesLength = pieces.length; pieceIndex < piecesLength; pieceIndex++) {
          var piece = pieces[pieceIndex];
          context.pushColor(colors[piece.type]);
          context.out(piece.text);
          context.popColor();
        }
        if (i < l - 1) {
          context.outLine();
        }
      }
      context.indent(-1);
    }
  }, {
    key: 'rootBegin',
    value: function rootBegin(context, type, nodeType) {
      context.pushColor(colors[type]);
      if (type === 'node') {
        context.out(nodeType === 'array' ? '[' : '{');
        context.indent();
      }
    }
  }, {
    key: 'rootEnd',
    value: function rootEnd(context, type, nodeType) {
      if (type === 'node') {
        context.indent(-1);
        context.out(nodeType === 'array' ? ']' : '}');
      }
      context.popColor();
    }
  }, {
    key: 'nodeBegin',
    value: function nodeBegin(context, key, leftKey, type, nodeType) {
      context.pushColor(colors[type]);
      context.out(leftKey + ': ');
      if (type === 'node') {
        context.out(nodeType === 'array' ? '[' : '{');
        context.indent();
      }
    }
  }, {
    key: 'nodeEnd',
    value: function nodeEnd(context, key, leftKey, type, nodeType, isLast) {
      if (type === 'node') {
        context.indent(-1);
        context.out(nodeType === 'array' ? ']' : '}' + (isLast ? '' : ','));
      }
      if (!isLast) {
        context.outLine();
      }
      context.popColor();
    }

    /* jshint camelcase: false */
    /* eslint-disable camelcase */

  }, {
    key: 'format_unchanged',
    value: function format_unchanged(context, delta, left) {
      if (typeof left === 'undefined') {
        return;
      }
      this.formatValue(context, left);
    }
  }, {
    key: 'format_movedestination',
    value: function format_movedestination(context, delta, left) {
      if (typeof left === 'undefined') {
        return;
      }
      this.formatValue(context, left);
    }
  }, {
    key: 'format_node',
    value: function format_node(context, delta, left) {
      // recurse
      this.formatDeltaChildren(context, delta, left);
    }
  }, {
    key: 'format_added',
    value: function format_added(context, delta) {
      this.formatValue(context, delta[0]);
    }
  }, {
    key: 'format_modified',
    value: function format_modified(context, delta) {
      context.pushColor(colors.deleted);
      this.formatValue(context, delta[0]);
      context.popColor();
      context.out(' => ');
      context.pushColor(colors.added);
      this.formatValue(context, delta[1]);
      context.popColor();
    }
  }, {
    key: 'format_deleted',
    value: function format_deleted(context, delta) {
      this.formatValue(context, delta[0]);
    }
  }, {
    key: 'format_moved',
    value: function format_moved(context, delta) {
      context.out('==> ' + delta[1]);
    }
  }, {
    key: 'format_textdiff',
    value: function format_textdiff(context, delta) {
      this.formatTextDiffString(context, delta[0]);
    }
  }]);
  return ConsoleFormatter;
}(BaseFormatter);

var defaultInstance$3 = void 0;

var format$3 = function format(delta, left) {
  if (!defaultInstance$3) {
    defaultInstance$3 = new ConsoleFormatter();
  }
  return defaultInstance$3.format(delta, left);
};

function log$1(delta, left) {
  console.log(format$3(delta, left));
}



var console$1 = Object.freeze({
	default: ConsoleFormatter,
	format: format$3,
	log: log$1
});



var index = Object.freeze({
	base: base,
	html: html,
	annotated: annotated,
	jsonpatch: jsonpatch,
	console: console$1
});

// use as 2nd parameter for JSON.parse to revive Date instances
function dateReviver(key, value) {
  var parts = void 0;
  if (typeof value === 'string') {
    // eslint-disable-next-line max-len
    parts = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})(?:\.(\d*))?(Z|([+-])(\d{2}):(\d{2}))$/.exec(value);
    if (parts) {
      return new Date(Date.UTC(+parts[1], +parts[2] - 1, +parts[3], +parts[4], +parts[5], +parts[6], +(parts[7] || 0)));
    }
  }
  return value;
}

function create(options) {
  return new DiffPatcher(options);
}

var defaultInstance$4 = void 0;

function diff() {
  if (!defaultInstance$4) {
    defaultInstance$4 = new DiffPatcher();
  }
  return defaultInstance$4.diff.apply(defaultInstance$4, arguments);
}

function patch() {
  if (!defaultInstance$4) {
    defaultInstance$4 = new DiffPatcher();
  }
  return defaultInstance$4.patch.apply(defaultInstance$4, arguments);
}

function unpatch() {
  if (!defaultInstance$4) {
    defaultInstance$4 = new DiffPatcher();
  }
  return defaultInstance$4.unpatch.apply(defaultInstance$4, arguments);
}

function reverse() {
  if (!defaultInstance$4) {
    defaultInstance$4 = new DiffPatcher();
  }
  return defaultInstance$4.reverse.apply(defaultInstance$4, arguments);
}

function clone$1() {
  if (!defaultInstance$4) {
    defaultInstance$4 = new DiffPatcher();
  }
  return defaultInstance$4.clone.apply(defaultInstance$4, arguments);
}

exports.DiffPatcher = DiffPatcher;
exports.formatters = index;
exports.console = console$1;
exports.create = create;
exports.dateReviver = dateReviver;
exports.diff = diff;
exports.patch = patch;
exports.unpatch = unpatch;
exports.reverse = reverse;
exports.clone = clone$1;

Object.defineProperty(exports, '__esModule', { value: true });

})));
</script>

<dom-module id="nuxeo-diff" assetpath="diff/">
  <template>
    <style include="iron-flex iron-flex-alignment nuxeo-styles">
      :host {
        display: block;
        --paper-input-container-underline: {
          display: none;
        };
      }

      nuxeo-object-diff[unified] ~ nuxeo-object-diff[unified],
      .side-by-side ~ .side-by-side {
        margin-top: 12px;
      }

      nuxeo-object-diff:not([unified]) {
        @apply --layout-vertical;
        @apply --layout-flex;
      }

      #controls {
        @apply --layout-horizontal;
        @apply --layout-end-justified;
        margin-bottom: 12px;
      }

      #diffContainer, #diffPane {
        @apply --layout-vertical;
      }

      #diffPickerPane {
        @apply --layout-horizontal;
      }

      .control ~ .control {
        margin-left: 8px;
      }

      .switchSides {
        @apply --layout-horizontal;
        @apply --layout-center;
      }

      .switchSides paper-icon-button {
        margin: 0 4px 16px 4px;
      }

      .deltaPane {
        @apply --layout-vertical;
      }

      .side-by-side {
        @apply --layout-horizontal;
      }

      .side-by-side nuxeo-object-diff:not([unified]):not(:first-child) {
        margin-left: 16px;
      }

      .diffPickers {
        @apply --layout-horizontal;
        @apply --layout-flex;
        overflow: hidden;
      }

      .diffPicker {
        @apply --paper-card;
        @apply --layout-flex;
        overflow: hidden;
        padding: 4px 4px 4px 8px;
      }

      .diffPickers > .switchSides {
        display: flex;
      }

      #diffPickerPane > .switchSides {
        display: none;
      }

      @media (max-width: 720px) {
        .diffPickers {
          @apply --layout-vertical;
          @apply --layout-flex;
        }

        .diffPicker {
          @apply --layout-flex-none;
        }

        .diffPickers > .switchSides {
          display: none;
        }

        #diffPickerPane > .switchSides {
          display: flex;
        }

        .switchSides paper-icon-button {
          transform: rotate(90deg);
        }
      }
    </style>

    <nuxeo-resource id="schema"></nuxeo-resource>
    <nuxeo-document id="doc" headers="[[headers]]" enrichers="[[enrichers]]" schemas="[[schemas]]"></nuxeo-document>

    <div id="diffContainer">
      <div id="controls">
        <paper-checkbox class="control" checked="{{showAll}}">[[i18n('diff.controls.showAll')]]</paper-checkbox>
        <template is="dom-if" if="[[_showUnifiedViewControl]]">
          <paper-toggle-button class="control" checked="{{_unifiedView}}">[[i18n('diff.controls.unifiedView')]]</paper-toggle-button>
        </template>
      </div>
      <div id="diffPickerPane">
        <div class="diffPickers">
          <div class="diffPicker">
            <nuxeo-select selected="{{leftUid}}" attr-for-selected="uid">
              <template is="dom-repeat" items="[[documents]]">
                <paper-item uid="[[item.uid]]">[[_title(item, _hasVersions)]]</paper-item>
              </template>
            </nuxeo-select>
          </div>
          <div class="switchSides">
            <paper-icon-button id="switchSidesButtonH" icon="nuxeo:switch-sides" on-tap="_switchSides"></paper-icon-button>
            <nuxeo-tooltip for="switchSidesButtonH">[[i18n('diff.controls.switchSides.tooltip')]]</nuxeo-tooltip>
          </div>
          <div class="diffPicker">
            <nuxeo-select selected="{{rightUid}}" attr-for-selected="uid">
              <template is="dom-repeat" items="[[documents]]">
                <paper-item uid="[[item.uid]]">[[_title(item, _hasVersions)]]</paper-item>
              </template>
            </nuxeo-select>
          </div>
        </div>
        <div class="switchSides">
          <paper-icon-button id="switchSidesButtonV" icon="nuxeo:switch-sides" on-tap="_switchSides"></paper-icon-button>
          <nuxeo-tooltip for="switchSidesButtonV">[[i18n('diff.controls.switchSides.tooltip')]]</nuxeo-tooltip>
        </div>
      </div>
      <div id="diffPane">
        <template is="dom-repeat" items="[[_getCommonSchemas(_schemas, showAll, _delta)]]" as="schema" sort="_sortSchemas">
          <nuxeo-card heading="[[schema.name]]" collapsible="" opened="">
            <div class="deltaPane">
              <template is="dom-repeat" items="[[_getCommonSchemaProperties(schema, showAll, _delta)]]" as="property">
                <template is="dom-if" if="[[unifiedView]]">
                  <nuxeo-object-diff property="[[_getPropertyName(schema, property)]]" label="[[_computeLabel(schema, property)]]" schema="[[schema]]" left-uid="[[leftUid]]" right-uid="[[rightUid]]" delta="[[_getPropertyDiff(_delta, property)]]" original-value="[[_getDocumentProperty(property, left)]]" new-value="[[_getDocumentProperty(property, right)]]" show-all="[[showAll]]" unified="" display-label=""></nuxeo-object-diff>
                </template>
                <template is="dom-if" if="[[!unifiedView]]">
                  <div class="side-by-side">
                    <nuxeo-object-diff property="[[_getPropertyName(schema, property)]]" label="[[_computeLabel(schema, property)]]" schema="[[schema]]" left-uid="[[leftUid]]" right-uid="[[rightUid]]" delta="[[_getPropertyDiff(_delta, property)]]" original-value="[[_getDocumentProperty(property, left)]]" new-value="[[_getDocumentProperty(property, right)]]" show-all="[[showAll]]" hide-additions="" display-label=""></nuxeo-object-diff>
                    <nuxeo-object-diff property="[[_getPropertyName(schema, property)]]" schema="[[schema]]" left-uid="[[leftUid]]" right-uid="[[rightUid]]" delta="[[_getPropertyDiff(_delta, property)]]" original-value="[[_getDocumentProperty(property, left)]]" new-value="[[_getDocumentProperty(property, right)]]" show-all="[[showAll]]" hide-deletions="" display-label=""></nuxeo-object-diff>
                  </div>
                </template>
              </template>
            </div>
          </nuxeo-card>
        </template>
      </div>
    </div>

  </template>

  <script>
    (function() {
      var _customLoadPromise;
      var typeDataCache = {};
      Polymer({
        is: 'nuxeo-diff',
        behaviors: [Nuxeo.I18nBehavior, Nuxeo.FiltersBehavior, Polymer.IronResizableBehavior],
        properties: {
          /**
           * The list of ids of the documents to compare.
           */
          docIds: {
            type: Array,
            value: []
          },
          /**
           * The list of documents in `docIds`, fetched using the `enrichers`, `schemas`and `headers` specified in the
           * element.
           */
          documents: {
            type: Array,
            value: [],
            readOnly: true
          },
          /**
           * If `true`, the element will display all properties including those without any differences.
           */
          showAll: {
            type: Boolean,
            value: false,
          },
          /**
           *  If `true`, the element will display content in a single column.
           */
          unifiedView: {
            type: Boolean,
            value: false,
            reflectToAttribute: true,
            readOnly: true
          },
          /**
           * List of content enrichers passed on to `provider`.
           * Already set by default are thumbnail, permissions and highlight.
           */
          enrichers: {
            type: String
          },
          /**
           * The headers passed on to `provider`.
           * Already set by default are 'X-NXfetch.document': 'properties' and 'X-NXtranslate.directoryEntry': 'label'.
           */
          headers: {
            type: String,
            value: {'X-NXfetch.document': 'properties', 'X-NXtranslate.directoryEntry': 'label'}
          },
          /**
           * The schemas passed on to `provider`.
           **/
          schemas: {
            type: String
          },
          /**
           * The id of the document on the left, where deletions occurred.
           */
          leftUid: {
            type: String,
            observer: 'leftUidChanged',
            notify: true
          },
          /**
           * The id of the document on the right, where additions occurred.
           */
          rightUid: {
            type: String,
            observer: 'rightUidChanged',
            notify: true
          },
          _unifiedView: {
            type: Boolean,
            value: false,
            observer: '_resize'
          },
          _showUnifiedViewControl: Boolean,
          _schemas: Array,
          left: {
            type: Object,
            notify: true
          },
          right:  {
            type: Object,
            notify: true
          },
          _delta: Object,
          _hasVersions: {
            type: Boolean,
            value: false
          }
        },

        observers: [
          '_docIdsChanged(docIds.*)'
        ],

        listeners: {
          'iron-resize': '_resize'
        },

        created: function() {
          if (!_customLoadPromise) {
            _customLoadPromise = new Promise(function(resolve, reject) {
              this.importHref(this.resolveUrl('imports.html'), resolve, reject);
            }.bind(this));
          }
        },

        _resize: function() {
          if (window.matchMedia('(max-width: 720px)').matches) {
            this._setUnifiedView(true);
            this._showUnifiedViewControl = false;
          } else {
            this._setUnifiedView(this._unifiedView);
            this._showUnifiedViewControl = true;
          }
        },

        _switchSides: function() {
          var right = this.rightUid;
          this.rightUid = this.leftUid;
          this.leftUid = right;
        },

        leftUidChanged: function(newValue, oldValue) {
          if (newValue === this.rightUid) {
            this.rightUid = oldValue;
          } else {
            this.diff();
          }
        },

        rightUidChanged: function(newValue, oldValue) {
          if (newValue === this.leftUid) {
            this.leftUid = oldValue;
          } else {
            this.diff();
          }
        },

        _computeLabel: function(schema, property) {
          var key = 'diffObject.property.label.' + property;
          var translation = this.i18n(key);
          return key !== translation ? translation : this._getPropertyName(schema, property);
        },

        _title: function(document) {
          return document && (document.title + (this._hasVersions && !document.isCheckedOut ?
            (' (v' + document.properties['uid:major_version'] + '.' + document.properties['uid:minor_version'] + ')')
            : ''));
        },

        /* DOM-repeat filters and sort functions */

        _filterUid: function(uid) {
          return function(document) {
            return document.uid != uid;
          }
        },

        _sortSchemas: function(schema1, schema2) {
          var schema1properties = this._getCommonProperties(this.left, this.right, schema1, this._delta);
          var schema2properties = this._getCommonProperties(this.left, this.right, schema2, this._delta);
          if ((schema1properties.length === 0 && schema1properties.length === schema2properties.length) ||
              (schema1properties.length > 0 && schema2properties.length > 0))  {
            return schema1.name > schema2.name;
          } else {
            return schema1properties.length < schema2properties.length;
          }
        },

        /* fetchers */

        _sequencer: function(promises) {
          return promises.reduce(function(current, next) {
            return current.then(next);
          }, Promise.resolve([]));
        },

        _docIdsChanged: function() {
          if (this.docIds && this.docIds.length > 1) {
            var calls = [];
            this._setDocuments([]);
            this.docIds.forEach(function(uid) {
              calls.push(function() {
                this.$.doc.docId = uid;
                return this.$.doc.get().then(function(response) {
                  this.push('documents', response);
                }.bind(this));
              }.bind(this));
            }.bind(this));
            this._sequencer(calls).then(function() {
              this._hasVersions = this.documents.some(function(doc) {
                return doc.isVersion;
              });
              this.rightUid = null; // prevent accidental comparison with an old document
              this.leftUid = this.documents[0].uid;
              this.rightUid = this.documents[1].uid;
            }.bind(this));
          }
        },

        _fetchSchemas: function(document) {
          var type = document.type;
          if (typeDataCache[type]) {
            return Promise.resolve(typeDataCache[type]);
          }
          this.$.schema.path = 'config/types/' + type;
          return this.$.schema.get().then(function(response) {
            typeDataCache[response.name] = response; // cache response
            return response;
          });
        },

        _fetchCommonSchemas: function(left, right) {
          // if both have the same type, only do a single fetch
          if (left && right && left.type === right.type) {
            return this._fetchSchemas(left).then(function(response) {
              return response.schemas;
            });
          }
          return this._fetchSchemas(left).then(function(response1) {
            return this._fetchSchemas(right).then(function(response2) {
              return response1.schemas.filter(function(schema1) {
                return !!response2.schemas.find(function(schema2) {
                  return schema1.name === schema2.name;
                });
              });
            });
          }.bind(this));
        },

        _getCommonProperties: function(left, right, schema, delta) {
          return Object.keys(left.properties).filter(function(leftPropName) {
            return !!Object.keys(right.properties).find(function(rightPropName) {
              return leftPropName === rightPropName &&
                     (schema ? leftPropName.startsWith((schema.prefix ? schema.prefix : schema.name) + ':') : true) &&
                     (delta ? delta[leftPropName] : true);
            });
          });
        },

        _getCommonSchemaProperties: function(schema, showAll, delta) {
          return this._getCommonProperties(this.left, this.right, schema, showAll ? null : delta);
        },

        _getCommonSchemas: function(schemas, showAll) {
          if (!schemas) {
            return;
          }
          return showAll ? schemas : schemas.filter(function(schema) {
            return this._getCommonProperties(this.left, this.right, schema, showAll ? null : this._delta).length > 0;
          }.bind(this));
        },

        /* comparison */

        _getPropertyDiff: function(delta, property) {
          return delta && delta[property];
        },

        _getDocumentProperty: function(property, document) {
          return document.properties[property];
        },

        _getPropertyName: function(schema, property) {
          if (!property || !schema) {
            return;
          }
          return property.replace(new RegExp('^' + (schema.prefix ? schema.prefix : schema.name) + ':'), '');
        },

        _diff: function() {
          if (!this.leftUid || !this.rightUid || this.leftUid === this.rightUid) {
            return;
          }
          var left = this.documents.find(function(doc) {
            return doc.uid === this.leftUid;
          }.bind(this));
          var right = this.documents.find(function(doc) {
            return doc.uid === this.rightUid;
          }.bind(this));
          this.left = left;
          this.right = right;
          this._fetchCommonSchemas(left, right).then(function(schemas) {
            this._schemas = schemas;
            var delta = jsondiffpatch.diff(left.properties, right.properties);
            this._schemas.forEach(function(schema) {
              this._filterDelta(delta, schema);
            }.bind(this));
            this._delta = delta;
          }.bind(this));
        },

        diff: function() {
          _customLoadPromise.then(this._diff.bind(this));
        },

        _filterDelta: function(delta, schema, parentPath) {
          var path = parentPath || '';
          // if it's an array diff
          if (delta['_t'] && delta['_t'] == 'a') {
            Object.keys(delta).filter(function(key) {
              return key !== '_t';
            }).forEach(function(key) {
              var subpath = path ? [path, key].join('.') : properties[i];
              var deltaObj = (Array.isArray(delta[key]) && delta[key].length > 0) ? delta[key][0] : delta[key];
              this._filterDelta(deltaObj, schema, subpath);
              if (Object.keys(delta[key]).length === 0) {
                delete delta[key];
              }
            }.bind(this));
          } else {
            var deltaObj = (Array.isArray(delta) && delta.length > 0) ? delta[0] : delta;
            var properties = parentPath ? Object.keys(deltaObj) : this._getCommonSchemaProperties(schema, false, deltaObj);
            for (var i = 0; i < properties.length; i++) {
              var key = properties[i];
              var subpath = path ? [path, key].join('.') : properties[i];
              var type;
              var subSchema;
              if (typeof schema === 'string') {
                type = schema.replace(/\[\]$/, '');
              } else {
                subSchema = schema.fields[this._getPropertyName(schema, key)];
                type = subSchema.type || subSchema;
              }
              switch (type) {
                case 'string':
                case 'date':
                case 'long':
                case 'integer':
                case 'boolean':
                case 'double':
                  break;
                case 'blob':
                  if (deltaObj[key] && !deltaObj[key].digest) {
                    delete deltaObj[key];
                  }
                  break;
                default:
                  if (deltaObj) {
                    this._filterDelta(deltaObj[key], subSchema, subpath, schema);
                  }
                  break;
              }
            }
          }
        }

      });
    })();
  </script>

</dom-module>
<dom-module id="nuxeo-csv-export-button" assetpath="nuxeo-csv-export/">
  <template>
    <nuxeo-operation-button id="btn" operation="Bulk.RunAction" input="[[provider]]" params="[[_params(provider, schemas, fields)]]" icon="nuxeo:csv-export" label="csvExportButton.label" show-label$="[[showLabel]]" poll-interval="[[pollInterval]]" error-label="csvExportButton.action.error" async="" download="">
    </nuxeo-operation-button>
  </template>
  <script>
    Polymer({
      is: 'nuxeo-csv-export-button',
      behaviors: [Nuxeo.I18nBehavior, Nuxeo.FiltersBehavior],
      properties: {
        /**
         * Page provider from which results are to be exported.
         */
        provider: {
          type: Object,
        },
        /**
         * The interval to poll for the result, in milliseconds.
         */
        pollInterval: {
          type: Number,
          value: 1000,
        },
        /**
         * A comma separated list of schemas to be used to get the results.
         * If `null` or `undefined`, the `provider`'s schemas will be used.
         */
        schemas: {
          type: String,
        },
        /**
         * A comma separated list of fields to be be exported.
         */
        fields: {
          type: String,
        },
        /**
         * `true` if the action should display the label, `false` otherwise.
         */
        showLabel: {
          type: Boolean,
          value: false,
        },

        /**
         * Current action status.
         */
        status: {
          type: Object,
          notify: true,
        }
      },

      ready: function() {
        this.$.btn.addEventListener('poll-start', this._onPollStart.bind(this));
        this.$.btn.addEventListener('response', this._onResponse.bind(this));
      },

      _params: function() {
        var actionParams = {};
        var schemas = this.schemas != null ? this.schemas : this.provider && this.provider.schemas;
        if (schemas) {
          actionParams.schemas = schemas.split(',').map(function(s) { return s.trim(); });
        }
        if (this.fields) {
          actionParams.xpaths = this.fields.split(',').map(function(s) { return s.trim(); });
        }
        return {
          action: 'csvExport',
          parameters: JSON.stringify(actionParams),
        };
      },

      _onPollStart: function() {
        this.fire('notify', { message: this.i18n('csvExportButton.action.poll') });
      },

      _onResponse: function() {
        this.fire('notify', { message: this.i18n('csvExportButton.action.completed') });
      }

    });
  </script>
</dom-module>
<dom-module id="nuxeo-sardine">
  <template>
    <style>
      :host([hidden]) {
        display: none;
      }
      #sardine {
        position: fixed;
        width: 128px;
        z-index: 9999;
      }

      #sardine img {
        position: relative;
        top: 16px;
        width: 100%;
        height: 100%;
        animation: upDown 5s linear infinite;
      }

      #wrapper {
        animation: rotate 5s linear infinite;
      }

      #feeling {
        position: absolute;
        top: -8px;
        left: 16px;
        font-size: 14px;
      }

      .left {
        transform: scaleX(-1);
      }

      .right {
        transform: scaleX(1);
      }

      @keyframes upDown {
        0%    { transform: translateY(0); }
        25%   { transform: translateY(-8px); }
        50%   { transform: translateY(0); }
        75%   { transform: translateY(8px); }
        100%  { transform: translateY(0);}
      }

      @keyframes rotate {
        0%    { transform: rotate(4deg); }
        12.5% { transform: rotate(2deg); }
        25%   { transform: rotate(0deg); }
        37.5% { transform: rotate(-2deg); }
        50%   { transform: rotate(-4deg); }
        62.5% { transform: rotate(-2deg); }
        75%   { transform: rotate(0deg); }
        87.5% { transform: rotate(2deg); }
        100%  { transform: rotate(4deg); }
      }
    </style>

    <div id="sardine">
      <div id="wrapper">
        <span id="feeling">[[feeling]]</span>
        <template is="dom-if" if="[[!hidden]]">
          <img src="images/sardine.png">
        </template>
      </div>
    </div>

  </template>

  <script>
    Polymer({
      is: 'nuxeo-sardine',
      properties: {
        hidden: {
          type: Boolean,
          value: false,
          notify: true,
          reflectToAttribute: true,
        },
        state: String,
        feeling: String,
      },

      ready: function() {
        this._onkeypress = function(e) {
          if (e.key === 'Escape') {
            this._off();
          }
        }.bind(this);
        this._onpointerout = function() {
          this._unknownLocation = true;
        }.bind(this);
        this._ondblclick = function() {
          this._off();
        }.bind(this);
        this._onpointermove = function(e) {
          if (this._idleTimeout) {
            clearTimeout(this._idleTimeout);
          }
          this._idleTimeout = setTimeout(function() {
            this.feeling = '';
          }.bind(this), 15000);
          this._unknownLocation = false;
          // XXX this will only capture the first touch on mobile, because the browser will reclaim the move for itself.
          // see https://developer.mozilla.org/en-US/docs/Web/Events/pointermove for more
          this._lastPointerEvent = e;
          if (this._req) {
            cancelAnimationFrame(this._req);
          }
          this._req = requestAnimationFrame(this._animate.bind(this));
        }.bind(this);
        customElements.whenDefined('nuxeo-suggester').then(function() {
          this.$.sardine.style.left = Math.random() * window.innerWidth + 'px';
          this.$.sardine.style.top = Math.random() * window.innerHeight + 'px';
          Nuxeo._Suggester.addCommand({
            id: 'sardine',
            trigger: {
              searchTerm: 'i love sardines!!!',
              startsWith: false,
            },
            suggestion: {
              id: 'sardine',
              icon: 'images/gift.png',
              label: 'I love sardines!!! ',
            },
            run: this._on.bind(this),
          });
        }.bind(this));
      },

      _on: function() {
        this.hidden = false;
        this.$.sardine.addEventListener('dblclick', this._ondblclick);
        if (window.PointerEvent) {
          window.addEventListener('pointermove', this._onpointermove, false);
          window.addEventListener('pointerout', this._onpointerout, false);
        } else {
          window.addEventListener('mousemove', this._onpointermove, false);
          window.addEventListener('mouseout', this._onpointerout, false);
        }
        window.addEventListener('keyup', this._onkeypress, false);
      },

      _animate: function() {
        var rect = this.$.sardine.getBoundingClientRect();
        var x1 = rect.left;
        var y1 = rect.top;
        var w = rect.width;
        var h = rect.height;
        var x2 = this._lastPointerEvent.x;
        var y2 = this._lastPointerEvent.y;
        x2 = (x2 + w) > window.innerWidth ? window.innerWidth - w : x2;
        y2 = (y2 + h) > window.innerHeight ? window.innerHeight - h : y2;
        var dist = Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
        if (dist < 32) {
          if (this._unknownLocation) {
            this.feeling = (!this._lastPointerEvent.pointerType || this._lastPointerEvent.pointerType === 'mouse') ?
              '' : '';
          } else if (!this._lastPointerEvent.pointerType || this._lastPointerEvent.pointerType !== 'touch') {
            this.feeling = '';
          }
        } else {
          this.feeling = '';
        }
        if (dist > 1) {
          var newX = this._lerp(x1, x2, 0.05);
          var newY = this._lerp(y1, y2, 0.05);
          this.$.sardine.style.left = newX + 'px';
          this.$.sardine.style.top = newY + 'px';
          x1 = this.$.sardine.getBoundingClientRect().left;
          if (!this._unknownLocation) {
            var dir = x1 < (this._lastPointerEvent.x - 32) ? 'left' : 'right';
            if (dir != this.$.sardine._dir) {
              this.$.sardine.classList.remove(this.$.sardine._dir);
              this.$.sardine.classList.add(dir);
            }
            this.$.sardine._dir = dir;
          }
          this._req = requestAnimationFrame(this._animate.bind(this));
        }
      },

      _off: function() {
        this.hidden = true;
        if (this._req) {
          cancelAnimationFrame(this._req);
        }
        if (this._idleTimeout) {
          clearTimeout(this._idleTimeout);
        }
        window.removeEventListener('pointermove', this._onpointermove, false);
        window.removeEventListener('keyup', this._onkeypress, false);
        window.removeEventListener('pointerleave', this._onpointerout);
        this.$.sardine.removeEventListener('dblclick', this._ondblclick);
      },

      _lerp: function (value1, value2, amount) {
        amount = amount < 0 ? 0 : amount;
        amount = amount > 1 ? 1 : amount;
        return value1 + (value2 - value1) * amount;
      },
    });
  </script>
</dom-module>
</div>